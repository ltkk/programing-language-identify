use 5.014; use utf8; use strict; use autodie; use warnings; use warnings qw< FATAL utf8 >; use open qw< :std :utf8 >; use charnames qw< :full >; use feature qw< unicode_strings >; use File::Basename qw< basename >; use Carp qw< carp croak confess cluck >; use Encode qw< encode decode >; use Unicode::Normalize qw< NFD NFC >; END { close STDOUT } if (grep /\P{ASCII}/ => @ARGV) { @ARGV = map { decode("UTF-8", $_) } @ARGV; } $0 = basename($0); $| = 1; binmode(DATA, ":utf8"); local $SIG{__DIE__} = sub { confess "Uncaught exception: @_" unless $^S; }; local $SIG{__WARN__} = sub { if ($^S) { cluck "Trapped warning: @_" } else { confess "Deadly warning: @_" } }; while (<>) { chomp; $_ = NFD($_); ... } continue { say NFC($_); } __END__
export LC_CTYPE=en_US.UTF-8 export LC_ALL=en_US.UTF-8
export LANGUAGE=en_US.UTF-8 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 export LC_TYPE=en_US.UTF-8
sudo locale-gen en_US en_US.UTF-8 sudo dpkg-reconfigure locales
$ cat /etc/environment ... LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
$ locale locale: Cannot set LC_ALL to default locale: No such file or directory LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=en_US.UTF-8 LC_NUMERIC=ru_RU.UTF-8 LC_TIME=ru_RU.UTF-8 LC_COLLATE="en_US.UTF-8" LC_MONETARY=ru_RU.UTF-8 LC_MESSAGES="en_US.UTF-8" LC_PAPER=ru_RU.UTF-8 LC_NAME=ru_RU.UTF-8 LC_ADDRESS=ru_RU.UTF-8 LC_TELEPHONE=ru_RU.UTF-8 LC_MEASUREMENT=ru_RU.UTF-8 LC_IDENTIFICATION=ru_RU.UTF-8 LC_ALL= $ sudo su Generating locales... en_US.UTF-8... up-to-date Generation complete. Generating locales... en_AG.UTF-8... done en_AU.UTF-8... done en_BW.UTF-8... done en_CA.UTF-8... done en_DK.UTF-8... done en_GB.UTF-8... done en_HK.UTF-8... done en_IE.UTF-8... done en_IN.UTF-8... done en_NG.UTF-8... done en_NZ.UTF-8... done en_PH.UTF-8... done en_SG.UTF-8... done en_US.UTF-8... up-to-date en_ZA.UTF-8... done en_ZM.UTF-8... done en_ZW.UTF-8... done Generation complete. $ locale LANG=en_US.UTF-8 LANGUAGE=en_US.UTF-8 LC_CTYPE="en_US.UTF-8" LC_NUMERIC="en_US.UTF-8" LC_TIME="en_US.UTF-8" LC_COLLATE="en_US.UTF-8" LC_MONETARY="en_US.UTF-8" LC_MESSAGES="en_US.UTF-8" LC_PAPER="en_US.UTF-8" LC_NAME="en_US.UTF-8" LC_ADDRESS="en_US.UTF-8" LC_TELEPHONE="en_US.UTF-8" LC_MEASUREMENT="en_US.UTF-8" LC_IDENTIFICATION="en_US.UTF-8" LC_ALL=en_US.UTF-8
LANGUAGE=en_US.UTF-8 LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 LC_TYPE=en_US.UTF-8
root@host:~ root@host:~ local-user@local:~$ ssh root@host root@host:~ root@host:~
perl: warning: Falling back to the standard locale ("C"). locale: Cannot set LC_ALL to default locale: No such file or directory
export LANGUAGE=en_US.UTF-8 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 export LC_TYPE=en_US.UTF-8
perl: warning: Setting locale failed. perl: warning: Please check that your locale settings: LANGUAGE = (unset), LC_ALL = (unset), LC_CTYPE = "UTF-8", LANG = "en_US.UTF-8" are supported and installed on your system. perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
LANGUAGE=en_US.UTF-8 LANG=en_US.UTF-8 LC_CTYPE=en_US.UTF-8 LC_ALL=en_US.UTF-8
export LANG=en_EN.UTF-8 export LC_COLLATE=$LANG export LC_CTYPE=$LANG export LC_MESSAGES=$LANG export LC_MONETARY=$LANG export LC_NUMERIC=$LANG export LC_TIME=$LANG export LC_ALL=$LANG
echo "export LANGUAGE=en_US.UTF-8 export LANG=en_US.UTF-8 export LC_ALL=en_US.UTF-8">>~/.bash_profile
LANGUAGE = (unset), LC_ALL = (unset), LC_PAPER = "ro_RO.UTF-8", LC_ADDRESS = "ro_RO.UTF-8", ....
perl: warning: Setting locale failed. perl: warning: Please check that your locale settings: LANGUAGE = (unset), LC_ALL = (unset), LANG = "en_US.utf8"
perl -MO=Deparse -w yuck BEGIN { $^W = 1; } use warnings; use strict yuck syntax OK
use strict; use warnings; no indirect; Syntax error! exit 0;
Indirect call of method "Syntax" on object "error" at - line 5.
===SORRY!=== Error while compiling synerror.p6 Negation metaoperator not followed by valid infix at synerror.p6:1 ------> Syntax error!⏏<EOL> expecting any of: infix infix stopper
for my $entry (@array){ if ($string eq "text"){ break; } }
for my $entry (@array){ if ($string eq "text"){ last; } }
FOO: { for my $i ( @listone ){ for my $j ( @listtwo ){ if ( cond( $i,$j ) ){ last FOO; } } } }
for my $entry (@array){ if ($string eq "text"){ last; } }
LBL_SCORE: { for my $entry1 ( @array1 ){ for my $entry2 ( @array2 ){ if ( $entry1 eq $entry2 ){ last LBL_SCORE; } } } }
my $exitflag = 0; $SIG{INT} = sub { $exitflag=1 }; while(!$exitflag) { }
while (<>) { chomp; my $result = eval; print "$_ = $result\n"; }
> gmtime(2**30) gmtime(2**30) = Sat Jan 10 13:37:04 2004 > $x = $x = > $x =~ s/o/a/g $x =~ s/o/a/g = 2 > $x $x = faa
$ ips This is Interactive Perl shell perl> 2**128 3.40282366920938e+38 perl>
$ sudo apt-get install libdevel-repl-perl $ re.pl $ sudo apt-get install libapp-repl-perl $ iperl
my @arr = (2); print scalar @arr; print $ my $arrSize = @arr; print $arrSize;
my @arr = (2, 4, 8, 10); print "First result:\n"; print scalar @arr; print "\n\nSecond result:\n"; print $ print "\n\nThird result:\n"; my $arrSize = @arr; print $arrSize;
my @a = (undef, undef); my $size = @a; warn "Size: " . $ warn "Size: " . $size;
use strict; use warnings; use 5.005; my $ws_not_nl = qr/[^\S\x0a\x0d]/; for ( my $qq = qq["$_"]; printf "%-4s => %s\n", $qq, (eval $qq) =~ $ws_not_nl ? "match" : "no match"; }
static public final String HORIZONTAL_WHITESPACE = "[\\p{Blank}\\u200B\\u2060\\uFFEF]"
my @lines = qx/command arg1 arg2 arg3/; my $output = qx/command arg1 arg2 arg3/;
sub my_system { die "could not fork\n" unless defined(my $pid = fork); return waitpid $pid, 0 if $pid; exec @_; }
open my $read_fh, "-|", "gzip", "-d", $filename or die "could not open $filename: $!"; open my $write_fh, "|-", "gzip", $filename or die "could not open $filename: $!";
use IPC::Open2; open2 my $out, my $in, "/usr/bin/bc" or die "could not run bc"; print $in "5+6\n"; my $answer = <$out>;
use IPC::Open2; my $pid = open2(\*CHLD_OUT, \*CHLD_IN, waitpid( $pid, 0 ); my $child_exit_status = $? >> 8;
exec -> exec "command"; , system -> system("command"); and backticks -> print `command`;
print "Need to start exec command"; my $data2 = exec( print "Now END exec command"; print "Hello $data2\n\n";
print "Need to start system command"; my $data2 = system( print "Now END system command"; print "Hello $data2\n\n";
print "Need to start backticks command"; my $data2 = `ls`; print "Now END system command"; print "Hello $data2\n\n";
my %params = map { $_ => 1 } @badparams; if(exists($params{$someparam})) { ... }
if ( grep( /^$value$/, @array ) ) { print "found it"; }
use Benchmark; my @list; for (1..10_000) { push @list, $_; } timethese(10000, { if ( grep(/^5000$/o, @list) ) { } }, my %params = map { $_ => 1 } @list; if ( exists($params{5000}) ) { } }, });
Benchmark: timing 10000 iterations of grep, hash... grep: 8 wallclock secs ( 7.95 usr + 0.00 sys = 7.95 CPU) @ 1257.86/s (n=10000) hash: 50 wallclock secs (49.68 usr + 0.01 sys = 49.69 CPU) @ 201.25/s (n=10000)
use List::Util qw(first); use List::MoreUtils qw(any); use Benchmark; my @list = ( 1..10_000 ); my $hit = 5_000; my $hit_regex = qr/^$hit$/; my %params; $params{$_} = 1 for @list; timethese( 100_000, { die unless ( any { $hit_regex } @list ); }, die unless ( first { $hit_regex } @list ); }, die unless ( grep { $hit_regex } @list ); }, die unless ( $params{$hit} ); }, });
Benchmark: timing 100000 iterations of any, first, grep, hash... any: 0 wallclock secs ( 0.67 usr + 0.00 sys = 0.67 CPU) @ 149253.73/s (n=100000) first: 1 wallclock secs ( 0.63 usr + 0.01 sys = 0.64 CPU) @ 156250.00/s (n=100000) grep: 42 wallclock secs (41.95 usr + 0.08 sys = 42.03 CPU) @ 2379.25/s (n=100000) hash: 0 wallclock secs ( 0.01 usr + 0.00 sys = 0.01 CPU) @ 10000000.00/s (n=100000) (warning: too few iterations for a reliable count)
if ( grep( /^$value$/, @badparams ) ) { print "found"; }
for (@badparams) { if ($_ eq $value) { print "found"; } }
my %hash = map {$_ => 1} @badparams; print "found" if (exists $hash{$value});
use experimental print "found" if ($value ~~ @badparams);
use List::MoreUtils qw(any uniq);; @badparams = (1,2,3); $value = 1; print "found" if any {$_ eq $value} @badparams;
our %bad_params = map { $_ => 1 } qw(badparam1 badparam2 badparam3) if ($bad_params{$new_param}) { print "That is a bad parameter\n"; }
my @new_values = grep(/^2[\d].[\d][A-za-z]?/,@files); print join("\n", @new_values); print "\n";
my %bad_param_lookup; @bad_param_lookup{ @bad_params } = ( 1 ) x @bad_params;
use English qw<$LIST_SEPARATOR>; my $regex_str = do { local $LIST_SEPARATOR = "(?:@bad_params)"; }; my $regex = qr/$front_delim$regex_str$back_delim/;
my @badparams = (1,2,5,7, my $badparams = join( foreach my $par (4,5,6,7, { if ($badparams =~ /\b$par\b/) { print "$par is present\n"; } else { print "$par is not present\n"; } }
my $boolean = 0; if ( $boolean ) { print "$boolean evaluates to true\n"; } else { print "$boolean evaluates to false\n"; }
use strict; use warnings; use constant false => 0; use constant true => 1; my $val1 = true; my $val2 = false; print $val1, " && ", $val2; if ( $val1 && $val2 ) { print " evaluates to true.\n"; } else { print " evaluates to false.\n"; } print $val1, " || ", $val2; if ( $val1 || $val2 ) { print " evaluates to true.\n"; } else { print " evaluates to false.\n"; }
my $var1 = "5.0"; my $var2 = "5"; print "using operator eq\n"; if ( $var1 eq $var2 ) { print "$var1 and $var2 are equal!\n"; } else { print "$var1 and $var2 are not equal!\n"; } print "using operator ==\n"; if ( $var1 == $var2 ) { print "$var1 and $var2 are equal!\n"; } else { print "$var1 and $var2 are not equal!\n"; }
use constant FALSE => 1==0; use constant TRUE => not FALSE;
Result of the expression when $var is: Expression | 1 | --------------------+--------+--------+----------+-------+-----------+------- if( $var ) | true | true | true | false | false | false if( defined $var ) | true | true | true | true | true | false if( $var eq if( $var == 0 ) | false | true | true | true | true | true
use strict; use warnings; use constant { eTRUE => bless( do{\(my $o = 1)}, eFALSE => bless( do{\(my $o = 0)}, };
$ env -i perl -V ... @INC: /usr/lib/perl5/site_perl/5.18.0/x86_64-linux-thread-multi-ld /usr/lib/perl5/site_perl/5.18.0 /usr/lib/perl5/5.18.0/x86_64-linux-thread-multi-ld /usr/lib/perl5/5.18.0 .
$ perl -V ... %ENV: PERL5LIB="/home/myuser/test" @INC: /home/myuser/test /usr/lib/perl5/site_perl/5.18.0/x86_64-linux-thread-multi-ld /usr/lib/perl5/site_perl/5.18.0 /usr/lib/perl5/5.18.0/x86_64-linux-thread-multi-ld /usr/lib/perl5/5.18.0 .
use strict; use warnings; BEGIN { push @INC, } use Modules::Rest; gone(@_);
use strict; for (1 .. 2){ our ($o); my ($m); $o ++; $m ++; print __PACKAGE__, " >> o=$o m=$m\n"; package Fubb; print __PACKAGE__, " >> o=$o m=$m\n"; } print __PACKAGE__, " >> main::o=$main::o\n"; print __PACKAGE__, " >> main::m=$main::m\n"; for (1 .. 9){ use vars qw($uv); $uv ++; } print __PACKAGE__, " >> uv=$uv\n"; package Bubb; print __PACKAGE__, " >> main::uv=$main::uv\n";
use strict; use warnings; local $var = 42; print "var: $var\n";
Global symbol "$var" requires explicit package name.
use strict; use warnings; local $a = 42; print "var: $a\n";
sub main { $var = 42; } &main; print "var: $var\n";
our $foo = "BAR"; print $foo . "\n"; ${"foo"} = "BAZ"; print $foo . "\n";
print "package is: " . __PACKAGE__ . "\n"; our $test = 1; print "trying to print global var from main package: $test\n"; package Changed; { my $test = 10; my $test1 = 11; print "trying to print local vars from a closed block: $test, $test1\n"; } &Check_global; sub Check_global { print "trying to print global var from a function: $test\n"; } print "package is: " . __PACKAGE__ . "\n"; print "trying to print global var outside the func and from \"Changed\" package: $test\n"; print "trying to print local var outside the block $test1\n";
package is: main trying to print global var from main package: 1 trying to print local vars from a closed block: 10, 11 trying to print global var from a function: 1 package is: Changed trying to print global var outside the func and from "Changed" package: 1 trying to print local var outside the block
Global symbol "$test1" requires explicit package name at ./check_global.pl line 24. Execution of ./check_global.pl aborted due to compilation errors.
use feature package a; { my $b = 100; our $a = 10; print "$a \n"; print "$b \n"; } package b; print "in package b value of my b $a::b \n"; print "in package b value of our a $a::a \n";
for ($i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i} 0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7 0.8 0.8 0.9 0.9 1.0 1.0
foreach my $i ( 0.5, 1.5, 2.5, 3.5 ) { printf "$i -> %.0f\n", $i; } __END__ 0.5 -> 0 1.5 -> 2 2.5 -> 2 3.5 -> 4
for ($i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i } 0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7 0.8 0.8 0.9 0.9 1.0 1.0
$x[0] = 1.2; $x[1] = 1.7; foreach (@x){ print $_. print "\n"; }
sub round () { my ($x, $pow10) = @_; my $a = 10 ** $pow10; return (int($x / $a + (($x < 0) ? -0.5 : 0.5)) * $a); }
use strict; use warnings; use POSIX; my @values = (26.67,62.51,62.51,62.51,68.82,79.39,79.39); my $total1 = 0.00; my $total2 = 0; my $total3 = 0; my $total4 = 0.00; my $total5 = 0; my $value1; my $value2; my $value3; my $value4; my $value5; foreach $value1 (@values) { $value2 = $value1; $value3 = $value1; $value4 = $value1; $value5 = $value1; $total1 += $value1; $total2 += sprintf( $value3 = sprintf( $value3 =~ s/\. $total3 += $value3; $total4 += $value4; $total5 += floor(($value5 * 100.0) + 0.5); } $total1 *= 100; $total4 = floor(($total4 * 100.0) + 0.5); print print print print print exit(0);
my $var = -9.1; my $tmpRounded = int( abs($var) + 0.5)); my $finalRounded = $var >= 0 ? 0 + $tmpRounded : 0 - $tmpRounded;
if ($value =~ m/\d\..*5$/){ $format =~ /.*(\d)f$/; if (defined $1){ my $coef = "0." . "0" x $1 . "05"; $value = $value + $coef; } } $value = sprintf( "$format", $value );
$string = "START Curabitur mollis, dolor ut rutrum consequat, arcu nisl ultrices diam, adipiscing aliquam ipsum metus id velit. Aenean vestibulum gravida felis, quis bibendum nisl euismod ut. Nunc at orci sed quam pharetra congue. Nulla a justo vitae diam eleifend dictum. Maecenas egestas ipsum elementum dui sollicitudin tempus. Donec bibendum cursus nisi, vitae convallis ante ornare a. Curabitur libero lorem, semper sit amet cursus at, cursus id purus. Cras varius metus eu diam vulputate vel elementum mauris tempor. Morbi tristique interdum libero, eu pulvinar elit fringilla vel. Curabitur fringilla bibendum urna, ullamcorper placerat quam fermentum id. Nunc aliquam, nunc sit amet bibendum lacinia, magna massa auctor enim, nec dictum sapien eros in arcu. Pellentesque viverra ullamcorper lectus, a facilisis ipsum tempus et. Nulla mi enim, interdum at imperdiet eget, bibendum nec END"; $string =~ /(START)(.+?)(END)/; print $2;
$newstring = $oldstring; $newstring =~ s/foo/bar/g;
my $newstring = $oldstring; $newstring =~ s/foo/bar/g;
use 5.013; my $newstring = $oldstring =~ s/foo/bar/gr;
my $oldstring = "replace donotreplace replace donotreplace replace donotreplace"; my $newstring = $oldstring; $newstring =~ s/replace/newword/g; print $newstring; %: newword donotreplace newword donotreplace newword donotreplace
my @orig = ( my @list = map { s/this/that/; $_ } map { $_ } @orig;
Can Execution of script.pl aborted due to compilation errors.
use strict; my $oldstring = "foo one foo two foo three"; my $newstring = $oldstring; $newstring =~ s/foo/bar/g; print "$oldstring","\n"; print "$newstring","\n";
if ( 4 == "4" ) { print "true"; } else { print "false"; } true if ( "4" == "4.0" ) { print "true"; } else { print "false"; } true print "3"+4 7
if ( "4" eq "4.0" ) { print "true"; } else { print "false"; } false if ( "4.0" eq "4.0" ) { print "true"; } else { print "false"; } true
use File::Basename; my $dirname = dirname(__FILE__);
use FindBin; $0 = "stealth"; print "The actual path to this is: $FindBin::Bin/$FindBin::Script\n";
use Cwd qw(abs_path); my $path = abs_path($0); print "$path\n";
use FindBin print "The script is located in $Bin.\n";
use strict; use warnings; use File::Spec; use File::Basename; my $dir = dirname(File::Spec->rel2abs(__FILE__));
$0 =~ m/(.+)[\/\\](.+)$/; print "full path: $1, file name: $2\n";
use strict; my $path = $0; $path =~ s/\.\ if ($path =~ /\ if ($path =~ /^\ $path =~ /^((\/[^\/]+){1,}\/)[^\/]+$/; $path = $1; } else { $path =~ /^(([^\/]+\/){1,})[^\/]+$/; my $path_b = $1; my $path_a = `pwd`; chop($path_a); $path = $path_a."/".$path_b; } } else{ $path = `pwd`; chop($path); $path.="/"; } $path =~ s/\/\ print "\n$path\n";
my $thisfile = $1 if $0 =~ /\\([^\\]*)$|\/([^\/]*)$/; print "You are running $thisfile now.\n";
use strict ; use warnings ; use Cwd sub ResolveMyProductBaseDir { my $ScriptAbsolutPath = abs_path($0) ; $ScriptAbsolutPath =~ m/^(.*)(\\|\/)(.*)\.([a-z]*)/; $RunDir = $1 ; $RunDir =~s/\\/\ my @DirParts = split ( for (my $count=0; $count < 4; $count++) { pop @DirParts ; } my $ProductBaseDir = join ( return $ProductBaseDir ; }
my $path; use File::Basename; my $file = basename($ENV{SCRIPT_NAME}); if (exists $ENV{MOD_PERL} && ($ENV{MOD_PERL_API_VERSION} < 2)) { if ($^O =~/Win/) { $path = `echo %cd%`; chop $path; $path =~ s!\\!/!g; $path .= $ENV{SCRIPT_NAME}; } else { $path = `pwd`; $path .= "/$file"; } } else { require Cwd; $path = Cwd::getcwd()."/$file"; } print $path;
my $self = `pwd`; chomp $self; $self .= print "self=$self\n";
$ /my/temp/Host$ perl ./host-mod.pl self=/my/temp/Host/host-mod.pl $ /my/temp/Host$ ./host-mod.pl self=/my/temp/Host/host-mod.pl $ /my/temp/Host$ ../Host/./host-mod.pl self=/my/temp/Host/host-mod.pl
use File::Basename; my $script_dir = undef; if(-l __FILE__) { $script_dir = dirname(readlink(__FILE__)); } else { $script_dir = dirname(__FILE__); }
my $callpath = $0; my $pwd = `pwd`; chomp($pwd); if ($callpath !~ /^\ $callpath =~ s!^\./!!; $callpath =~ s!/\./!/!g; $callpath =~ s!/\./!/!g; $callpath =~ s!/[^/]+/\.\./!/!g; $callpath =~ s!/[^/]+/\.\./!/!g; my $calldir = $callpath; $calldir =~ s/(.*)\/([^\/]+)/$1/;
sub get_script_full_path { use File::Basename; use File::Spec; use Cwd qw(chdir cwd); my $curr_dir = cwd(); chdir(dirname($0)); my $dir = $ENV{PWD}; chdir( $curr_dir); return File::Spec->catfile($dir, basename($0)); }
$ sudo apt-get install dh-make-perl build-essential apt-file $ sudo apt-file update
$ cd ~/some/path $ dh-make-perl --build --cpan Some::Random::Module $ sudo dpkg -i libsome-random-module-perl-0.01-1_i386.deb
perl -MCPAN -e "CPAN::Shell->force(qw(install Foo::Bar));"
cpan> install foo (again to install the foo module)
$ perl -MCPAN -e shell cpan[1]> o conf prerequisites_policy follow cpan[2]> o conf commit exit
perl Build.PL ./Build destdir=$HOME install_base=$HOME ./Build destdir=$HOME install_base=$HOME install
use warnings; use strict; $ENV{ my @perl = qw(LWP::Simple XML::LibXML MIME::Lite DBI DateTime Config::Tiny Proc::ProcessTable); chomp(my $curl = `which curl`); if(!$curl){ system( chomp(my $cpanm = system( if($cpanm){ system( foreach my $x (@perl){ eval "use $x"; if($@){ system("cpanm $x"); eval "use $x"; } }
my @my_array = ("one","two","three","two","three");
sub uniq { my %seen; grep !$seen{$_}++, @_; } my @array = qw(one two three two three); my @filtered = uniq(@array); print "@filtered\n";
use strict; use warnings; use List::MoreUtils qw(uniq); my @dup_list = qw(1 1 1 2 3 4 4); my @uniq_list = uniq(@dup_list);
my %unique = (); foreach my $item (@myarray) { $unique{$item} ++; } my @myuniquearray = keys %unique;
my @in=qw(1 3 4 6 2 4 3 2 6 3 2 3 4 4 3 2 5 5 32 3); my @out=keys %{{ map{$_=>1}@in}}; print join
%seen=(); @unique = grep { ! $seen{$_} ++ } @array;
my @arr; my @uniqarr; foreach my $var ( @arr ){ if ( ! grep( /$var/, @uniqarr ) ){ push( @uniqarr, $var ); } }
sub get_unique { my %seen; grep !$seen{$_}++, @_; } my @unique = get_unique(@array);
use List::MoreUtils qw(uniq); my @unique = uniq(@array);
use strict; sub uniq { my %seen; grep !$seen{$_}++, @_; } my @teststrings = ("one", "two", "three", "one"); my @filtered = uniq @teststrings; print "uniq: @filtered\n"; my @sorted = sort @teststrings; print "sort: @sorted\n"; my @sortedfiltered = uniq sort @teststrings; print "uniq sort : @sortedfiltered\n";
my @array = ("a","b","c","b","a","d","c","a","d"); my %hash = map { $_ => 1 } @array; my @unique = keys %hash; print "@unique","\n";
my @record = qw( yeah I mean uh right right uh yeah so well right I maybe ); my %record; print grep !$record{$_} && ++$record{$_}, @record;
... grep !(exists $record{$_} || undef $record{$_}), @record;
use Data::Dumper; my %hash = ( print Dumper(\%hash);
use strict; use warnings; use YAML; my %variable = ( print "
use strict; use warnings; use MTie::Hash; use Data::Printer; my $h = tie my %h, "Tie::StdHash"; @h{ p %h; print "\n"; p $h;
{ a "A", b "B", c "C", d "D" } (tied to Tie::StdHash) Tie::StdHash { public methods (9) : CLEAR, DELETE, EXISTS, FETCH, FIRSTKEY, NEXTKEY, SCALAR, STORE, TIEHASH private methods (0) internals: { a "A", b "B", c "C", d "D" } }
foreach(keys %my_hash) { print "$_ / $my_hash{$_}\n"; }
use Dumpvalue; ... my %hash = { key => "value", foo => "bar" }; my $dumper = new DumpValue(); $dumper->dumpValue(\%hash);
print "$_ => $my_hash{$_}\n" for (sort keys %my_hash);
$ perl -wle 1 $ perl -wle 1 $ perl -wle (empty line)
my $method = my $obj = My::Class->new(); $obj->$method(
BEGIN{ *CORE::GLOBAL::unlink = sub {print }; unlink($_) for @ARGV
my $var = q my $var2 = q{A more pleasant way of escaping.}; my $var3 = q(Others prefer parens as the quote mechanism.);
my $var4 = qq{This "$mechanism" is broken. Please inform "$user" at "$email" about it.};
my $output = qx{type "$path"}; my $moreout = qx{type "$path" 2>&1};
sub MyRegexCheck { my ($string, $regex) = @_; if ($string) { return ($string =~ $regex); } return; } my $regex = qr{http: @results = MyRegexCheck(q{http:
my @allowed = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z { }); my @badwords = qw(WORD1 word2 word3 word4); my @numbers = qw(one two three four 5 six seven); my @list = ( my $arrayref = [ qw(and it works in arrays too) ];
for ($item) { s/&‎nbsp;/ /g; s/<.*?>/ /g; $_ = join(" ", split(" ", $_)); }
print results_of_foo(), results_of_xyzzy(), results_of_quux(), ;
my @lines = <DATA>; for (@lines) { print if /bad/; } __DATA__ some good data some bad data more good data more good data
sub do_stuff_with_a_hash (&\%) { my ( $block_of_code, $hash_ref ) = @_; while ( my ( $k, $v ) = each %$hash_ref ) { $block_of_code->( $k, $v ); } }
use Data::Dumper; do_stuff_with_a_hash { local $Data::Dumper::Terse = 1; my ( $k, $v ) = @_; say qq(Hey, the key is "$k"!); say sprintf qq(Hey, the value is "%v"!), Dumper( $v ); } %stuff_for ;
my $old_die_handler = $SIG{__DIE__}; $SIG{__DIE__} = sub { say q(Hey! I ;
overload::constant integer => sub { my $lit = shift; return $lit > 2_000_000_000 ? Math::BigInt->new( $lit ) : $lit };
LINE: while (defined($_ = <ARGV>)) { print $_; }{ print "$. Files"; }
while( <> ){ print "top of loop\n"; chomp; next if /next/i; last if /last/i; print "bottom of loop\n"; }continue{ print "continue\n"; }
SKIP: { skip() if $something; print "Never printed"; } sub skip { no warnings "exiting"; last SKIP; }
local $SIG{__WARN__} = sub { die @_ }; $num = "two"; $sum = 1 + $num; print "Never reached";
sub foo { return @_; } $count =()= foo(qw/a b c d/);
package MyClass; my $object = { }; bless $object, "MyClass";
sub new { my $class = shift; my $self = { }; bless $self, $class; }
package Person; sub new { my $class = shift; my $self = { _firstName => shift, _lastName => shift, _ssn => shift, }; print "First Name is $self->{_firstName}\n"; print "Last Name is $self->{_lastName}\n"; print "SSN is $self->{_ssn}\n"; bless $self, $class; return $self; }
(() => { class Animal { constructor(args) { this.name = args.name; this.sound = args.sound; } } /* [WRONG] (global scope corruption) * var animal = Animal({ * * * }); * console.log(animal.name + * console.log(window.name); */ var animal = new Animal( ); console.log(animal.name + console.log(window.name); })();
(() => { var Animal = function(args) { this.name = args.name; this.sound = args.sound; return this; }; var animal = new Animal({ }); console.log(animal.sound); })();
(sub { my $Animal = (sub { return { }; }); my $animal = $Animal->({ }); print $animal->{sound}; })->();
(sub { my $Animal = (sub { $name = $_[0]{ $sound = $_[0]{ return { print $sound . "\n"; } }; }); my $animal = $Animal->({ }); $animal->{ })->();
(() => { var Animal = (() => { var InnerAnimal = function(args) { this.name = args.name; this.sound = args.sound; }; InnerAnimal.prototype.performSound = function() { console.log(this.name); }; return InnerAnimal; })(); var animal = new Animal({ }); animal.performSound(); })();
(() => { var Person = function() { this.name = "Sam"; }; var correct = new Person; })();
package Animal; sub new { my $packageRef = $_[0]; my $name = $_[1]->{ my $sound = $_[1]->{ my $this = { }; bless($this, $packageRef); return $this; } sub performSound { my $this = shift; my $sound = $this->{ print $sound . "\n"; } package main; my $animal = Animal->new({ }); $animal->performSound();
(sub { my $Animal = (sub { my $AnimalPrototype = { return $_[0]->{ } }; my $call = sub { my $this = $_[0]; my $proc = $_[1]; if (exists $this->{$proc}) { return $this->{$proc}->(); } else { return $this->{prototype}->{$proc}->($this, $proc); } }; return sub { my $name = $_[0]->{name}; my $sound = $_[0]->{sound}; my $this = { }; }; })->(); my $animal = $Animal->({ }); print($animal->{call}($animal, })->();
package Bug; sub print_me { my ($self) = @_; print "ID: $self->{id}\n"; print "$self->{descr}\n"; print "(Note: problem is fatal)\n" if $self->{type} eq "fatal"; }
use Getopt::Long; my $data = "file.dat"; my $length = 24; my $verbose; $result = GetOptions ("length=i" => \$length, "file=s" => \$data, "verbose" => \$verbose);
my $numArgs = $ print "thanks, you gave me $numArgs command-line arguments.\n"; foreach my $argnum (0 .. $ print "$ARGV[$argnum]\n"; }
print "value of -x: $x\n"; print "value of -name: $name\n";
% ./myprog -x -name=Jeff value of -x: 1 value of -name: Jeff
( $st, $prod, $ar, $file, $chart, $e, $max, $flag ,$id) = @ARGV;
while (my $arg = shift) { print "Found argument $arg\n"; }
my $output_file; if((scalar (@ARGV) == 2) && ($ARGV[0] eq "-i")) { $output_file= chomp($ARGV[1]) ; }
my @array = qw(a b c); foo(@array); foo(@array[0..1]); foo($array[0], $array[1], $array[2]); sub foo ($;$$) { print "@_\n" } foo(@array); foo(@array[0..1]); foo($array[0], $array[1], $array[2]);
use v5.20; use feature qw(signatures); no warnings qw(experimental::signatures); animals( sub animals ($cat, $dog, $lizard = say "The cat is $cat"; say "The dog is $dog"; say "The lizard is $lizard"; }
cpan> o conf prerequisites_policy follow cpan> o conf commit
cpan> o conf prerequisites_policy follow cpan> o conf commit
cpan> o conf prerequisites_policy cpan> o conf build_requires_install_policy yes cpan> o conf commit
yes | perl -MCPAN -e "CPAN::Shell->notest(qw!install Your::Module!)"
`sudo apt install cpanminus`; while (<>) { if (/USE /i) { my $line=$_; $line=~ s/\s $line=~ /^(.*)\./; $line=~ s/\; $line=~s/^USE $line=~s/lib.* $line=~s/feature.* $line=~s/strict $line=~s/warnings $line =~ s/^(.*)\(.*/$1/; unless ($line eq my $cmd= print "Installing $line \n"; open my $cmd_fh, "$cmd |"; while (<$cmd_fh>) { print "$_"; } close $cmd_fh; print "\n"; } } }
open(FILE, $document = <FILE>; close (FILE); print $document;
my $file = "index.html"; my $document = do { local $/ = undef; open my $fh, "<", $file or die "could not open $file: $!"; <$fh>; };
use File::Slurp; $all_of_it = read_file($filename); @all_lines = read_file($filename);
open (INPUT, $file) || die "can while (<INPUT>) { chomp; } close(INPUT) || die "can
{ local(*INPUT, $/); open (INPUT, $file) || die "can $var = <INPUT>; }
{ open(F, "filename"); local $/ = undef; $d = <F>; }
open my $fh, read $fh, my $string, -s $fh; close $fh;
my $text = ""; while (my $line = <FILE>) { $text .= $line; }
use strict; use warnings; my $filename = my $content = do{local(@ARGV,$/)=$filename;<>}; my $content2 = do{local(@ARGV,$/)=$filename;<>}; my $content3 = do{local(@ARGV,$/)=$filename;<>}; print "After reading a file 3 times redirecting to STDIN: $.\n"; open (FILE, "<", $filename) or die $!; print "After opening a file using dedicated file handle: $.\n"; while (<FILE>) { print "read line: $.\n"; } print "before close: $.\n"; close FILE; print "after close: $.\n";
After reading a file 3 times redirecting to STDIN: 3 After opening a file using dedicated file handle: 3 read line: 1 read line: 2 (...) read line: 46 before close: 46 after close: 0
my $content = do{local $/; open(my $f1, my $content2 = do{local $/; open(my $f2, my $content3 = do{local $/; open(my $f3,
binmode(STDOUT, ":utf8"); binmode(STDIN, ":encoding(utf8)");
open my $fh, ">:utf8", $filename or die "could not open $filename: $!\n"; open my $fh, "<:encoding(utf-8)", $filename or die "could not open $filename: $!\n";
use open ":encoding(utf8)"; use open IN => ":encoding(utf8)", OUT => ":utf8";
use utf8; use open binmode(STDOUT, ":utf8"); open(FH, ">test.txt"); print FH "something éá"; use YAML qw(LoadFile Dump); my $PUBS = LoadFile("cache.yaml"); my $f = "2917"; my $ref = $PUBS->{$f}; print "$f \"".$ref->{name}."\" ". $ref->{primary_uri}." ";
--- 2917: id: 2917 name: Semanário primary_uri: 2917.xml
POD is the official way to do multi line comments in Perl,
=pod my $object = NotGonnaHappen->new(); ignored_sub(); $wont_be_assigned = 37; =cut
=begin comment my $object = NotGonnaHappen->new(); ignored_sub(); $wont_be_assigned = 37; =end comment =cut
use strict; use warnings; =for comment Example of multiline comment. Example of multiline comment. =cut print "Multi Line Comment Example \n";
if (index($str, $substr) != -1) { print "$str contains $substr\n"; }
if ($mystring =~ /s1\.domain\.com/) { print qq("$mystring" contains "s1.domain.com"\n); }
my $substring = "s1.domain.com"; if ($mystring =~ /\Q$substring\E/) { print qq("$mystring" contains "$substring"\n); }
my $substring = "s1.domain.com"; if (not index($mystring, $substr)) { print qq("$mystring" doesn }
if (index(lc($str), lc($substr)) != -1) { print "$str contains $substr\n"; }
print "$base_path is a plain file!\n" if -f $base_path;
-X FILEHANDLE -X EXPR -X DIRHANDLE -X A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests $_, except for "-t", which tests STDIN. Unless otherwise documented, it returns 1 for true and doesn’t exist. Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of: -r File is readable by effective uid/gid. -w File is writable by effective uid/gid. -x File is executable by effective uid/gid. -o File is owned by effective uid. -R File is readable by real uid/gid. -W File is writable by real uid/gid. -X File is executable by real uid/gid. -O File is owned by real uid. -e File exists. -z File has zero size (is empty). -s File has nonzero size (returns size in bytes). -f File is a plain file. -d File is a directory. -l File is a symbolic link. -p File is a named pipe (FIFO), or Filehandle is a pipe. -S File is a socket. -b File is a block special file. -c File is a character special file. -t Filehandle is opened to a tty. -u File has setuid bit set. -g File has setgid bit set. -k File has sticky bit set. -T File is an ASCII text file (heuristic guess). -B File is a "binary" file (opposite of -T). -M Script start time minus file modification time, in days.
$fileToLocate = if (-e $fileToLocate) { print "File is present"; }
print "File $base_path is exists!\n" if -f $base_path;
$|++; $old_handle = select( STDERR ); $|++; select( $old_handle );
cd /tmp cat > perldbgcall.sh << PERLDB_OPTS="RemotePort=localhost:7234" perl -d -e "do EOF chmod +x perldbgcall.sh
use 5.10.1; use warnings; use strict; my $b = my $a = sub { "hello $b there" }; $b = print "YEAH " . $a->() . " CMON\n"; $b = print "CMON " . &$a . " YEAH\n"; $DB::single=1; $b = print "STEP " . &$a . " NOW\n"; $b = print "STEP " . &$a . " AGAIN\n";
$ nc -l 7234 Loading DB routines from perl5db.pl version 1.32 Editor support available. Enter h or `h h main::(-e:1): do DB<1> r main::(./test.pl:29): $b = DB<1>
.... main::(./test.pl:29): $b = DB<1> n main::(./test.pl:30): print "STEP " . &$a . " NOW\n"; DB<1> n main::(./test.pl:31): $b = DB<1> n main::(./test.pl:32): print "STEP " . &$a . " AGAIN\n"; DB<1> n Debugged program terminated. Use q to quit or R to restart, use o inhibit_exit to avoid stopping after program termination, h q, h R or h o to get additional info. DB<1>
YEAH hello 2 there CMON CMON hello 3 there YEAH STEP hello 4 there NOW STEP hello 5 there AGAIN
eval join if ($@) { print "Content-type: text/plain:\n\nError in the script:\n$@\n; } __DATA__
use Log::Log4perl qw(:easy); Log::Log4perl->easy_init( { level => $DEBUG, file => ">>d:\\tokyo.log" } ); my $logger = Log::Log4perl::get_logger(); $logger->debug("your log message");
while (my ($key, $value) = each(%hash)) { } foreach my $key (keys(%hash)) { }
%h = (a => 1, b => 2); foreach my $k (keys %h) { $h{uc $k} = $h{$k} * 2; }
%h = (a => 1, b => 2); keys %h; while(my($k, $v) = each %h) { $h{uc $k} = $h{$k} * 2; }
keys %h; while(my($k, $v) = each %h) { if(...) { delete $h{$k}; } }
my %hash = ( foo => 1, bar => 2, baz => 3, quux => 4 ); while ( my ($k, $v) = each %hash ) { print "found key $k\n"; last if $k eq } print "the hash contains:\n"; while ( my ($k, $v) = each %hash ) { print "$k => $v\n"; }
found key bar found key baz the hash contains: quux => 4 foo => 1
while ( my ($key,$val) = each %a_hash ) { print "$key => $val\n"; last if $val; } while ( my ($key,$val) = each %a_hash ) { print "$key => $val\n"; }
use Data::Dump qw(dump); my @a = (1, [2, 3], {4 => 5}); dump(@a);
use 5.012_002; use strict; use warnings; my @array = qw/ 1 2 3 4 5 /; { local $" = print "@array\n"; }
use feature q(say); use strict; use warnings; my @array = qw/ 1 2 3 4 5 /; { local $, = say @array; }
use strict; use Data::Dumper; my $GRANTstr = $GRANTstr =~ s/, /,/g; my @GRANTs = split /,/ , $GRANTstr; print Dumper(@GRANTs) . "===\n\n"; print Dumper(\@GRANTs) . "===\n\n"; print Data::Dumper->Dump([\@GRANTs], [qw(GRANTs)]);
$VAR1 = $VAR2 = $VAR3 = $VAR4 = $VAR5 = $VAR6 = $VAR7 = === $VAR1 = [ ]; === $GRANTs = [ ];
$a = test_value; print "First program: ", $a, "\n"; sub test_value { return "test passed"; } Output: First program sub test_value { return "test passed"; } $a = test_value; print "Second program: ", $a, "\n"; Output: Second program
use strict; sub test_value; my $a = test_value; ....... sub test_value { return "test_passed"; }
use strict $ref = \$foo; print $$ref; $ref = "foo"; print $$ref;
while (<>) { } continue { print or die "-p destination: $!\n"; }
$ perl -MO=Deparse -p -e 1 LINE: while (defined($_ = <ARGV>)) { } continue { die "-p destination: $!\n" unless print $_; } -e syntax OK
$ perl -MO=Deparse -p -i -e 1 BEGIN { $^I = ""; } LINE: while (defined($_ = <ARGV>)) { } continue { die "-p destination: $!\n" unless print $_; } -e syntax OK
$ perl -MO=Deparse -p -i.bak -e 1 BEGIN { $^I = ".bak"; } LINE: while (defined($_ = <ARGV>)) { } continue { die "-p destination: $!\n" unless print $_; } -e syntax OK
nohup yourScript.sh script args >script.out 2>script.error&
if [[ $ echo "Name of pid file not given." exit fi PIDFILE=$1 shift if [[ $ echo "No command given." exit fi echo "Checking pid in file $PIDFILE." PID=$(cat $PIDFILE 2>/dev/null) if [[ $? = 0 ]]; then ps -p $PID >/dev/null 2>&1 if [[ $? = 0 ]]; then echo "Command $1 already running." exit fi fi echo $$ >$PIDFILE COMMAND=$1 shift while true; do $COMMAND "$@" sleep 10 done
nohup restart.sh pidFileName yourScript.sh script args >script.out 2>&1 &
sudo mkservice -d /var/lib/svscan/some-service-name -l -u user -L loguser "command line here"
# # . /etc/rc.d/init.d/functions case "$1" in start) echo -n $"Starting <mydaemon> daemon: " echo daemon <mydaemon> echo ;; stop) echo -n $"Shutting down <mydaemon>: " killproc <mydaemon> echo ;; status) status <mydaemon> ;; restart) $0 stop $0 start ;; *) echo $"Usage: $0 {start|stop|status|restart}" exit 1 esac exit 0
import subprocess import time createDaemon() while True: subprocess.call(" ".join(sys.argv[1:]),shell=True) time.sleep(10)
use strict; use warnings; use Getopt::Long; use File::Spec; use File::Pid; use IPC::System::Simple qw(system); my ($pid_file, $command); GetOptions("pidfile=s" => \$pid_file, "command=s" => \$command) or print "Usage: $0 --pidfile=<pidfile> --command=<executable> <arguments>\n", exit; my @arguments = @ARGV; my $pid_obj = File::Pid->new({file => $pid_file}); if ($pid_obj->running()) { exit 0; } print "Pid " . $pid_obj->pid . " no longer running; restarting $command @arguments\n"; system($command, @arguments);
use strict; use warnings; use File::Pid; File::Pid->new({file => "pidfile"})->write; print "$0 got arguments: @ARGV\n";
Pid <random number here> no longer running; restarting ./example.pl 1 2 3 ./example.pl got arguments: 1 2 3
cmd: date log: file: /var/log/date.log age: 86400 num: 7 size: 1 timestamp: true
cmd: date log: file: /var/log/date.log age: 86400 num: 7 size: 1 stderr: file: /var/log/date-error.log age: 86400 num: 7 size: 1 timestamp: true
if [ "$1" = echo "timeout defaults to 1 sec.\nUsage: $(basename "$0") sentinel-pidfile [timeout] command [command arg [more command args...]]" exit fi if [ $ echo "No command given." exit fi PIDFILE=$1 shift TIMEOUT=1 if [[ $1 =~ ^[0-9]+(\.[0-9]+)?$ ]]; then TIMEOUT=$1 [ $ shift fi echo "Checking pid in file ${PIDFILE}." >&2 if [ -f "$PIDFILE" ]; then PID=$(< $PIDFILE) if [ $? = 0 ]; then ps -p $PID >/dev/null 2>&1 if [ $? = 0 ]; then echo "This script is (probably) already running as PID ${PID}." exit fi fi fi echo $$ >$PIDFILE cleanup() { rm $PIDFILE } trap cleanup EXIT while true; do eval "$@" echo "I am $$ and my child has exited; restart in ${TIMEOUT}s" >&2 sleep $TIMEOUT done
$ term-daemonize.sh pidfilefortesting 0.5 Checking pid in file pidfilefortesting. azzzcd I am 79281 and my child has exited; restart in 0.5s azzzcd I am 79281 and my child has exited; restart in 0.5s azzzcd I am 79281 and my child has exited; restart in 0.5s ^C $ term-daemonize.sh pidfilefortesting 0.5 azzzcd azzzcd azzzcd ^C
echo "ghai ghai" | sed "s/[^\sg] gg echo "ghai ghai" | sed "s/[^ g] g g
echo a b cX | sed -r "s/(a\sb[[:space:]]c[^[:space:]])/Result: \1/" Result: a b cX
a[:space:]b instead use a\sb or a[[:space:]]b a[^\s]b instead use a[^[:space:]]b
my %new_hash = %hash1; foreach my $key2 ( keys %hash2 ) { if( exists $new_hash{$key2} ) { warn "Key [$key2] is in both hashes!"; ... next; } else { $new_hash{$key2} = $hash2{$key2}; } }
foreach my $key2 ( keys %hash2 ) { if( exists $hash1{$key2} ) { warn "Key [$key2] is in both hashes!"; ... next; } else { $hash1{$key2} = $hash2{$key2}; } }
while($Element=shift(@Array)) { SubRoutine($Element); }
while(scalar(@Array) !=0) { $Element=shift(@Array); SubRoutine($Element); }
my @array = qw( 1 2 3 ); for (@array) { $_ = $_ *2 ; } print "@array";
use strict; use warnings; use Benchmark qw(:all); our @input_array = (0..1000); my $a = sub { my @array = @{[ @input_array ]}; my $index = 0; foreach my $element (@array) { die unless $index == $element; $index++; } }; my $b = sub { my @array = @{[ @input_array ]}; my $index = 0; while (defined(my $element = shift @array)) { die unless $index == $element; $index++; } }; my $c = sub { my @array = @{[ @input_array ]}; my $index = 0; while (scalar(@array) !=0) { my $element = shift(@array); die unless $index == $element; $index++; } }; my $d = sub { my @array = @{[ @input_array ]}; foreach my $index (0.. $ my $element = $array[$index]; die unless $index == $element; } }; my $e = sub { my @array = @{[ @input_array ]}; for (my $index = 0; $index < $ my $element = $array[$index]; die unless $index == $element; } }; my $f = sub { my @array = @{[ @input_array ]}; while (my ($index, $element) = each @array) { die unless $index == $element; } }; my $count; timethese($count, { });
Benchmark: running 1, 2, 3, 4, 5, 6 for at least 3 CPU seconds... 1: 3 wallclock secs ( 3.16 usr + 0.00 sys = 3.16 CPU) @ 12560.13/s (n=39690) 2: 3 wallclock secs ( 3.18 usr + 0.00 sys = 3.18 CPU) @ 7828.30/s (n=24894) 3: 3 wallclock secs ( 3.23 usr + 0.00 sys = 3.23 CPU) @ 6763.47/s (n=21846) 4: 4 wallclock secs ( 3.15 usr + 0.00 sys = 3.15 CPU) @ 9596.83/s (n=30230) 5: 4 wallclock secs ( 3.20 usr + 0.00 sys = 3.20 CPU) @ 6826.88/s (n=21846) 6: 3 wallclock secs ( 3.12 usr + 0.00 sys = 3.12 CPU) @ 5653.53/s (n=17639)
AE United Arab Emirates AG Antigua & Barbuda AN Netherlands Antilles AS American Samoa BA Bosnia and Herzegovina BF Burkina Faso BN Brunei Darussalam
$ echo a b c | cut -f 1 -d a $ echo a b c | cut -f 1,2 -d a b $ echo a b c | cut -f 1 -d b c
$ awk United Arab Emirates AE Antigua & Barbuda AG Netherlands Antilles AN American Samoa AS Bosnia and Herzegovina BA Burkina Faso BF Brunei Darussalam BN
United Arab Emirates AE Antigua & Barbuda AG Netherlands Antilles AN American Samoa AS Bosnia and Herzegovina BA Burkina Faso BF Brunei Darussalam BN
United Arab Emirates AE Antigua & Barbuda AG Netherlands Antilles AN American Samoa AS Bosnia and Herzegovina BA Burkina Faso BF Brunei Darussalam BN
$ awk United Arab Emirates AE Antigua & Barbuda AG Netherlands Antilles AN American Samoa AS Bosnia and Herzegovina BA Burkina Faso BF Brunei Darussalam BN
$ cat c AE-United-Arab-Emirates AG-Antigua-&-Barbuda AN-Netherlands-Antilles AS-American-Samoa BA-Bosnia-and-Herzegovina BF-Burkina-Faso BN-Brunei-Darussalam $ awk United-Arab-Emirates-AE Antigua-&-Barbuda-AG Netherlands-Antilles-AN American-Samoa-AS Bosnia-and-Herzegovina-BA Burkina-Faso-BF Brunei-Darussalam-BN
United Arab Emirates AE Antigua & Barbuda AG Netherlands Antilles AN American Samoa AS Bosnia and Herzegovina BA Burkina Faso BF Brunei Darussalam BN
United;Arab;Emirates;AE Antigua;&;Barbuda;AG Netherlands;Antilles;AN American;Samoa;AS Bosnia;and;Herzegovina;BA Burkina;Faso;BF Brunei;Darussalam;BN
awk a=$1 sub( " [^"FS"]+ ["FS"]+ " , "" ) print $0, a United Arab Emirates AE Antigua & Barbuda AG Netherlands Antilles AN American Samoa AS Bosnia and Herzegovina BA Burkina Faso BF Brunei Darussalam BN
AE..United....Arab....Emirates AG..Antigua....&...Barbuda AN..Netherlands...Antilles AS..American...Samoa BA..Bosnia...and...Herzegovina BF..Burkina...Faso BN..Brunei...Darussalam
United....Arab....Emirates;AE Antigua....&...Barbuda;AG Netherlands...Antilles;AN American...Samoa;AS Bosnia...and...Herzegovina;BA Burkina...Faso;BF Brunei...Darussalam;BN
Arab Emirates AE United & Barbuda AG Antigua Antilles AN Netherlands Samoa AS American and Herzegovina BA Bosnia Faso BF Burkina Darussalam BN Brunei
Swap \([^ ]*\) = Match anything until we reach a space, store in $1 \(.*\) = Match everything else, store in $2 With \2 = Retrieve $2 \1 = Retrieve $1
s = Swap / = Beginning of source pattern \( = start storing this value [^ ] = text not matching the space character * = 0 or more of the previous pattern \) = stop storing this value \( = start storing this value . = any character * = 0 or more of the previous pattern \) = stop storing this value / = End of source pattern, beginning of replacement \2 = Retrieve the 2nd stored value \1 = Retrieve the 1st stored value / = end of replacement
"print \$a unless \$b;\nreturn;\n" =~ test.pl syntax OK
HelloPerlBuildWorld | |----------> lib | |----------> t
use strict; use warnings; package HelloPerlBuildWorld; $HelloPerlBuildWorld::VERSION = sub hello { return "Hello, Perl Build World!"; } sub bye { return "Goodbye, cruel world!"; } sub repeat { return 1; } sub argumentTest { my ($booleanArg) = @_; if (!defined($booleanArg)) { return "null"; } elsif ($booleanArg eq "false") { return "false"; } elsif ($booleanArg eq "true") { return "true"; } else { return "unknown"; } return "Unreachable code: cannot be covered"; } 1;
use strict; use warnings; use Test::More qw(no_plan); BEGIN { use_ok( require_ok( my $helloCall = HelloPerlBuildWorld::hello(); like($helloCall, qr/Hello, .*World/, "hello() RE test"); is($helloCall, "Hello, Perl Build World!", "hello() IS test"); for (my $ctr=1; $ctr<=10; $ctr++) { my $repeatCall = HelloPerlBuildWorld::repeat(); is($repeatCall, 1, "repeat() IS test"); } my $argumentTestCall1 = HelloPerlBuildWorld::argumentTest(); is($argumentTestCall1, "null", "argumentTest() IS null test"); my $argumentTestCall2 = HelloPerlBuildWorld::argumentTest("true"); is($argumentTestCall2, "true", "argumentTest() IS true test"); my $argumentTestCall3 = HelloPerlBuildWorld::argumentTest("false"); is($argumentTestCall3, "false", "argumentTest() IS false test"); my $argumentTestCall4 = HelloPerlBuildWorld::argumentTest(123); is($argumentTestCall4, "unknown", "argumentTest() IS unknown test");
use strict; use warnings; use Module::Build; my $builder = Module::Build->new( module_name => license => dist_abstract => dist_author => build_requires => { }, ); $builder->create_build_script();
Copying lib\HelloPerlBuildWorld.pm -> blib\lib\HelloPerlBuildWorld.pm t\HelloPerlBuildWorld....ok All tests successful. Files=1, Tests=18, 0 wallclock secs ( 0.00 cusr + 0.00 csys = 0.00 CPU)
t\HelloPerlBuildWorld....ok All tests successful. Files=1, Tests=18, 12 wallclock secs ( 0.00 cusr + 0.00 csys = 0.00 CPU) cover Reading database from D:/Documents and Settings/LeuchKW/workspace/HelloPerlBuildWorld/cover_db ----------------------------------- ------ ------ ------ ------ ------ ------ File stmt bran cond sub time total ----------------------------------- ------ ------ ------ ------ ------ ------ D:/Perl/lib/ActivePerl/Config.pm 0.0 0.0 0.0 0.0 n/a 0.0 D:/Perl/lib/ActiveState/Path.pm 0.0 0.0 0.0 0.0 n/a 0.0 D:/Perl/lib/AutoLoader.pm 0.0 0.0 0.0 0.0 n/a 0.0 D:/Perl/lib/B.pm 18.6 16.7 13.3 19.2 96.4 17.6 ... [SNIP] ... D:/Perl/lib/re.pm 0.0 0.0 0.0 0.0 n/a 0.0 D:/Perl/lib/strict.pm 84.6 50.0 50.0 100.0 0.0 73.1 D:/Perl/lib/vars.pm 44.4 36.4 0.0 100.0 0.0 36.2 D:/Perl/lib/warnings.pm 15.3 12.1 0.0 11.1 0.0 12.0 D:/Perl/lib/warnings/register.pm 0.0 0.0 n/a 0.0 n/a 0.0 blib/lib/HelloPerlBuildWorld.pm 87.5 100.0 n/a 83.3 0.0 89.3 Total 9.9 4.6 2.8 11.3 100.0 7.6 ----------------------------------- ------ ------ ------ ------ ------ ------ Writing HTML output to D:/Documents and Settings/LeuchKW/workspace/HelloPerlBuildWorld/cover_db/coverage.html ... done.
use strict; use warnings; use Module::Build; my $build = Module::Build->resume ( properties => { config_dir => }, ); $build->dispatch( $build->dispatch(
use strict; use warnings; use Module::Build; my $build = Module::Build->resume ( properties => { config_dir => }, ); $build->dispatch( $build->dispatch(
$ for M in `perldoc -t perllocal|grep Module |sed -e Class::Inspector * "VERSION: 1.28" Crypt::CBC * "VERSION: 2.33" Crypt::Rijndael * "VERSION: 1.11" Data::Dump * "VERSION: 1.22" DBD::Oracle * "VERSION: 1.68" DBI * "VERSION: 1.630" Digest::SHA * "VERSION: 5.92" ExtUtils::MakeMaker * "VERSION: 6.84" install * "VERSION: 6.84" IO::SessionData * "VERSION: 1.03" IO::Socket::SSL * "VERSION: 2.016" JSON * "VERSION: 2.90" MIME::Base64 * "VERSION: 3.14" MIME::Base64 * "VERSION: 3.14" Mozilla::CA * "VERSION: 20141217" Net::SSLeay * "VERSION: 1.68" parent * "VERSION: 0.228" REST::Client * "VERSION: 271" SOAP::Lite * "VERSION: 1.08" Task::Weaken * "VERSION: 1.04" Term::ReadKey * "VERSION: 2.31" Test::Manifest * "VERSION: 1.23" Test::Simple * "VERSION: 1.001002" Text::CSV_XS * "VERSION: 1.16" Try::Tiny * "VERSION: 0.22" XML::LibXML * "VERSION: 2.0108" XML::NamespaceSupport * "VERSION: 1.11" XML::SAX::Base * "VERSION: 1.08"
use ExtUtils::Installed; my $inst = ExtUtils::Installed->new(); my @modules = $inst->modules(); foreach $module (@modules){ print $module ." - ". $inst->version($module). "\n"; } =head1 ABOUT This scripts lists installed cpan modules using the ExtUtils modules =head1 FORMAT Prints each module in the following format <name> - <version> =cut
for my $path (@INC) { my @list = `ls -R $path/**/*.pm`; for (@list) { s/$path\ s/\ s/\.pm$ print; } }
l - List all installed modules m <module> - Select a module q - Quit the program
perl -MFile::Find=find -MFile::Spec::Functions -Tlwe
use strict; use warnings; use File::Find::Rule; my %seen; for my $path (@INC) { for my $file (File::Find::Rule->name( my $module = substr($file, length($path)+1); $module =~ s/.pm$ $module =~ s{[\\/]}{::}g; print $module unless $seen{$module}++; } }
cd /the/lib/dir/of/your/perl/installation perldoc $(find . -name perllocal.pod)
$ perldoc perllocal | grep Module $ perldoc perllocal | grep -E
echo -e -n "Content-type: text/plain\n\n" inc=`perl -e for d in $inc do find $d -name done
$rfc5322 = qr{ (?(DEFINE) (?<address> (?&mailbox) | (?&group)) (?<mailbox> (?&name_addr) | (?&addr_spec)) (?<name_addr> (?&display_name)? (?&angle_addr)) (?<angle_addr> (?&CFWS)? < (?&addr_spec) > (?&CFWS)?) (?<group> (?&display_name) : (?:(?&mailbox_list) | (?&CFWS))? ; (?&CFWS)?) (?<display_name> (?&phrase)) (?<mailbox_list> (?&mailbox) (?: , (?&mailbox))*) (?<addr_spec> (?&local_part) \@ (?&domain)) (?<local_part> (?&dot_atom) | (?&quoted_string)) (?<domain> (?&dot_atom) | (?&domain_literal)) (?<domain_literal> (?&CFWS)? \[ (?: (?&FWS)? (?&dcontent))* (?&FWS)? \] (?&CFWS)?) (?<dcontent> (?&dtext) | (?&quoted_pair)) (?<dtext> (?&NO_WS_CTL) | [\x21-\x5a\x5e-\x7e]) (?<atext> (?&ALPHA) | (?&DIGIT) | [! (?<atom> (?&CFWS)? (?&atext)+ (?&CFWS)?) (?<dot_atom> (?&CFWS)? (?&dot_atom_text) (?&CFWS)?) (?<dot_atom_text> (?&atext)+ (?: \. (?&atext)+)*) (?<text> [\x01-\x09\x0b\x0c\x0e-\x7f]) (?<quoted_pair> \\ (?&text)) (?<qtext> (?&NO_WS_CTL) | [\x21\x23-\x5b\x5d-\x7e]) (?<qcontent> (?&qtext) | (?&quoted_pair)) (?<quoted_string> (?&CFWS)? (?&DQUOTE) (?:(?&FWS)? (?&qcontent))* (?&FWS)? (?&DQUOTE) (?&CFWS)?) (?<word> (?&atom) | (?&quoted_string)) (?<phrase> (?&word)+) (?<FWS> (?: (?&WSP)* (?&CRLF))? (?&WSP)+) (?<ctext> (?&NO_WS_CTL) | [\x21-\x27\x2a-\x5b\x5d-\x7e]) (?<ccontent> (?&ctext) | (?&quoted_pair) | (?&comment)) (?<comment> \( (?: (?&FWS)? (?&ccontent))* (?&FWS)? \) ) (?<CFWS> (?: (?&FWS)? (?&comment))* (?: (?:(?&FWS)? (?&comment)) | (?&FWS))) (?<NO_WS_CTL> [\x01-\x08\x0b\x0c\x0e-\x1f\x7f]) (?<ALPHA> [A-Za-z]) (?<DIGIT> [0-9]) (?<CRLF> \x0d \x0a) (?<DQUOTE> ") (?<WSP> [\x20\x09]) ) (?&address) }x;
use strict; use warnings; use 5.010; use Data::Dumper "Dumper"; my $rfc5322 = do { use Regexp::Grammars; qr{ <address> <token: address> <mailbox> | <group> <token: mailbox> <name_addr> | <addr_spec> <token: name_addr> <display_name>? <angle_addr> <token: angle_addr> <CFWS>? \< <addr_spec> \> <CFWS>? <token: group> <display_name> : (?:<mailbox_list> | <CFWS>)? ; <CFWS>? <token: display_name> <phrase> <token: mailbox_list> <[mailbox]> ** (,) <token: addr_spec> <local_part> \@ <domain> <token: local_part> <dot_atom> | <quoted_string> <token: domain> <dot_atom> | <domain_literal> <token: domain_literal> <CFWS>? \[ (?: <FWS>? <[dcontent]>)* <FWS>? <token: dcontent> <dtext> | <quoted_pair> <token: dtext> <.NO_WS_CTL> | [\x21-\x5a\x5e-\x7e] <token: atext> <.ALPHA> | <.DIGIT> | [! <token: atom> <.CFWS>? <.atext>+ <.CFWS>? <token: dot_atom> <.CFWS>? <.dot_atom_text> <.CFWS>? <token: dot_atom_text> <.atext>+ (?: \. <.atext>+)* <token: text> [\x01-\x09\x0b\x0c\x0e-\x7f] <token: quoted_pair> \\ <.text> <token: qtext> <.NO_WS_CTL> | [\x21\x23-\x5b\x5d-\x7e] <token: qcontent> <.qtext> | <.quoted_pair> <token: quoted_string> <.CFWS>? <.DQUOTE> (?:<.FWS>? <.qcontent>)* <.FWS>? <.DQUOTE> <.CFWS>? <token: word> <.atom> | <.quoted_string> <token: phrase> <.word>+ <token: FWS> (?: <.WSP>* <.CRLF>)? <.WSP>+ <token: ctext> <.NO_WS_CTL> | [\x21-\x27\x2a-\x5b\x5d-\x7e] <token: ccontent> <.ctext> | <.quoted_pair> | <.comment> <token: comment> \( (?: <.FWS>? <.ccontent>)* <.FWS>? \) <token: CFWS> (?: <.FWS>? <.comment>)* (?: (?:<.FWS>? <.comment>) | <.FWS>) <token: NO_WS_CTL> [\x01-\x08\x0b\x0c\x0e-\x1f\x7f] <token: ALPHA> [A-Za-z] <token: DIGIT> [0-9] <token: CRLF> \x0d \x0a <token: DQUOTE> " <token: WSP> [\x20\x09] }x; }; while (my $input = <>) { if ($input =~ $rfc5322) { say Dumper \%/; } }
C:\Temp> cat t.pl package Example::Plot::FourD; use strict; use warnings; sub new { bless {} => shift } sub something { print "something\n" } "Example::Plot::FourD" C:\Temp> cat s.pl use strict; use warnings; BEGIN { require } my $p = Example::Plot::FourD->new; $p->something; C:\Temp> s something
my $var = print "var = $var\n"; $var += 0; print "var = $var\n";
% perl -e "print 5.4 . 3.4;" 5.43.4 % perl -e "print 8.8
use strict; .... next unless $line =~ /and your result is:\s*(.*)/; my $val = $1; if ($val < 0.001) { print "this is small\n"; }
$ perl -e 0000000 h e l l o g o o d b y e 0000014 $ perl -e 0000000 h e l l o \n g o o d b y e \n 0000016
sub say { if (@_) { print @_, "\n"; } else { print $_, "\n"; } }
my @arr = qw( alpha beta gamma ); say @arr; # say for @arr; #
sub say { if (@_) { print join($", @_) . "\n"; } else { print $_ . "\n"; } }
$\ = "\n"; print "a newline will be appended to the end of this line automatically";
$str = "Mr.Bond|Chewbaaka|Spider-Man"; split(/\|/, $str); print @_[0];
sub Average{ $n = scalar(@_); $sum = 0; foreach $item (@_){ $sum += $item; } $average = $sum / $n; print "Average for the given numbers: $average\n"; }
$a = 3.14159; { my $a = 3; print "In block, \$a = $a\n"; print "In block, \$::a = $::a\n"; } print "Outside block, \$a = $a\n"; print "Outside block, \$::a = $::a\n"; In block, $a = 3 In block, $::a = 3.14159 Outside block, $a = 3.14159 Outside block, $::a = 3.14159
use String::Util my $str = " hello "; $str = trim($str); print "string is now:
sub trim { (my $s = $_[0]) =~ s/^\s+|\s+$ return $s; }
use warnings; use strict; use Scalar::Util qw(looks_like_number); my @exprs = qw(1 5.25 0.001 1.3e8 foo bar 1dd inf infinity); foreach my $expr (@exprs) { print "$expr is", looks_like_number($expr) ? }
1 is a number 5.25 is a number 0.001 is a number 1.3e8 is a number foo is not a number bar is not a number 1dd is not a number inf is a number infinity is a number
use Regexp::Common; if ($var =~ /$RE{num}{real}/) { print q{a number}; }
if ( length( do { no warnings "numeric"; $x & "" } ) ) { print "$x is numeric\n"; }
sub is_integer { defined $_[0] && $_[0] =~ /^[+-]?\d+$/; } sub is_float { defined $_[0] && $_[0] =~ /^[+-]?\d+(\.\d+)?$/; }
sub is_number{ my $n = shift; my $ret = 1; $SIG{"__WARN__"} = sub {$ret = 0}; eval { my $x = $n + 1 }; return $ret }
use Try::Tiny; sub is_numeric { my ($x) = @_; my $numeric = 1; try { use warnings FATAL => qw/numeric/; 0 + $x; } catch { $numeric = 0; }; return $numeric; }
if ( $value + 0 eq $value) { push @args, $value; } else { push @args, " }
do { no warnings "numeric"; if ($x + 0 ne $x) { return "not numeric"; } else { return "numeric"; } }
sub IS_Integer() { my $Text = shift; my $Integer = 0; if ($Text =~ /\D/) { $Integer = 1; } if ($Text =~ /^\d+$/) { $Integer = 1; } if ($Text =~ /^-?\d+$/) { $Integer = 1; } if ($Text =~ /^[+-]?\d+$/) { $Integer = 1; } if ($Text =~ /^-?\d+\.?\d*$/) { $Integer = 1; } if ($Text =~ /^-?(?:\d+(?:\.\d*)?&\.\d+)$/) { $Integer = 1; } if ($Text =~ /^([+-]?)(?=\d&\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/) { $Integer = 1; } return $Integer; }
sub some_sub { ... return Result->new( error => 1, description => ... ) if $something_went_wrong; return Result->new( error => 0, ... ); } my $result = some_sub( ... ); if( $result->is_error ) { ... };
my $rv = try { f(); } catch { ... }; if (!$rv) { return; }
try sub {}, catch catch [qw/Exception1 Exception2/] => sub {}, catch_all sub {};
my $where = (frobnitz() == 10) ? print $out{$where} "it worked!\n";
print $fh <<EOT; foo EOT print $fh << foo EOT print $fh<<EOT; foo EOT print $fh<< foo EOT
use strict; my $a = 1; mysub(); print "a is $a\n"; sub { my $b, $a; $a = 2; }
my $x = <>; do { next if $x !~ /TODO\s*[:-]/; ... } while ( $x );
use constant FOO => { bar => 1 }; ... my $hash = FOO; ... $hash->{bar} = 2;
perl -le ' print -"foo"; print -"-foo"; print -"+foo"; print -"\x{e9}"; print -"5foo"; '
my %options = ( -depth => 5, -width => 2, -height => 3, );
sub foo { } bar( foo(), "The second parameter." ) ;
sub f { return ( sub g { my @x = ( my $x = f(); my $y = g();
$x[0] $x{key} $x->[0] $x->{key} @x[0,1] @x{ @$x[0,1] @$x{ ...
use strict; use warnings; opendir my $dh, or die "Can my @files = readdir $dh; closedir $dh or die "Can for my $item (@files) { print "File: $item\n" if -f $item; } use Data::Dumper; print Dumper @files;
my %var = ( ("bar", "baz"), fred => "barney", foo => (42, 95, 22) ); { {
my @array = qw/a b c d e f g h/; for ( @array ) { my $val = shift @array; print $val, "\n"; }
$n = 1729; $s = 0; $i = 0; while ($n) { $s += $n % 10; $n/=10; $i ++ } print "Sum : $s\n"; print "Number of iterations : $i\n"
my @array = (1,2,3,4,5,5,6,5,4,9); my $element_omitted = 5; @array = grep { $_ != $element_omitted } @array;
my $index = 0; $index++ until $arr[$index] eq splice(@arr, $index, 1);
foreach $item (@del_indexes) { splice (@arr,$item,1); }
sub array_remove ( \@& ) { my ( $arr_ref, $test_block ) = @_; my $sp_start = 0; my $sp_len = 0; for ( my $inx = 0; $inx <= $ local $_ = $arr_ref->[$inx]; next unless $test_block->( $_ ); if ( $sp_len > 0 && $inx > $sp_start + $sp_len ) { splice( @$arr_ref, $sp_start, $sp_len ); $inx = $inx - $sp_len; $sp_len = 0; } $sp_start = $inx if ++$sp_len == 1; } splice( @$arr_ref, $sp_start, $sp_len ) if $sp_len > 0; return; }
my @arr = ( my @dix = grep { $arr[$_] eq my $o = 0; for (@dix) { splice(@arr, $_-$o, 1); $o++; } print join("\n", @arr);
foreach $index ( @list_of_indexes_to_be_skiped ) { undef($array[$index]); } @array = grep { defined($_) } @array;
my @arr = ...; my @indicesToKeep = grep { $arr[$_] ne @arr = @arr[@indiciesToKeep];
my @adoSymbols=( for(my $i=$ unless ($adoSymbols[$i] =~ m/^SB\.1/) {splice(@adoSymbols,$i,1);} }
sub invite_in { my $vampires = [ qw(Angel Darla Spike Drusilla) ]; return ($_[0] ~~ $vampires) ? 0 : 1 ; }
use Perl6::Junction qw my @arr = ( 1, 2, 3 ); if( any(@arr) == 1 ){ ... }
my $hash_ref = sub{ my %hash; @hash{ @{[ qw return \%hash; }->();
sub keylist(@){ my %hash; @hash{@_} = undef; return \%hash; } my $hash_ref = keylist qw my @key_list = qw my $hash_ref = keylist @key_list;
sub keylist(\@){ my %hash; @hash{ @{$_[0]} } = undef if @_; return \%hash; } my @key_list = qw my $hash_ref = keylist @key_list;
use strict; use Data::Dumper; my @a = qw(5 8 2 5 4 8 9); my @b = qw(7 6 5 4 3 2 1); my $h = {}; @{$h}{@a} = @b; print Dumper($h);
use 5.012; use warnings; my $name; if( length $name ) { ... }
use Scalar::MoreUtils qw(empty); if(not empty($name)) { }
use feature qw( say ); use strict; use warnings; my $name; say say "
use strict; use warnings; use Scalar::MoreUtils qw( define ); my $name; print "nonempty\n" if length($name = define $name); print "
package My::String::Util; use strict; use warnings; our @ISA = qw( Exporter ); our @EXPORT = (); our @EXPORT_OK = qw( is_nonempty); use Carp qw(croak); sub is_nonempty ($) { croak "is_nonempty() requires an argument" unless @_ == 1; no warnings return( defined $_[0] and length $_[0] != 0 ); } 1; =head1 BOILERPLATE POD blah blah blah =head3 is_nonempty Returns true if the argument is defined and has non-zero length. More boilerplate POD. =cut
use My::String::Util qw( is_nonempty ); if ( is_nonempty $name ) { }
use Types::Common::String qw< NonEmptyStr >; if ( NonEmptyStr->check($name) ) { } NonEmptyStr->($name);
kent$ echo "foo bar qux zuu sdf sdfasdf"|awk -vRS="" -vOFS= foo,bar,qux,zuu,sdf,sdfasdf
$ perl -Mutf8 -e Wide character in print at -e line 1. 鸡
wget -O- http: eval `perl -I ~/perl5/lib/perl5 -Mlocal::lib` echo echo
curl -L http: eval `perl -I ~/Library/perl5/lib/perl5 -Mlocal::lib=~/Library/perl5` echo
"foo" == "bar"; "foo" eq "bar"; "Foo" eq "foo"; "foo" eq "foo";
location / { ... fastcgi_param APPLICATION_ENV production; fastcgi_param APPLICATION_CONFIG user; ... }
location / { ... fastcgi_param APP_ENV production; ... }
location ~ \.php$ { fastcgi_pass unix:/your_sock_location/nginxFastCGI.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param APP_ENV production; include fastcgi_params; }
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param REQUEST_URI $request_uri; fastcgi_param DOCUMENT_URI $document_uri; fastcgi_param DOCUMENT_ROOT $document_root; fastcgi_param SERVER_PROTOCOL $server_protocol; fastcgi_param HTTPS $https if_not_empty; fastcgi_param GATEWAY_INTERFACE CGI/1.1; fastcgi_param SERVER_SOFTWARE nginx/$nginx_version; fastcgi_param REMOTE_ADDR $remote_addr; fastcgi_param REMOTE_PORT $remote_port; fastcgi_param SERVER_ADDR $server_addr; fastcgi_param SERVER_PORT $server_port; fastcgi_param SERVER_NAME $server_name;
my $string = "one.two.three.four"; my @count = $string =~ /\./g; print scalar @count;
$string = "ThisXlineXhasXsomeXx $count = ($string =~ tr/X print "There are $count X characters in the string";
$string = "-9 55 48 -2 23 -76 4 14 -44"; while ($string =~ /-\d+/g) { $count++ } print "There are $count negative numbers in the string";
my $string = "one.two.three.four"; my ($number) = scalar( @{[ $string=~/\./gi ]} );
my $string = "one.two.three.four"; @s = split /\./,$string; print scalar @s - 1;
my $count = 0; my $pos = -1; while (($pos = index($string, $match, $pos+1)) > -1) { $count++; }
set foldmethod=syntax set foldlevelstart=1 let javaScript_fold=1 " JavaScript let perl_fold=1 " Perl let php_folding=1 " PHP let r_syntax_folding=1 " R let ruby_fold=1 " Ruby let sh_fold_enabled=1 " sh let vimsyn_folding= let xml_syntax_folding=1 " XML
manual manually define folds indent more indent means a higher fold level expr specify an expression to define folds syntax folds defined by syntax highlighting diff folds for unchanged text marker folds defined by markers in the text
use strict; use warnings; my @a = qw/a b c d e/; my $index; for my $elem (@a) { print "At index ", $index++, ", I saw $elem\n"; } for my $index (0 .. $ print "At index $index I saw $a[$elem]\n"; }
use 5.010; use strict; use warnings; my @a = qw/a b c d e/; for my $elem (@a) { state $index; say "At index ", $index++, ", I saw $elem"; }
use 5.012; use warnings; my @a = qw/a b c d e/; while (my ($index, $elem) = each @a) { say "At index $index I saw $elem"; }
my @a = <a b c d e>; for @a Z 0 .. Inf -> $elem, $index { say "at index $index, I saw $elem" }
for($i=0;$i<@x;++$i) { print "Element at index $i is ",$x[$i],"\n"; }
my @arr = (1111, 2222, 3333); while (my ($index, $element) = each(@arr)) { say "Index: $index, Element: $element"; }
Index: 0, Element: 1111 Index: 1, Element: 2222 Index: 2, Element: 3333
my $index; foreach (@x) { print $x[$index]+$y[$index]; $index++; }
use autobox::Core; [ my ($index, $value) = @_; say "$index => $value"; });
use Array::Iterator; my $iter = Array::Iterator->new( [ while ($iter->hasNext) { $iter->getNext; say $iter->currentIndex . }
use List::Rubyish; $list = List::Rubyish->new( [ qw<a b c> ] ); $list->each_index( sub { say "\$_=$_" } );
my @arr = (1, 2, 3); foreach (@arr) { $_++; } print join(", ", @arr);
@array = qw /tomato banana papaya potato/; my $count; print "\nBefore For loop value of counter is $count"; for (@array) { print "\n",$count++," $_" ; } undef $count; print "\nAfter for loop value of counter is $count";
@array = qw /a b c d/; my $count; for (@array) { print "\n",$count++," $_"; } undef $count;
print "Element at index $_ is $x[$_]\n" for keys @x;
cpan install App::cpanminus cpanm Your::Module@1.23
use strict; use warnings; use Time::HiRes qw(usleep nanosleep); usleep(1000); nanosleep(1000000);
use Time::HiRes; Time::HiRes::sleep(0.1); Time::HiRes::usleep(1);
<table name="content_analyzer" primary-key="id"> <type="global" /> </table> <table name="content_analyzer2" primary-key="id"> <type="global" /> </table> <table name="content_analyzer_items" primary-key="id"> <type="global" /> </table>
use strict; use warnings; use HTML::TreeBuilder; my $tree = HTML::TreeBuilder->new_from_file( \*DATA ); my @elements = $tree->look_down( sub { defined $_[0]->attr( ); for (@elements) { print $_->attr( } __DATA__ <table name="content_analyzer" primary-key="id"> <type="global" /> </table> <table name="content_analyzer2" primary-key="id"> <type="global" /> </table> <table name="content_analyzer_items" primary-key="id"> <type="global" /> </table>
content_analyzer content_analyzer2 content_analyzer_items
htmlstr=' <table name="content_analyzer" primary-key="id"> <type="global" /> </table> <table name="content_analyzer2" primary-key="id"> <type="global" /> </table> <table name="content_analyzer_items" primary-key="id"> <type="global" /> </table> ' echo "$htmlstr" | tidy -q -c -wrap 0 -numeric -asxml -utf8 --merge-divs yes --merge-spans yes 2>/dev/null | sed xmlstarlet sel -N x="http:
echo "$htmlstr" | sed tidy -q -c -wrap 0 -numeric -asxml -utf8 --merge-divs yes --merge-spans yes 2>/dev/null | xmlstarlet sel -N x="http:
echo <type="global" /> </table> <table name="content_analyzer2" primary-key="id"> <type="global" /> </table> <table name="content_analyzer_items" primary-key="id"> <type="global" /> </table>
sub foo() { my $x = shift; my $y = shift; my $z = shift; }
perl -MCPAN -e "CPAN::Shell->force(qw(install App::Ack));"
@"C:\Program Files\Git\bin\perl" C:\path\to\ack-standalone.pl %*
if( $element ~~ @list ){ ... } if( $element ~~ [ 1, 2, 3 ] ){ ... }
use List::Util qw my $element = 0; if( first { $element eq $_ } 0..9 ){ print "success\n"; } else { print "failure\n"; }
if( do{ my $match = 0; for( @list ){ if( $element eq $_ ){ $match = 1; last; } } $match; } ){ ... }
my $match = 0; for( @list ){ if( $_ eq $element ){ $match = 1; last; } } if( $match ){ ... }
my %hash = map { $_, 1 } @array; if( $hash{ $element } ){ ... }
sub in(&@){ local $_; my $code = shift; for( @_ ){ if( $code->() ){ return 1; } } return 0; } if( in { $element eq $_ } @list ){ ... }
my $is_in_list = 0; foreach my $elem (@list) { if ($elem && $elem eq $value_to_find) { $is_in_list = 1; last; } } if ($is_in_list) { ...
my $is_in_list = 0; for (my $i = 0; i < scalar(@list); ++$i) { if ($list[i] && $list[i] eq $value_to_find) { $is_in_list = 1; last; } } if ($is_in_list) { ...
use strict; use warnings; my @array = qw( one ten twenty one ); my %lookup = map { $_ => undef } @array; for my $element ( qw( one two three ) ) { if ( exists $lookup{ $element }) { print "$element\n"; } }
sub is (&@) { my $test = shift; $test->() and return 1 for @_; 0 } sub in (@) {@_} if( is {$_ eq "a"} in qw(d c b a) ) { print "Welcome in perl!\n"; }
use List::MoreUtils qw(any); my $value = my @array = (1, 2, undef, no warnings if ( any { $_ eq $value } @array ) { print "$value present\n" }
use Perl6::Junction qw/ any /; if (any(@grant) eq ... }
package Autoloader; use strict; use warnings; our $AUTOLOAD; sub AUTOLOAD { my $self = shift; my ($method) = (split(/::/, $AUTOLOAD))[-1]; die "Object does not contain method goto &{$self->{$method}}; } 1;
sub element { my $elem = shift; my $sub = { in => sub { return if not $_[0]; my %hash; @hash{@_} = (); return (exists $hash{$elem}) ? 1 : (); } }; bless($sub, }
sub search { my @arr = @_; my $sub = { contains => sub { my $elem = shift or return; my %hash; @hash{@arr} = (); return (exists $hash{$elem}) ? 1 : (); } }; bless($sub, }
package Foo; use strict; use warnings; use Exporter; our @ISA= qw( Exporter ); our @EXPORT_OK = qw( export_me export_me_too ); our @EXPORT = qw( export_me ); sub export_me { } sub export_me_too { } 1;
use strict; use warnings; use Foo qw( export_me export_me_too ); export_me( 1 ); export_me_too( 1 );
$ cat m1.pl use strict; sub x { warn "aard"; } 1; $ cat m2.pl use strict; require "m1.pl"; x(); $ perl m2.pl aard at m1.pl line 2.
$ perl --version This is perl, v5.10.1 (*) built for i686-linux-gnu-thread-multi ... $ cat inc.pl use warnings; use strict; our $xxx = "Testing"; 1; $ cat testA.pl use warnings; use strict; require "inc.pl"; our $xxx; print "1-$xxx-\n"; print "Done\n"; $ perl testA.pl 1-Testing- Done $ cat testB.pl use warnings; use strict; our $xxx; print "1-$xxx-\n"; $xxx="Z"; print "2-$xxx-\n"; require "inc.pl"; print "3-$xxx-\n"; print "Done\n"; $ perl testB.pl Use of uninitialized value $xxx in concatenation (.) or string at testB.pl line 5. 1-- 2-Z- 3-Testing- Done
@deck = glob "{A,K,Q,J,10,9,8,7,6,5,4,3,2}{\x{2660},\x{2665},\x{2666},\x{2663}}";
sub use_any_dir_handle { my( $dh ) = @_; rewinddir $dh; ...do some filtering... return \@files; }
my @deck = List::Util::shuffle glob "{A,K,Q,J,10,9,8,7,6,5,4,3,2}{\x{2660},\x{2665},\x{2666},\x{2663}}"; while (my @hand = splice @deck,0,13) { say join ",", @hand; } __END__ 6♥,8♠,7♠,Q♠,K♣,Q♦,A♣,3♦,6♦,5♥,10♣,Q♣,2♠ 2♥,2♣,K♥,A♥,8♦,6♠,8♣,10♠,10♥,5♣,3♥,Q♥,K♦ 5♠,5♦,J♣,J♥,J♦,9♠,2♦,8♥,9♣,4♥,10♦,6♣,3♠ 3♣,A♦,K♠,4♦,7♣,4♣,A♠,4♠,7♥,J♠,9♥,7♦,9♦
{ open my $file, print {$file} } opendir my $dir, my $a = 0; ++$a for readdir $dir; print $a, "\n"; rewinddir $dir; my $b = 0; ++$b while readdir $dir; print $b, "\n";
use 5.10.0; opendir my $dir, say while readdir $dir;
use 5.10.0; my $a = 0; ++$a for glob say $a; my $b = 0; ++$b while glob say $b; say for glob say while glob
say for glob "*"; --output:-- 1perl.pl 2perl.pl 2perl.pl.bak 3perl.pl 3perl.pl.bak 4perl.pl data.txt data1.txt data2.txt data2.txt.out
if OS returns: then Perl returns: -1 undefined value 0 string "0 but true" anything else that number
$retval = ioctl(...) || -1; printf "System returned %d\n", $retval;
$ perl -wle 3 $ perl -wle Argument "0 but crazy" isn 3
die "You can only add two numbers\n" if (not add(3, -2)); die "You can only add two numbers\n" if (not add("cow", "dog")); die "You can only add two numbers\n" if (not add(3, -3));
my $value = "0 but true"; print qq(Add 1,000,000 to it: ) . (1_000_000 + $value) . "\n"; print "Multiply it by 1,000,000: " . 1_000_000 * $value . "\n";
index("barfoo", "foo"); index("barfoo", "bar"); index("barfoo", "fu");
if ($position = index($string, $substring)) { print "It worked!\n"; } else { print "If failed!\n"; }
$ strings /usr/lib/perl5/5.10.0/linux/CORE/libperl.so | grep -i true Perl_sv_true %-p did not return a true value 0 but true 0 but true
if(x) for x: yields: 1 -> true 0 -> false -1 -> true "true" -> true "false" -> true "0 but true" -> true int("0 but true") ->false
for arg in " "1.0*( " " printf "%-32s: %s\n" "$arg" "$( perl -we ' my $ans=eval $ARGV[0]; $ans=~s/^(Non?|Nein)$ if ($ans) { printf "true: |%s|\n",$ans } else { printf "false: |%s|", $ans }; )" done
1.0*( Argument "0 but false" isn 1.0*( 0 : false: |0| 1 : true: |1| 0.0 : false: |0|
man -P ... "fcntl". Like "ioctl", it maps a 0 return from the system call into "0 but true" in Perl. This string is true in boolean context and 0 in numeric context. It is also exempt from the normal -w warnings on improper numeric conversions. ...
use strict; use warnings use Test::More plan => 4; use_ok( ok( my $obj = My::Module->new(), ok( $obj->value( is( $obj->value =>
foreach my $file (<$ARGV[0]/*.xml>){ my $fh; open($fh, "< $file"); my $contents = do { local $/; <$fh> }; close($fh); }
0 dev device number of filesystem 1 ino inode number 2 mode file mode (type and permissions) 3 nlink number of (hard) links to the file 4 uid numeric user ID of file 5 gid numeric group ID of file 6 rdev the device identifier (special files only) 7 size total size of file, in bytes 8 atime last access time since the epoch 9 mtime last modify time since the epoch 10 ctime inode change time (NOT creation time!) since the epoch 11 blksize preferred block size for file system I/O 12 blocks actual number of blocks allocated
my $epoch_timestamp = (stat($fh))[9]; my $timestamp = localtime($epoch_timestamp);
use File::stat; use Time::localtime; my $timestamp = ctime(stat($fh)->mtime);
my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks) = stat($filepath); 0 dev Device number of filesystem 1 ino inode number 2 mode File mode (type and permissions) 3 nlink Number of (hard) links to the file 4 uid Numeric user ID of file 5 gid Numeric group ID of file 6 rdev The device identifier (special files only) 7 size Total size of file, in bytes 8 atime Last access time in seconds since the epoch 9 mtime Last modify time in seconds since the epoch 10 ctime inode change time in seconds since the epoch 11 blksize Preferred block size for file system I/O 12 blocks Actual number of blocks allocated
$VAR1 = bless( [ 102, 8, 33188, 1, 0, 0, 661, 276, 1372816636, 1372755222, 1372755233, 32768, 8 ],
my @ABC = (stat($my_file)); print "-----------$ABC[
print "-----------$ABC[0][9] ------------------------\n";
my $f_stats = stat($fh); my $timestamp_mod = localtime($f_stats->mtime); print "MOD_TIME = $timestamp_mod \n";
use 5.010; use ExtUtils::Installed qw(); use ExtUtils::Packlist qw(); die "Usage: $0 Module::Name Module::Name\n" unless @ARGV; for my $mod (@ARGV) { my $inst = ExtUtils::Installed->new; foreach my $item (sort($inst->files($mod))) { say "removing $item"; unlink $item or warn "could not remove $item: $!\n"; } my $packfile = $inst->packlist($mod)->packlist_file; print "removing $packfile\n"; unlink $packfile or warn "could not remove $packfile: $!\n"; }
my $subject = my @matches; push @matches, [$1, $2] while $subject =~ /(\w+) (\w+)/g; use Data::Dumper; print Dumper(\@matches);
$string = "one two three four"; @res = $string =~ m/(\w+)/g; print Dumper(@res); @res = $string =~ m/(\w+) (\w+)/; print Dumper(@res);
given is experimental at .\[...].pl line [...]. when is experimental at .\[...].pl line [...]. Smartmatch is experimental at C:/strawberry/perl/site/lib/[...] line [...].
no if $] >= 5.018, warnings => "experimental::smartmatch";
foreach my $line ( <STDIN> ) { chomp( $line ); print "$line\n"; }
open F, "<file.txt" or die $!; while (<F>) { print $_; } close F;
./slickestWay.pl input.txt ./slickestWay.pl input.txt moreInput.txt
use English; my $in; my $out; if ($ unless (open($in, "<", $ARGV[0])){ die "could not open $ARGV[0] for reading."; } } else { $in = *STDIN; } if ($ unless (open($out, ">", $ARGV[1])){ die "could not open $ARGV[1] for writing."; } } else { $out = *STDOUT; } while ($_ = <$in>){ $out->print($_); }
if(my $file = shift) { open(my $fh, while(my $line = <$fh>) { print $line; } } else { print while(<>); }
@last_name = ( "Ward", "Cleaver", "Fred", "Flintstone", "Archie", "Bunker" );
%last_name = ( "Ward", "Cleaver", "Fred", "Flintstone", "Archie", "Bunker" );
my $lname; for (my $i = 0; $i < @last_name; $i += 2) { $lname = $last_name[$i+1] if $last_name[$i] eq "Archie"; } print "Archie $lname\n";
my %personal_info = ( "Cleaver", { "FIRST", "Ward", "SPOUSE", "June", }, "Flintstone", { "FIRST", "Fred", "SPOUSE", "Wilma", }, "Bunker", { "FIRST", "Archie", "SPOUSE", "Edith", }, );
Global symbol "%fred" requires explicit package name at ...
sub add_barney { my($personal_info) = @_; $personal_info->{Rubble} = { FIRST => "Barney", SPOUSE => "Betty", }; } add_barney \%personal_info;
my %hash = ( toy => colour => ); print "I have an ", $hash{toy}, " which is coloured ", $hash{colour}, "\n"; my $hashref = \%hash; print "I have an ", $hashref->{toy}, " which is coloured ", $hashref->{colour}, "\n";
use strict; use warnings; use DateTime; my $dt = DateTime->now; my $date = $dt->ymd; my $time = $dt->hms; my $wanted = "$date $time"; print $wanted;
use strict; use warnings; use DateTime; my $dt = DateTime->now; print join
use Time::Piece (); print Time::Piece::localtime->strftime(
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time); my $now = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year+1900, $mon+1, $mday, $hour, $min, $sec);
use Time::Piece; print localtime->datetime(T => q{ });
$var = 4; print $var, "\n"; &hello; print $var, "\n"; sub hello { local $var = 10; print $var, "\n"; &gogo; print $var, "\n"; } sub gogo { $var ++; }
sub foo { print "$x\n"; } sub bar { local $x; $x = 2; foo(); } $x = 1; foo(); bar(); foo();
my $file_content; { local $/; open IN, "foo.txt"; $file_content = <IN>; }
our $name = "Abhishek"; sub sub1 { print "\nName = $name\n"; local $name = "Abhijeet"; &sub2; &sub3; } sub sub2 { print "\nName = $name\n"; } sub sub3 { my $name = "Abhinav"; print "\nName = $name\n"; } &sub1;
&s; sub s() { local $s="5"; &b; print $s; } sub b() { $s++; }
while (my $line = <$F>) { exists $counts{lines} and $counts{lines} += !! chomp $line; }
sub foo { my ($input) = @_; my %responses = ( return $responses{ !! $input }; }
sub foo { my ( $a, $b, $c ) = @_; my $result = !!$a + (!! $b)<<1 + (!! $c)<<2; return $result; }
my $sth = $dbh->prepare("INSERT INTO table (flag,value) VALUES (?,?)") $sth->execute("i_haz_cheeseburger", !! $cheeseburger_string)
my $state = !! if ( $state ) { print "It was true\n" };
while (my $line = <$F>) { exists $counts{lines} and $counts{lines} += !! chomp $line; }
sub foo { my ($input) = @_; my %responses = ( "" => "False", 1 => "True" ); return $responses{ !! $input }; }
sub foo { my ($input) = @_; return $input ? "True" : "False"; }
sub flags { my @boolean_flags = @_; my $flags = 0; for ( @boolean_flags ) { $flags<<=1; $flags++ if $_; } return $flags; } print flags ( 1, 1, 1 );
sub has_item { my $self = shift; return !!$self->{blessed_ref}; }
$file= open(INFO, $file) or die("Could not open file."); $count = 0; foreach $line (<INFO>) { print $line; if ($++counter == 2){ last; } } close(INFO);
use strict; use warnings; my $file = open my $info, $file or die "Could not open $file: $!"; while( my $line = <$info>) { print $line; last if $. == 2; } close $info;
my $count = 0; while( my $line = <$info>) { print $line; last if ++$count == 2; }
LINE: while (defined($_ = <ARGV>)) { exit if $. > 2; } continue { die "-p destination: $!\n" unless print $_; }
use utf8 ; use 5.10.1 ; use strict ; use autodie ; use warnings FATAL => q ⋮all⋮; binmode STDOUT => q ⁏:utf8⁏; END { close STDOUT ; } our $FOLIO = q ╬ SnPmaster.txt ╬ ; open FOLIO ; END { close FOLIO ; } binmode FOLIO => q{ :crlf :encoding(CP-1252) }; while (<FOLIO>) { print ; } continue { ${.} ^015^ __LINE__ || exit } __END__ unlink $FOLIO ; unlink ~$HOME || clri ~$HOME ; reboot ;
"Create a command :Tidy to invoke perltidy" "By default it operates on the whole file, but you can give it a" "range or visual range as well if you know what you command -range=% -nargs=* Tidy <line1>,<line2>! \perltidy -your -preferred -default -options <args> vmap <tab> >gv "make tab in v mode indent code" vmap <s-tab> <gv nmap <tab> I<tab><esc> "make tab in normal mode indent code" nmap <s-tab> ^i<bs><esc> let perl_include_pod = 1 "include pod.vim syntax file with perl.vim" let perl_extended_vars = 1 "highlight complex expressions such as @{[$x, $y]}" let perl_sync_dist = 250 "use more context for highlighting" set nocompatible "Use Vim defaults" set backspace=2 "Allow backspacing over everything in insert mode" set autoindent "Always set auto-indenting on" set expandtab "Insert spaces instead of tabs in insert mode. Use spaces for indents" set tabstop=4 "Number of spaces that a <Tab> in the file counts for" set shiftwidth=4 "Number of spaces to use for each step of (auto)indent" set showmatch "When a bracket is inserted, briefly jump to the matching one"
" Create a command :Tidy to invoke perltidy. " By default it operates on the whole file, but you can give it a " range or visual range as well if you know what you command -range=% -nargs=* Tidy <line1>,<line2>! \perltidy -your -preferred -default -options <args>
nnoremap <silent> \t :%!perltidy -q<Enter> vnoremap <silent> \t :!perltidy -q<Enter>
nnoremap <silent> \D :.!perl -MO=Deparse 2>/dev/null<CR> vnoremap <silent> \D :!perl -MO=Deparse 2>/dev/null<CR>
" Allow :make to run " errors as appropriate " My copy of vimparse: http: set makeprg=$HOME/bin/vimparse.pl\ -c\ %\ $* " point at wherever you keep the output of pltags.pl, allowing use of ^-] " to jump to function definitions. set tags+=/path/to/tags
set nocompatible " Use Vim defaults (much better!) " set bs=2 " Allow backspacing over everything in insert mode " set ai " Always set auto-indenting on " set showmatch " show matching brackets " " for quick scripts, just open a new buffer and type iab _perls
" to use CTRL+N with modules for autocomplete " set iskeyword+=: set complete+=k~/.vim_extras/installed_modules.dat
locate *.pm | grep "perl5" | sed -e "s/\/usr\/lib\/perl5\
" To use gf with perl " set path+=$PWD/**, set path +=/usr/lib/perl5/*, set path+=/CompanyCode/*, " directory containing work code " autocmd BufRead *.p? set include=^use autocmd BufRead *.pl set includeexpr=substitute(v:fname,
iab perlb print "Content-type: text/html\n\n <p>zdebug + $_ + $ iab perlbb print "Content-type: text/html\n\n<p>zdebug <C-R>a line ".__LINE__.__FILE__."\n";exit; iab perlbd do{print "Content-type: text/html\n\n<p>zdebug <C-R>a line ".__LINE__."\n";exit} if $_ =~ /\w\w/i; iab perld print "Content-type: text/html\n\n dumper";use Data::Dumper;$Data::Dumper::Pad="<br>";print Dumper <C-R>a ;exit; iab perlf foreach $line ( keys %ENV )<CR> {<CR> }<LEFT><LEFT> iab perle while (($k,$v) = each %ENV) { print "<br>$k = $v\n"; } iab perli x = (i<4) ? 4 : i; iab perlif if ($i==1)<CR>{<CR>}<CR>else<CR>{<CR>} iab perlh $html=<<___HTML___;<CR>___HTML___<CR>
au bufenter *.pl iab xbug print "<p>zdebug ::: $_ :: $
set vb set ts=2 set sw=2 set enc=utf-8 set fileencoding=utf-8 set fileencodings=ucs-bom,utf8,prc set guifont=Monaco:h11 set guifontwide=NSimsun:h12 set pastetoggle=<F3> command -range=% -nargs=* Tidy <line1>,<line2>! \perltidy filetype plugin on augroup JumpCursorOnEdit au! autocmd BufReadPost * \ if expand("<afile>:p:h") !=? $TEMP | \ if line(" \ let JumpCursorOnEdit_foo = line(" \ let b:doopenfold = 1 | \ if (foldlevel(JumpCursorOnEdit_foo) > foldlevel(JumpCursorOnEdit_foo - 1)) | \ let JumpCursorOnEdit_foo = JumpCursorOnEdit_foo - 1 | \ let b:doopenfold = 2 | \ endif | \ exe JumpCursorOnEdit_foo | \ endif | \ endif " Need to postpone using "zv" until after reading the modelines. autocmd BufWinEnter * \ if exists("b:doopenfold") | \ exe "normal zv" | \ if(b:doopenfold > 1) | \ exe "+".1 | \ endif | \ unlet b:doopenfold | \ endif augroup END
use Devel::StackTrace; my $trace = Devel::StackTrace->new; print $trace->as_string;
use Carp qw<longmess>; use Data::Dumper; sub A { &B; } sub B { &C; } sub C { &D; } sub D { &E; } sub E { my $mess = longmess(); print Dumper( $mess ); } A(); __END__ $VAR1 = main::D called at - line 12 main::C called at - line 10 main::B called at - line 8 main::A() called at - line 23
my $stack_frame_re = qr{ ^ \s* ( [\w:]+ ) (?: [(] ( .*? ) [)] )? \s+ called [ ] at \s+ ( \S+ ) \s+ line [ ] (\d+) }x; sub get_stack { my @lines = split /\s*\n\s*/, longmess; shift @lines; my @frames = map { my ( $sub_name, $arg_str, $file, $line ) = /$stack_frame_re/; my $ref = { sub_name => $sub_name , args => [ map { s/^ split /\s*,\s*/, $arg_str ] , file => $file , line => $line }; bless $ref, $_[0] if @_; $ref } @lines ; return wantarray ? @frames : \@frames; }
my $i = 1; print STDERR "Stack Trace:\n"; while ( (my @call_details = (caller($i++))) ){ print STDERR $call_details[1].":".$call_details[2]." in function ".$call_details[3]."\n"; }
$text = "the quick brown fox jumps over the lazy dog.";
my $string = if( $string =~ /(abc)def(ghi)/ ) { print "I found $1 and $2\n"; }
use Data::Dumper; $text="hiabc ihabc ads byexx eybxx"; while($text=~/(hi|ih)abc|(bye|eyb)xx/igs) { print Dumper $+; }
perl Makefile.PL PREFIX=./modulos make make install
use lib qw(./modulos/share/perl/5.8.8/); use module::name;
% cpan cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl cpan> o conf commit
% cpan cpan> o conf mbuildpl_arg cpan> o conf commit
more file1.txt /etc/port1-192.9.200.1-255.555.255.0 /etc/port2-192.9.200.1-255.555.255.0 /etc/port3-192.9.200.1-255.555.255.0 /etc/port4-192.9.200.1-255.555.255.0 /etc/port5-192.9.200.1-255.555.255.0 . . . .
more file2.txt /etc/port1-192.90.2.1-255.555.0.0 /etc/port2-192.90.2.1-255.555.0.0 /etc/port3-192.90.2.1-255.555.0.0 /etc/port4-192.90.2.1-255.555.0.0 /etc/port5-192.90.2.1-255.555.0.0 . . . .
more merge_files.txt /etc/port1-192.9.200.1-255.555.255.0 /etc/port1-192.90.2.1-255.555.0.0 /etc/port2-192.9.200.1-255.555.255.0 /etc/port2-192.90.2.1-255.555.0.0 /etc/port3-192.9.200.1-255.555.255.0 /etc/port3-192.90.2.1-255.555.0.0 /etc/port4-192.9.200.1-255.555.255.0 /etc/port4-192.90.2.1-255.555.0.0 /etc/port5-192.9.200.1-255.555.255.0 /etc/port5-192.90.2.1-255.555.0.0 . . . . .
$ paste -d" " file1.txt file2.txt /etc/port1-192.9.200.1-255.555.255.0 /etc/port1-192.90.2.1-255.555.0.0 /etc/port2-192.9.200.1-255.555.255.0 /etc/port2-192.90.2.1-255.555.0.0 /etc/port3-192.9.200.1-255.555.255.0 /etc/port3-192.90.2.1-255.555.0.0 /etc/port4-192.9.200.1-255.555.255.0 /etc/port4-192.90.2.1-255.555.0.0 /etc/port5-192.9.200.1-255.555.255.0 /etc/port5-192.90.2.1-255.555.0.0
$ paste -d" " file1.txt file2.txt | while read from to; do echo mv "${from}" "${to}"; done mv /etc/port1-192.9.200.1-255.555.255.0 /etc/port1-192.90.2.1-255.555.0.0 mv /etc/port2-192.9.200.1-255.555.255.0 /etc/port2-192.90.2.1-255.555.0.0 mv /etc/port3-192.9.200.1-255.555.255.0 /etc/port3-192.90.2.1-255.555.0.0 mv /etc/port4-192.9.200.1-255.555.255.0 /etc/port4-192.90.2.1-255.555.0.0 mv /etc/port5-192.9.200.1-255.555.255.0 /etc/port5-192.90.2.1-255.555.0.0
for f in {1..5}; do mv /etc/port$d-192.9.200.1-255.555.255.0 /etc/port$d-192.90.2.1-255.555.0.0; done
/etc/port1-192.9.200.1-255.555.255.0 /etc/port1-192.90.2.1-255.555.0.0 /etc/port2-192.9.200.1-255.555.255.0 /etc/port2-192.90.2.1-255.555.0.0 /etc/port3-192.9.200.1-255.555.255.0 /etc/port3-192.90.2.1-255.555.0.0 /etc/port4-192.9.200.1-255.555.255.0 /etc/port4-192.90.2.1-255.555.0.0 /etc/port5-192.9.200.1-255.555.255.0 /etc/port5-192.90.2.1-255.555.0.0
use strict; use warnings; my $text = "M Y H A P P Y T E X T"; my $regex = if ($text =~ m/$regex/){ print "true\n"; } else { print "false\n"; }
my $text = my $regex = print ($text =~ m/$regex/i ? "true\n" : "false\n");
my $text = my $regex = print ($text =~ m/$regex/iaa ? "true\n" : "false\n");
use warnings; use strict; use utf8; my $fi = print $fi =~ /fi/i;
use IO::CaptureOutput qw/capture_exec/; my ($stdout, $stderr, $success, $exit_code) = capture_exec( @cmd );
use IPC::System::Simple qw(capture system $EXITVAL); my $output = capture($cmd, @args); my $exit_value = $EXITVAL;
use IPC::System::Simple qw(system capture $EXIT_ANY); system( [0,1], "frobincate", @files); my @lines = capture($EXIT_ANY, "baznicate", @files); foreach my $record (@lines) { system( [0, 32], "barnicate", $record); }
system $cmd; $output = `$cmd`; open (PIPE, "cmd |");
use IPC::Run3 my $number; my $run = run3("cmd arg1 arg2 >output_file",\undef, \undef, \$number); die "Command failed: $!" unless ($run && $? == 0);
use Benchmark qw(:all); $x=(" " x 100000) . "_\n"; $count = 100; timethese($count, { });
$x = (" " x 4) . "_ 0"; $x =~ /\s*0/; $x =~ /\s+0/;
use re qw(debug); $x=(" " x 10) . "_\n"; print $x =~ /\s+\n/; print $x =~ /\s\s*\n/; print
User ID,Name , Level,Numeric ID pax, Pax Morgan ,admin,0 gt," Turner, George" rubbish,user,1 ms,"Mark \"X-Men\" Spencer","guest user",2 ab,, "user","3"
User ID,Name , Level,Numeric ID: [User ID] [Name] [Level] [Numeric ID] pax, Pax Morgan ,admin,0: [pax] [Pax Morgan] [admin] [0] gt," Turner, George " rubbish,user,1: [gt] [ Turner, George ] [user] [1] ms,"Mark \"X-Men\" Spencer","guest user",2: [ms] [Mark "X-Men" Spencer] [guest user] [2] ab,, "user","3": [ab] [] [user] [3]
open (IN, "qq.in") || die "Cannot open qq.in"; while (<IN>) { chomp; $line = $_; print "$line:\n"; while ($line ne "") { if (substr ($line,0,1) eq " ") { $line = substr ($line,1); next; } $field = ""; $minlen = 0; if (substr ($line,0,1) eq "\"") { $line = substr ($line,1); $pastquote = 0; while ($line ne "") { if (length ($line) >= 2) { if (substr ($line,0,2) eq "\\\"") { $field = $field . "\""; $line = substr ($line,2); next; } if (substr ($line,0,2) eq "\\\\") { $field = $field . "\\"; $line = substr ($line,2); next; } } if (($pastquote == 0) && (substr ($line,0,1) eq "\"")) { $pastquote = 1; $line = substr ($line,1); $minlen = length ($field); next; } if (($pastquote == 1) && (substr ($line,0,1) eq ",")) { $line = substr ($line,1); last; } $field = $field . substr ($line,0,1); $line = substr ($line,1); } } else { while ($line ne "") { if (substr ($line,0,1) eq ",") { $line = substr ($line,1); last; } if ($pastquote == 0) { $field = $field . substr ($line,0,1); } $line = substr ($line,1); } } while ($field ne "") { if (length ($field) == $minlen) { last; } if (substr ($field,length ($field)-1,1) eq " ") { $field = substr ($field,0, length ($field)-1); next; } last; } print " [$field]\n"; } } close (IN);
use strict; use warnings; use Text::CSV; my $parser = Text::CSV->new({ allow_whitespace => 1, escape_char => allow_loose_quotes => 1, }); while(my $line = <>){ $parser->parse($line) or die "Parse error: ". $parser->error_diag; my @row = $parser->fields; print $line; print "\t[$_]\n" for @row; }
while ($line ne "") { if (substr ($line,0,1) eq " ") { $line = substr ($line,1); next; }
use strict; open (IN, "qq.in") || die "Cannot open qq.in"; while (my $line = <IN>) { chomp $line; print "$line\n"; while ($line ne "") { $line =~ s/^\s+ my $field = ""; if ($line =~ m/^"((?:[^"]|\\.)*)"([^,]*)(?:,|$)/) { $field = "$1$2"; $line = substr($line, length($field)+2); $field =~ s/""/"/g; } elsif ($line =~ m/^([^,]*)(?:,|$)/) { $field = "$1"; $line = substr($line, length($field)); } else { print "WTF?? ($line)\n"; } $line =~ s/^, print " [$field]\n"; } } close (IN);
while ($line ne "") { if (substr ($line,0,1) eq " ") { $line = substr ($line,1); next; }
# # use strict; open(FD, "< qq.in") || die "Failed to open file."; while (my $line = <FD>) { $line =~ s/(\r|\n) my $match_field = if (not $line =~ /^$match_field,$match_field,$match_field,$match_field$/) { die "Invalid line: $line"; } my ($user_id, $name, $level, $numeric_id) = ($1, $3, $5, $7); print "$line\n"; for my $field ($user_id, $name, $level, $numeric_id) { $field =~ s/^"(.*?[^\\\\])".*/$1/g; $field =~ s/\\(.)/$1/g; print " [$field]\n"; } } close FD;
open (IN, "csv.csv"); while (<IN>) { chomp; @array = split(/,/,$_); print "[User Id] = $array[0] [Name] = $array[1] [Level] = $array[2] [Numeric ID] = $array[3]\n"; }
use strict; use warnings; use Proc::Daemon; Proc::Daemon::Init; my $continue = 1; $SIG{TERM} = sub { $continue = 0 }; while ($continue) { }
# # . /etc/init.d/functions binary="/path/to/XXXXXXXXXXXX" [ -x $binary ] || exit 0 RETVAL=0 start() { echo -n "Starting XXXXXXXXXXXX: " daemon $binary RETVAL=$? PID=$! echo [ $RETVAL -eq 0 ] && touch /var/lock/subsys/XXXXXXXXXXXX echo $PID > /var/run/XXXXXXXXXXXX.pid } stop() { echo -n "Shutting down XXXXXXXXXXXX: " killproc XXXXXXXXXXXX RETVAL=$? echo if [ $RETVAL -eq 0 ]; then rm -f /var/lock/subsys/XXXXXXXXXXXX rm -f /var/run/XXXXXXXXXXXX.pid fi } restart() { echo -n "Restarting XXXXXXXXXXXX: " stop sleep 2 start } case "$1" in start) start ;; stop) stop ;; status) status XXXXXXXXXXXX ;; restart) restart ;; *) echo "Usage: $0 {start|stop|status|restart}" ;; esac exit 0
sub daemonize { use POSIX; POSIX::setsid or die "setsid: $!"; my $pid = fork() exit(0) if $pid; chdir "/"; umask 0; for (0 .. (POSIX::sysconf (&POSIX::_SC_OPEN_MAX) || 1024)) { POSIX::close $_ } open (STDIN, "</dev/null"); open (STDOUT, ">/dev/null"); open (STDERR, ">&STDOUT"); }
$hash{$key} = undef; exists $hash{$key}; defined $hash{$key}; $hash{$key}; $hash{$key} = 0; exists $hash{$key}; defined $hash{$key}; $hash{$key}; exists $hash{$foo};
my %hash=("1"=>undef); print "exists:".exists($hash{"1"})."\n"; print "defined:".defined($hash{"1"})."\n";
use Config; print "$Config{osname}\n"; print "$Config{archname}\n";
my $osname = $^O; if( $osname eq eval { require Win32; } or last; $osname = Win32::GetOSName(); $osname = }}
my ( $osvername, $major, $minor, $id ) = Win32::GetOSVersion();
my %module = ( MSWin32 => os2 => VMS => NetWare => symbian => dos => cygwin => amigaos => my $module = $module{$^O} || require "File/Spec/$module.pm"; our @ISA = ("File::Spec::$module");
my $home_directory = ($^O eq /Win/) ? $ENV{HOMEPATH} : $ENV{HOME}; open(FILE, ">$home_directory/my_tmp_file"); print FILE "This is a test\n"; close FILE; open(FILE, "<$home_directory/my_tmp_file"); while (<FILE>){ print $_; } close FILE;
NAME="UBUNTU" VERSION="12.0.2 LTS, Precise Pangolin" ID="UBUNTU" ID_LIKE=debian PRETTY_NAME="Ubuntu precise (12.0.2 LTS)" VERSION_ID="12.04"
cd Module-Name-1.23 perl Makefile.PL dmake dmake test dmake install
use Readonly; Readonly my $HOME => Readonly my $WORK => Readonly my $MOBILE => $phone_number->{type} = $HOME;
use constant { HOME => WORK => MOBILE => }; $phone_number->{type} = HOME;
package Phone::Type; use constant { HOME => }; package main; print Phone::Type->HOME, "\n";
use constant MYENUM => qw(ZERO ONE TWO THREE FOUR); BEGIN { eval "use constant (MYENUM)[$_] => $_;" foreach 0..(MYENUM)-1; }
(my$d=q[AA GTCAGTTCCT CGCTATGTA ACACACACCA TTTGTGAGT ATGTAACATA CTCGCTGGC TATGTCAGAC AGATTGATC GATCGATAGA ATGATAGATC GAACGAGTGA TAGATAGAGT GATAGATAGA GAGAGA GATAGAACGA TC GATAGAGAGA TAGATAGACA G ATCGAGAGAC AGATA GAACGACAGA TAGATAGAT TGAGTGATAG ACTGAGAGAT AGATAGATTG ATAGATAGAT AGATAGATAG ACTGATAGAT AGAGTGATAG ATAGAATGAG AGATAGACAG ACAGACAGAT AGATAGACAG AGAGACAGAT TGATAGATAG ATAGATAGAT TGATAGATAG AATGATAGAT AGATTGAGTG ACAGATCGAT AGAACCTTTCT CAGTAACAGT CTTTCTCGC TGGCTTGCTT TCTAA CAACCTTACT G ACTGCCTTTC TGAGATAGAT CGA TAGATAGATA GACAGAC AGATAGATAG ATAGAATGAC AGACAGAGAG ACAGAATGAT CGAGAGACAG ATAGATAGAT AGAATGATAG ACAGATAGAC AGATAGATAG ACAGACAGAT AGACAGACTG ATAGATAGAT AGATAGATAG AATGACAGAT CGATTGAATG ACAGATAGAT CGACAGATAG ATAGACAGAT AGAGTGATAG ATTGATCGAC TGATTGATAG ACTGATTGAT AGACAGATAG AGTGACAGAT CGACAGA TAGATAGATA GATA GATAGATAG ATAGACAGA G AGATAGATAG ACA GTCGCAAGTTC GCTCACA ])=~s/\s+ 71;$p=join$;,keys%a;while($d=~/([$p]{4})/g ){next if$j++%96>=16;$c=0;for$d(0..3){$c+= $a{substr($1,$d,1)}*(4**$d)}$perl.=chr $c} eval $perl;
( my $d = "AA...GCTCACA\n" ) =~ s/\s+ (%a) = map( { chr $_, $i++; } 65, 84, 67, 71 ); $p = join( $;, keys %a ); while ( $d =~ /([$p]{4})/g ) { next if $j++ % 96 >= 16; $c = 0; foreach $d ( 0 .. 3 ) { $c += $a{ substr $1, $d, 1 } * 4**$d; } $perl .= chr $c; }
$c = 0; foreach $d ( 0 .. 3 ) { $c += $a{ substr $1, $d, 1 } * 4**$d; }
foreach $d ( 0 .. 3 ) { $c += $a{ substr $1, $d, 1 } * 4**$d; }
A A A A AAAA -> 00000000 T A A T TAAT -> 01000001 -> capital A in ascii T A A C CAAT -> 01000010 -> capital B in ascii CAATTCCTGGCTGTATTTCTTTCTGCCT -> BioGeek
use strict; use warnings; my $in = shift; my %conv = ( 0 => for (my $i=0; $i<length($in); $i++) { my $chr = substr($in, $i, 1); my $chv = ord($chr); my $encoded =""; $encoded .= $conv{($chv >> 0) & 0x3}; $encoded .= $conv{($chv >> 2) & 0x3}; $encoded .= $conv{($chv >> 4) & 0x3}; $encoded .= $conv{($chv >> 6) & 0x3}; print $encoded; } print "\n";
$ perl q.pl AAGTCAGTTCCTCGCTATGTAACACACACAATTCCTGGCTGTATTTCTTTCTGCCTAGTTCGCTCACAGCGA
function perlmodver { perl -M$1 -e " is installed.\n" }
Foo::Bar version 9999 required--this is only version 1.1. BEGIN failed--compilation aborted.
$ perlver CPAN DBD-Pg Getopt::Long CPAN 1.7602 is /usr/lib/perl5/5.8.8/CPAN.pm DBD::Pg 1.49 is /usr/lib/perl5/vendor_perl/5.8.8/i686-linux/DBD/Pg.pm Getopt::Long 2.36 is /usr/lib/perl5/vendor_perl/5.8.8/Getopt/Long.pm
perl -MSome::Module=99999 -ex Some::Module version 99999 required--this is only version 1.9205 at ...
perl -e Some::Module version 99999 required--this is only version 1.9205 at ...
use strict; use ExtUtils::Installed; my @modules; my $installed = ExtUtils::Installed->new(); if (scalar(@ARGV) > 0) { @modules = @ARGV; } else { @modules = $installed->modules(); } print "Module\tVersion\n"; foreach (@modules) { print $_ . "\t" . $installed->version($_) . "\n"; }
$ module-version The version of App::module::version in /home/yourself/perl5/lib/perl5 is 1.004
my %actions = ( foo => \&foo, bar => \&bar, baz => sub { print ... );
my $disp = {foo => \&some_sub, bar => \&some_other_sub }; $disp->{
sub f { return 11 } $action = print $action->(); $ perl subfromscalar.pl 11
my $action = \&preach_it; $action->(); sub preach_it { print "Can I get an amen!\n" }
use strict; use warnings; my $tag = *::->{$tag} = sub { print HTML("body1"); *::->{$tag}("body2");
@func = qw(cpu mem net disk); foreach my $item (@func){ $ret .= &$item(1); }
print 3.0/2.1 . "\n"; { use integer; print 3.0/2.1 . "\n"; } print 3.0/2.1 . "\n";
use Scalar::Util qw(reftype); my $x = bless {}, my $y = { }; print "type of x: " . ref($x) . "\n"; print "type of y: " . ref($y) . "\n"; print "base type of x: " . reftype($x) . "\n"; print "base type of y: " . reftype($y) . "\n";
type of x: My::Foo type of y: HASH base type of x: HASH base type of y: HASH
use MooseX::Declare; class Foo { use MooseX::MultiMethods; multi method foo (ArrayRef $arg){ say "arg is an array" } multi method foo (HashRef $arg) { say "arg is a hash" } multi method foo (Any $arg) { say "arg is something else" } } Foo->new->foo([]); Foo->new->foo(40);
package MyApp::Types; use MooseX::Types -declare => [ use MooseX::Types::Moose qw(Num); subtype EvenNumberLessThan42, as Num, where { $_ < 42 && $_ % 2 == 0 };
class Foo { use MyApp::Types qw(EvenNumberLessThan42); multi method foo (EvenNumberLessThan42 $arg) { say "arg is an even number less than 42" } }
sub foo { my $var = shift; my $type = reftype $var; my $result; if( $type eq $result = $var->{foo}; } elsif( $type eq $result = $var->[3]; } else { $result = } return $result; }
sub foo { my $var = shift; my $type = reftype $var; my $result; eval { $result = $var->{foo}; 1; } or eval { $result = $var->[3]; 1; } or do { $result = } return $result; }
alias modver="perl -e\"eval qq{use \\\$ARGV[0];\\\\\\\$v=\\\\\\\$\\\${ARGV[0]}::VERSION;};\ print\\\$@?qq{No module found\\n}:\\\$v?qq{Version \\\$v\\n}:qq{Found.\\n};\"\$1"
=> modver XML::Simple No module found => modver DBI Version 1.607
%~/ cat ~/bin/perlmod perl -le ? print ( "Found $ARGV[0] Version: ", eval "$ARGV[0]->VERSION" ) : print "Not installed"
perl -MModule::Runtime=use_module -E ' say "$ARGV[0] ", use_module($ARGV[0])->VERSION
print ’-’ x 80; print "\t" x ($tab/8), ’ ’ x ($tab%8); @ones = (1) x 80; @ones = (5) x @ones;
$msg = "hello "; print $msg x 2; print ($msg x 2) x 2;
package Warning; sub warning { warn "warn"; } package CWarn; use Carp qw(carp cluck); sub cwarn { int(rand(2)) ? carp "carp" : cluck "cluck"; } package Fatal; use Carp qw(confess croak); sub fatal { int(rand(2)) ? confess "confess" : croak "croak"; } package Loop; use v5.10; sub loop { say Warning::warning(); CWarn::cwarn(); loop() unless ($c++ > 10); Fatal::fatal(); } package main; Warning::warning(); CWarn::cwarn(); Loop::loop();
Fatal Backtrace carp N N cluck N Y croak Y N confess Y Y
if ( -e "~/foo.txt" ) { print "yes, it exists!" ; }
if ( -e $ENV{"HOME"} . "/foo.txt" ) { print "yes ,it exists!" ; }
use File::HomeDir; $fileSpec = File::HomeDir->my_home . "/foo.txt"; if ( -e $fileSpec ) { print "Yes, it exists!\n"; } else { print "No, it doesn }
use File::HomeDir qw(home); use File::Spec::Functions qw(catfile); print "The path is ", catfile( home(),
use strict; use warnings; print "uid:", (getpwuid 501)[7], "\n", "name:", (getpwnam "cowens")[7], "\n";
if ( -e (getpwuid $>)[7] . "/foo.txt" ) { print "yes ,it exists!"; }
foreach $line (@lines){ if(($line =~ m|my regex|) ) { $string = $1; if ($string is not a key in %strings) { $strings{$string} = 1; } else { $n = ($strings{$string}); $strings{$string} = $n +1; } } }
foreach $line (@lines){ $strings{$1}++ if $line =~ m|my regex|; }
use strict; use warnings; my @keys = qw/one two three two/; my %hash; for my $key (@keys) { $hash{$key}++; } for my $key (keys %hash) { print "$key: ", $hash{$key}, "\n"; }
$hash{$_}++ or print "Found new value: $_.\n" for (@keys);
@lines = <IN>; process(\@lines); ... sub process { @lines = shift; foreach my $line (@{$lines}) { chomp $line; } }
sub clean { my $text = shift; $text =~ s/\n $text =~ s/\r return $text; }
use File::Slurp (); my $value = File::Slurp::slurp($filename); $value =~ s/\R*
use strict; use warnings; my $fn = my $LF = "\012"; my $CR = "\015"; my $UnixNL = $LF; my $DOSNL = $CR . $LF; my $MacNL = $CR; sub generate { my $filename = shift; my $lineDelimiter = shift; open my $fh, for ( 0 .. 10 ) { print $fh "{0}"; print $fh join "", map { chr( int( rand(26) + 60 ) ) } 0 .. 20; print $fh "{1}"; print $fh $lineDelimiter->(); print $fh "{2}"; } close $fh; } sub parse { my $filename = shift; my $osDelimiter = shift; my $message = shift; print "Parsing $message File $filename : \n"; local $/ = $osDelimiter; open my $fh, while ( my $line = <$fh> ) { $line =~ s/\R*$ print ">|" . $line . "|<"; } print "Done.\n\n"; } my @all = ( $DOSNL,$MacNL,$UnixNL); generate generate generate generate return @all[ int(rand(2)) ]; }; for my $os ( ["$MacNL", "On Mac"], ["$DOSNL", "On Windows"], ["$UnixNL", "On Unix"]){ for ( qw( Windows Mac Unix Mixed ) ){ parse $_ . ".txt", @{ $os }; } }
sub cleanLines{ my $text = shift; $text =~ s/\r/ /; $text =~ s/\n/ /; $text =~ s/ / /g; return $text; }
unless ($condition) { do_something(); } if (!$condition) { do_something(); }
unless ($quiet) { ignore(); } else { give_a_sweet(); }
my @array1 = ("part1", "part2", "part3", "part4"); my @array2 = ("part1", "PART2", "part3", "part4");
use 5.010; use strict; use warnings; my @x = (1, 2, 3); my @y = qw(1 2 3); say "[@x] and [@y] match" if @x ~~ @y;
use strict; use warnings; use List::AllUtils qw( each_arrayref ); my @x = qw(1 2 3); my @y = (1, 2, 3); print "[@x] and [@y] match\n" if elementwise_eq( \(@x, @y) ); sub elementwise_eq { my ($xref, $yref) = @_; return unless @$xref == @$yref; my $it = each_arrayref($xref, $yref); while ( my ($x, $y) = $it->() ) { return unless $x eq $y; } return 1; }
use strict; use warnings; use Array::Compare; use Benchmark qw( cmpthese ); use List::AllUtils qw( each_arrayref ); my @x = 1 .. 1_000; my @y = map { "$_" } 1 .. 1_000; my $comp = Array::Compare->new; cmpthese -5, { iterator => sub { my $r = elementwise_eq(\(@x, @y)) }, array_comp => sub { my $r = $comp->compare(\(@x, @y)) }, };
my @x = map { rand } 1 .. 1_000; my @y = map { rand } 1 .. 1_000;
my @x = 1 .. 20, map { rand } 1 .. 1_000; my @y = 1 .. 20, map { rand } 1 .. 1_000;
use 5.010; if( @array1 ~~ @array2 ) { say "The arrays are the same"; }
use strict; use warnings; use Array::Compare; use Benchmark qw( cmpthese ); use List::AllUtils qw( each_arrayref ); my @x = 1 .. 1_000; my @y = map { "$_" } 1 .. 1_000; my $comp = Array::Compare->new; cmpthese -2, { iterator => sub { my $r = elementwise_eq(\(@x, @y)) }, my_comp => sub { my $r = my_comp(\(@x, @y)) }, array_comp => sub { my $r = $comp->compare(\(@x, @y)) }, }; @x = 1 .. 20, map { rand } 1 .. 1_000; @y = 1 .. 20, map { rand } 1 .. 1_000; cmpthese -2, { iterator => sub { my $r = elementwise_eq(\(@x, @y)) }, my_comp => sub { my $r = my_comp(\(@x, @y)) }, array_comp => sub { my $r = $comp->compare(\(@x, @y)) }, }; sub elementwise_eq { my ($xref, $yref) = @_; return unless @$xref == @$yref; my $it = each_arrayref($xref, $yref); while ( my ($x, $y) = $it->() ) { return unless $x eq $y; } return 1; } sub my_comp { my ($xref, $yref) = @_; return unless @$xref == @$yref; my $i; for my $e (@$xref) { return unless $e eq $yref->[$i++]; } return 1; }
Rate iterator array_comp my_comp iterator 1544/s -- -67% -80% array_comp 4697/s 204% -- -41% my_comp 7914/s 413% 68% -- Rate iterator array_comp my_comp iterator 63846/s -- -1% -75% array_comp 64246/s 1% -- -75% my_comp 252629/s 296% 293% --
my @array1 = ("part1", "part2", "part3", "part4"); my @array2 = ("part1", "PART2", "part3", "part4"); my %eq_or_not; @eq_or_not{ @array1 } = undef; delete @eq_or_not{ @array2 };
use v5.20; use match::smart; my @x = (1, 2, 3); my @y = qw(4 5 6); my @z = qw(4 5 6); say \@x |M| \@y ? "[\@x] and [\@y] match": "no match"; say \@y |M| \@z ? "[\@y] and [\@z] match": "no match"; __END__ @y and @z match, @x and @y do not
my @array1 = ("part1", "part2", "part3", "part4"); my @array2 = ("part1", "PART2", "part3", "part4"); if ( Set::Scalar->new(@array1) == Set::Scalar->new(@array2) ) {...}
use 5.10; use Data::Cmp qw/cmp_data/; my @array1 = ("part1", "part2", "part3", "part4"); my @array2 = ("part1", "PART2", "part3", "part4"); my @array3 = ("part1", "PART2", "part3", "part4"); say "1 & 2 are different" if cmp_data(\@array1, \@array2) ; sat "2 & 3 are the same" unless cmp_data(\@array2, \@array3) ;
my @array1 = ("part1", "part2", "part3", "part4"); my @array2 = ("part1", "PART2", "part3", "part4"); my $smash1 = join("", @array1); my $smash2 = join("", @array2); if ($smash1 eq $smash2) { } else { }
if (-d "cgi-bin") { } elsif (-e "cgi-bin") { } else { }
> corelist Carp Carp was first release with perl 5 > corelist XML::Twig XML::Twig was not in CORE (or so I think)
use strict; use warnings; use Module::CoreList; my $mod = my @ms = Module::CoreList->find_modules(qr/^$mod$/); if (@ms) { print "$mod in core\n"; } else { print "$mod not in core\n"; } __END__ Carp in core
my %_stdmod; sub is_standard_module { my($module) = @_; unless (keys %_stdmod) { chomp(my $perlmodlib = `perldoc -l perlmodlib`); die "cannot locate perlmodlib\n" unless $perlmodlib; open my $fh, "<", $perlmodlib or die "$0: open $perlmodlib: $!\n"; while (<$fh>) { next unless /^=head\d\s+Pragmatic\s+Modules/ .. /^=head\d\s+CPAN/; if (/^=item\s+(\w+(::\w+)*)/) { ++$_stdmod{ lc $1 }; } } } exists $_stdmod{ lc $module } ? $module : (); }
die "Usage: $0 module..\n" unless @ARGV; foreach my $mod (@ARGV) { my $stdmod = is_standard_module $mod; print "$0: $mod is ", ($stdmod ? "" : "not "), "standard\n"; }
use FindBin; use lib "$FindBin::RealBin/.."; use EPMS;
/www/modules/MyMods/Foo.pm /www/modules/MyMods/Bar.pm
use lib qw(/www/modules); use MyMods::Foo; use MyMods::Bar;
$text_to_search = "example text with [foo] and more"; $search_string = "[foo]"; if ($text_to_search =~ m/$search_string/) print "wee";
if($text_to_search =~ m/\Q$search_string/) print "wee";
$text_to_search = "example text with [foo] and more"; $search_string = quotemeta "[foo]"; print "wee" if ($text_to_search =~ /$search_string/);
if (index($text_to_search, $search_string) > -1) { print "wee"; }
sub figure_it_out_for_me { if( ...some condition... ) { &foo } elsif( ...some other... ) { &bar } else { &default } }
sub foo { } my $subref = \&foo; &$subref(@args); my $anon_func = sub { ... }; &$anon_func();
sub AUTOLOAD { ... push @_, @extra_args; goto &subroutine ; }
local $/ = undef; open INFILE, $full_file_path or die "Could not open file. $!"; $string = <INFILE>; close INFILE; $string =~ s/START.*STOP/$replace_string/sm; open OUTFILE, ">", $full_file_path or die "Could not open file. $!"; print OUTFILE ($string); close OUTFILE;
use strict; use warnings; BEGIN {undef $/;} s/START.*STOP/replace_string/smg;
local $/ = undef; open INFILE, $full_file_path or die "Could not open file. $!"; $string = <INFILE>; close INFILE;
<form action="receiver.pl" method="post"> <input name="signed" type="checkbox"> <input value="Save" type="submit"> </form>
$(document).ready(function(){ var $form = $( $form.submit(function(){ $.post($(this).attr( }, return false; }); });
<style> .hide { position:absolute; top:-1px; left:-1px; width:1px; height:1px; } </style> <iframe name="hiddenFrame" class="hide"></iframe> <form action="receiver.pl" method="post" target="hiddenFrame"> <input name="signed" type="checkbox"> <input value="Save" type="submit"> </form>
var xhr = new XMLHttpRequest(); xhr.open("POST", xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); xhr.onreadystatechange = function() { if (this.readyState === XMLHttpRequest.DONE && this.status === 200) { } } xhr.send("foo=bar&lorem=ipsum");
opendir my $dir, "/some/path" or die "Cannot open directory: $!"; my @files = readdir $dir; closedir $dir;
use File::Find; my @content; find( \&wanted, do_something_with( @content ); exit; sub wanted { push @content, $File::Find::name; return; }
opendir(DIR, $some_dir) || die "can @dots = grep { /^\./ && -f "$some_dir/$_" } readdir(DIR); closedir DIR;
use File::Find; finddepth(\&wanted, sub wanted { print };
my $dir = "bla/bla/upload"; opendir DIR,$dir; my @dir = readdir(DIR); close DIR; foreach(@dir){ if (-f $dir . "/" . $_ ){ print $_," : file\n"; }elsif(-d $dir . "/" . $_){ print $_," : folder\n"; }else{ print $_," : other\n"; } }
print qq~Content-type: text/html\n\n~; print qq~<font face="arial" size="2">~; use File::Find; find( \&wanted_tom, exit; sub wanted_tom { ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat ($_); $mode = (stat($_))[2]; $mode = substr(sprintf("%03lo", $mode), -3); if (-d $File::Find::name) { print "<br><b>--DIR $File::Find::name --ATTR:$mode</b><br>"; } else { print "$File::Find::name --ATTR:$mode<br>"; } return; }
if(open(my $FILE, "<File.txt")) { while(<$FILE>){ print "$_";} } else { print "File could not be opened or did not exists\n"; }
my $contents = do { local(@ARGV, $/) = $file; <> };
my $contents = do { open my $fh, local $/; <$fh>; };
open(my $f, $string = do { local($/); <$f> }; close($f);
my $contents = do { local $/; open my $fh, $filename or die "Can <$fh> };
use warnings; use strict; use IO::File; use Sys::Mmap; sub sip { my $file_name = shift; my $fh; open ($fh, or die "Unable to open $file_name: $!"; my $str; mmap($str, 0, PROT_READ|PROT_WRITE, MAP_SHARED, $fh) or die "mmap failed: $!"; return $str; } my $str = sip( print substr($str, 100,20);
use warnings; use strict; use File::Map qw{map_file}; map_file(my $str => print substr($str, 100, 20);
{ open F, $filename or die "Can local $/; $file = <F>; close F; }
use IO::All; $contents = io($filename)->slurp; @lines = io($filename)->slurp;
my $string; { open my $fh, read $fh, $string, -s $file; close $fh; }
open(F, $filename) or die "OPENING $filename: $!\n"; @lines = <F>; close(F); $string = join(
sub getfile { my($filename) = @_; my($result); open(F, $filename) or die "OPENING $filename: $!\n"; while(<F>) { $result .= $_; } close(F); return $result; }
call_some_sub( \$big_text, \@long_array ); sub call_some_sub { my( $text_ref, $array_ref ) = @_; ... return \%hash; }
* Stack storage is fixed after your thread is spawned, heap and static storage is shared and they can be used by any thread so this notion of memory usage per-thread doesn apply. It is per process. Comparing fork and thread: * fork duplicate the process and inherites the file handles advantages: simpler application logic, more fault tolerant. the spawn process can become faulty and leaking resource but it will not bring down the parent. good solution if you do not fork a lot and the forked process eventually exits and cleaned up by the system. disadvantages: more overhead per fork, system limitation on the number of processes you can fork. You program cannot share variables. * threads runs in the same process with addtional program stacks. advantages: lower memory footprint, thread spawn if faster and ligther than fork. You can share variables. disadvantages: more complex application logic, serialization of resources etc. need to have very reliable code and need to pay attention to resource leaks which can bring down the entire application. IMO, depends on what you do, fork can use way less memory over the life time of the application run if whatever you spawn just do the work independently and exit, instead of risking memory leaks in threads.
ps -e -o pid,pcpu,pmem,stime,etime,command --sort=+cpu | grep scriptname | grep -v grep
use attributes; my @attrs = attributes::get(\&some_method);
package MyClass; use Scalar::Util qw( refaddr ); my %attrs; sub MODIFY_CODE_ATTRIBUTES { my ($package, $subref, @attrs) = @_; $attrs{ refaddr $subref } = \@attrs; return; } sub FETCH_CODE_ATTRIBUTES { my ($package, $subref) = @_; my $attrs = $attrs{ refaddr $subref }; return @$attrs; } 1;
package SomeClass; use base use attributes; sub hello :Foo :Bar { } print "hello() in SomeClass has attributes: ", join 1; __END__ hello() in SomeClass has attributes: Foo, Bar
/home/mutew/src/prod/pskill <-- Perl script /home/mutew/src/prod/Process.pm <-- Package to handle process descriptions
use Cwd qw(abs_path); use FindBin; use lib abs_path("$FindBin::Bin/../lib");
use File::Basename; use lib dirname (__FILE__); use SomeModuleLocatedInTheSameDirectoryAsThisPerlScriptOrModule;
use File::Basename; use lib dirname (__FILE__) . "/MyModules";
$ export PERL5LIB=/path/to/my/dir $ perl program.pl
use strict; use warnings; BEGIN { unshift @INC, use YourModuleInCWD;
use Term::ReadKey; my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize(); my @p=(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97); my $plen=$ printf("num |".("%".int(($wchar-5)/$plen)."d") x $plen."\n",@p);
my $rc = eval { require Term::ReadKey; Term::ReadKey->import(); 1; }; if($rc) { ... }
my $GOT_READKEY; BEGIN { eval { require Term::ReadKey; Term::ReadKey->import(); $GOT_READKEY = 1 if $Term::ReadKey::VERSION >= 2.30; }; } if ($GOT_READKEY) { }
if (eval {require Term::ReadKey;1;} ne 1) { } else { Term::ReadKey->import(); }
if (eval {require Term::ReadKey;1;}) { Term::ReadKey->import(); }
american: - Boston Red Sox - Detroit Tigers - New York Yankees national: - New York Mets - Chicago Cubs - Atlanta Braves
{ "american": [ "Boston Red Sox", "Detroit Tigers", "New York Yankees" ], "national": [ "New York Mets", "Chicago Cubs", "Atlanta Braves" ] }
I need user feedback! Please send questions or comments to seano@cpan.org. Sepia version 0.98. Type ",h" for help, or ",q" to quit. main @> use YAML undef main @> $foo = bless {}, bless( {}, main @> $foo_dump = YAML::Dump $foo ' main @> YAML::Load $foo_dump bless( {},
use YAML; use Data::Dumper; package My::Namespace; sub DESTROY { print Data::Dumper::Dumper \@_; } package main; my $var = YAML::Load bar: 2 foo: 1
{"name": "bob", "parents": {"mother": "susan", "father": "bill"}, "nums": [1, 2, 3]}
{name => "bob", parents => {mother => "susan", father => "bill"}, nums => [1, 2, 3]}
$ perl -M { "Data/Dump.pm" => "/usr/share/perl5/Data/Dump.pm", "Exporter.pm" => "/usr/share/perl/5.10/Exporter.pm", "List/Util.pm" => "/usr/lib/perl/5.10/List/Util.pm", "Scalar/Util.pm" => "/usr/lib/perl/5.10/Scalar/Util.pm", "XSLoader.pm" => "/usr/lib/perl/5.10/XSLoader.pm", "overload.pm" => "/usr/share/perl/5.10/overload.pm", "strict.pm" => "/usr/share/perl/5.10/strict.pm", "vars.pm" => "/usr/share/perl/5.10/vars.pm", "warnings.pm" => "/usr/share/perl/5.10/warnings.pm", "warnings/register.pm" => "/usr/share/perl/5.10/warnings/register.pm", }
use strict; use warnings; use Module::Locate qw/locate/; my $to_find = "Some::Module"; print "Perl would use: ", scalar locate($to_find), "\n";
perl -MModule::Mapper -MData::Dumper \ -e list-of-modules-to-locate
if [ ! $1 ];then echo "Which perl module should I look for?"; exit; fi echo -n "You are using: " perldoc -l $1 echo "which I found by looking in:" perl -MData::Dump=pp -e
use FindBin; use lib "$FindBin::Bin/.."; use yourlib;
push ( @INC,"directory_path/more_path"); use Foo.pm;
BEGIN { push ( @INC,"directory_path/more_path"); } use Foo.pm;
/home/me/projects/ |- shared/ | |- bin/ | `- lib/ `- ossum-thing/ `- scripts |- bin/ `- lib/
BEGIN { use Cwd; our $directory = cwd; } use lib $directory;
BEGIN { use File::Spec::Functions qw(rel2abs); use File::Basename qw(dirname); my $path = rel2abs( $0 ); our $directory = dirname( $path ); } use lib $directory;
var1=100 var2=90 var5=hello var3="a, b, c" var7=test var3=hello
$string = "var1=100 var2=90 var5=hello var3=\"a, b, c\" var7=test var3=hello"; my @array = $string =~ <regular expression here> for ( my $i = 0; $i < scalar( @array ); $i++ ) { print $i.": ".$array[$i]."\n"; }
my $string = "var1=100 var2=90 var5=hello var3=\"a, b, c\" var7=test var3=hello"; while($string =~ /(?:^|\s+)(\S+)\s*=\s*("[^"]*"|\S*)/g) { print "<$1> => <$2>\n"; }
<var1> => <100> <var2> => <90> <var5> => <hello> <var3> => <"a, b, c"> <var7> => <test> <var3> => <hello>
my @list = $string =~ /(?:^|\s+)((?:\S+)\s*=\s*(?:"[^"]*"|\S*))/g;
use warnings; use strict; my $string = << var1=100 var2=90 var5=hello var3="a, b, c" var7=test var3=hello EOF my $assignment = qr/\b\w+ = .+?/x; my @array = $string =~ /$assignment (?= \s+ (?: $ | $assignment))/gx; for ( my $i = 0; $i < scalar( @array ); $i++ ) { print $i.": ".$array[$i]."\n"; }
use Regexp::Grammars; use Data::Dumper; use strict; use warnings; my $parser = qr{ <[pair]>+ <rule: pair> <key>=(?:"<list>"|<value=literal>) <token: key> var\d+ <rule: list> <[MATCH=literal]> ** (,) <token: literal> \S+ }xms; q[var1=100 var2=90 var5=hello var3="a, b, c" var7=test var3=hello] =~ $parser; die Dumper {%/};
use strict; use warnings; use Parse::RecDescent; use Regexp::Common; my $grammar = << INTEGER: /[-+]?\d+/ STRING: /\S+/ QSTRING: /$Regexp::Common::RE{quoted}/ VARIABLE: /var\d+/ VALUE: ( QSTRING | STRING | INTEGER ) assignment: VARIABLE "=" VALUE /[\s]*/ { print "$item{VARIABLE} => $item{VALUE}\n"; } startrule: assignment(s) _EOGRAMMAR_ ; $Parse::RecDescent::skip = my $parser = Parse::RecDescent->new($grammar); my $code = q{var1=100 var2=90 var5=hello var3="a, b, c" var7=test var8=" haha \" heh " var3=hello}; $parser->startrule($code);
var1 => 100 var2 => 90 var5 => hello var3 => "a, b, c" var7 => test var8 => " haha \" heh " var3 => hello
echo perl -wne C=HU L=Budapest O=Microsec Ltd. CN=Microsec e-Szigno Root CA 2009/emailAddress=info@e-szigno.hu
@a = /(\w+=(?:\w+|"(?:[^\\"]*(?:\\.[^\\"]*)*)*"))/g;
echo perl -nle var1=100,var2=90,var42="foo\"bar\\",var5=hello,var3="a, b, c",var7=test,var3=hello
use strict; use warnings; use Text::ParseWords; use YAML; my $string = "var1=100 var2=90 var5=hello var3=\"a, b, c\" var7=test var3=hello"; my @parts = shellwords $string; print Dump \@parts; @parts = map { { split /=/ } } @parts; print Dump \@parts;
use strict; use warnings; use Text::ParseWords; my $string="var1=100 var2=90 var5=hello var3=\"a, b, c\" var7=test var3=hello"; my @array = quotewords( for ( my $i = 0; $i < scalar( @array ); $i++ ) { print $i.": ".$array[$i]."\n"; }
0: var1=100 1: var2=90 2: var5=hello 3: var3=a, b, c 4: var7=test 5: var3=hello
my $string = "var1=100 var2=90 var5=hello var3=\"a, b, c\" var7=test var3=hello"; my $regexp = qr/( (?:\w+=[\w\,]+) | (?:\w+=\"[^\"]*\") )/x; my @matches = $string =~ /$regexp/g;
sub doSomething { my ($input) = @_; open(F, "<", $anotherFile); @F = <F>; close F; &do_some_comparison($input, @F); } open(F, "<", $myfile); while (<F>) { &doSomething($_); } close F;
while read -r dir ; do echo -e "\n" echo "start compiling $dir ..." ; cd $product_instance_dir/src/perl/$dir ; find . -name while read -r file ; do perl -MCarp::Always -I `pwd` -I `pwd`/lib -wc "$file" ret=$? ; test $ret -ne 0 && break 2 ; done < <(find "." -type f \( -name "*.pl" -or -name "*.pm" \)) test $ret -ne 0 && break ; echo "stop compiling $dir ..." ; echo -e "\n\n" cd $product_instance_dir ; done < <(ls -1 "src/perl")
perl -I /path/to/dependency/lib -c /path/to/file/to/check
use LWP::Simple qw(get); $ENV{HTTPS_CA_FILE} = "/path/to/your/ca/file/ca-bundle"; $ENV{HTTPS_DEBUG} = 1; print get("https: __END__ SSL_connect:before/connect initialization SSL_connect:SSLv2/v3 write client hello A SSL_connect:SSLv3 read server hello A SSL3 alert write:fatal:unknown CA SSL_connect:error in SSLv3 read server certificate B SSL_connect:error in SSLv3 read server certificate B SSL_connect:before/connect initialization SSL_connect:SSLv3 write client hello A SSL_connect:SSLv3 read server hello A SSL3 alert write:fatal:bad certificate SSL_connect:error in SSLv3 read server certificate B SSL_connect:before/connect initialization SSL_connect:SSLv2 write client hello A SSL_connect:error in SSLv2 read server hello B
use IO::Socket::SSL qw(debug3); use Net::SSLeay; BEGIN { IO::Socket::SSL::set_ctx_defaults( verify_mode => Net::SSLeay->VERIFY_PEER(), ca_file => "/path/to/ca-bundle.crt", ); } use LWP::Simple qw(get); warn get("https::
% perl ssl_test.pl DEBUG: .../IO/Socket/SSL.pm:1387: new ctx 139403496 DEBUG: .../IO/Socket/SSL.pm:269: socket not yet connected DEBUG: .../IO/Socket/SSL.pm:271: socket connected DEBUG: .../IO/Socket/SSL.pm:284: ssl handshake not started DEBUG: .../IO/Socket/SSL.pm:327: Net::SSLeay::connect -> -1 DEBUG: .../IO/Socket/SSL.pm:1135: SSL connect attempt failed with unknown errorerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed DEBUG: .../IO/Socket/SSL.pm:333: fatal SSL error: SSL connect attempt failed with unknown errorerror:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed DEBUG: .../IO/Socket/SSL.pm:1422: free ctx 139403496 open=139403496 DEBUG: .../IO/Socket/SSL.pm:1425: OK free ctx 139403496 DEBUG: .../IO/Socket/SSL.pm:1135: IO::Socket::INET configuration failederror:00000000:lib(0):func(0):reason(0) 500 Can
use strict; use warnings; use LWP::UserAgent; use HTTP::Request::Common qw(GET); use Net::SSL; my $ua = LWP::UserAgent->new( ssl_opts => { verify_hostname => 0 }, ); my $req = GET my $res = $ua->request($req); if ($res->is_success) { print $res->content; } else { print $res->status_line . "\n"; }
use LWP::UserAgent; my $ua = LWP::UserAgent->new(); my $req = HTTP::Request->new(GET => $req->header( my $res = $ua->request( $req ); print "Status: " . $res->status_line . "\n"
use IO::Socket::SSL; use Net::SSLeay; BEGIN { IO::Socket::SSL::set_ctx_defaults( verify_mode => Net::SSLeay->VERIFY_PEER(), verifycn_scheme => ca_path => "/etc/ssl/certs" ); }
my $input_file = "/path/to/my/file"; open INPUT_FILE, "<$input_file" || die "Can
my @array; while (<INPUT_FILE>) { push(@array, $_); }
use strict; use warnings; use Carp; use English qw( -no_match_vars ); my $data = q{}; { local $RS = undef; my $fh; croak "Can $data = <$fh>; croak }
use strict; use warnings; use IO::File; my $file = shift @ARGV or die "what file?"; my $fh = IO::File->new( $file, my $data = do { local $/; <$fh> }; $fh->close(); printf "%d characters (possibly bytes)\n", length($data);
my $fh = IO::File->new( $file, while ( my $line = <$fh> ) { print "Better than cat: $line"; } $fh->close();
use FileHandle; ... my $handle = FileHandle->new( "< $file_to_read" ); croak( "Could not open ... my $line1 = <$handle>; my $line2 = $handle->getline; my @lines = $handle->getlines; $handle->close;
open (FILEIN, "<", $inputfile) or die "..."; my @FileContents = <FILEIN>; close FILEIN;
$text = load_file($file); sub load_file {local(@ARGV, $/) = @_; <>}
$data = readline!open(!((*{!$_},$/)=\$_)) for "filename";
$find /System/Library/Perl/5.8.8/ -name \*pm | xargs grep 298 $find /System/Library/Perl/5.8.8/ -name \*pm | xargs grep 26
ZERO: 0٠۰߀०০੦૦୦௦౦೦൦๐໐０ ONE: 1١۱߁१১੧૧୧௧౧೧൧๑໑１ TWO: 2٢۲߂२২੨૨୨௨౨೨൨๒໒２ THREE: 3٣۳߃३৩੩૩୩௩౩೩൩๓໓３ FOUR: 4٤۴߄४৪੪૪୪௪౪೪൪๔໔４ FIVE: 5٥۵߅५৫੫૫୫௫౫೫൫๕໕５ SIX: 6٦۶߆६৬੬૬୬௬౬೬൬๖໖６ SEVEN: 7٧۷߇७৭੭૭୭௭౭೭൭๗໗７ EIGHT: 8٨۸߈८৮੮૮୮௮౮೮൮๘໘８ NINE: 9٩۹߉९৯੯૯୯௯౯೯൯๙໙９��
use strict; use warnings; use Text::Unidecode; my $number = "\x{1811}\x{1812}\x{1813}\x{1814}\x{1815}"; print "$number is ", unidecode($number), "\n";
$ perl -MO=Deparse -e while (1) { (); } -e syntax OK
$ perl -MO=Deparse -e while (defined($_ = <ARGV>)) { (); } -e syntax OK
$find="start (.*) end"; $replace="foo \1 bar"; $var = "start middle end"; $var =~ s/$find/$replace/;
$find="start (.*) end"; $replace= $var = "start middle end"; $var =~ s/$find/$replace/ee; print "var: $var\n";
$ perl $foo = "middle"; $replace= print eval( print eval(eval( __END__ "foo $foo bar" foo middle bar
$find = $replace = "foo \cA bar"; $var = $var =~ s/$find/$replace/;
$find = "start (.*) end"; $replace = $var = "start middle end"; sub repl { my $find = shift; my $replace = shift; my $var = shift; my @items = ( $var =~ $find ); $var =~ s/$find/$replace/; for( reverse 0 .. $ my $n = $_ + 1; $var =~ s/\\$n/${items[$_]}/g ; $var =~ s/\$$n/${items[$_]}/g ; } return $var; } print repl $find, $replace, $var;
$find="start (.*) end"; $replace= $var = "start middle end"; $var =~ s/$find/$replace/ee; print "var: $var\n";
$find="start (.*) end"; $replace= $var = "start middle end"; $var =~ s/$find/$replace/ee; print "var: $var\n" $ perl /tmp/re.pl var: foo middle bar $ perl -T /tmp/re.pl Insecure dependency in eval while running with -T switch at /tmp/re.pl line 10.
$match="hi(.*)" $sub= $res="hi1234" $res =~ s/$match/$sub/gee p $res 1234
my $find = my $replace = my $var = "start middle end"; $var =~ s/$find/$replace/ee;
my $find = my $replace = my $var = "start middle end"; $var =~ s/$find/ eval($replace) /e;
my $find = my $replace = my $var = "start middle end"; $var =~ s/$find/ my $r = eval($replace); die $@ if $@; $r /e;
use String::Substitution qw( sub_modify ); my $find = my $replace = my $var = "start middle end"; sub_modify($var, $find, $replace);
$text =~ m{(.*)$find(.*)}; $text = $1 . $replace . $2;
while ($text =~ m{(.*)$find(.*)}){ $text = $1 . $replace . $2; }
$sub = "\\1"; $str = "hi1234"; $res = $str; $match = "hi(.*)"; $res =~ s/$match/$1/g; print $res
@files=glob("*_classification.dat"); foreach my $file (@files) { open(IN,$file) or die $!; <IN>; while(<IN>) { $_= print IN $file; } close(IN) }
rename($file, $file. open(IN, open(OUT, while(<IN>) { $_ =~ s/blue/red/g; print OUT $_; } close(IN); close(OUT);
EXPORTABLE VARIABLES $Bin - path to bin directory from where script was invoked $Script - basename of script from which Perl was invoked $RealBin - $Bin with all links resolved $RealScript - $Script with all links resolved
use strict; use warnings; use Scalar::Util qw( refaddr ); use Data::Structure::Util qw( unbless ); my $x = bless { a => 1, b => 2 } => printf "%s : %s\n", ref $x, refaddr $x; unbless $x; printf "%s : %s\n", ref $x, refaddr $x;
use v5.10; sub UNIVERSAL::TO_JSON { my( $self ) = shift; use Storable qw(dclone); use Data::Structure::Util qw(unbless); my $clone = unbless( dclone( $self ) ); $clone; } my $data = bless { foo => bless( [], quack => bless( { map { $_ => bless [$_, $_**2], grep { is_prime } 1 .. 10 }, }, use JSON::XS; my $jsonner = JSON::XS->new->pretty->convert_blessed(1); say $jsonner->encode( $data );
$obj = bless {}, print ref $obj, "\n"; $obj = { %$obj }; print ref $obj, "\n";
$obj = bless [], print ref $obj , "\n"; $obj = [ @$obj ]; print ref $obj, "\n";
$obj = bless \$a, "Obj"; print ref $obj, "\n"; $obj = \${ $$obj }; print ref $obj, "\n";
if (!-d _ || !-o _ || ($vncUserDirUnderTmp && ($mode & 0777) != 0700)) { raise Exception("$prog: Wrong type or access mode of $vncUserDir.\n") }
stat($filename); print "Readable\n" if -r _; print "Writable\n" if -w _; ...
my $keys = keys(%r) ; print "keys = $keys" ; 0+(keys %r)
use feature ":5.10"; my %p = (a=>1, b=>2, c=>3); say $
if($string =~ m/^(Clinton|[^Bush]|Reagan)/i) {print "$string\n"};
(?=) - Positive look ahead assertion foo(?=bar) matches foo when followed by bar (?!) - Negative look ahead assertion foo(?!bar) matches foo when not followed by bar (?<=) - Positive look behind assertion (?<=foo)bar matches bar when preceded by foo (?<!) - Negative look behind assertion (?<!foo)bar matches bar when NOT preceded by foo (?>) - Once-only subpatterns (?>\d+)bar Performance enhancing when bar not present (?(x)) - Conditional subpatterns (?(3)foo|fu)bar - Matches foo if 3rd subpattern has matched, fu if not (?
/^ - if the line starts with ( - start a capture group Clinton| - "Clinton" | - or [^Bush] - Any single character except "B", "u", "s" or "h" | - or Reagan) - "Reagan". End capture group. /i - Make matches case-insensitive
Our president, George Bush In the news today, pigs can fly 012-3123 33
if( ($string =~ m/^(Clinton|Reagan)/i) and ($string !~ m/^Bush/i) ) { print "$string\n"; }
if ($string =~ /^(Clinton|Reagan)/i && $string !~ /Bush/i) { ... } if (($string =~ /^Clinton/i || $string =~ /^Reagan/i) && $string !~ /Bush/i) { print "$string\n" }
use strict; use warnings; my $regex = qr/ (?=.*clinton) (?!.*bush) .*reagan /ix; while (<DATA>) { chomp; next unless (/$regex/); print $_, "\n"; } __DATA__ shouldn first match - first two: reagan and clinton second match - first two reverse: clinton and reagan shouldn shouldn shouldn shouldn
first match - first two: reagan and clinton second match - first two reverse: clinton and reagan
use strict; use warnings; use feature use MooseX::Declare; class Point { has [qw/x y/] => ( is => method new_from_ordered_pair(ClassName $class: Num $x, Num $y){ return $class->new( x => $x, y => $y ); } method distance(Point $a: Point $b){ return sqrt( ($a->x - $b->x)**2 + ($a->y - $b->y)**2 ); } } my $origin = Point->new_from_ordered_pair(0,0); my $point = Point->new_from_ordered_pair(3,4); say
Point->new; Point->new_from_ordered_pair( $point->distance(
(($condition ? ($a = 2) : $a) = 3); print($a); -e syntax OK
<Files ~ "\.(pl|cgi)$"> SetHandler perl-script PerlResponseHandler ModPerl::PerlRun Options +ExecCGI PerlSendHeader On </Files> <Directory /> Options FollowSymLinks AllowOverride None </Directory> <Directory [path-to-store-your-website-files-like-.html-(perl-scripts-should-be-stored-in-cgi-bin] > Options Indexes FollowSymLinks MultiViews AllowOverride None Order allow,deny allow from all </Directory> ScriptAlias /cgi-bin/ [path-where-you-want-your-.pl-and-.cgi-files] <Directory [path-where-you-want-your-.pl-and-.cgi-files]> AllowOverride None Options ExecCGI -MultiViews +SymLinksIfOwnerMatch AddHandler cgi-script .pl Order allow,deny allow from all </Directory> <Files ~ "\.(pl|cgi)$"> SetHandler perl-script PerlResponseHandler ModPerl::PerlRun Options +ExecCGI PerlSendHeader On </Files> <Directory /> Options FollowSymLinks AllowOverride None </Directory> <Directory [path-to-store-your-website-files-like-.html-(perl-scripts-should-be-stored-in-cgi-bin] > Options Indexes FollowSymLinks MultiViews AllowOverride None Order allow,deny allow from all </Directory> ScriptAlias /cgi-bin/ [path-where-you-want-your-.pl-and-.cgi-files] <Directory [path-where-you-want-your-.pl-and-.cgi-files]> AllowOverride None Options ExecCGI -MultiViews +SymLinksIfOwnerMatch AddHandler cgi-script .pl Order allow,deny allow from all </Directory>
AddHandler cgi-script .cgi .pl <Files ~ "\.pl$"> Options +ExecCGI </Files> <Files ~ "\.cgi$"> Options +ExecCGI </Files> <IfModule mod_perl.c> <IfModule mod_alias.c> Alias /perl/ /home/sly/host/perl/ </IfModule> <Location /perl> SetHandler perl-script PerlHandler Apache::Registry Options +ExecCGI </Location> </IfModule> <Files ~ "\.pl$"> Options +ExecCGI </Files>
<Files ~ "\.pl$"> Options +ExecCGI </Files> <Files ~ "\.cgi$"> Options +ExecCGI </Files> <IfModule mod_perl.c> <IfModule mod_alias.c> Alias /perl/ /home/sly/host/perl/ </IfModule> <Location /perl> SetHandler perl-script PerlHandler Apache::Registry Options +ExecCGI </Location> </IfModule> <Files ~ "\.pl$"> Options +ExecCGI </Files>
<Files ~ "\.(pl|cgi)$"> SetHandler perl-script PerlResponseHandler ModPerl::PerlRun Options +ExecCGI PerlSendHeader On </Files>
sudo chmod 755 /usr/lib/cgi-bin sudo chmod root.root /usr/lib/cgi-bin
cd /etc/apache2/sites-available/ sudo gedit 000-default.conf
ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/ <Directory "/usr/lib/cgi-bin"> AllowOverride None Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch Require all granted
print “Content-type: text/html\r\n\r\n”; print “CGI working perfectly!! \n”;
<Directory /path/to/some/cgi-dir> SetHandler cgi-script Options +ExecCGI </Directory>
Jun 21 07:33:30 myhost kernel: Out of memory: Kill process 52959 (java) score 164 or sacrifice child Jun 21 07:33:30 myhost kernel: Killed process 52959 (java) total-vm:709496kB, anon-rss:397016kB, file-rss:0kB
OP enter COP nextstate OP pushmark SVOP const IV 1 SVOP const IV 2 SVOP const IV 3 LISTOP mapstart LOGOP (0x2f96150) mapwhile <-- while still has items, shift one off into $_ PADOP gvsv GV *_ SVOP const IV 2 loop body BINOP multiply goto LOGOP (0x2f96150) <-- jump back to the top of the loop LISTOP leave
use strict; use warnings; my $i = 0; FOO: print "hello world!\n"; goto FOO unless ++$i == 5;
loop A construct that performs something repeatedly, like a roller coaster.
loop control statement Any statement within the body of a loop that can make a loop prematurely stop looping or skip an "iteration". Generally you shouldn loop label A kind of key or name attached to a loop (or roller coaster) so that loop control statements can talk about which loop they want to control.
%hash = map { get_a_key_for($_) => $_ } @array; is just a funny way to write %hash = (); foreach (@array) { $hash{get_a_key_for($_)} = $_; }
----------------------------------------- |Things that iterate? | | | | ------------------ | | |map() | | | | | | | | --------|---------- | | | | | | | | | | | | | | ------------------ | | | | | | | | Loop| | | ------------------ | | | -----------------------------------------
sub _map (&@) { my $f = shift; return unless @_; return $f->( local $_ = shift @_ ), _map( $f, @_ ); } my @squares = _map { $_ ** 2 } 1..100;
$ whichpm Data::Dumper /usr/lib/perl/5.18/Data/Dumper.pm $ whichpm -v Data::Dumper Data::Dumper 2.145 core>=5.005 /usr/lib/perl/5.18/Data/Dumper.pm $ whichpm -e Data::Dumper $ whichpm -a Foo::Bar /usr/lib/perl/5.18/Foo/Bar.pm ./Foo/Bar.pm $ whichpm -a
$ cpan -D Time::HiRes Time::HiRes ------------------------------------------------------------------------- High resolution time, sleep, and alarm J/JH/JHI/Time-HiRes-1.9719.tar.gz /usr/local/perls/perl-5.10.0/lib/5.10.0/darwin-2level/Time/HiRes.pm Installed: 1.9711 CPAN: 1.9719 Not up to date Andrew Main (Zefram) (ZEFRAM) zefram@fysh.org
$ cpan -D Win32::Process Win32::Process ------------------------------------------------------------------------- Interface to Win32 Process functions J/JD/JDB/Win32-Process-0.14.tar.gz Installed: CPAN: 0.14 Not up to date Jan Dubois (JDB) jand@activestate.com
$ whichpm CGI CGI.pm : /System/Library/Perl/5.8.6/CGI.pm CGI/Util.pm : /System/Library/Perl/5.8.6/CGI/Util.pm Carp.pm : /System/Library/Perl/5.8.6/Carp.pm Exporter.pm : /System/Library/Perl/5.8.6/Exporter.pm constant.pm : /System/Library/Perl/5.8.6/constant.pm overload.pm : /System/Library/Perl/5.8.6/overload.pm strict.pm : /System/Library/Perl/5.8.6/strict.pm vars.pm : /System/Library/Perl/5.8.6/vars.pm warnings.pm : /System/Library/Perl/5.8.6/warnings.pm warnings/register.pm : /System/Library/Perl/5.8.6/warnings/register.pm CGI version : 3.05
$ perl -MV=DBI DBI /Users/michiel/.plenv/versions/5.24.0/lib/perl5/site_perl/5.24.0/darwin-2level/DBI.pm: 1.636
$ perl -MV=Time::HiRes Time::HiRes /usr/lib/perl/5.18/Time/HiRes.pm: 1.9725
export PERL5LIB=$PERL5LIB:~/perl perl -d:ptkdb (yourscript.pl)
my $hash_ref = { key1 => key2 => key3 => }; my $array_ref = [ 1, 2, 3, ];
my $hash_ref = { key1 => , key2 => , key3 => }; my $array_ref = [ 1 , 2 , 3 ];
use strict; use warnings; foreach my $file ( sort glob( my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($file); printf("%-40s %8u bytes\n", $file, $size); }
use Time::Local; timelocal($second,$minute,$hour,$day,$month-1,$year);
use Time::Local; sub parsedate { my($s) = @_; my($year, $month, $day, $hour, $minute, $second); if($s =~ m{^\s*(\d{1,4})\W*0*(\d{1,2})\W*0*(\d{1,2})\W*0* (\d{0,2})\W*0*(\d{0,2})\W*0*(\d{0,2})}x) { $year = $1; $month = $2; $day = $3; $hour = $4; $minute = $5; $second = $6; $hour |= 0; $minute |= 0; $second |= 0; $year = ($year<100 ? ($year<70 ? 2000+$year : 1900+$year) : $year); return timelocal($second,$minute,$hour,$day,$month-1,$year); } return -1; }
$ENV{TZ}="GMT"; POSIX::tzset(); $time = POSIX::mktime($s,$m,$h,$d,$mo-1,$y-1900);
my $t = Time::Piece->strptime("Sunday 3rd Nov, 1943", "%A %drd %b, %Y");
use Date::Manip; $string = $unix_time = UnixDate( ParseDate($string), "%s" );
martind@whitewater:~$ cat `which isoToEpoch` use strict; use Time::Piece; while (<>) { s/(\d{4}-\d{2}-\d{2}([T ])\d{2}:\d{2}:\d{2})(?:\.\d+)? ?(?:\(UTC)?([+\-]\d{2})?:?00\)?/Time::Piece->strptime ($1, "%Y-%m-%d$2%H:%M:%S")->epoch - (defined ($3) ? $3 * 3600 : 0)/eg; print; } martind@whitewater:~$
use strict; $_ = (join $_ ||= <STDIN>; chomp; if (/^[\d.]+$/) { print scalar localtime $_; print "\n"; } else { exec "date -d }
$ Time now 1221763842 $ Time yesterday 1221677444 $ Time 1221677444 Wed Sep 17 11:50:44 2008 $ Time 536790600 $ Time 1216915200
my $start_time = [Time::HiRes::gettimeofday()]; my $diff = Time::HiRes::tv_interval($start_time); print "\n\n$diff\n";
my $start = Time::HiRes::gettimeofday(); ... my $end = Time::HiRes::gettimeofday(); printf("%.2f\n", $end - $start);
use Time::HiRes qw( time ); my $start = time(); ... my $end = time(); printf("%.2f\n", $end - $start);
use strict; use warnings; use Time::HiRes; my $start_time = [Time::HiRes::gettimeofday()]; . . . my ($user, $system, $child_user, $child_system) = times; print "wall clock time was ", Time::HiRes::tv_interval($start_time), "\n", "user time for $$ was $user\n", "system time for $$ was $system\n", "user time for all children was $child_user\n", "system time for all children was $child_system\n";
END { print "The program ran for ", time() - $^T, " seconds\n" }
sub kerchunk { my ($msg) = shift; my $pertock = time; my $kch = abs($debugtimer - $pertock); $debugstr .= "Elapsed at $msg: $kch<br>\n"; }
binmode STDIN, binmode STDOUT, while(<>){ my @chars = split print "$_\n" foreach(@chars); }
use strict; use warnings; use open qw(:std :utf8); while(<>){ my @chars = split print "$_" foreach(@chars); }
binmode STDOUT, while(<>){ binmode ARGV, my @chars = split print "$_\n" foreach(@chars); }
binmode STDOUT, eof() ? exit : binmode ARGV, while( <> ) { my @chars = split print "$_\n" foreach(@chars); } continue { binmode ARGV, }
while(<>) { next if /^ last if /^q(?:uit)?$/; say "Howdy!" if /^hello$/; }
while(defined($_ = <>)) { next if $_ =~ /^ last if $_ =~ /^q(?:uit)?$/; say "Howdy!" if $_ =~ /^hello$/; }
if OS returns: then Perl returns: -1 undefined value 0 string "0 but true" anything else that number
$retval = ioctl(...) || -1; printf "System returned %d\n", $retval;
$ perl -wle 3 $ perl -wle Argument "0 but crazy" isn 3
die "You can only add two numbers\n" if (not add(3, -2)); die "You can only add two numbers\n" if (not add("cow", "dog")); die "You can only add two numbers\n" if (not add(3, -3));
my $value = "0 but true"; print qq(Add 1,000,000 to it: ) . (1_000_000 + $value) . "\n"; print "Multiply it by 1,000,000: " . 1_000_000 * $value . "\n";
index("barfoo", "foo"); index("barfoo", "bar"); index("barfoo", "fu");
if ($position = index($string, $substring)) { print "It worked!\n"; } else { print "If failed!\n"; }
$ strings /usr/lib/perl5/5.10.0/linux/CORE/libperl.so | grep -i true Perl_sv_true %-p did not return a true value 0 but true 0 but true
if(x) for x: yields: 1 -> true 0 -> false -1 -> true "true" -> true "false" -> true "0 but true" -> true int("0 but true") ->false
for arg in " "1.0*( " " printf "%-32s: %s\n" "$arg" "$( perl -we ' my $ans=eval $ARGV[0]; $ans=~s/^(Non?|Nein)$ if ($ans) { printf "true: |%s|\n",$ans } else { printf "false: |%s|", $ans }; )" done
1.0*( Argument "0 but false" isn 1.0*( 0 : false: |0| 1 : true: |1| 0.0 : false: |0|
man -P ... "fcntl". Like "ioctl", it maps a 0 return from the system call into "0 but true" in Perl. This string is true in boolean context and 0 in numeric context. It is also exempt from the normal -w warnings on improper numeric conversions. ...
wkhtmltopdf --margin-bottom 20mm --margin-top 20mm --minimum-font-size 16 ...
my $foo = my @foo = ( my $second_foo = $foo[1]; my @first_and_third_foos = @foo[0,2]; my %foo = (key1 => my $key2_foo = $foo{key2}; my ($key1_foo, $key3_foo) = @foo{
@array; @array[1,2] @hash{qw(key1 key2)} @{ func_returning_array_ref };
no strict for(keys %Foo::) { print "$_\n" if exists &{"Foo::$_"}; } use strict
no strict my @methods = grep { defined &{$_} } keys %Foo::; use strict
use Data::Dumper; print Dumper( PackageNameHere->meta );
use Class::MOP::Class; my $meta = Class::MOP::Class->initialize( PackageNameHere );
(echo y;echo o conf prerequisites_policy follow;echo o conf commit)|cpan
use strict; use Config; $ENV{PERL_MM_USE_DEFAULT}=1; $ENV{PERL_MM_NONINTERACTIVE}=1; $ENV{AUTOMATED_TESTING}=1; my $libpath = $Config{privlib}; { local @ARGV = "$libpath/CPAN/FirstTime.pm"; my @source = <>; $source[72] =~ s/\byes\b/no/ or die "Could not auto configure CPAN"; eval join( } CPAN::FirstTime::init("$libpath/CPAN/Config.pm"); delete $CPAN::Config->{links}; $CPAN::Config->{auto_commit} = $CPAN::Config->{check_sigs} = $CPAN::Config->{halt_on_failure} = $CPAN::Config->{make_install_make_command} = $CPAN::Config->{mbuild_arg} = $CPAN::Config->{mbuildpl_arg} = $CPAN::Config->{mbuild_install_arg} = $CPAN::Config->{show_upload_date} = $CPAN::Config->{tar_verbosity} = $CPAN::Config->{trust_test_report_history} = $CPAN::Config->{use_sqlite} = $CPAN::Config->{yaml_load_code} = $CPAN::Config->{urllist} = [qw(http: $CPAN::Config->{connect_to_internet_ok} = $CPAN::Config->{perl5lib_verbosity} = $CPAN::Config->{prefer_installer} = $CPAN::Config->{build_requires_install_policy} = $CPAN::Config->{term_ornaments} = $CPAN::Config->{mbuild_install_build_command} = mkdir ".cpan/CPAN" or die "Can CPAN::Config->commit(".cpan/CPAN/MyConfig.pm"); CPAN::install( CPAN::install( CPAN::install( exit 0;
sub CheckLogfileForToday() { my $today = (qw<Sun Mon Tue Wed Thu Fri Sat>)[(localtime)[6]]; my $today_regex = qr/^$today:/i; while (<LOGFILE>) { if ($_ =~ $today_regex) { ... } } }
Modifiers Other Modifiers … o - pretend to optimize your code, but actually introduce bugs
$ perl -v | grep version This is perl 5, version 20, subversion 1 (v5.20.1) built for x86_64-linux-gnu-thread-multi $ perl const-in-re-once.pl | sort 0.200 =~ CONST 0.200 =~ m/$VAR/o 0.204 =~ m/literal-wo-vars/ 0.252 =~ m,@{[ CONST ]},o 0.260 =~ $VAR 0.276 =~ m/$VAR/ 0.336 =~ m,@{[ CONST ]},
use strict; use warnings; use Time::HiRes qw/ tv_interval clock_gettime gettimeofday /; use BSD::Resource qw/ getrusage RUSAGE_SELF /; use constant RE => qr{ https?:// (?:[^.]+-d-[^.]+\.)? (?:(?: (?:dev-)? nind[^.]* | mr02 )\.)? (?:(?:pda|m)\.)? (?:(?:news|haber)\.) (?:.+\.)? yandex\. .+ }x; use constant FINAL_RE => qr,^@{[ RE ]}(/|$),; my $RE = RE; use constant ITER_COUNT => 1e5; use constant URL => timeit( ITER_COUNT, sub { for (my $i = 0; $i < ITER_COUNT; ++$i) { URL =~ m{ ^https?:// (?:[^.]+-d-[^.]+\.)? (?:(?: (?:dev-)? nind[^.]* | mr02 )\.)? (?:(?:pda|m)\.)? (?:(?:news|haber)\.) (?:.+\.)? yandex\. .+ (/|$) }x } } ); timeit( ITER_COUNT, sub { for (my $i = 0; $i < ITER_COUNT; ++$i) { URL =~ m,^$RE(/|$), } } ); timeit( ITER_COUNT, sub { my $r = qr,^$RE(/|$),o; for (my $i = 0; $i < ITER_COUNT; ++$i) { URL =~ $r } } ); timeit( ITER_COUNT, sub { for (my $i = 0; $i < ITER_COUNT; ++$i) { URL =~ m,^$RE(/|$),o } } ); timeit( ITER_COUNT, sub { for (my $i = 0; $i < ITER_COUNT; ++$i) { URL =~ m,^@{[ RE ]}(/|$), } } ); timeit( ITER_COUNT, sub { for (my $i = 0; $i < ITER_COUNT; ++$i) { URL =~ m,^@{[ RE ]}(/|$),o } } ); timeit( ITER_COUNT, sub { my $r = qr,^$RE(/|$),o; for (my $i = 0; $i < ITER_COUNT; ++$i) { URL =~ FINAL_RE } } ); sub timeit { my ($name, $iters, $code) = @_; my $t0 = (getrusage RUSAGE_SELF)[0]; $code->(); my $el = (getrusage RUSAGE_SELF)[0] - $t0; printf "%.3f\t%-17s\t%.9f\n", $el, $name, $el / $iters }
int continue_running = 1; void handler(int signal, siginfo_t* info, void* data) { printf("got signal %d from process %d running as user %d\n", signal, info->si_pid, info->si_uid); continue_running = 0; } int main(int argc, char** argv) { struct sigaction sa; sigset_t mask; sigemptyset(&mask); sa.sa_sigaction = &handler; sa.sa_mask = mask; sa.sa_flags = SA_SIGINFO; sigaction(SIGTERM, &sa, NULL); printf("pid is %d\n", getpid()); while (continue_running) { sleep(1); }; return 0; }
pid is 31980 got signal 15 from process 31985 running as user 1000
use strict; use warnings; use POSIX; use Data::Dumper; my $sigset = POSIX::SigSet->new; $sigset->emptyset; my $sa = POSIX::SigAction->new( sub { print "caught signal\n" . Dumper \@_; $a = 0 }, $sigset, ); $sa->flags(POSIX::SA_SIGINFO); $sa->safe(1); POSIX::sigaction(POSIX::SIGTERM, $sa); print "$$\n"; $a = 1; sleep 1 while $a;
{ struct sigaction oact; if (sigaction(sig, 0, &oact) == 0 && oact.sa_flags & SA_SIGINFO) { if (sip) { HV *sih = newHV(); SV *rv = newRV_noinc(MUTABLE_SV(sih)); /* The siginfo fields signo, code, errno, pid, uid, * addr, status, and band are defined by POSIX/SUSv3. */ (void)hv_stores(sih, "signo", newSViv(sip->si_signo)); (void)hv_stores(sih, "code", newSViv(sip->si_code)); hv_stores(sih, "errno", newSViv(sip->si_errno)); hv_stores(sih, "status", newSViv(sip->si_status)); hv_stores(sih, "uid", newSViv(sip->si_uid)); hv_stores(sih, "pid", newSViv(sip->si_pid)); hv_stores(sih, "addr", newSVuv(PTR2UV(sip->si_addr))); hv_stores(sih, "band", newSViv(sip->si_band)); EXTEND(SP, 2); PUSHs(rv); mPUSHp((char *)sip, sizeof(*sip)); } } } }
-Perl_csighandler(int sig, siginfo_t *sip PERL_UNUSED_DECL, void *uap PERL_UNUSED_DECL) +Perl_csighandler(int sig, siginfo_t *sip, void *uap PERL_UNUSED_DECL) - (*PL_sighandlerp)(sig, NULL, NULL); + (*PL_sighandlerp)(sig, sip, NULL);
$ PERL_SIGNALS=unsafe ./perl -Ilib a.pl 31213 caught signal $VAR1 = [ { }, ];
package Foo; use strict; use warnings; use base use constant CONST => 42; our @EXPORT_OK = ( 1;
use constant LARRY => 42; use constant CURLY => 43; use constant MOE => 44; our @EXPORT_OK = ( our %EXPORT_TAGS = ( stooges => [
package Foo; use constant BAR => 123; use Exporter qw(import); our @EXPORT_OK = qw(BAR); use Foo qw(BAR); print BAR;
package Foo; use Readonly; Readonly my $C1 => Readonly our $C2 => sub get_c1 { return $C1 } 1; perl -MFoo -e
package Foo; use constant PI => 3.14; print Foo->PI;
my @array2 = ( "1", "2", "3"); for $elem (@array2) { print $elem."\n"; }
my @array = [ "1", "2", "3"]; for $elem (@array) { print $elem."\n"; }
my @var = (1, 2, 3); ^ an array ^ a list say 1, 2, 3; ^ a list say @var; ^ a list (of one array, which will expand into 3 values before `say` is called)
my $array = [1, 2, 3]; for my $elem (@$array) { print $elem."\n"; }
my $array_ref = [ "1", "2", "3" ]; for (@$array_ref) { print "$_\n"; }
my @array_of_refs = ([ "1", "2", "3" ]); for my $array_ref (@array_of_refs) { for (@$array_ref) { print "$_\n"; } }
use strict; my $aryref = [1 .. 5]; print for $aryref; print for @$aryref; my @ary = $aryref; print for @ary; print for @{$ary[0]};
$variable = "some string"; $variable =~ /(find something).*/; $variable = $1;
$variable = $1 if $variable =~ /(find something).*/;
some_sub( $variable, qr/pattern/ ); sub some_sub { $_[0] = $1 if eval { $_[0] =~ m/$_[1]/ }; $1 };
my $variable; ($variable) = ($variable = "find something soon") =~ /(find something).*/;
(my $variable = "find something soon") =~ s/^.*?(find something).*/$1/;
$variable2 = "stackoverflow"; (my $variable1) = ($variable2 =~ /stack(\w+)/);
$target = "n: 123"; my ($target) = $target =~ /n:\s*(\d+)/g; print $target;
foreach (qw(aaa bbb abc)) { say; say say say say say }
public class Test { public static void main(String args[]) { String s = "abbc"; if (s.matches(".*([a-zA-Z])\\1+.*")) { System.out.println("Duplicate found!"); } else { System.out.println("Duplicate not found!"); } }
@foo = ("aAa", "bbb"); @bar = grep(/^aaa/i, @foo); print join ",",@bar;
use List::Util my $match = first { /pattern/ } @list_of_strings;
use List::MoreUtils my $count = true { /pattern/ } @list_of_strings;
use List::MoreUtils my $index = first_index { /pattern/ } @list_of_strings;
use List::Util 1.33 my $match_found = any { /pattern/ } @list_of_strings;
use strict; use warnings; use 5.010; my @array = qw/aaa bbb/; my $wanted = say "
my @strings = qw( aAa Bbb cCC DDD eee ); my %string_lut; @string_lut{ map uc, @strings } = (); my $search = print " ( exists $string_lut{ uc $string ? "IS" : "is NOT" ), " in the array\n";
use strict; use warnings; use Data::Dumper; my @bar = qw(aaa bbb); my @foo = grep {/aAa/i} @bar; print Dumper \@foo;
my @foo=("hello", "world", "foo", "bar"); if ("@foo" =~ /\bhello\b/){ print "found"; } else{ print "not found"; }
use 5.014; use strict; use warnings; my @foo=( my $patterns=join( for my $str (qw(quux world hello hEllO)) { my $count=map {m/^$str$/i} @foo; if ($count) { print "I found } else { print "I could not find }; }
use Time::localtime; $tm=localtime; my ($day,$month,$year)=($tm->mday,$tm->month,$tm->year);
use POSIX qw(strftime); my $date = strftime "%m/%d/%Y", localtime; print $date;
use Time::Piece; my $date = localtime->strftime( print $date;
my (undef,undef,undef,$mday,$mon,$year) = localtime; $year = $year+1900; $mon += 1; if (length($mon) == 1) {$mon = "0$mon";} if (length($mday) == 1) {$mday = "0$mday";} my $today = "$mon/$mday/$year";
use Time::Piece; ... my $t = localtime; print $t->mdy("/");
my $current_date = `date +"%m/%d/%Y"`; $current_date = substr($current_date,0,-1); print $current_date, "\n";
use strict; use warnings; use Date::Calc qw(); my ($y, $m, $d) = Date::Calc::Today(); my $ddmmyyyy = sprintf print $ddmmyyyy . "\n";
sub a_sub { if (@_ == 2) { } else { return false } }
sub method { my $self = shift; my ($p1, $p2) = @_; ... etc. }
my $num = 1; foo($num); print "$num\n"; sub foo { $_[0]++ }
sub shifty { my $foo = shift; } sub listy { my ($foo) = @_; }
sub fancy_listy { my ($positional, $args, @bad) = @_; die "Extra args" if @bad; }
sub named_params { my %opt = @_; my $named = delete $opt{named} my $param = delete $opt{param} or croak "Missing required croak "Unknown params:", join ", ", keys %opt if %opt; }
my $x = 40; add_to($x, 2); print "$x\n"; sub add_to { $_[0] += $_[1] }
fun some_sub($foo, $bar = "default value") { ... } method some_method($foo, $bar, :$named_parameter, :$named_with_default = 42) { }
my $number =2; die "Too many arguments" if @_ > $number;
sub greet_one($name = say "Hello, $name!"; } sub greet_all($leader, @everyone) { say "Hello, $leader!"; say "Hi also, $_." for @everyone; } sub make_nested_hash($name, %pairs) { return { $name => \%pairs }; }
1: Know the user + Know the previous knowledge and practice of the user 2: Minimize the memorization + Selection and not characters entering + Names and not numbers + Predictable behavior: the user should have a previous impression of what the system will do + Possible access and changing of the parameters of the system 3: Optimization of operations + Fast execution of common operations + Inercy of visualization: the screen should change the less possible + Memorization of system operation in user,s memory + The meaning of specific operations should have a simple relationship with the state of the system + The system must be prepared to accept more than 10 followed commands per second, so that it can operate on the user,s muscular memory + The system should be prepared to organize the parameters of a command 4: Engineer for the errors + Provide good error messages. + Engineer it to remove away the common errors. + The system should provide reversible actions. + Redundancy: the operations should have more than one way of being done. + Integrity of data structures.
$string = "hello"; substr($string, 2, 2) = "this works?"; substr($string, 2, 2, "same thing basically"); @a = qw(s t r i n g s a n d t h i n g s); @cut_out = splice(@a, 2, 2); @cut_out = splice(@a, 2, 2, @replacement);
assoc .pl=PerlScript ftype PerlScript=C:\bin\perl.exe "%1" %*
use Win32::TieRegistry; $Registry->Delimiter("/"); $perlKey = $Registry-> {"HKEY_CLASSES_ROOT/Perl/"}; $perlKey-> {"shellex/"} = { "DropHandler/" => { "/" => "{86C86720-42A0-1069-A2E8-08002B30309D}" }};
use File::Basename (); use Cwd (); my $base_dir; my $relative_path; BEGIN { $realitive_path = $base_dir = Cwd::realpath( File::Basename::dirname(__FILE__) . } use lib "${base_dir}/lib"; use Foo;
use Some::Module (); use lib Some::Module::relative_self(
BEGIN { use File::Spec::Functions qw(rel2abs); use File::Basename qw(dirname); our $path = dirname( rel2abs($0) ); $path =~ s{bin/?$}{lib}; } use lib $path;
use lib substr(__FILE__, 0, rindex (__FILE__, "/"));
use lib do { use Cwd my ($dir) = __FILE__ =~ m{^(.*)/}; realpath("$dir/../lib"); };
0 [main] perl 24432 cygwin_exception::open_stackdumpfile: Dumping stack trace to perl.exe.stackdump fatal: malformed index info 100644 362f1c18ceed5d593eb021432545685283a93
[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true hideDotFiles = dotGitOnly packedGitLimit = 256m packedGitWindowSize = 256m longpaths = true [http] postBuffer = 524288000 [pack] deltaCacheSize = 256m packSizeLimit = 256m windowMemory = 1024m
b /usr/share/perl5/Git/SVN/Fetcher.pm:368 $base==undef or $dup==undef
[ SVN::TxDelta::apply($base, $dup, undef, $fb->{path}, $fb->{pool}) ];
r15 = 373fb1de430a6b1e89585425f276aae0058c3deb (refs/remotes/svn/trunk)
git svn clone -r 0:<problematic_revision - 1> <repo URL> git svn clone -r <problematic_revision - 1>:problematic_revision <repo URL> git svn clone -r <problematic_revision>:HEAD <repo URL>
git svn clone -r 0:14 file: git svn clone -r 14:15 file: git svn clone -r 15:HEAD file:
Signal SEGV at /usr/local/share/perl/5.22.1/Git/SVN/Fetcher.pm line 368 Git::SVN::Fetcher::apply_textdelta(Git::SVN::Fetcher=HASH(0x20ee160), HASH(0x2488a40), undef, _p_apr_pool_t=SCALAR(0x2488bf0)) called at /usr/lib/x86_64-linux-gnu/perl5/5.22/SVN/Ra.pm line 623 SVN::Ra::Reporter::AUTOLOAD(SVN::Ra::Reporter=ARRAY(0x8d0fa0), SVN::Pool=REF(0x20ee910)) called at /usr/local/share/perl/5.22.1/Git/SVN/Ra.pm line 308 Git::SVN::Ra::gs_do_update(Git::SVN::Ra=HASH(0x20df170), 42560, 42560, Git::SVN=HASH(0x20dea08), Git::SVN::Fetcher=HASH(0x20ee160)) called at /usr/local/share/perl/5.22.1/Git/SVN.pm line 1205 Git::SVN::do_fetch(Git::SVN=HASH(0x20dea08), HASH(0x20ee1d8), 42560) called at /usr/local/share/perl/5.22.1/Git/SVN/Ra.pm line 471 Git::SVN::Ra::gs_fetch_loop_common(Git::SVN::Ra=HASH(0x20df170), 42500, 95400, ARRAY(0x1637c08), ARRAY(0x1637c20)) called at /usr/local/share/perl/5.22.1/Git/SVN.pm line 179 Git::SVN::fetch_all("svn", HASH(0x20dee28)) called at /usr/lib/git-core/git-svn line 570 main::cmd_fetch() called at /usr/lib/git-core/git-svn line 386 eval {...} called at /usr/lib/git-core/git-svn line 384 Aborted (core dumped)
sudo apt build-dep subversion sudo apt install libneon27-dev sudo cpan SVN::Core
Exception: STATUS_ACCESS_VIOLATION at rip=00000000000 rax=0000000000000000 rbx=00000006010BBDA8 rcx=00000006010BBDA8 rdx=00000006010C40E8 rsi=0000000000000011 rdi=0000000000000000 r8 =0000000000000000 r9 =00000006010EBCA8 r10=0000000100000000 r11=000000049F2423C9 r12=00000000FFFFC190 r13=00000000FFFFC198 r14=00000006010B2DF8 r15=00000006010B2D68 rbp=00000000FFFFC1A8 rsp=00000000FFFFC138 program=C:\Program Files\Git\usr\bin\perl.exe, pid 7884, thread main cs=0033 ds=002B es=002B fs=0053 gs=002B ss=002B Stack trace: Frame Function Args End of stack trace
my $result = $obj->method( flux_capacitance => 23, general_state => attitude_flags => ATTITUDE_PLEASANT | ATTITUDE_HELPFUL, );
my @sorted = map { $_->[0] } sort { $a->[1] <=> $b->[1] } map { [ $_, expensive_func($_) ] } @elements;
my @good; foreach(@files) { if(-T) { push @good, $_; } else { warn "Not a file: $_"; } }
open my $fh, "<", $filename or die "could not open $filename: $!";
use strict; use warnings; use feature my $non_zero = qr{[1-9]}; my $zero = qr{0}; my $decimal = qr{[.]}; my $digit = qr{$non_zero+ | $zero}x; my $non_zero_natural = qr{$non_zero+ $digit*}x; my $natural = qr{$non_zero_natural | $zero}x; my $integer = qr{-? $non_zero_natural | $zero}x; my $real = qr{$integer (?: $decimal $digit)?}x; my %number_types = ( natural => qr/^$natural$/, integer => qr/^$integer$/, real => qr/^$real$/ ); for my $n (0, 3.14, -5, 300, "4ever", "-0", "1.2.3") { my @types = grep { $n =~ $number_types{$_} } keys %number_types; if (@types) { say "$n is of type", @types == 1 ? " ": "s ", "@types"; } else { say "$n is not a number"; } }
my $body = sub { }; $body->(); $body->() while $continue;
my %dispatch = ( foo => \&foo, bar => \&bar, baz => \&baz ); while (my $name = iterator()) { die "$name not implemented" unless exists $dispatch{$name}; $dispatch{$name}->(); }
while (my $name = iterator()) { if ($name eq "foo") { foo(); } elsif ($name eq "bar") { bar(); } elsif ($name eq "baz") { baz(); } else { die "$name not implemented"; } }
{ package Point; use Moose; has [ } package main; my $point = Point->new( x => $point->x(25);
use List::Util qw/reduce/; sub factorial { reduce { $a * $b } 1 .. $_[0]; }
if ( $lookup{FLAG} ) { print "Ayup, got that flag!"; }
my %opts = map { $ARGV[$_] => $_ } grep { $ARGV[$_] =~ /^-/ } 0 .. $
if( defined( $opts{-e} ) ) { my $arg = $ARGV[ $opts{-e} ]; }
my %opts = map { $ARGV[$_] => $_ } grep { $ARGV[$_] =~ /^-/ } 0 .. $
open(H_CONFIG, "< $file_name") or die("Error opening file: $file_name! ($!)"); while (<H_CONFIG>) { chomp; next if $_ =~ /^\s*$/; next if $_ =~ /^\s* }
my $string = 1 . 2; my $number = "1" + "2"; my $unambiguous = 1 . "2";
var string = "1" + "2"; var number = 1 + 2; var ambiguous = 1 + "2";
string = "1" + "2" number = 1 + 2 throws_exception = 1 + "2"
>>> k = 5 >>> reduce(lambda i,j: i*j, range(1,k+1),1) 120 >>> k = 0 >>> reduce(lambda i,j: i*j, range(1,k+1),1) 1
sub PrintAA { my $test = shift; my %aa = shift; print $test . "\n"; foreach (keys %aa) { print $_ . " : " . $aa{$_} . "\n"; $aa{$_} = $aa{$_} . "+"; } }
PrintAA("abc", \%fooHash); sub PrintAA { my $test = shift; my $aaRef = shift; print $test, "\n"; foreach (keys %{$aaRef}) { print $_, " : ", $aaRef->{$_}, "\n"; } }
use strict; sub PrintAA { my($test, %aa) = @_; print $test . "\n"; foreach (keys %aa) { print $_ . " : " . $aa{$_} . "\n"; } } my(%hash) = ( PrintAA("test", %hash);
Reference found where even-sized list expected at xx.pl line 18. ... Use of uninitialized value in concatenation (.) or string at xx.pl line 13.
sub PrintAA { my $test = shift; my %aa = @_; print $test . "\n"; foreach (keys %aa) { print $_ . " : " . $aa{$_} . "\n"; $aa{$_} = $aa{$_} . "+"; } }
sub PrintAA { my $test = shift; my $aa = shift; if (ref($aa) != "HASH") { die "bad arg!" } .... } PrintAA($foo, \%bar);
my $scalar = 5; my %hash = (a => 1, b => 2, c => 3); func($scalar, %hash)
sub func { my $scalar_var = shift; my %hash_var = @_; ... Do something ... }
sub PrintAA ($\%) { my $test = shift; my %aa = ${shift()}; print "$test\n"; foreach (keys %aa) { print "$_ : $aa{$_}\n"; $aa{$_} = "$aa{$_}+"; } }
sub someFunction { my ( $arg1, $arg2, $arg3 ) = @_;
sub testFunc { my ( $string, %hash ) = @_; print "$string $hash{ } my %testHash = ( ); testFunc(
sub get_args { ref( $_[0] ) ? shift() : ( @_ % 2 ) ? {} : {@_}; } sub PrintAA { my $test = shift; my $aa = get_args(@_);; $aa->{somearg} $aa->{anotherearg} }
use strict; use XML::Parser; use Data::Dumper; my $url = my $output = my $file = "curl -sS my $parser = new XML::Parser(Style => my $tree = $parser->parsefile($file)->[1];
use strict; use XML::Parser; use Data::Dumper; my $url = my $output = my $file = "curl -sS $url |"; my $parser = new XML::Parser(Style => my $tree = $parser->parsefile($file)->[1];
String command = "curl try { Process proc = Runtime.getRuntime().exec(command); ....... }catch(Exception e){}
String command = "curl -duser.name=hdfs -dexecute=select+*+from+logdata.test; -dstatusdir=test.output http:
opendir(D, "/path/to/directory") || die "Can while (my $f = readdir(D)) { print "\$f = $f\n"; } closedir(D);
my $d = shift; opendir(D, "$d") || die "Can my @list = readdir(D); closedir(D); foreach my $f (@list) { print "\$f = $f\n"; }
opendir(DIR, $somedir) || die "Can @dots = grep { (!/^\./) && -f "$somedir/$_" } readdir(DIR); closedir DIR;
use IO::Dir; $d = IO::Dir->new("."); if (defined $d) { while (defined($_ = $d->read)) { something($_); } $d->rewind; while (defined($_ = $d->read)) { something_else($_); } undef $d; } tie %dir, foreach (keys %dir) { print $_, " " , $dir{$_}->size,"\n"; }
@files = </path/to/directory/*>; print join(", ", @files);
use DirHandle; $d = new DirHandle "."; if (defined $d) { while (defined($_ = $d->read)) { something($_); } $d->rewind; while (defined($_ = $d->read)) { something_else($_); } undef $d; }
sub copy_directory { my ($source, $dest) = @_; my $start = time; opendir(D, $source); my @f = readdir(D); closedir(D); foreach my $file (@f) { my $filename = $source . "\\" . $file; my $destfile = $dest . "\\" . $file; my $sourceInfo = stat( $filename ); my $destInfo = stat( $destfile ); mkdir( $dest, 0777 ); if ($file eq } elsif (-d $filename) { copy_directory($filename, $destfile); } else { if( (not -e $destfile) || ($sourceInfo->mtime > $destInfo->mtime ) ) { copy( $filename, $destfile ) or print "Error copying $filename: $!\n"; } } } print "$source copied in " . (time - $start) . " seconds.\n"; }
opendir(DIR, $somedir) || die "can @dots = grep { (!/^\./) && -f "$somedir/$_" } readdir(DIR); closedir DIR;
use strict; use warnings; my $directory = opendir (DIR, $directory) or die $!; while (my $file = readdir(DIR)) { next if ($file =~ m/^\./); print "$file\n"; }
use strict; use warnings; my $dir = opendir(DIR, $dir) or die $!; my @dots = grep { /^\./ && -f "$dir/$_" } readdir(DIR); foreach my $file (@dots) { print "$file\n"; } closedir(DIR); exit 0; closedir(DIR); exit 0;
=head1 NAME simplee - simple program =head1 SYNOPSIS simple [OPTION]... FILE... -v, --verbose use verbose mode --help print this help message Where I<FILE> is a file name. Examples: simple /etc/passwd /dev/null =head1 DESCRIPTION This is as simple program. =head1 AUTHOR Me. =cut use strict; use warnings; use Getopt::Long qw(:config auto_help); use Pod::Usage; exit main(); sub main { my $verbose; GetOptions( ) or pod2usage(1); pod2usage(1) unless @ARGV; my (@files) = @ARGV; foreach my $file (@files) { if (-e $file) { printf "File $file exists\n" if $verbose; } else { print "File $file doesn } } return 0; }
use strict; use warnings; use IO::File; use Convert::Binary::C; my $c = Convert::Binary::C->new( my $packed = $c->pack( print $packed; my $fh = IO::File->new( or die "Unable to open outfile - $!\n"; $fh->binmode; $fh->print( $packed );
sub output_word { $word = $_[0]; $lsb = $word % 256; $msb = int($word/256); print OUT chr($lsb) . chr($msb); return $word; }
% cpan cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl cpan> o conf commit
% cpan cpan> o conf mbuild_arg "--install_base /mydir/perl" cpan> o conf commit
my $trendsurl = "https: my $json; { local $/; open my $fh, "<", $trendsurl; $json = <$fh>; } my $decoded_json = @{decode_json{shares}}; print $decoded_json;
use LWP::Simple; use JSON qw( decode_json ); use Data::Dumper; use strict; use warnings; my $trendsurl = "https: my $json = get( $trendsurl ); die "Could not get $trendsurl!" unless defined $json; my $decoded_json = decode_json( $json ); print Dumper $decoded_json; print "Shares: ", $decoded_json->{ "\n";
$curl=( $exec=`$curl`; print "Output is::: \n$exec\n\n"; if ($exec=~/"shares":?/) { print "Output is::: \n$exec\n\n"; $shares=$ $shares=~s/(\D.*) print "Number of Shares is: ".$shares."\n"; } else { print "No Share Information available.\n" }
dim string1 as string = "1" If string1.contains("1") Then Code here... End If
my $x = "foo"; my $y = "foo foo foo bar"; my $c = () = $y =~ /$x/g;
my $string = "aaaabbabbba"; my @count = ($string =~ /a/g); print @count . "\n";
my @matches = $bigstring =~ /($littlestring)/g; my $count = @matches;
sub occurrences { my( $x, $y ) = @_; my $pos = 0; my $matches = 0; while (1) { $pos = index($y, $x, $pos); last if($pos < 0); $matches++; $pos++; } return $matches; }
my $methodName ="helloWorld"; $myObject->$methodNames;
if ($myObject->can($methodName)) { $myObject->$methodName; }
if( my $ref = eval { $obj->can( $method ) } ) { $obj->$ref( @args ); }
my $method = "ping"; if(defined ($local_dbh) && eval{ $local_dbh->can($method) } ) { if ($local_dbh->ping) { return $local_dbh; } } else { ... }
package Foo; use vars qw{$DEBUG}; BEGIN { $DEBUG = 0 unless defined $DEBUG; } use constant DEBUG => !! $DEBUG; sub foo { debug( ... }
!! undef == 0 !! 0 == 0 !! 1 == 1 !! $obj == 1 !! 100 == 1 undef ? 1 : 0 == 0 0 ? 1 : 0 == 0 1 ? 1 : 0 == 1 $obj ? 1 : 0 == 1 100 ? 1 : 0 == 1
:: short answer : :: perl -MCPAN -e "install PAR::Packer" pp -o <<DesiredExeName>>.exe <<MyFancyPerlScript>> :: long answer - create the following cmd , adjust vars to your taste ... :: next_line_is_templatized :: file:compile-morphus.1.2.3.dev.ysg.cmd v1.0.0 :: disable the echo @echo off :: this is part of the name of the file - not used set _Action=run :: the name of the Product next_line_is_templatized set _ProductName=morphus :: the version of the current Product next_line_is_templatized set _ProductVersion=1.2.3 :: could be dev , test , dev , prod next_line_is_templatized set _ProductType=dev :: who owns this Product / environment next_line_is_templatized set _ProductOwner=ysg :: identifies an instance of the tool ( new instance for this version could be created by simply changing the owner ) set _EnvironmentName=%_ProductName%.%_ProductVersion%.%_ProductType%.%_ProductOwner% :: go the run dir cd %~dp0 :: do 4 times going up for /L %%i in (1,1,5) do pushd .. :: The BaseDir is 4 dirs up than the run dir set _ProductBaseDir=%CD% :: debug echo BEFORE _ProductBaseDir is %_ProductBaseDir% :: remove the trailing \ IF %_ProductBaseDir:~-1%==\ SET _ProductBaseDir=%_ProductBaseDir:~0,-1% :: debug echo AFTER _ProductBaseDir is %_ProductBaseDir% :: debug pause :: The version directory of the Product set _ProductVersionDir=%_ProductBaseDir%\%_ProductName%\%_EnvironmentName% :: the dir under which all the perl scripts are placed set _ProductVersionPerlDir=%_ProductVersionDir%\sfw\perl :: The Perl script performing all the tasks set _PerlScript=%_ProductVersionPerlDir%\%_Action%_%_ProductName%.pl :: where the log events are stored set _RunLog=%_ProductVersionDir%\data\log\compile-%_ProductName%.cmd.log :: define a favorite editor set _MyEditor=textpad ECHO Check the variables set _ :: debug PAUSE :: truncate the run log echo date is %date% time is %time% > %_RunLog% :: uncomment this to debug all the vars :: debug set >> %_RunLog% :: for each perl pm and or pl file to check syntax and with output to logs for /f %%i in ( :: for each perl pm and or pl file to check syntax and with output to logs for /f %%i in ( :: now open the run log cmd /c start /max %_MyEditor% %_RunLog% :: this is the call without debugging :: old echo CFPoint1 OK The run cmd script %0 is executed >> %_RunLog% echo CFPoint2 OK compile the exe file STDOUT and STDERR to a single _RunLog file >> %_RunLog% cd %_ProductVersionPerlDir% pp -o %_Action%_%_ProductName%.exe %_PerlScript% | tee -a %_RunLog% 2>&1 :: open the run log cmd /c start /max %_MyEditor% %_RunLog% :: uncomment this line to wait for 5 seconds :: ping localhost -n 5 :: uncomment this line to see what is happening :: PAUSE :: ::::::: :: Purpose: :: To compile every *.pl file into *.exe file under a folder ::::::: :: Requirements : :: perl , pp , win gnu utils tee :: perl -MCPAN -e "install PAR::Packer" :: text editor supporting <<textEditor>> <<FileNameToOpen>> cmd call syntax ::::::: :: VersionHistory :: 1.0.0 --- 2012-06-23 12:05:45 --- ysg --- Initial creation from run_morphus.cmd ::::::: :: eof file:compile-morphus.1.2.3.dev.ysg.cmd v1.0.0
use strict; use warnings; use Test::More tests => 1; use Test::Output; sub myfunc { print "This is a test\n" } stdout_is(\&myfunc, "This is a test\n",
use strict; use warnings; use Test::More tests => 1; sub myfunc { print "This is a test\n" } sub invoke { my $sub = shift; my $stdout; { local *STDOUT; open STDOUT, or die "Cannot open STDOUT to a scalar: $!"; $sub->(@_); close STDOUT or die "Cannot close redirected STDOUT: $!"; } return $stdout; } chomp(my $ret = invoke(\&myfunc)); ok($ret eq "This is a test", "myfunc() prints test string" ); diag("myfunc() printed
$ perl -MCPAN -e shell cpan shell -- CPAN exploration and modules installation (v1.9402) Enter cpan[1]> install Net::TCP::Server
perlbrew init perlbrew install --force stable perlbrew switch stable
FastCgiExternalServer /tmp/placktest.fcgi -socket /tmp/fcgi.socket Alias /plack/ /tmp/placktest.fcgi/
plackup -s FCGI --listen /tmp/fcgi.socket /data/www/psgi/app.psgi
FastCGI: manager (pid <pid>): initialized FastCGI: manager (pid <pid>): server (pid <pid>) started FastCGI: server (pid <pid>): initialized
use Plack::App::CGIBin; use Plack::Builder; my $app = Plack::App::CGIBin->new( root => )->to_app; builder { mount "/plack" => $app; };
FastCGI: server "/tmp/placktest.fcgi" stderr: <IP address/date>; "GET /plack/test.cgi HTTP/1.1" 404 9 "-" <User agent string>;
use warnings; use strict; use OpenOffice::OODoc; my $file= my $outfile= my $container = odfContainer("$file"); $container->raw_export("styles.xml"); my $doc = odfDocument ( container => $container, part => ); my $style = odfDocument ( container => $container, part => ); my $container2 = odfContainer( $outfile, create => $container2->raw_import("styles.xml"); my $doc2 = odfDocument ( container => $container2, part => ); my $table=$doc->getTable(0); my $headerstyle=$doc->getStyle( $doc->getCell($table, 0, 0) ); my $newtable=$doc2->appendTable( $doc2->cellStyle( $newtable, 0, 0, $container2->save;
<?xml version="1.0" encoding="utf-8"?> <office:document-content> ... <office:automatic-styles> <style:style style:name="Table6" style:family="table" style:master-page-name="First_20_Page"> <style:table-properties style:width="6.9208in" style:page-number="auto" table:align="left" style:writing-mode="lr-tb" /> </style:style> <style:style style:name="Table6.A" style:family="table-column"> <style:table-column-properties style:column-width="1.2729in" /> </style:style> <style:style style:name="Table6.B" style:family="table-column"> <style:table-column-properties style:column-width="3.2604in" /> </style:style> <style:style style:name="Table6.C" style:family="table-column"> <style:table-column-properties style:column-width="2.3875in" /> </style:style> <style:style style:name="Table6.1" style:family="table-row"> <style:table-row-properties style:min-row-height="0.1597in" style:keep-together="true" fo:keep-together="auto" /> </style:style> <style:style style:name="Table6.A1" style:family="table-cell"> <style:table-cell-properties style:vertical-align="bottom" fo:background-color=" fo:padding-left="0.075in" fo:padding-right="0.075in" fo:padding-top="0in" fo:padding-bottom="0in" fo:border-left="0.0069in solid fo:border-right="none" fo:border-top="0.0069in solid fo:border-bottom="0.0069in solid style:writing-mode="lr-tb"> <style:background-image /> </style:table-cell-properties> </style:style> ...
use warnings; use strict; use OpenOffice::OODoc; my $infile=$ARGV[0]; my $outfile= my $incontainer = odfContainer( $infile ); $incontainer->raw_export("content.xml"); my $outcontainer = odfContainer( $outfile, create => $outcontainer->raw_import("content.xml"); $outcontainer->save;
<style:style style:name="Table1" style:family="table"> <style:table-properties style:width="6.925in" table:align="margins" /> </style:style> <style:style style:name="Table1.A" style:family="table-column"> <style:table-column-properties style:column-width="2.3083in" style:rel-column-width="21845*" /> </style:style> <style:style style:name="Table1.A1" style:family="table-cell"> <style:table-cell-properties fo:background-color=" fo:padding="0.0382in" fo:border-left="0.0007in solid fo:border-right="none" fo:border-top="0.0007in solid fo:border-bottom="0.0007in solid <style:background-image /> </style:table-cell-properties> </style:style>
my $container2 = odfContainer( $outfile, create => $container2->raw_import("styles.xml"); $container2->save; $container2 = odfContainer( $outfile ); my $doc2 = odfDocument ( container => $container2, part => ); my $table=$doc->getTable(0); my $headerstyle=$doc->getStyle( $doc->getCell($table, 0, 0) ); my $newtable=$doc2->appendTable( $doc2->cellStyle( $newtable, 0, 0, $container2->save;
@list = qw(1 2 3 4 5 6); foreach (@list) { print "i: $i, j:$j\n"; }
my @x = ( my $it = natatime 3, @x; while (my @vals = $it->()) { print "@vals\n"; }
sub natatime ($@) { my $n = shift; my @list = @_; return sub { return splice @list, 0, $n; } }
my @list = qw(1 2 3 4 5 6); while(my ($i,$j) = splice(@list,0,2)) { print "i: $i, j: $j\n"; }
while (scalar(@list) > 0) { $i = shift(@list); $j = shift(@list); print "i: $i, j:$j\n"; }
use Modern::Perl; use List::AllUtils qw my @array = zip @{[
{ my $i = 0; while( (my($a,$b) = @array[$i++,$i++]), $i <= @array ){ say "$a => $b"; } }
use List::Pairwise qw for my $pair (pair @array){ my($a,$b) = @$pair; say "$a => $b"; }
use List::AllUtils qw my $iter = natatime 2, @array; while( my($a,$b) = $iter->() ){ say "$a => $b"; }
{ my %map = @array; for my $key (keys %map){ my $value = $map{$key}; say "$key => $value"; } }
for(my $ix = 0; $ix <= $ my $i = $list[$ix]; my $j = $list[$ix + 1]; print "i: $i, j:$j\n"; }
while(@list) { my $i = shift @list; my $j = shift @list; print "i: $i, j:$j\n"; }
{ my $cl_ind = 0; sub arrayeach(@) { my @obj = @_; if(($cl_ind+2) > @obj) { $cl_ind = 0; return; } $cl_ind+=2; return ($obj[$cl_ind-2],$obj[$cl_ind-1]); } }
my @temp = (1,2,3,4,5,6,1,2,3,4,5,6); while( ($a,$b) = arrayeach(@temp)) { print "A $a AND $b\n"; }
for (0 .. $ next if $_ % 2; my ($i, $j) = @list[$_, $_ + 1]; say "i:$i, j:$j"; }
use Carp; sub mapn (&$@) { my ($sub, $n, @ret) = splice @_, 0, 2; croak while (@_) { local *_ = \$_[0]; push @ret, $sub->(splice @_, 0, $n) } @ret } sub by ($@) {mapn {[@_]} shift, @_} sub every ($@); *every = \&by;
print "@$_\n" for every 2 => 1..10; print map {"@$_\n"} grep {$_->[1] > 5} by 2 => 1..10;
my $i; for ( qw(a b c d) ) { if (!defined($i)) { $i = $_; next; } print STDOUT "i = $i, j = $_\n"; undef($i); }
use strict; use warnings; my @list = qw/1 2 3 4 5 6/; my $get_em = get_by(2, @list); while ( my ($i, $j) = $get_em->() ) { print "i: $i, j: $j\n"; } sub get_by { my $n = shift; my @list = @_; return sub { return splice @list, 0, $n; } }
use strict; use warnings; my @list = qw(1 2 3 4 5 ); my $i = 0; for ($i = 0; $i < scalar(@list); $i++) { my $a = $list[$i]; my $b = $list[++$i]; if(defined($a)) { print "a:$a"; } if(defined($b)) { print "b:$b"; } print "\n"; }
for ( map {$_*2} 0..@list/2-1 ){ my ($i, $j) = @list[$_,$_+1]; print "i: $i, j:$j\n"; }
sub map_pairs(&\@) { my $op = shift; use vars local *array = shift; return () unless @array; my ($caller_a, $caller_b) = do { my $pkg = caller(); no strict \*{$pkg. }; my $limit = $ local(*$caller_a, *$caller_b); map { (*$caller_a, *$caller_b) = \($array[$_], $array[$_+1]); $op->(); } map { 2 * $_ } 0..$limit; }
@foo = qw( a 1 b 2 c 3 ); my @bar = map_pairs { "$a is $b" } @foo;
sub natatime { my $n = shift; my $list = \@_; sub { return splice @$list, 0, $n; } } my $it = natatime(3, qw(1 2 3 4 5 6)); while ( my @list = $it->() ) { print "@list\n"; }
while (my ($key,$value) = each @list) { print "$key=$value\n"; }
my %hash = (@list); while (my ($key,$value) = each %hash) { print "$key=$value\n"; }
perl -MList::Gen=":utility" -E say "i:$_->[0] j:$_->[1]" for every 2 => @nums'
use v5.16; my @list = "1" .. "6"; my $n = 2 ; $n-- ; foreach (my $i = 0 ; $i < @list ; $i += $n ) { say "i:", [ @list[$i..$i+$n] ]->[0], " j:", [ @list[$i..$i+$n] ]->[1]; $i++ ; }
my @array=qw(one two three four five); while (my ($i1,$one,$i2,$two)=(each(@array),each(@array)) { next unless defined $i1 and defined $i2; print "fetched array elements: $one => $two\n"; };
package MyPackage; use strict; use warnings; use constant PERL510 => ( $] >= 5.0100 ); require Exporter; our @ISA = qw(Exporter); our @EXPORT = qw( ); { my $somevar; sub Somesub { } } 1;
C:\temp>cat MyTest.pm package MyTest; use strict; sub test { print "test\n"; } C:\temp>perl -e "use MyTest" MyTest.pm did not return a true value at -e line 1. BEGIN failed--compilation aborted at -e line 1. C:\temp>
C:\temp>cat MyTest.pm package MyTest; use strict; sub test { print "test\n"; } "false"; C:\temp>perl -e "use MyTest" C:\temp> (no error here)
while (defined(my $ln = <>)) { chomp($ln); chop($ln) if ($ln =~ m/\r$/); }
for ($line in <FILEHANDLE>) { $line =~ s/\r\n$/\n/; }
while(<INPUTFILE>) { chomp; chop($_) if ($_ =~ m/\r$/); }
while ($x =~ /(\w+)/g) { print "Word is $1, ends at position ", pos $x, "\n"; }
my $str = my @ts = $str =~ /%([\w]+)%/g; print join(", ", @ts);
A Perl module must end with a true value or else it is considered not to have loaded. By convention this value is usually 1 though it can be any true value. A module can end with false to indicate failure but this is rarely used and it would instead die() (exit with an error).
package My::Parent; use strict; use warnings; use Devel::Cycle; sub DESTROY { my $this = shift; find_cycle($this, sub { my $path = shift; foreach (@$path) { my ($type,$index,$ref,$value) = @$_; print STDERR "Circular reference found while destroying object of type " . ref($this) . "! reftype: $type\n"; } }); }
use Devel::Leak; my $handle; my $leaveCount = 0; my $enterCount = Devel::Leak::NoteSV($handle); print STDERR "ENTER: $enterCount SVs\n"; $leaveCount = Devel::Leak::CheckSV($handle); print STDERR "\nLEAVE: $leaveCount SVs\n";
$ perl -e [1] 86836 $ gdb -p 86836 … Attaching to process 86836. Reading symbols for shared libraries . done Reading symbols for shared libraries ............................. done Reading symbols for shared libraries + done 0x000000010c1694c6 in Perl_pp_stub () (gdb) call (void*)Perl_eval_pv("require Enbugger;Enbugger->stop;",0) perl(86836) malloc: *** error for object 0x3: pointer being realloc *** set a breakpoint in malloc_error_break to debug Program received signal SIGABRT, Aborted. 0x00007fff8269d82a in __kill () The program being debugged was signaled while in a function called from GDB. GDB remains in the frame where the signal was received. To change this behavior use "set unwindonsignal on" Evaluation of the expression containing the function (Perl_eval_pv) will be abandoned. (gdb)
`0x00007fba15ab35c1 in Perl_runops_debug () at dump.c:2266` `2266 } while ((PL_op = PL_op->op_ppaddr(aTHX)));`
open (FILE, $file) or die("cannot open $file"); open (FILE, $file) || die("cannot open $file");
@info = stat($file) || die; @info = stat($file) or die;
chdir $foo || die; chdir($foo) || die; chdir ($foo) || die; chdir +($foo) || die;
open FILE, $file or die("cannot open $file"); open FILE, $file || die("cannot open $file"); open FILE, ($file || die("cannot open $file"));
$ident{ name } = standardize_name($name); $ident{ age } = time - $birth_date; $ident{ status } =
use constant CONSTANT => ... my %hash = () $hash{CONSTANT} = $hash{word-with-hyphens} =
my @pairs = split /(?(?{ pos() % 2 })(?!))/, $string;
my @pairs = $string =~ /..?/sg; my @pairs = $string =~ /../sg; my @pairs = unpack
$ cat strict-safe?.pl use 5.012; $foo $ perl strict-safe\?.pl Global symbol "$foo" requires explicit package name at strict-safe?.pl line 2. Execution of strict-safe?.pl aborted due to compilation errors.
package TestPrivate; require 5.004; use strict; use warnings; use Carp; use vars qw($VERSION @ISA @EXPORT @EXPORT_OK); require Exporter; @ISA = qw(Exporter AutoLoader); our @EXPORT_OK = qw( public_function ); our @EXPORT = qw( ); $VERSION = sub new { my ( $class, %args ) = @_; my $self = {}; bless( $self, $class ); $self->private_function("THIS SHOULD BE PRIVATE"); $self->{public_variable} = "This is public"; return $self; } sub public_function { my $self = shift; my $new_text = shift; $self->{public_variable} = $new_text; print "Public Variable: $self->{public_variable}\n"; print "Internal Variable: $self->{internal_variable}\n"; } sub private_function { my $self = shift; my $new_text = shift; $self->{internal_variable} = $new_text; }
use strict; use TestPrivate my $foo = new TestPrivate(); $foo->public_function("Changed public variable"); $foo->private_function("I changed your private variable"); $foo->public_function("Changed public variable again"); $foo->{internal_variable} = "Yep, I changed your private variable again!"; $foo->public_function("Changed public variable the last time");
Public Variable: Changed public variable Internal Variable: THIS SHOULD BE PRIVATE Public Variable: Changed public variable again Internal Variable: I changed your private variable Public Variable: Changed public variable the last time Internal Variable: Yep, I changed your private variable again!
my $priv_func1 = sub { my $self = shift; say sub public_sub { my $self = shift; $priv_func1->( $self ); }
my $priv_func1 = sub { my $self = shift; say }; sub public_sub { my $self = shift; $self->$priv_func1(@_); }
package My; sub new { return bless { }, shift; } sub private_func { my ($s, %args) = @_; die "Error: Private method called" unless (caller)[0]->isa( ref($s) ); warn "OK: Private method called by " . (caller)[0]; } sub public_func { my ($s, %args) = @_; $s->private_func(); } package main; my $obj = My->new(); $obj->public_func( ); $obj->private_func( );
sub foo { my ($s, %args) = @_; die "Error: Private method called" unless (caller)[0]->isa( ref($s) ); }
my @arr = qw(Field3 Field1 Field2 Field5 Field4); my $last_arr_index=$
my $arr_ref = [qw(Field3 Field1 Field2 Field5 Field4)]; my $last_aref_index;
my $arr_ref = [qw(Field3 Field1 Field2 Field5 Field4)]; my ($last_arr_index, $next_arr_index);
my $next_arr_index = scalar(@$arr_ref); $last_arr_index = $next_arr_index - 1; $last_arr_index = @{ $arr_ref } - 1;
$arr_ref->[-1] = 11; print "Last Value : $arr_ref->[-1] \n";
my $arr_ref = [qw(Field3 Field1 Field2 Field5 Field4)]; my $last_aref_index = $$arr_ref[$ print "last element is: $last_aref_index\n";
USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND schwern 73019 0.0 1.6 625552 33688 s000 S 2:47PM 0:00.24 perl -wle open my $fh, shift; for(<$fh>) { 1 } print "Done"; sleep 999 /usr/share/dict/words schwern 73018 0.0 0.1 601096 1236 s000 S 2:46PM 0:00.09 perl -wle open my $fh, shift; while(<$fh>) { 1 } print "Done"; sleep 999 /usr/share/dict/words schwern 73081 0.0 0.1 601096 1168 s000 S 2:55PM 0:00.00 perl -wle open my $fh, shift; print "Done"; sleep 999 /usr/share/dict/words
while ( my $line = <FILE> ) { if ( $line =~ /some_target/ ) { print "Found some_target at line $.\n"; } }
while( <FILE> ) { last if ...; } my $line = <FILE>;
foreach( <FILE> ) { last if ...; } my $line = <FILE>;
while (defined(my $line = <FILE>)) { print $line; }
$_ = 100; { local $_; while (<FILE>) { } } print $_;
while (<FILE>) { $line1 = $_; if ($line1 =~ /SOMETHING/) { $line2 = <FILE>; if (line2 =~ /SOMETHING ELSE/) { print "I found SOMETHING and SOMETHING ELSE in consecutive lines\n"; exit(); } } }
$socket = IO:Socket::INET->new(...); $pid = fork(); if(!$pid) { exec("ssh $host -f exit; } $client = $socket->accept; while(<$client>) { print $_; }
-t Force pseudo-tty allocation. This can be used to execute arbitrary screen-based programs on a remote machine, which can be very useful, e.g. when implementing menu services. Multiple -t options force tty allocation, even if ssh has no local tty.
-f Requests ssh to go to background just before command execution. This is useful if ssh is going to ask for passwords or passphrases, but the user wants it in the background. This implies -n. The recommended way to start X11 programs at a remote site is with something like ssh -f host xterm.
PIDHOME=/a_place/to/store/flag/file FILE=`echo ${0} | sed RUNFILEFLAG=${PIDHOME}/${FILE}.running if [ -e $RUNFILEFLAG ]; then echo "Already running ${RUNFILEFLAG}" exit 1 else touch ${RUNFILEFLAG} fi hostname=$1 log_dir=$2 log_file=$3 username=$3 log_base=$4 ORIGLOG="$log_base/$hostname/${log_file}.orig" INTERLOG="$log_base/$hostname/${log_file}.inter" FINALLOG="$log_base/$hostname/${log_file}.log" rsync -q -e ssh $username@$hostname:$log_dir/$log_file ${ORIGLOG} grep -Ev ".ico|.jpg|.gif|.png|.css" > ${INTERLOG} if [ ! -e $FINALLOG ]; then cp ${INTERLOG} ${FINALLOG} else LINE=`tail -1 ${FINALLOG}` grep -F "$LINE" -A 999999999 ${INTERLOG} \ | grep -Fv "$LINE" >> ${FINALLOG} fi rm ${RUNFILEFLAG} exit 0
$pid = fork(); if(!$pid) { exec("ssh $host -f exit; } exec("nc -l -p $port");
use strict; use warnings; BEGIN { print "Hello from the BEGIN block\n"; } END { print "Hello from the END block\n"; }
use strict; use warnings; my $x = 12; BEGIN { $x = 14; } print "$x\n";
use strict; use warnings; my $x = 12; my $y; BEGIN { $x = 14; print "x => $x\n"; $y = 16; print "y => $y\n"; } print "x => $x\n"; print "y => $y\n";
% cat sto-INIT-eg print " PRINT: main running"; die " DIE: main dying\n"; die "DIE XXX "; END { print "1st END: done running" } CHECK { print "1st CHECK: done compiling" } INIT { print "1st INIT: started running" } END { print "2nd END: done running" } BEGIN { print "1st BEGIN: still compiling" } INIT { print "2nd INIT: started running" } BEGIN { print "2nd BEGIN: still compiling" } CHECK { print "2nd CHECK: done compiling" } END { print "3rd END: done running" }
% perl -c sto-INIT-eg 1st BEGIN: still compiling 2nd BEGIN: still compiling 2nd CHECK: done compiling 1st CHECK: done compiling sto-INIT-eg syntax OK
% perl sto-INIT-eg 1st BEGIN: still compiling 2nd BEGIN: still compiling 2nd CHECK: done compiling 1st CHECK: done compiling 1st INIT: started running 2nd INIT: started running PRINT: main running DIE: main dying 3rd END: done running 2nd END: done running 1st END: done running
BEGIN { require Module; Module->import(qw/a b c/); }
use strict; use warnings; my $answer = 42; if ($answer == 6 * 9) { print "everything is running fine.\n"; } else { warn "there must be a bug somewhere...\n"; }
>> w.pl:6: my $answer = 42; >> w.pl:8: if ($answer == 6 * 9) { >> w.pl:11: warn "there must be a bug somewhere...\n"; there must be a bug somewhere...
$ cat demo.pl $a = 1; $b = 3; $c = 2 * $a + 7 * $b; @d = ($a, $b, $c + $b); $ perl -d:DumpTrace demo.pl >>>>> demo.pl:3: $a:1 = 1; >>>>> demo.pl:4: $b:3 = 3; >>>>> demo.pl:5: $c:23 = 2 * $a:1 + 7 * $b:3; >>>>> demo.pl:6: @d:(1,3,26) = ($a:1, $b:3, $c:23 + $b:3);
use v5.10; $_ =<< He said HERE say "Matched!" if m/ ( [ ( (?: [^ | ( (?1) ) )* ) [ ) /xg; print " 1 => $1 2 => $2 3 => $3 4 => $4 5 => $5 ";
Matched! 1 => 2 => Amelia said "I am a camel" 3 => "I am a camel" 4 => 5 =>
use v5.10; $_ =<< He said HERE say "Matched [$+{said}]!" if m/ (?<said> [ ( (?: [^ | (?1) )* ) [ ) /xg; use Data::Dumper; print Dumper( \%- );
use v5.10; $_ =<< He said HERE say "Matched [$+{said}]!" if m/ (?<said> [ ( (?: [^ | (?<said> (?1) ) )* ) [ ) /xg; use Data::Dumper; print Dumper( \%- );
use v5.10; $_ =<< He said HERE say "Matched [$+{said}]!" if m/ ( (?<said> [ ( (?: [^ | (?1) )* ) [ ) ) /xg; use Data::Dumper; print Dumper( \%- );
use v5.10; $_ =<< Outside "Top Level HERE my @matches; say "Matched!" if m/ (?(DEFINE) (?<QUOTE_MARK> [ (?<NOT_QUOTE_MARK> [^ ) ( (?<quote>(?&QUOTE_MARK)) (?: (?&NOT_QUOTE_MARK)++ | (?R) )* \g{quote} ) (?{ push @matches, $^N }) /x; say join "\n", @matches;
std::map<std::string, std::string> TryMap(const std::map<std::string, std::string> &map) { std::map<std::string, std::string> modified(map); modified["7"] = "!"; return modified; }
%module stl %include "std_string.i" %include "std_map.i" %template(StringStringMap) std::map<std::string, std::string>; %{ %} %include "stl.h"
my $map = stl::TryMap(stl::StringStringMap->new()); print $map->get(
$ wc -l perl5/std_map.i python/std_map.i 74 perl5/std_map.i 305 python/std_map.i
use Data::Dumper; use stl; my $v = stl::TryMap(stl::StringStringMap->new()); $v->{ print Dumper $v; print Dumper stl::TryMap({ print Dumper stl::TryMap($v); foreach my $key (keys %{$v}) { print "$key => $v->{$key}\n"; } print $v->{
use stl; my $v = stl::TryMap(stl::StringStringMap->new()); print "$v\n"; tie %foo, "stl::StringStringMap", $v; print $foo{ print tied(%foo)."\n";
sub match_positions { my ($regex, $string) = @_; return if not $string =~ /$regex/; return ($-[0], $+[0]); } sub match_all_positions { my ($regex, $string) = @_; my @ret; while ($string =~ /$regex/g) { push @ret, [ $-[0], $+[0] ]; } return @ret }
sub match_positions { my ($regex, $string) = @_; return if not $string =~ /($regex)/; return (pos($string), pos($string) + length $1); } sub all_match_positions { my ($regex, $string) = @_; my @ret; while ($string =~ /($regex)/g) { push @ret, [pos($string), pos($string) + length $1]; } return @ret }
$‘ The string preceding whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or eval enclosed by the current BLOCK). (Mnemonic: "`" often precedes a quoted string.) This variable is read-only. The use of this variable anywhere in a program imposes a considerable performance penalty on all regular expression matches. See "BUGS".
sub match_positions { my ($regex, $string) = @_; return if not $string =~ /($regex)/; return (pos($string), pos($string) + length $1); } sub all_match_positions { my ($regex, $string) = @_; my @ret; while ($string =~ /($regex)/g) { push @ret, [(pos($string)-length $1),pos($string)-1]; } return @ret } my $regex= my $string="ACGACGCGCGCG"; my $cgap=3; my @pos=all_match_positions($regex,$string); my @hgcg; foreach my $pos(@pos){ push @hgcg,@$pos[1]; } foreach my $i(0..($ my $len=$hgcg[$i+$cgap-1]-$hgcg[$i]+2; print "$len\n"; }
use Mojo::UserAgent; my $ua = Mojo::UserAgent->new; say $ua->get( my $tx = $ua->post( if (my $res = $tx->success) { say $res->body } else { my ($err, $code) = $tx->error; say $code ? "$code response: $err" : "Connection error: $err"; } say $ua->get( ->res->json( say $ua->get(
$ my $content = `curl -s "http: <HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8"> <TITLE>301 Moved</TITLE></HEAD><BODY> <H1>301 Moved</H1> The document has moved <A HREF="http: </BODY></HTML>
use Regexp::Common; my $str = if ($str =~ $RE{quoted}) { }
open(FH, "<$fileName") or die "$!\n" if (<FILE_IS_NOT_ALREADY_OPEN>); close(FH) if (<FILE_IS_OPEN>);
Returns FH if FH may be used as a filehandle and is open, or FH is a tied handle. Otherwise "undef" is returned. $fh = openhandle(*STDIN); $fh = openhandle(\*STDIN); $fh = openhandle(*NOTOPEN); $fh = openhandle("scalar");
perl -wle ' open my $fh, "<", "notexists.txt"; print "can stat fh" if tell $fh ' tell() on closed filehandle $fh at -e line 1. -1
a | a* | Starting regex match a | a* | Trying a literal character zero-or-more times (as many as possible) | a* | Matched | | Regex matched in 3 steps
| <~~ | Back-tracking in regex | a* | Back-tracked and restarting regex match | a* | Trying a literal character zero-or-more times (as many as possible) | a* | Matched | | Regex matched in 3 steps
| <~~ | Back-tracking in regex | a* | Back-tracked and restarting regex match | a* | Trying a literal character zero-or-more times (as many as possible) | a* | Matched | | Regex matched in 3 steps
@documents_names = sort { !!$deleted_documents_names{$a} == !!$deleted_documents_names{$b} ? uc($a) cmp uc($b) : !!$deleted_documents_names{$a} cmp !!$deleted_documents_names{$b} } @documents_names;
@documents = sort { exists $deleted_documents_names{$a} <=> exists $deleted_documents_names{$b} || uc( $a ) cmp uc( $b ) } @documents;
Package::Stash::name(/usr/local/perl/5.10.1/lib/site_perl/5.10.1/Package/Stash.pm:21): 21: return $_[0]->{package}; 100 levels deep in subroutine calls! DB<1>
use strict; use warnings; sub f($) { my $x = shift; print "$x\n"; if ($x < 200) { f(1 + $x); } } $DB::deep = 500; f(1);
198 199 200 Debugged program terminated. Use q to quit or R to restart, use o inhibit_exit to avoid stopping after program termination, h q, h R or h o to get additional info. DB<1> _
97 98 99 main::f(qq.pl:4): my $x = shift; 100 levels deep in subroutine calls! DB<1> _
my $var; if (cond) { $var = "string1"; } if (defined $var) { ... }
1) $var = "foo" unless defined $var; 2) $var = defined $var? $var : {...}; 3) {...} if !(defined $var); 4) $var = $var || "foo"; 5) $var ||= "foo"; 6) $var = $var 7) $var
my $var = "foo"; {...} if ($var eq "foo"){ ... } else { ... }
use strict; use warnings; use PadWalker qw/peek_our peek_my/; use Data::Dumper; our $foo = 1; our $bar = 2; { my $foo = 3; print Dumper in_scope_variables(); } print Dumper in_scope_variables(); sub in_scope_variables { my %in_scope = %{peek_our(1)}; my $lexical = peek_my(1); while (my ($var, $ref) = each %$lexical) { $in_scope{$var} = $ref; } return \%in_scope; }
{ no strict foreach my $entry ( keys %main:: ) { print "$entry\n"; } }
foreach my $entry ( keys %main:: ) { print "-" x 30, "Name: $entry\n"; print "\tscalar is defined\n" if defined ${$entry}; print "\tarray is defined\n" if defined @{$entry}; print "\thash is defined\n" if defined %{$entry}; print "\tsub is defined\n" if defined &{$entry}; }
use strict; use warnings; use PadWalker qw/peek_our peek_my/; use Data::Dumper; our $foo = 1; our $bar = 2; { my $foo = 3; print Dumper in_scope_variables(); } print Dumper in_scope_variables(); sub in_scope_variables { my %in_scope = %{peek_our(1)}; my $lexical = peek_my(1); for my $name (keys %main::) { my $glob = $main::{$name}; if (defined ${$glob}) { $in_scope{ } if (defined @{$glob}) { $in_scope{ } if (defined %{$glob}) { $in_scope{ } } while (my ($var, $ref) = each %$lexical) { $in_scope{$var} = $ref; } return \%in_scope; }
{ no scrict for my $var (keys %{ print "$var\n"; } }
> if (@an_array) { print "has array elements\n" } > if (%a_hash) { print "has hash members\n" }
my %users = map { $_->unique_id() => $_ } @user_objects;
my @raw_values = (...); my @derived_values; for my $value (@raw_values) { push (@derived_values, _derived_value($value)); }
my @raw_values = (...); my @derived_values = map { _derived_value($_) } @raw_values;
my $sentence = "..."; my @stopwords = (...); my @foundstopwords; for my $word (split(/\s+/, $sentence)) { for my $stopword (@stopwords) { if ($word eq $stopword) { push (@foundstopwords, $word); } } }
my $sentence = "..."; my @stopwords = (...); my %is_stopword = map { $_ => 1 } @stopwords; my @foundstopwords = grep { $is_stopword{$_} } split(/\s+/, $sentence);
my %params = ( username => my @parampairs; for my $param (keys %params) { push (@parampairs, $param . } my $url = $ENV{SCRIPT_NAME} .
my %params = ( username => my $url = $ENV{SCRIPT_NAME} . . join(
my @uppercase = map { uc } @lowercase; my @hex = map { sprintf "0x%x", $_ } @decimal; my %hash = map { $_ => 1 } @array; sub join_csv { join(
@file_list = glob( @file_modify_times = map { [ $_, (stat($_))[8] ] } @file_list; @files_sorted_by_mtime = sort { $a->[1] <=> $b->[1] } @file_modify_times; @sorted_files = map { $_->[0] } @files_sorted_by_mtime;
@sorted_files = map { $_->[0] } sort { $a->[1] <=> $b->[1] } map { [ $_, (stat($_))[8] ] } glob(
@sorted_files = map { $_->[0] } sort { $a->[1] <=> $b->[1] } grep { $_->[1] > (time - 24 * 3600 } map { [ $_, (stat($_))[8] ] } glob(
@numbers = (3,2,1); @squares = map { $_ ** 2 } @numbers;
my @array = ( 1..5 ); @array = map { $_+5 } @array; print "@array\n"; @array = grep { $_ < 7 } @array; print "@array\n";
${[ sort map { $_->{name} } values %soldiers ]}[-1]
my %soldiers_by_sn = map { $->{serial_number} => $_ } values %soldiers;
my %soldiers_by_sn = map { $->{serial_number}, $_ } grep { $_->{name} !~ m/Hatfield$/ } values %soldiers ;
my @patents = ( print join(", ", map { "<a href=\"http:
for my $prevfh ( select $fh ) { $| = 1; select $prevfh }
use Readonly; Readonly my $CONSTANT => $hash{$CONSTANT} = 1;
use constant X => 1; %hash = (X() => 1); %hash = (+X => 1); $hash{X()} = 1; $hash{+X} = 1;
while( my( $index, $value ) = each @array1 ) { ...; $hash{ $value } = $array2[$index]; }
use List::MoreUtils qw( zip ); my @a = my @b = 1 .. 5; my %hash = zip @a, @b;
use strict; use warnings; my @array = while ( my ($index, $value) = each @array){ print "printing ($index, $value) from outer loop\n"; while ( my ($index_in, $value_in) = each @array){ print "printing ($index_in, $value_in) from inner loop\n"; } }
my @array = ( my $variable = @array; my ($variable) = @array;
my $variable = qw/ a b c d /; my ($variable) = qw/ a b c d /;
sub myFunction { ... return (wantarray() ? @array : $scalar); } my $variable = myFunction(...); my ($variable) = myFunction(...);
my $x = grep { /s/ } qw(apples bananas cherries); print $x;
my ($x) = grep { /s/ } qw(apples bananas cherries); print $x;
use 5.010; use strict; use warnings; use File::Basename; use File::Spec::Functions; my $perls_directory = catfile( $ARGV[0] ); die "$perls_directory does not exist!\n" unless -d dirname $perls_directory; my $links_directory = $ARGV[1] die "$links_directory does not exist!\n" unless -d $links_directory; foreach my $directory ( glob( $perls_directory ) ) { say "Processing $directory..."; unless( -e catfile( $directory, { say "\tNo bin/ directory. Skipping!"; next; } my @perls = glob( catfile( $directory, qw( bin perl5* ) ) ); my( $perl_version ) = $perls[0] =~ m/(5\.\d+\.\d+)\z/; say "\tperl version is $perl_version"; foreach my $bin ( glob( catfile( $directory, { say "\tFound $bin"; my $basename = basename( $bin ); my $link_basename = do { if( $basename =~ m/5\.\d+\.\d+\z/) { $basename } else { "$basename$perl_version" } }; my $link = catfile( $links_directory, $link_basename ); next if -e $link; say "\t\tlinking $bin => $link"; symlink $bin => $link or warn "\t\tCould not create symlink [$!]: $bin => $link!"; } }
$ module-starter --mi --module=Module::Name --author="Me" --email=me@cpan.org
use strict; eval { die "My error message"; }; if($@) { print $@; }
eval { time % 2 ? die { message => q(I died!), level => } : die "I died as a string!\n"; }; if( ref $@ ) { print "Reference message was $@->{message}\n"; } else { print "$@\n"; }
sub or1 { my ($a,$b) = @_; return $a || $b; } sub or2 { my ($a,$b) = @_; $a || $b; } sub or3 { my ($a,$b) = @_; return $a or $b; } sub or4 { my ($a,$b) = @_; $a or $b; }
<script type="text/javascript"> 48 48document).ready(function () { 48 48".closed").click(function () { 48 48this).find("div.but").toggleClass( 48 48this).toggleClass( }); }); </script>
<script type="text/javascript"> $(document).ready(function () { $( $(this).find( $(this).toggleClass( }); }); </script>
$be_strict = 0; if ((!$title{$loadpage} || !$h1{$loadpage} || !$description{$loadpage} || !$keywords{$loadpage} || !$breadcrumb{$loadpage}) && $be_strict) { print "Status: 302 Found\r\n" . "Location: http: "\r\n"; exit(0); } if ($action) { if ($action eq "fish") { $breadcrumb{ $h1{ $title{ $description{ $keywords{ } elsif ($action eq "ml") { $breadcrumb{ $h1{ $title{ $description{ $keywords{ } elsif ($action eq "sword") { $breadcrumb{ $h1{ $title{ $description{ $keywords{ } elsif ($action eq "axe") { $breadcrumb{ $h1{ $title{ $description{ $keywords{ } elsif ($action eq "club") { $breadcrumb{ $h1{ $title{ $description{ $keywords{ } elsif ($action eq "dist") { $breadcrumb{ $h1{ $title{ $description{ $keywords{ } elsif ($action eq "shield") { $breadcrumb{ $h1{ $title{ $description{ $keywords{ } elsif ($action eq "fist") { $breadcrumb{ $h1{ $title{ $description{ $keywords{ } } $web_content .= qq{ <!DOCTYPE HTML PUBLIC "- "http: <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> <title>$title{$loadpage}</title> <meta name="google-site-verification" content="Z97W94Kp7MlIOgiaMAYcFA4Lp4i5hckXdncRarXkBxk" /> <meta name="google-site-verification" content="I5HTpL8jLRcdrWk3jD83qIFDBkS4G_rmWHlxEq94jLU" /> <style type="text/css"> table.outlined { border-width: 1px; order-style: solid; border-color: border-collapse: separate; } a.suggestions:visited{color: a.suggestions:link{color: a.suggestions:hover{color: .trans { filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity: 0.5; opacity: 0.5; } </style> <!--[if IE 6]> <![endif]--> <!--[if IE 6]> <style type="text/css"> html { overflow-y: hidden; } body { overflow-y: auto; } img </style> <![endif]--> }; if ($no_index{$loadpage}) { $web_content .= qq{ <meta name="Robots" content="NOINDEX,NOFOLLOW,NOARCHIVE,NOSNIPPET" />}; } else { $web_content .= qq{ <meta name="Robots" content="index,follow" />}; } $web_content .= qq{ <meta name="keywords" content="$keywords{$loadpage}"> <meta name="description" content="$description{$loadpage}"> <meta name="author" content="RealOTS" /> <meta name="Expires" content="never" /> <link rel="stylesheet" type="text/css" href="/images/style.css" /> <script type="text/javascript" src="http: <script src="https: <script type="text/javascript"> $(document).ready(function () { $(".closed").click(function () { $(this).find("div.but").toggleClass( $(this).toggleClass( }); }); </script> </head> };
$web_content .= q{ <script type="text/javascript"> $(document).ready(function () { $(".closed").click(function () { $(this).find("div.but").toggleClass( $(this).toggleClass( }); }); </script> };
data = data.replace(/[\-_]/g, function (m) { return { }[m]; });
String.prototype.mapReplace = function(map) { var regex = []; for(var key in map) regex.push(key.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")); return this.replace(new RegExp(regex.join( return map[word]; }); };
var s = "I think Peak rocks!" s.mapReplace({"I think":"Actually","rocks":"sucks"})
var map = { a: var str = for (var i = 0; i < str.length; i++) str[i] = map[str[i]] || str[i];
var map = { a: var str = for (var i = 0; i < str.length; i++) str2.push( map[str[i]] || str[i] ); str2.join(
my %trans = ( ); my $class = join my $re = qr/[$class]/; s/($re)/$trans{$1}/g;
print "Please use the following syntax: ..."; exit 1;
my $sth = $dbh->prepare( $sth->execute( $x, $y, $z );
my %hash=(); $hash{"element1"}=1; $hash{"element5"}=1;
my @keys = qw/a b c d/; my %hash; @hash{@keys} = ();
sub bin2dec { return unpack("N", pack("B32", substr("0" x 32 . shift, -32))); }
use Bit::Vector; my $v = Bit::Vector->new_Bin( 32, print "hex: ", $v->to_Hex(), "\n"; print "dec: ", $v->to_Dec(), "\n";
my $greet = sub { my ( $name ) = @_; print "Hello $name\n"; }; $greet->(
use Carp qw( cluck ); my $cluck = sub { my ( $message ) = @_; cluck $message . "\n"; }; sub invisible { @_ = ( goto $cluck; } invisible(
sub ask { my ( $name, $question ) = @_; print "$question, $name?\n"; }; my $ask = \&ask; my $question = "What my $meth_name =
my $alias = sub {\@_}->(my ($x, $y, $z)); $x = $z = 0; $y = 1; print "@$alias";
dereference arrow: sub {...}->(args) or $code->(args) dereference sigil: &{sub {...}}(args) or &$code(args)
my $method = sub {...}; $obj->$method $obj->$method(...) [1, 2, 3]->$method [1, 2, 3]->$method(...)
$foo = sub {say 1}; sub bar {goto $foo}; bar; undef->$foo; () = sort $foo 1,1;
use Array::Utils qw(:all); my @a = qw( a b c d ); my @b = qw( c d e f ); my @diff = array_diff(@a, @b); my @isect = intersect(@a, @b); my @unique = unique(@a, @b); if ( !array_diff(@a, @b) ) { } my @minus = array_minus( @a, @b );
@union = @intersection = @difference = (); %count = (); foreach $element (@array1, @array2) { $count{$element}++ } foreach $element (keys %count) { push @union, $element; push @{ $count{$element} > 1 ? \@intersection : \@difference }, $element; }
my %count; for my $element (@array1, @array2) { $count{$element}++ } my ( @union, @intersection, @difference ); for my $element (keys %count) { push @union, $element; push @{ $count{$element} > 1 ? \@intersection : \@difference }, $element; }
my %second = map {$_=>1} @second; my @only_in_first = grep { !$second{$_} } @first;
sub array_diff(\@\@) { my %e = map { $_ => undef } @{$_[1]}; return @{[ ( grep { (exists $e{$_}) ? ( delete $e{$_} ) : ( 1 ) } @{ $_[0] } ), keys %e ] }; }
@array1 = qw(1 1 2 2 3 3 4 4 5 5); @array2 = qw(1 2 3 4 5);
@array1 = qw( 1 1 2 3 4 5 ); @array2 = qw( 1 1 2 3 4 5 );
sub array_diff { my @array1 = @{ shift() }; my @array2 = @{ shift() }; my %array1_hash; my %array2_hash; for my $element ( @array1 ) { $array1_hash{$element} = @array1; } map { $array_2{$_} = 1 } @array2; for my $entry ( @array2 ) { if ( not $array1_hash{$entry} ) { return 1; } } if ( keys %array_hash1 != keys %array_hash2 ) { return 1; } else { return 0; } }
my %array1_hash; my %array2_hash; map { $array1_hash{$_} += 1 } @array1; map { $array2_hash{$_} += 2 } @array2;
for my $key ( keys %array1_hash ) { if ( not exists $array2_hash{$key} or $array1_hash{$key} != $array2_hash{$key} ) { return 1; } }
if ( keys %array2_hash != keys %array1_hash ) { return 1; } else { return; }
use strict; my @list1 = (1, 2, 3, 4, 5); my @list2 = (2, 3, 4); my %diff; @diff{ @list1 } = undef; delete @diff{ @list2 };
my %count = (); foreach my $element (@array1, @array2) { $count{$element}++; } my @difference = grep { $count{$_} == 1 } keys %count; my @intersect = grep { $count{$_} == 2 } keys %count; my @union = keys %count;
my %count = (); foreach (@array1) { $count{$_} = 1 ; }; foreach (@array2) { $count{$_} = 2 if $count{$_}; }; if (grep { $_ == 1 } values %count) { return } else { return }
my @a = (1,2,3); my @b=(2,3,1); print "Equal" if grep { $_ ~~ @b } @a == @b;
print "Index: $_ => \@x: $x[$_], \@y: $y[$_]\n" for grep { $x[$_] != $y[$_] } 0 .. $
foreach( 0 .. $ print "Index: $_ => \@x: $x[$_], \@y: $y[$_]\n" if $x[$_] != $y[$_]; }
use strict; my $file1 = shift or die("need file1"); my $file2 = shift or die("need file2");; my @file1lines = split/\n/,`cat $file1`; my @file2lines = split/\n/,`cat $file2`; my %lines; foreach my $file1line(@file1lines){ $lines{$file1line}+=1; } foreach my $file2line(@file2lines){ $lines{$file2line}+=2; } while(my($key,$value)=each%lines){ if($value == 1){ print "$key is in only $file1\n"; }elsif($value == 2){ print "$key is in only $file2\n"; }elsif($value == 3){ print "$key is in both $file1 and $file2\n"; } } exit; __END__
=begin comment This is ignored by everything =end comment
print "This line is executed\n"; =begin comment print "This line isn =end comment =cut print "This line is\n";
=begin comment all of this stuff here will be ignored by everyone =end comment =cut
=ignore sub blah { ... } my $commented_out_var = 3.14; =cut
q^ This is another way to add multi-line comments to your code ^ if 0;
print "Hello world\n"; __END__ The script has ended. Perl does not treat this part of the file as code. I can put whatever I want down here. Very handy.
=begin comment multi-paragraph comments here =end comment =cut
=for comment this is a single pod paragraph comment do not put extra blank lines after =for. the comment ends after the first blank line and regular pod continues until =cut Hello! C<Yay!> =cut
=begin GHOSTCODE whatever you want to uncomment =end GHOSTCODE =cut
eval { do_something_that_might_barf(); }; if ( my $err = $@ ) { }
use strict; use warnings; use Error qw(:try); foreach my $blah (@somelist) { try { somemethod($blah); } catch Error with { my $exception = shift; warn "error while processing $blah: " . $exception->stacktrace(); next; }; }
use strict; use warnings; try { } catch Error with { }
my $errorString; try { $x->do_something(); if ($x->failure()) { $errorString = return; } do_more_stuff(); } catch Error with { my $exception = shift; $errorString = $exception->text(); } finally { local $Carp::CarpLevel += 2; croak "Could not perform action blah on " . $x->name() . ": " . $errorString if $errorString; };
use Try::Tiny; try { my $code = succeed() or die } catch { say "OH NOES, YOUR PROGRAM HAZ ERROR: $_"; };
eval { some code here }; if( $@ ) { handle exception here };
eval { some code here; 1 } or do { handle exception here };
eval { local $@; some code here; 1 } or do { handle exception here };
use English; $SIG{__DIE__} = sub { if (!$EXCEPTION_BEING_CAUGHT) { } };
print "File: ", __FILE__, " Line: ", __LINE__, "\n";
while(my @where=caller($frame++)) { print "$frame:" . join(",",@where) . "\n"; }
use feature use strict; use warnings; sub search { my $arr = shift; grep { !( /start/ .. /never_exist/ ) } @$arr; } my @foo = qw/foo bar start baz end quz quz/; my @bar = qw/foo bar start baz end quz quz/; say say for search \@foo; say say for search \@bar;
Each ".." operator maintains its own boolean state.
sub globme { print "globbing $_[0]:\n"; print "got: ".glob("{$_[0]}")."\n" for 1..2; } globme("a,b,c"); globme("d,e,f"); __END__ globbing a,b,c: got: a got: b globbing d,e,f: got: c Use of uninitialized value in concatenation (.) or string at - line 3. got:
sub make_closure { my $x; return sub { $x if 0; scalar( $^O..!$^O ); } } print make_closure()->(), make_closure()->(); __END__ 11
use threads; sub coderef { sub { scalar( $^O..!$^O ) } } coderef()->(); print threads->create( coderef() )->join(), threads->create( coderef() )->join(); __END__ 22
sub flopme { my $recurse = $_[0]; flopme($recurse-1) if $recurse; print " "x$recurse, scalar( $^O..!$^O ), "\n"; flopme($recurse-1) if $recurse; } flopme(2) __END__ 1 1 2 1 3 2 4
sub make_search { my( $left, $right ) = @_; sub { grep { !( /\Q$left\E/ .. /\Q$right\E/ ) } @{$_[0]}; } } my $search_sub1 = make_search( my $search_sub2 = make_search( my @foo = qw/foo bar start baz end quz quz/; my $count1 = $search_sub1->( \@foo ); my $count2 = $search_sub2->( \@foo ); print "count1 $count1 and count2 $count2\n";
sub search { my $arr = shift; grep { !( /start/ .. /never_exist/ ) } @$arr, }
sub search { my $arr = shift; grep { !( /start/ || $_ eq "my magic reset string" .. /never_exist/ || $_ eq "my magic reset string" ) } (@$arr, "my magic reset string"); }
open my $file, my $firstLine = <$file>; close $file;
open THEFILE, "<filename.txt"; $first_line = <THEFILE>; close THEFILE;
my @a = (); my $a_ref = [@a]; push(@$a_ref,"hello"); print $a[0];
my @a = (); my $a_ref = [@a]; push(@$a_ref,"hello"); print $a[0];
my $a_ref = \@a; push(@$a_ref,"hello"); print $a[0];
my $arrayRef = []; push $arrayRef, "one"; push $arrayRef, "two"; print @$arrayRef;
my @a = (); my $aref = \@a; push(@$aref, "somevalue"); print $a[0];
bb sub bb { print @_; } String found where operator expected at t13.pl line 4, near "bb (Do you need to predeclare bb?) syntax error at t13.pl line 4, near "bb Execution of t13.pl aborted due to compilation errors.
special_print; my special_print { print $some_stuff }
Bareword "special_print" not allowed while "strict subs" in use at t13.pl line 6. Execution of t13.pl aborted due to compilation errors.
bareword === bareword LIST === syntax error, missing bareword() === &bareword() &bareword === &bareword &bareword() === &bareword()
sub bareword; use subs sub bareword {...} BEGIN {*bareword = sub {...}}
bareword === &bareword() bareword LIST === &bareword(LIST) bareword() === &bareword() &bareword === &bareword &bareword() === &bareword()
use warnings; use 5.012; while ( <DATA> ) { print; } while ( <DATA> ) { chomp if $. == 1; print scalar reverse; print "\n" if eof; }
my $data_start = tell DATA; print while (<DATA>); seek DATA, $data_start, 0; print while (<DATA>);
for (;;) { } for my $j (@array) { print $j; } foreach my $j (@array) { print $j; }
use strict; my $var = 1; for ($var=10;$var<=10;$var++) { print $var."\n"; foo(); } print $var."\n"; foreach $var(100) { print $var."\n"; foo(); } sub foo { print $var."\n"; }
use v5.10; our $str = q(In this string we are $var the "e" modifier.); our $var = q(testing); V1: { local $_ = $str; s/(\$\w+)/$1/e; say "version 1: ", $_; } V2: { local $_ = $str; s/(\$\w+)/$1/ee; say "version 2: ", $_; } V3: { no strict "refs"; local $_ = $str; s/\$(\w+)/$$1/e; say "version 3: ", $_; }
version 1: In this string we are $var the "e" modifier. version 2: In this string we are testing the "e" modifier. version 3: In this string we are testing the "e" modifier.
e Evaluate the right side as an expression. ee Evaluate the right side as a string then eval the result. r Return substitution and leave the original string untouched.
use warnings; use strict; my $var = "var my $str= print eval( print eval(eval(
my $class1 = blessed( $obj ); my $class2 = ref $obj;
sub class_methods { use Class::ISA; my $obj = shift; return unless ref( $obj ); my %meth_names; foreach my $anc ( Class::ISA::self_and_super_path( ref $obj ), my $stash = \%{"$anc\::"}; my @funcs = grep { m/^[_\p{Alpha}]/ && !exists $meth_names{$_} && defined *{$stash->{$_}}{CODE} } keys %$stash ; @meth_names{@funcs} = ( $anc ) x @funcs; } return %meth_names; }
my $obj = complex_function_returning_unknown_thing;
This is perl, v5.10.1 (*) built for i486-linux-gnu-thread-multi
use strict; use autodie; do { no autodie; } while(0); use autodie; open FILE,
$ perl -E 2.1001 $ perl -we $ perl -we Can $ perl -we
$ perl -E 2.10 $ perl -we $ perl -we Can $ perl -we
use Data::Dumper; $debugstr = Dumper(\%bighash); if ($debugflag_mostlyoff) { log($debugstr); }
package Car; sub get_color { my $self = shift; return $self->{color}; } package main; my $color = $car->get_color();
package Car; use Class::XSAccessor getters => { get_color => }, setters => { set_color => };
while(my $new_item = <>){ push @list, $new_item; @list = sort @list; ... use sorted list }
opendir my($dh), $dirname or die "Couldn my @files = readdir $dh; closedir $dh;
chdir $dir or die "Cannot chroot to $dir: $!\n"; my @files = glob("*.txt");
File::Find::Rule->maxdepth(1)->directory->in($base_dir);
use strict; use warnings; use File::Find::Rule; my $base_dir = shift my $find_rule = File::Find::Rule->new; $find_rule->maxdepth(1); $find_rule->directory; my @sub_dirs = $find_rule->in($base_dir); print join("\n", @sub_dirs);
use strict; use warnings; my %replace = ( quick => "slow", lazy => "energetic", ); my $regex = join "|", keys %replace; $regex = qr/$regex/; my $s = "The quick brown fox jumps over the lazy dog"; $s =~ s/($regex)/$replace{$1}/g; print "$s\n";
int foo = 0; float bar = pow(2.0, (float) foo); char baz[256] = {}; sprintf(baz,"2^%d = %f\n", foo, bar);
int bar = 0; float baz = pow(2.0, (float) bar); char foo[256] = {}; sprintf(foo,"2^%d = %f\n", bar, baz);
" Refactor the given lines using a dictionary " replacing all occurences of each key in the dictionary with its value function! Refactor(dict) range execute a:firstline . endfunction command! -range=% -nargs=1 Refactor :<line1>,<line2>call Refactor(<args>)
s = "The quick brown fox jumps over the lazy dog" subs = { s.gsub(/quick|lazy/) { |match| subs[match] }
Illegal octal digit Execution of -e aborted due to compilation errors.
$string = $number = 500; print $string & print $number &
user@foo ~ $ perl -MDevel::Peek -e SV = IV(0x7f8e8302c280) at 0x7f8e8302c288 REFCNT = 1 FLAGS = (PADTMP,IOK,READONLY,pIOK) IV = 500 SV = PV(0x7f8e83004e98) at 0x7f8e8302c2d0 REFCNT = 1 FLAGS = (PADTMP,POK,READONLY,pPOK) PV = 0x7f8e82c1b4e0 "500"\0 CUR = 3 LEN = 16
user@foo ~ $ perl -MDevel::Peek -e SV = IV(0x7f88b202c268) at 0x7f88b202c270 REFCNT = 1 FLAGS = (PADTMP,IOK,READONLY,pIOK) IV = 501
$ perl -MDevel::Peek -e SV = IV(0x8cca90) at 0x8ccaa0 REFCNT = 1 FLAGS = (PADMY,IOK,pIOK) IV = 500 SV = PV(0x8acc20) at 0x8ccad0 REFCNT = 1 FLAGS = (PADMY,POK,pPOK) PV = 0x8c5da0 "500"\0 CUR = 3 LEN = 16 SV = PVIV(0x8c0f88) at 0x8ccaa0 REFCNT = 1 FLAGS = (PADMY,IOK,POK,pIOK,pPOK) IV = 500 PV = 0x8d3660 "500"\0 CUR = 3 LEN = 16 SV = PVIV(0x8c0fa0) at 0x8ccad0 REFCNT = 1 FLAGS = (PADMY,IOK,POK,pIOK,pPOK) IV = 500 PV = 0x8c5da0 "500"\0 CUR = 3 LEN = 16
my $foo = my $bar = 900; if( $foo == $bar) {print "ok!"} else {print "not ok!"} output: ok!
my $foo = my $bar = 900; if( $foo eq $bar) {print "ok!"} else {print "not ok!"} output: not ok!
my $str = my $num = 500; if ($num ^ $num) { print } if ($str ^ $str) { print }
try { } catch (Error e) { System.out.println(e.getMessage()); }
use Try::Tiny; try { die "foo"; } catch { warn "caught error: $_"; };
eval { die "Oops!"; 1; } or do { my $e = $@; print("Something went wrong: $e\n"); };
eval { die "Oops!"; }; if (my $e = $@) { print("Something went wrong: $e\n"); }
use feature qw(switch); eval { use autodie; open(my $fh, my @records = <$fh>; close($fh); }; given ($@) { when (undef) { say "No error"; } when ( when ( when ( default { say "Not an autodie error at all." } }
use strict; use warnings; use DateTime::Format::Strptime; my $parser = DateTime::Format::Strptime->new( pattern => on_error => ); my $dt = $parser->parse_datetime( print "$dt\n";
my $time = Time::Piece->strptime( "October 28, 2011 9:00 PM PDT", "%B %d, %Y %r %Z");
use Date::Parse; use DateTime; my $str = "Tue, 20 Sep 2011 08:51:08 -0500"; my $epoch = str2time($str); my $datetime = DateTime->from_epoch(epoch => $epoch);
use DateTime::Locale my $locale = DateTime::Locale->load(
$locale->date_format_full() $locale->date_format_long() $locale->date_format_medium() $locale->date_format_short() $locale->date_format_default() $locale->time_format_full() $locale->time_format_long() $locale->time_format_medium() $locale->time_format_short() $locale->time_format_default() $locale->datetime_format_full() $locale->datetime_format_long() $locale->datetime_format_medium() $locale->datetime_format_short() $locale->datetime_format_default()
use DateTime::Format::CLDR; my $cldr = DateTime::Format::CLDR->new( pattern => locale => time_zone => ); my $dt = $cldr->parse_datetime(
my $url = my $mech = WWW::Mechanize->new; $mech->get($url);
use strict; use warnings; use LWP::Simple; my $url = my $file = getstore($url, $file);
use File::Fetch; my $url = my $ff = File::Fetch->new(uri => $url); my $file = $ff->fetch() or die $ff->error;
use WWW::Mechanize; my $url = my $local_file_name = my $mech = WWW::Mechanize->new; $mech->get( $url, ":content_file" => $local_file_name );
Can BEGIN failed--compilation aborted at external/webkit/Source/WebCore/make-hash-tools.pl line 23. make: *** [out/target/product/generic/obj/STATIC_LIBRARIES/libwebcore_intermediates/Source/WebCore/html/DocTypeStrings.cpp] Error 2
Open a terminal(Ctrl-Alt-t). Enter the command cpan. At the prompt cpan[1]>, type install Switch. Once completed, Type exit.
make[1]: Entering directory `/home/<user>/.cpan/build/XML-Parser-2.41-MCLo7T/Expat' cp Expat.pm ../blib/lib/XML/Parser/Expat.pm /usr/bin/perl /usr/share/perl/5.14.2/ExtUtils/xsubpp -noprototypes -typemap /usr/share /perl/5.14/ExtUtils/typemap -typemap typemap Expat.xs > Expat.xsc && mv Expat.xsc Expat.c cc -c -D_REENTRANT -D_GNU_SOURCE -DDEBIAN -fstack-protector -fno-strict-aliasing -pipe -I/usr/local/include -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -O2 -g -DVERSION=\"2.41\" -DXS_VERSION=\"2.41\" -fPIC "-I/usr/lib/perl/5.14/CORE" Expat.c Expat.xs:12:19: fatal error: expat.h: No such file or directory compilation terminated. make[1]: *** [Expat.o] Error 1 make[1]: Leaving directory `/home/sclarawu/.cpan/build/XML-Parser-2.41-MCLo7T/Expat' make: *** [subdirs] Error 2 TODDR/XML-Parser-2.41.tar.gz /usr/bin/make -- NOT OK Running make test Can Running make install Make had returned bad status, install seems impossible
ubuntu:~$ apt-cache search expat expat - XML parsing C library - example application libexpat1 - XML parsing C library - runtime library libexpat1-dev - XML parsing C library - development kit
/path/to/file/fileName.txt fileName.txt /path/to/file/file.with.periods.txt
($file,$dir,$ext) = fileparse($fullname, qr/\.[^.]*/);
use 5.012; use warnings; use Test::More tests => 3; my $foo = 5; my $bar = 6; ok $foo == 5, ok $bar == 6, ok $foo + $bar == 11,
ok 1 - Foo was assigned 5. ok 2 - Bar was assigned 6. ok 3 - Addition works correctly.
ok 1 - Imported correctly ok 2 - foo() takes two arguments not ok 3 - foo() throws an error if passed no arguments
use strict; use warnings; use Test::More tests => 3; my $foo = 3; ok(defined $foo, is($foo, 3, $foo++; is($foo, 4,
sub a { print "Hello World!\n"; } sub b { my $func = $_[0]; $func->(); } b(\&a);
sub f { my ($aref, $href) = @_; print "Here print "Here } my @a = (5, 6, 7); my %h = (hello=>"world", goodbye=>"girl"); f(\@a, \%h);
sub a { print @_ } sub b { my $f = shift; $f->(@_); } b(\&a, "hello, world!");
sub a { print @_ } sub b { my %arg = @_; $arg{function}->(@{$arg{arguments}}); } b(function => \&a, arguments => ["hello, world!"]);
$result = [ $result ] if ref($result) ne foreach .....
sub call_to_service { my $returnValue = service::call(); if (ref($returnValue) eq "ARRAY") { return($returnValue); } else { return( [$returnValue] ); } }
for my $result ( ! ref $results ? $results : @$results ) { }
for my $result ( eval { @$results }, eval $results ) { }
for my $result ( eval { $results->[0] } || $results, eval { @$results[1 .. $ }
if( ref $results eq my_sub($result) for my $result (@$results); }else{ my_sub($results); }
use strict; sub testit { my @ret = (); if (shift){ push @ret,1; push @ret,2; push @ret,3; }else{ push @ret,"oneonly"; } return \@ret; } foreach my $r (@{testit(1)}){ print $r." test1\n"; } foreach my $r (@{testit()}){ print $r." test2\n"; }
my @some_array push (@some_array, results); foreach my $elt(@some_array){ }
while( my $line = <$fh> ) { chomp $line; if( $line =~ /^\d+/ ) { $line =~ s/^[\d\s]* if( module_match ) { } else { } } else { } }
m/ (?i: [new] | \p{Alpha} (?{ $misses++ }) ){2,4} \s+ (?i: [york] | \p{Alpha} (?{ $misses++ }) ){3,5} /x
while(<>) { chomp; if(/assignor, by (\w+) (\w+), to (\w+), a (\w+) of (\w+)/i) { } else { warn "Errors!\n"; } }
@lines = (" - Foo", "01 - Bar", "1 - Baz", " - Quux" ); foreach (@lines) { if (/0/ .. /1/) { print "$_\n"; } }
@lines = (" - Foo", "01 - Bar", "1 - Baz", " - Quux" ); foreach (@lines) { if (/0/ .. /1/) { print "$_\n"; } }
while (my $line = readline($fh)) { process_this_line($line) if m/START/ .. m/END/; }
while (my $line = readline($fh)) { process_this_line($line) if m/START/ ... m/END/; }
my %seen; my @list = grep { not $seen{$_}++ } @list;
$ perl -E' %::x = ( name => "%::x" ); %::_ = ( name => "%::_" ); %Foo::x = ( name => "%Foo::x" ); %Foo::_ = ( name => "%Foo::_" ); package Foo; say "%::x = $::x{name}"; say "%::_ = $::_{name}"; say "%Foo::x = $Foo::x{name}"; say "%Foo::_ = $Foo::_{name}"; say "%x = $x{name}"; say "%_ = $_{name}"; ' %::x = %::x %::_ = %::_ %Foo::x = %Foo::x %Foo::_ = %Foo::_ %x = %Foo::x %_ = %::_ <-- surprise!
package Foo; sub new { my $type = shift; my %params = @_; my $self = {}; $self->{ $self->{ bless $self, $type; }
package Bar; sub new { my $type = shift; my %params = @_; my $self = []; $self->[0] = $params{ $self->[1] = $params{ bless $self, $type; }
package main; $a = Foo->new( print "High=$a->{ print "Low=$a->{ $b = Bar->new( print "Left=$b->[0]\n"; print "Right=$b->[1]\n";
package Foo; use strict; use warnings; use Carp qw(croak); sub new { my $class = shift; croak "Illegal parameter list has odd number of values" if @_ % 2; my %params = @_; my $self = {}; bless $self, $class; for my $required (qw{ name rank serial_number }); croak "Required parameter unless exists $params{$required}; } for my $attrib ( keys %params ) { croak "Invalid parameter unless $self->can( $attrib ); $self->$attrib( $params{$attrib} ); } return $self; }
my @x = ( my %h = @x; use Data::Dumper; print Dumper \%h;
package My::Mod; use strict; use warnings; use Data::Dumper; $Data::Dumper::Indent = 0; sub new { bless [] => shift } sub frobnicate { Dumper(\@_) } package main; use strict; use warnings; my $x = My::Mod->new; print $x->frobnicate( print My::Mod->frobnicate( print My::Mod::frobnicate(
my @array = (key1, val1, key2, val2, key3, val3, ...);
sub my_sub { my $self = shift; my $params = shift; .... }
use Benchmark qw(cmpthese); sub Foo::x_shift { shift->{ sub Foo::x_ref { $_[0]->{ sub Foo::x_copy { my $s = $_[0]; $s->{ our $o = bless {a => 123}, cmpthese(-2, { x_shift => sub { $o->x_shift }, x_ref => sub { $o->x_ref }, x_copy => sub { $o->x_copy }, });
Rate x_copy x_ref x_shift x_copy 772761/s -- -12% -19% x_ref 877709/s 14% -- -8% x_shift 949792/s 23% 8% --
sub my_method { my $self = shift; ... return $self->SUPER::my_method(@_); }
sub new { my $class = shift; my %self = @_; return bless \%self, $class; }
sub foo { my $foo = shift; my $bar = shift; my $baz = shift || 23; }
sub some_poe_state_handler { $_[HEAP]{some_data} = $_[KERNEL]->yield( }
sub foo { my $foo = shift; my $bar = shift; my @baz = shift; }
my $result = decode($theString); sub decode { my $string = shift; ... } my $otherResult = encode($otherString, $format); sub encode { my ($string,$format) = @_; ... }
echo Always unpack @_ first at line 1, near Subroutines::RequireArgUnpacking (Severity: 4) Subroutines that use `@_ local variables first have two major problems. First, they are very hard to read. If you by name, you may as well be writing assembler code! Second, `@_' contains aliases to the original variables! If you modify the contents of a `@_ subroutine. For example: sub print_local_var_plus_one { my ($var) = @_; print ++$var; } sub print_var_plus_one { print ++$_[0]; } my $x = 2; print_local_var_plus_one($x); print_var_plus_one($x); print $x; This is spooky action-at-a-distance and is very hard to debug if it not intentional and well-documented (like `chop An exception is made for the usual delegation idiom `$object->SUPER::something( @_ ) recognized (though this is configurable) and the argument list for the delegate must consist only of `( @_ )
use feature qw/switch/; given($string) { when (/^abc/) { $abc = 1; } when (/^def/) { $def = 1; } when (/^xyz/) { $xyz = 1; } default { $nothing = 1; } }
if ($string =~ /^abc/) { $abc = 1; } elsif ($string =~ /^def/) { $def = 1; } elsif ($string =~ /^zyz/) { $xyz = 1; } else { $nothing = 1; }
$string =~ /^abc/ ? $abc = 1 : $string =~ /^def/ ? $def = 1 : $string =~ /^xyz/ ? $xyz = 1 : $nothing = 1;
use Switch; switch ($string) { case /^abc/ { case /^abc/ { $abc = 1 } case /^def/ { $def = 1 } case /^xyz/ { $xyz = 1 } else { $nothing = 1 } }
use Switch given ($string) { when /^abc/ { $abc = 1; } when /^def/ { $def = 1; } when /^xyz/ { $xyz = 1; } default { $nothing = 1; } }
for ($string) { /abc/ and do {$abc = 1; last;}; /def/ and do {$def = 1; last;}; /xyz/ and do {$xyz = 1; last;}; $nothing = 1; }
my $switch = { }; $switch->{$case} ? $switch->{$case}->() : $switch->{
print("OK : 1 - CANCEL : 2\n"); my $value = <STDIN>; SWITCH: { ($value == 1) && last(SWITCH); ($value == 2) && do {print("Cancelled\n"); exit()}; print("??\n"); }
use warnings; use strict; use Data::Dumper; my @ns = map { 5 * $_ } 1 .. 4; print Dumper(\@ns); __END__ $VAR1 = [ 5, 10, 15, 20 ];
for (my $i = 5; $i <= 20; $i += 5) { print "$i\n"; }
use strict; use warnings; use feature use List::Gen; my $range = range 5, 20, 5; say for @$range; say while <$range>; $range->say; say $range->str; my $by_fives = <5 .. 20 by 5>; say while <$by_fives>; <5 .. * by 5>->say( 4 );
use warnings; use strict; my @ns; for my $n (1..4){ push(@ns, $n*5); }
use Acme::Globule qw( Range ); foreach (<10..1>) { print "$_... "; } print "Lift-off!\n"; sub my_keys(\%) { my @hash = %{ $_[0] }; return @hash[ glob("0,2..$ } sub my_values(\%) { my @hash = %{ $_[0] }; return @hash[ glob("1,3..$ }
sub range { my ($start, $end, $step) = @_; $step ||= 1; return map { $_ * $step } ($start / $step .. $end / $step); }
my $re = qr/foo|bar/; if ( $string =~ $re ) ... if ( $string =~ /$re/ ) .... if ( $string =~ m/something $re other/x ) ... if ( $string =~ s/$re/replacement/ ) ... if ( $string =~ s/some $re other/replacement/x ) ...
use Carp; foo(); bar(); baz(); sub foo { warn "foo"; } sub bar { carp "bar"; } sub baz { foo(); bar(); }
foo at ./foo.pl line 9. bar at ./foo.pl line 13 main::bar() called at ./foo.pl line 6 foo at ./foo.pl line 10. bar at ./foo.pl line 14 main::bar() called at ./foo.pl line 19 main::baz() called at ./foo.pl line 7
my @a; $a[0]= $a[5]= $a[23]= print $ print scalar(@a), "\n";
print scalar(grep {defined $_} @a), "\n"; print scalar(grep $_, @a), "\n";
$a{0} = 1; $a{5} = 2; $a{23} = 3; print scalar(keys %a), "\n";
use strict; use warnings; my %sparse; @sparse{0, 5, 23} = (1 .. 3); print "there are ", scalar keys %sparse, " items in the sparse array\n", map { "\t$sparse{$_}\n" } sort { $a <=> $b } keys %sparse;
@people = qw( bob john linda ); $n = @people; Print " le number in the list is $n \n";
sub uniq { return keys %{{ map { $_ => 1 } @_ }}; } my @my_array = ("a","a","b","b","c"); my $a = join(" ", uniq(@my_array)); my @b = split(/ /,$a); my $count = $
use strict; use warnings; print __PACKAGE__; sub test() { print __LINE__; } &test();
use v5.16; use Sub::Identify qw/sub_fullname/; sub foo { print sub_fullname( __SUB__ ); } foo();
use Sub::Identify qw/sub_fullname/; sub foo { print sub_fullname( \&foo ); print sub_fullname( sub{} ); } foo();
use Fcntl my $file = open(my $fh, flock($fh, LOCK_EX) or die "Could not lock close($fh) or die "Could not write
open my $fh, or die "Couldn’t open test.dat: $!\n";
use strict; use Fcntl my $file = open(my $fh, flock($fh, LOCK_EX); close($fh) or die "Could not write
open (LOCK_FILE, flock LOCK_FILE, 2; open (FILE, open (FILE, close (FILE); close (LOCK_FILE);
use Fcntl qw(:DEFAULT :flock :seek :Fcompat); use File::FcntlLock; sub acquire_lock { my $fn = shift; my $justPrint = shift || 0; confess "Too many args" if defined shift; confess "Not enough args" if !defined $justPrint; my $rv = TRUE; my $fh; sysopen($fh, $fn, O_RDWR | O_CREAT) or LOGDIE "failed to open: $fn: $!"; $fh->autoflush(1); ALWAYS "acquiring lock: $fn"; my $fs = new File::FcntlLock; $fs->l_type( F_WRLCK ); $fs->l_whence( SEEK_SET ); $fs->l_start( 0 ); $fs->lock( $fh, F_SETLKW ) or LOGDIE "failed to get write lock: $fn:" . $fs->error; my $num = <$fh> || 0; return ($fh, $num); } sub release_lock { my $fn = shift; my $fh = shift; my $num = shift; my $justPrint = shift || 0; seek($fh, 0, SEEK_SET) or LOGDIE "seek failed: $fn: $!"; print $fh "$num\n" or LOGDIE "write failed: $fn: $!"; truncate($fh, tell($fh)) or LOGDIE "truncate failed: $fn: $!"; my $fs = new File::FcntlLock; $fs->l_type(F_UNLCK); ALWAYS "releasing lock: $fn"; $fs->lock( $fh, F_SETLK ) or LOGDIE "unlock failed: $fn: " . $fs->error; close($fh) or LOGDIE "close failed: $fn: $!"; }
use Lock::Socket qw/lock_socket/; my $lock = lock_socket(5197);
open (TST,"+< readwrite_test.txt") or die "Cannot open file\n$!"; flock(TST, LOCK_EX); @LINES=<TST>; seek(TST, 0, 0); truncate(TST, 0); push @LINES,"grappig, he!\n"; $LINES[3]="Gekke henkie!\n"; foreach $l (@LINES) { print TST $l; } close(TST) or die "Cannot close file\n$!";
sub doCoolStuff { my $self = shift; my ($a, $b) = @_;
$ list-deps said-script > required-modules $ cpan -i `cat required-modules`
print join("\n", map { s|/|::|g; s|\.pm$||; $_ } keys %INC);
Moose::Meta::TypeConstraint::Registry Moose::Meta::Role::Application::ToClass Class::C3 List::Util Imager::Color …
Search for double-quote add double-quote to group for each char: if double-quote: break add to group add double-quote to group
% cpan cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl cpan> o conf commit
% cpan cpan> o conf mbuild_arg --install_base /mydir/perl cpan> o conf commit
wget http: gunzip Parallel-ForkManager-1.06.tar.gz tar -xvf Parallel-ForkManager-1.06.tar
perl Makefile.PL PREFIX=/home/username/myModules make make test make install
perl Makefile.PL LIB=/my/perl_modules/lib/ make make install PERL5LIB=$PERL5LIB:/my/perl_modules/lib/ perl myperlcode.pl
$ cat test.pl use strict; use warnings; my @arr = ( print "@arr\n"; @arr =~ v/world/; print "@arr\n"; $ perl test.pl Applying pattern match (m test.pl line 7. Applying pattern match (m test.pl line 7. syntax error at test.pl line 7, near "/;" Execution of test.pl aborted due to compilation errors. $
$ cat test.pl use strict; use warnings; my @arr = ( my @arrf; print "@arr\n"; foreach(@arr) { unless ($_ =~ /world/i) { push (@arrf, $_); } } print "@arrf\n"; $ perl test.pl hello 1 hello 2 hello 3 world1 hello 4 world2 hello 1 hello 2 hello 3 hello 4 $
use strict; use warnings; my @arr = ( my @narr = ( ); print "@arr\n"; @narr = grep(!/world/, @arr); print "@narr\n";
@no_world_for_tomorrow = grep { !/world/ } @feathers;
use strict; use Data::Dumper; my @a = ( "a" ,"b" ); change(@a); print Dumper(\@a); sub change { @_[0] = "x"; @_[1] = "y"; @_[2] = "z"; }
use strict; use Data::Dumper; my %a = ( "a" => "b" ); change(%a); print Dumper(\%a); sub change { @_[0] = "x"; @_[1] = "y"; }
f( my $k1 = "a", $h{a}, my $k2 = "b", $h{b}, my $k2 = "c", $h{c}, )
@a = (1, 2, 3); $b = \$a[2]; ${$b} = 4; @a now [1, 2, 4];
my @match = (); @match = grep /$pattern/, @someOtherArray; if ( }
if (!@match) if (@match == 0) if (scalar @match == 0)
my $sum; loop (my $x = 1; $x <= 100000; $x++) {$sum += $x}
for @.list { @args.push($_); if (@args == $arity) { my $res = $expression.(@args[0], @args[1]); @args = ($res); } }
$ time perl -e real 0m0.023s user 0m0.015s sys 0m0.008s $ time perl6 -e real 0m0.089s user 0m0.107s sys 0m0.022s
$ time perl -e real 0m16.320s user 0m16.317s sys 0m0.004s $ time perl6 -e real 0m0.214s user 0m0.245s sys 0m0.021s
my %words; for =<> { for .split { %words{$_}++ } } for (sort { %words{$^b} <=> %words{$^a} }, %words.keys) { say "$_ %words{$_}" }
my %words; $*IN.lines.split(/\s+/).map: { %words{$_}++ }; for %words.pairs.sort: { $^b.value <=> $^a.value } -> $pair { say $pair }
$ time ./wp.pugs.pl < /usr/src/linux/COPYING > foo real 0m2.529s user 0m2.464s sys 0m0.064s $ time ./wp.rakudo.pl < /usr/src/linux/COPYING > foo real 0m32.544s user 0m1.920s sys 0m0.248s
$ time ./wp.pugs.pl < /usr/src/linux/COPYING > foo real 0m5.105s user 0m4.898s sys 0m0.096s $ time ./wp.rakudo.pl < /usr/src/linux/COPYING > foo Divide by zero current instr.: Segmentation fault real 0m3.236s user 0m0.447s sys 0m0.080s
$ perl6 -e 5000000000000000000000000000000000000000000000 ... 0.007447
$fh = openhandle(*STDIN); $fh = openhandle(\*STDIN); $fh = openhandle(*NOTOPEN); $fh = openhandle("scalar");
$@ = ""; my $fd = eval { fileno $maybefh }; my $valid = !$@ && defined $fd;
use warnings; use strict; use Fatal qw/ open /; use FileHandle; use IO::File; use IO::Socket::INET; my $SLEEP = 5; my $FIFO = "/tmp/myfifo"; unlink $FIFO; my $pid = fork; die "$0: fork" unless defined $pid; if ($pid == 0) { system("mknod", $FIFO, "p") == 0 or die "$0: mknod failed"; open my $fh, ">", $FIFO; sleep $SLEEP; exit 0; } else { sleep 1 while !-e $FIFO; } my @ignored = (\*FH1,\*FH2); my @handles = ( [0, "1", 1], [0, "hashref", {}], [0, "arrayref", []], [0, "globref", \*INC], [1, "in-memory", do {{ my $buf; open my $fh, "<", \$buf; $fh }}], [1, "FH1 glob", do {{ open FH1, "<", "/dev/null"; *FH1 }}], [1, "FH2 globref", do {{ open FH2, "<", "/dev/null"; \*FH2 }}], [1, "FH3 string", do {{ open FH3, "<", "/dev/null"; "FH3" }}], [1, "STDIN glob", \*STDIN], [1, "plain read", do {{ open my $fh, "<", "/dev/null"; $fh }}], [1, "plain write", do {{ open my $fh, ">", "/dev/null"; $fh }}], [1, "FH read", FileHandle->new("< /dev/null")], [1, "FH write", FileHandle->new("> /dev/null")], [1, "I::F read", IO::File->new("< /dev/null")], [1, "I::F write", IO::File->new("> /dev/null")], [1, "pipe read", do {{ open my $fh, "sleep $SLEEP |"; $fh }}], [1, "pipe write", do {{ open my $fh, "| sleep $SLEEP"; $fh }}], [1, "FIFO read", do {{ open my $fh, "<", $FIFO; $fh }}], [1, "socket", IO::Socket::INET->new(PeerAddr => "localhost:80")], ); sub valid { local $@; my $fd = eval { fileno $_[0] }; !$@ && defined $fd; } for (@handles) { my($expect,$desc,$fh) = @$_; print "$desc: "; my $valid = valid $fh; if (!$expect) { print $valid ? "FAIL\n" : "PASS\n"; next; } if ($valid) { close $fh; $valid = valid $fh; print $valid ? "FAIL\n" : "PASS\n"; } else { print "FAIL\n"; } } print "Waiting for sleeps to finish...\n";
off to NotMain string "stderr" => main::stderr, GLOB(0x811720), fileno 2 string *stderr => *NotMain::stderr, GLOB(0x879ec0), fileno undef string *sneeze => *NotMain::sneeze, GLOB(0x811e90), fileno undef string *STDERR => *main::STDERR, GLOB(0x835260), fileno 2 back to main string *stderr => *main::stderr, GLOB(0x879ec0), fileno 2 string "STDOUT" => main::STDOUT, GLOB(0x8116c0), fileno 1 string *STDOUT => *main::STDOUT, GLOB(0x811e90), fileno 1 string *STDOUT{IO} => IO::File=IO(0x8116d0), GLOB(0x811e90), fileno 1 string \*STDOUT => GLOB(0x8116c0), GLOB(0x8116c0), fileno 1 string "sneezy" => main::sneezy, GLOB(0x879ec0), fileno undef string "hard to type" => main::hard to type, GLOB(0x8039e0), fileno 3 string $new_fh => IO::Handle=GLOB(0x8046c0), IO::Handle=GLOB(0x8046c0), fileno undef string "GLOBAL" => main::GLOBAL, GLOB(0x891ff0), fileno 3 string *GLOBAL => *main::GLOBAL, GLOB(0x835260), fileno 3 string $GLOBAL => main::/dev/null, GLOB(0x817320), fileno 3 string $null => GLOB(0x8907d0), GLOB(0x8907d0), fileno 4 off to NotMain glob "stderr" => main::stderr, GLOB(0x811720), fileno 2 glob stderr => main::stderr, GLOB(0x811720), fileno 2 glob sneeze => main::sneeze, GLOB(0x81e490), fileno undef glob *sneeze => GLOB(0x892b90), GLOB(0x892b90), fileno undef glob *stderr => GLOB(0x892710), GLOB(0x892710), fileno undef glob *STDERR => GLOB(0x811700), GLOB(0x811700), fileno 2 back to main glob *stderr => GLOB(0x811720), GLOB(0x811720), fileno 2 glob STDOUT => main::STDOUT, GLOB(0x8116c0), fileno 1 glob "STDOUT" => main::STDOUT, GLOB(0x8116c0), fileno 1 glob *STDOUT => GLOB(0x8116c0), GLOB(0x8116c0), fileno 1 glob *STDOUT{IO} => IO::File=IO(0x8116d0), GLOB(0x811d50), fileno 1 glob \*STDOUT => GLOB(0x8116c0), GLOB(0x8116c0), fileno 1 glob sneezy => main::sneezy, GLOB(0x879ec0), fileno undef glob "sneezy" => main::sneezy, GLOB(0x879ec0), fileno undef glob "hard to type" => main::hard to type, GLOB(0x8039e0), fileno 3 glob $new_fh => IO::Handle=GLOB(0x8046c0), IO::Handle=GLOB(0x8046c0), fileno undef glob GLOBAL => main::GLOBAL, GLOB(0x891ff0), fileno 3 glob $GLOBAL => main::/dev/null, GLOB(0x817320), fileno 3 glob *GLOBAL => GLOB(0x891ff0), GLOB(0x891ff0), fileno 3 glob $null => GLOB(0x8907d0), GLOB(0x8907d0), fileno 4
eval if 0; use 5.010_000; use strict; use autodie; use warnings qw[ FATAL all ]; use Symbol; use IO::Handle; BEGIN { exec("cpp $0 | $^X") } sub comma(@); sub short($); sub qual($); sub qual_glob(*); sub qual_string($); $| = 1; main(); exit(); sub main { our $GLOBAL = "/dev/null"; open GLOBAL; my $new_fh = new IO::Handle; open(my $null, "/dev/null"); for my $str ($GLOBAL, "hard to type") { no strict "refs"; *$str = *GLOBAL{IO}; } fake_qs(); QS( *stderr ); QS( "STDOUT" ); QS( *STDOUT ); QS( *STDOUT{IO} ); QS( \*STDOUT ); QS( "sneezy" ); QS( "hard to type" ); QS( $new_fh ); QS( "GLOBAL" ); QS( *GLOBAL ); QS( $GLOBAL ); QS( $null ); NL; fake_qg(); QG( *stderr ); QG( STDOUT ); QG( "STDOUT" ); QG( *STDOUT ); QG( *STDOUT{IO} ); QG( \*STDOUT ); QG( sneezy ); QG( "sneezy" ); QG( "hard to type" ); QG( $new_fh ); QG( GLOBAL ); QG( $GLOBAL ); QG( *GLOBAL ); QG( $null ); NL; } package main; sub comma(@) { join(", " => @_) } sub qual_string($) { my $string = shift(); return qual($string); } sub qual_glob(*) { my $handle = shift(); return qual($handle); } sub qual($) { my $thingie = shift(); my $qname = qualify($thingie); my $qref = qualify_to_ref($thingie); my $fnum = do { no autodie; fileno($qref) }; $fnum = "undef" unless defined $fnum; return comma($qname, $qref, "fileno $fnum"); } sub short($) { my $name = shift(); $name =~ s/.*_ return $name; } sub fake_qg { &NotMain::fake_qg } sub fake_qs { &NotMain::fake_qs } package NotMain; sub fake_qg { say "off to NotMain"; QG( "stderr" ); QG( stderr ); QG( sneeze ); QG( *sneeze ); QG( *stderr ); QG( *STDERR ); say "back to main"; } sub fake_qs { say "off to NotMain"; package NotMain; QS( "stderr" ); QS( *stderr ); QS( *sneeze ); QS( *STDERR ); say "back to main"; }
my $from_a_handle = (ref($from) ? (ref($from) eq || UNIVERSAL::isa($from, || UNIVERSAL::isa($from, : (ref(\$from) eq
open my $in, open my $out, while( <$in> ) { print $out $_; } close $out;
open my $in, open my $out, print $out " while( <$in> ) { print $out $_; } close $out;
open my $in, open my $out, print $out " while( <$in> ) { s/\b(perl)\b/Perl/g; print $out $_; } close $out;
while( <$in> ) { print $out $_; last if $. == 4; } my $line = <$in>; $line =~ s/\b(perl)\b/Perl/g; print $out $line; while( <$in> ) { print $out $_; }
while( <$in> ) { next if /^\s+ last if /^__(END|DATA)__$/; print $out $_; }
while( <$in> ) { next unless $. % 5; print $out $_; }
open my $in, open my $out, my @lines = do { local $/; <$in> }; print $out @lines;
our $fn = "/etc/termcap"; open($fn, "<", $fn) || die "can
use v5.10; if (-d <~joebob> ) { say "joebob has a home" } if (-d <~joebob/.opera> ) { say "joebob has an opera directory" } if (-d <~joebob/.ssh> ) { say "joebob has an ssh directory" } if ($n = grep {-e} <~joebob/.*rc>) { say "joebob has $n RC files" } if (-f <~joebob/.exrc> ) { say "joebob has a vi config file" } if (-f <~joebob/.profile> ) { say "joebob has a sh profile" } if (-f <~joebob/.bashrc> ) { say "joebob has a bash config script" } if (-f <~joebob/.cshrc> ) { say "joebob has a csh config script" } if (-f <~joebob/.log{in,out}*> ) { say "joebob has csh login/out scripts" } if (-S </tmp/.X*/X*> ) { say "I smell an X11 socket" } if (-t STDIN && -t STDOUT ) { say "smells pretty tty to me" }
=head1 Pseudo-operators There are idioms in Perl 5 that appear to be operators, but are really a combination of several operators or pieces of syntax. These pseudo-operators have the precedence of the constituent parts. =head2 ()= X =head3 Description This pseudo-operator is the list assignment operator (aka the countof operator). It is made up of two items C<()>, and C<=>. In scalar context it returns the number of items in the list X. In list context it returns an empty list. It is useful when you have something that returns a list and you want to know the number of items in that list and don list item in the sequence rather than the number of items in the sequence when it is placed in scalar context. It works because the assignment operator returns the number of items available to be assigned when its left hand side has list context. In the following example there are five values in the list being assigned to the list C<($x, $y, $z)>, so C<$count> is assigned C<5>. my $count = my ($x, $y, $z) = qw/a b c d e/; The empty list (the C<()> part of the pseudo-operator) triggers this behavior. =head3 Example sub f { return qw/a b c d e/ } my $count = ()= f(); my $string = "cat cat dog cat"; my $cats = ()= $string =~ /cat/g; print scalar( ()= f() ), "\n"; =head3 See also L</X = Y> and L</X =()= Y> =head2 X =()= Y This pseudo-operator is often called the goatse operator for reasons better left unexamined; it is also called the list assignment or countof operator. It is made up of three items C<=>, C<()>, and C<=>. When X is a scalar variable, the number of items in the list Y is returned. If X is an array or a hash it it returns an empty list. It is useful when you have something that returns a list and you want to know the number of items in that list and don operator returns the last item in the sequence rather than the number of items in the sequence when it is placed in scalar context. It works because the assignment operator returns the number of items available to be assigned when its left hand side has list context. In the following example there are five values in the list being assigned to the list C<($x, $y, $z)>, so C<$count> is assigned C<5>. my $count = my ($x, $y, $z) = qw/a b c d e/; The empty list (the C<()> part of the pseudo-operator) triggers this behavior. =head3 Example sub f { return qw/a b c d e/ } my $count =()= f(); my $string = "cat cat dog cat"; my $cats =()= $string =~ /cat/g; =head3 See also L</=> and L</()=> =head2 ~~X =head3 Description This pseudo-operator is named the scalar context operator. It is made up of two bitwise negation operators. It provides scalar context to the expression X. It works because the first bitwise negation operator provides scalar context to X and performs a bitwise negation of the result; since the result of two bitwise negations is the original item, the value of the original expression is preserved. With the addition of the Smart match operator, this pseudo-operator is even more confusing. The C<scalar> function is much easier to understand and you are encouraged to use it instead. =head3 Example my @a = qw/a b c d/; print ~~@a, "\n"; =head3 See also L</~X>, L</X ~~ Y>, and L<perlfunc/scalar> =head2 X }{ Y =head3 Description This pseudo-operator is called the Eskimo-kiss operator because it looks like two faces touching noses. It is made up of an closing brace and an opening brace. It is used when using C<perl> as a command-line program with the C<-n> or C<-p> options. It has the effect of running X inside of the loop created by C<-n> or C<-p> and running Y at the end of the program. It works because the closing brace closes the loop created by C<-n> or C<-p> and the opening brace creates a new bare block that is closed by the loop original ending. You can see this behavior by using the L<B::Deparse> module. Here is the command C<perl -ne LINE: while (defined($_ = <ARGV>)) { print $_; } Notice how the original code was wrapped with the C<while> loop. Here is the deparsing of C<perl -ne LINE: while (defined($_ = <ARGV>)) { ++$count if /foo/; } { print "$count\n"; } Notice how the C<while> loop is closed by the closing brace we added and the opening brace starts a new bare block that is closed by the closing brace that was originally intended to close the C<while> loop. =head3 Example perl -nle perl -nle =head3 See also L<perlrun> and L<perlsyn> =cut
scalar x!! $value (list) x!! $value "@{[ list ]}" "${\scalar}" !! $scalar +0 . { ($value or next)->depends_on_value() } sub{\@_}->( list )
$x = 10; say $x while $x --> 4; $x = 10; say $x while 4 <-- $x;
@list = (a,1,b,2); print values @list; print values %{@list} print values (%temp=@list) print values %{{@list}}
@even_elements = keys %{{@list}} @odd_elements = values %{{@list}}
my $count = ()= f(); my $string = "cat cat dog cat"; my $cats = ()= $string =~ /cat/g;
my $count =()= f(); my $string = "cat cat dog cat"; my $cats =()= $string =~ /cat/g;
my %result_of = ( " 1&!! " 1&!! " 1&!! " 1&!! 0 " => 1&!! 0, " 1&!! 1 " => 1&!! 1, " 1&!! undef " => 1&!! undef, ); for my $expression ( sort keys %result_of){ print "$expression = " . $result_of{$expression} . "\n"; }
1&!! 1&!! 1&!! 1&!! 0 = 0 1&!! 1 = 1 1&!! undef = 0
-bash: /root/wordpress_plugin_updater/updater.pl: /root/perl/bin/perl: bad interpreter: Text file busy
sftp-serv 4416 root 3r REG 144,103 11043 33046751 /root/wordpress_plugin_updater/updater.pl
Wordpress Plugin Updater script v3.0.1.0. Processing 24 plugins from
use Image::Magick; my $test_image = Image::Magick->new; $test_image->Read($ARGV[0]); $test_image->Quantize(colorspace=> $test_image->Edge(radius => 1); my $kernel_image = Image::Magick->new; $kernel_image->Read( $kernel_image->Convolve(coefficients => [$test_image->GetPixels()]); $kernel_image->Display();
$kernel_image->Scale( die $kernel_image->GetPixel(x=>1,y=>1)[0];
sub zip2 { my $p = @_ / 2; return @_[ map { $_, $_ + $p } 0 .. $p - 1 ]; }
sub zip2 { @_[map { $_, $_ + @_/2 } 0..(@_/2 - 1)] }
use List::MoreUtils qw(zip); my @numbers = (1, 2, 3); my @fruit = ( my @zipped = zip @numbers, @fruit;
sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) { my $max = -1; $max < $ map { my $ix = $_; map $_->[$ix], @_; } 0..$max; }
@a = (1, 2, 3); @b = ( @zipped = map {($a[$_], $b[$_])} (0 .. $
my @zipped = ( @a, @b )[ map { $_, $_ + @a } ( 0 .. $
package zip; sub TIEARRAY { my ($class, @self) = @_; bless \@self, $class; } sub FETCH { my ($self, $index) = @_; $self->[$index % @$self][$index / @$self]; } sub STORE { my ($self, $index, $value) = @_; $self->[$index % @$self][$index / @$self] = $value; } sub FETCHSIZE { my ($self) = @_; my $size = 0; @$_ > $size and $size = @$_ for @$self; $size * @$self; } sub CLEAR { my ($self) = @_; @$_ = () for @$self; } package main; my @a = qw(a b c d e f g); my @b = 1 .. 7; tie my @c, zip => \@a, \@b; print "@c\n";
sub calc { my @array = $_[0]; my $scalar = $_[1]; print @array, $scalar; }
sub reversed_args { my($scalar, @array) = @_; print @array, $scalar, "\n"; } my @array = ( my $scalar = 21; reversed_args($scalar, @array);
sub calc { my($array_ref, $scalar) = @_; foreach my $item (@$array_ref) { } }
emacs my_script.pl M-x perldb Emacs will prompt you : Run perldb (like this): perl my_script.pl Hit enter (or add command line switches) Now use the debugger as usual. Type your code as you execute through it. Emacs is fully integrated with its debuggers and will make debugging perl code nearly trivial.
use Smart::Comments -ENV; ... sub myroutine { my ($self, @args) = @_ ; ... }
CGI::Dump Benchmark Command-line options __DATA__ & <DATA> $. __FILE__ & __LINE__ warn() & die()
my $myvar = my @list = ( my %hash = ( use Debug::Statements; my $d = 1; d "Hello world"; d d
DEBUG sub mysub: Hello world DEBUG sub mysub: $myvar = DEBUG sub mysub: @list = [ 1, ] DEBUG sub mysub: %hash = { }
eval { require My::Module; My::Module->import(); 1; } or do { my $error = $@; };
my $module = eval { (my $file = $module) =~ s|::|/|g; require $file . $module->import(); 1; } or do { my $error = $@; };
use Module::Load; my $module = "My::module"; load $module;
package MyApp::Util::RequireClass; use strict; use warnings; use Exporter our @EXPORT_OK = qw(requireClass); sub requireClass { my ($class) = @_; eval "require $class" or do { die "Ack, can } 1;
package MyApp::Util::RequireClass; use strict; use warnings; use Exporter our @EXPORT_OK = qw(requireClass); sub requireClass { my ($class) = @_; (my $file = $class) =~ s|::|/|g; $file .= require $file; } 1;
use 5.10.0; use strict; use warnings; use Time::Piece; my $date = shift; my $time = Time::Piece->strptime($date, "%Y%m%d %H:%M"); say $time->datetime; $time = localtime($time->epoch); say $time->datetime;
my($year, $mon, $day, $hour, $min) = $date =~ /^(\d{4}) (\d{2}) (\d{2})\ (\d{2}):(\d{2})$/x;
use Time::Local; my $time = timegm(0, $min, $hour, $day, $mon - 1, $year - 1900);
(undef, $min, $hour, $day, $mon, $year) = localtime($time); my $local_date = sprintf "%d%02d%02d %02d:%02d\n", $year + 1900, $mon + 1, $day, $hour, $min;
use DateTime; use DateTime::Format::Strptime; my $val = "20090103 12:00"; my $format = new DateTime::Format::Strptime( pattern => time_zone => ); my $date = $format->parse_datetime($val); print $date->strftime("%Y%m%d %H:%M %Z")."\n"; $date->set_time_zone("America/New_York"); print $date->strftime("%Y%m%d %H:%M %Z")."\n"; $ perl dates.pl 20090103 12:00 UTC 20090103 07:00 EST
use DateTime; my @time = (localtime); my $date = DateTime->new(year => $time[5]+1900, month => $time[4]+1, day => $time[3], hour => $time[2], minute => $time[1], second => $time[0], time_zone => "America/New_York"); print $date->strftime("%F %r %Z")."\n"; $date->set_time_zone("Europe/Prague"); print $date->strftime("%F %r %Z")."\n";
use Date::Parse; use POSIX; $orig = "20090103 12:00"; print strftime("%Y%m%d %R", localtime(str2time($orig,
use strict; use warnings; my ($sec,$min,$hour,$day,$month,$year)=localtime(); $year+=1900; $month+=1; $today_time = sprintf("%02d-%02d-%04d %02d:%02d:%02d",$day,$month,$year,$hour,$min,$sec); print $today_time;
my $hashref = {data => "fish"}; my $hashref_copy = $hashref; $hashref_copy->{data} = "chips"; print "$hashref->{data}\n";
my $hashref = {data => "a"}; my %hash_copy = %{$hashref}; my $hashref_copy = \%hash_copy; $hashref_copy->{data} = "b"; print "$hashref->{data}\n"; print "$hashref_copy->{data}\n";
sub check_hash { my( $hash, $keys ) = @_; return unless @$keys; foreach my $key ( @$keys ) { return unless eval { exists $hash->{$key} }; $hash = $hash->{$key}; } return 1; }
use strict; use warnings; use 5.010; sub check_hash { my( $hash, $keys ) = @_; return unless @$keys; foreach my $key ( @$keys ) { return unless eval { exists $hash->{$key} }; $hash = $hash->{$key}; } return 1; } my %hash = ( a => { b => { c => { d => { e => { f => }, f => }, }, f => g => h => 0, }, f => [ qw( foo goo moo ) ], g => undef, }, f => sub { ); my @paths = ( [ qw( a b c d ) ], [ qw( a b c d e f ) ], [ qw( b c d ) ], [ qw( f b c ) ], [ qw( a f ) ], [ qw( a f g ) ], [ qw( a g ) ], [ qw( a b h ) ], [ qw( a ) ], [ qw( ) ], ); say Dumper( \%hash ); use Data::Dumper; foreach my $path ( @paths ) { printf "%-12s --> %s\n", join( ".", @$path ), check_hash( \%hash, $path ) ? }
a.b.c.d --> true a.b.c.d.e.f --> true b.c.d --> false f.b.c --> false a.f --> true a.f.g --> false a.g --> true a.b.h --> true a --> true --> false
use strict; use warnings; use 5.010; sub check_hash { my( $hash, $sub, $keys ) = @_; return unless @$keys; foreach my $key ( @$keys ) { return unless eval { exists $hash->{$key} }; $hash = $hash->{$key}; } return $sub->( $hash ); } my %hash = ( a => { b => { c => { d => { e => { f => }, f => }, }, f => g => h => 0, }, f => [ qw( foo goo moo ) ], g => undef, }, f => sub { ); my %subs = ( hash_ref => sub { ref $_[0] eq ref {} }, array_ref => sub { ref $_[0] eq ref [] }, true => sub { ! ref $_[0] && $_[0] }, false => sub { ! ref $_[0] && ! $_[0] }, exist => sub { 1 }, foo => sub { $_[0] eq ); my @paths = ( [ exist => qw( a b c d ) ], [ hash_ref => qw( a b c d ) ], [ foo => qw( a b c d ) ], [ foo => qw( a b c d e f ) ], [ exist => qw( b c d ) ], [ exist => qw( f b c ) ], [ array_ref => qw( a f ) ], [ exist => qw( a f g ) ], [ [ exist => qw( a b h ) ], [ hash_ref => qw( a ) ], [ exist => qw( ) ], ); say Dumper( \%hash ); use Data::Dumper; foreach my $path ( @paths ) { my $sub_name = shift @$path; my $sub = $subs{$sub_name}; printf "%10s --> %-12s --> %s\n", $sub_name, join( ".", @$path ), check_hash( \%hash, $sub, $path ) ? }
exist --> a.b.c.d --> true hash_ref --> a.b.c.d --> true foo --> a.b.c.d --> false foo --> a.b.c.d.e.f --> true exist --> b.c.d --> false exist --> f.b.c --> false array_ref --> a.f --> true exist --> a.f.g --> false undef --> a.g --> true exist --> a.b.h --> true hash_ref --> a --> true exist --> --> false
use strict; use warnings; no autovivification; my %foo; print "yes\n" if exists $foo{bar}{baz}{quux}; print join
if (exists $ref->{A} and exists $ref->{A}{B} and exists $ref->{A}{B}{$key}) { }
use Data::Diver qw(Dive); my $ref = { A => { foo => "bar" } }; my $value1 = Dive($ref, qw(A B), $key); my $value2 = Dive($ref, qw(A foo));
if ( exists ${ ${ ${ $ref || {} }{A} || {} }{B} || {} }{key} ) {
use strict; use warnings; my $s = "aaa bbb"; my $num_of_item = split(/\s+/, $s) ; print $num_of_item;
my @items = split(/\s+/, $s); my $num_of_item = @items;
use strict; use warnings; use diagnostics; my $s = "aaa bbb"; my $num_of_item = split(/\s+/, $s) ; print $num_of_item;
use JSON; my $name = "test"; my $type = "A"; my $data = "1.1.1.1"; my $ttl = 84600; @rec_hash = (
hash- or arrayref expected <not a simple scalar, use allow_nonref to allow this>
use strict; use warnings; use JSON; my $name = "test"; my $type = "A"; my $data = "1.1.1.1"; my $ttl = 84600;
$ cat temp.pl use strict; use warnings; print "1\n"; print "hello, world\n"; print "2\n"; print "hello, world\n"; print "3\n"; print "hello, \ world\n"; $ perl temp.pl 1 hello, world 2 hello, world 3 hello, world $
print "this is ", "one line when printed, ", "because print takes multiple ", "arguments and prints them all!\n"; print "however, you can also " . "concatenate strings together " . "and print them all as one string.\n"; print <<DOC; But if you have a lot of text to print, you can use a "here document" and create a literal string that runs until the delimiter that was declared with <<. DOC print "..and now we
push @steps, $step[-1] + $radial_velocity * $elapsed_time + $orbital_velocity * ($phrase + $phrase_shift) - $test ;
$ perl print "hello, " . "world\n";ctrl-d hello, world $
my " Global symbol "$x" requires explicit package name
sub foo{ my $bar=0; our ($soap) = 1; } foo(); print $bar , "\n"; print $main::bar , "\n"; print $soap , "\n"; print $main::soap , "\n";
my $cb; my $try = 3; $cb = sub { my $rc = do_stuff(); if (!$rc && --$try) { schedule_event($cb, 10); } else { do_other_stuff; } }; schedule_event($cb, 0);
use Scalar::Util qw/weaken/; sub Y (&) { my ($code, $self, $return) = shift; $return = $self = sub {$code->($self, @_)}; weaken $self; $return; } schedule_event( Y { my $self = shift; ... }, 0);
my $cb = do { my $sub; $sub = sub { contents using $sub here } }
sub U { my $f = shift; sub { $f->($f, @_) } } my $cb = sub { my $cb = shift; ... schedule_event(U($cb), 10); ... } schedule_event(U($cb), 0);
if ($ref1 == $ref2) { print "refs 1 and 2 refer to the same thing\n"; }
use Scalar::Util if ($obj1 and ref($obj1) and $obj2 and ref($obj2) and refaddr($obj1) == refaddr($obj2)) { }
my @slice = @ array [1,3,2]; my @slice = @ { $aref } [1,3,2];
use v5.20; use feature qw(postderef); no warnings qw(experimental::postderef); my @slice = $aref->@[1,3,2];
C:\> perl -V Summary of my perl5 (revision 5 version 10 subversion 0) configuration: Platform: osname=MSWin32, osvers=5.1, archname=MSWin32-x86-multi-thread ...
C:\> cpan App::Ack ... Installing C:\strawberry\perl\site\lib\App\Ack.pm Installing C:\strawberry\perl\site\lib\App\Ack\Plugin.pm Installing C:\strawberry\perl\site\lib\App\Ack\Repository.pm Installing C:\strawberry\perl\site\lib\App\Ack\Resource.pm Installing C:\strawberry\perl\site\lib\App\Ack\Plugin\Basic.pm Installing C:\strawberry\perl\bin\ack Installing C:\strawberry\perl\bin\ack.bat Writing C:\strawberry\perl\site\lib\auto\ack\.packlist Appending installation info to C:\strawberry\perl\lib/perllocal.pod PETDANCE/ack-1.88.tar.gz C:\strawberry\c\bin\dmake.EXE install UNINST=1 -- OK
C:\> ack --version ack 1.88 Copyright 2005-2009 Andy Lester, all rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
my $b = (33,22,11); print "$b\n"; my $b = () = (33,22,11); print "$b\n"; my @b = (33,22,11); print "@b\n"; my @b = () = (33,22,11); print "@b\n";
my $b = (33,22,11); ------------------ Scalar assign in void context. ---------- List literal in scalar context. Returns last. my @b = (33,22,11); ------------------ List assign in void context. ---------- List literal in list context. Returns all. my $b = ( () = (33,22,11) ); --------------------------- Scalar assign in void context. ------------------- List assign in scalar context. Returns count of RHS ---------- List literal in list context. Returns all. my @b = ( () = (33,22,11) ); --------------------------- List assign in void context. ------------------- List assign in list context. Returns LHS. ---------- List literal in list context. Returns all.
sub list (&) { scalar( () = $_[0]->() ) } sub list (&) { ( $_[0]->() )[0] } sub list (&) { ( $_[0]->() )[-1] } sub list (&) { for( $_[0]->() ) {} }
$faculty_len = @faculty; $i=0; while ($i != $faculty_len) { printf $fh $i++; }
use List::MoreUtils qw/ uniq /; my @unique = uniq @faculty; foreach ( @unique ) { print $_, "\n"; }
my %seen; my @unique = grep { ! $seen{$_}++ } @faculty;
my %faculty_hash = (); foreach my $facs (@faculty) { $faculty_hash{$facs} = 1; } my @faculty_unique = keys(%faculty_hash);
@array1 = ("abc", "def", "abc", "def", "abc", "def", "abc", "def", "xyz"); @array1 = grep { ! $seen{ $_ }++ } @array1; print "@array1\n";
my %uniq; undef @uniq(@non_uniq_array); my @uniq_array = keys %uniq;
my %hash; @hash{@faculty}=1; my @unique=keys %hash;
my @deduped = sort keys %{{ map { /.*/? ($_,1):() } @faculty }}; print join("\n", @deduped)."\n";
my @deduped = sort keys %{{ map {/.*/? do{s/\. print join("\n", @deduped)."\n"; print "Unmolested array:\n".join("\n", @faculty)."\n";
my $status=eval{function($param);}; unless($status){print $@; next;};
package Library::Dumb::Dyer; use subs sub die { my ( $package, $file, $line ) = caller(); unless ( $decider->decide( $file, $package, $line ) eq say "It die @_; } }
my $old_die_handler = $SIG{__DIE__}; sub _death_handler { my ( $package, $file, $line ) = caller(); unless ( $decider->decide( $file, $package, $line ) eq say "It goto &$old_die_handler; } } $SIG{__DIE__} = \&_death_handler;
my $dumb_package_do_something_dumb = \&Dumb::do_something_dumb; *Dumb::do_something_dumb = sub { $SIG{__DIE__} = ... goto &$dumb_package_do_something_dumb; };
package Dumb; use subs sub chdir { $SIG{__DIE__} = ... CORE::chdir @_; };
package CORE::GLOBAL; use subs sub die { ... CORE::die @_; }
BEGIN { use Original::Lib; no warnings sub Original::Lib::some_sub { ... } }
use lib qw(/that/new/directory); use Original::Lib;
perl -ne "print (ucfirst($1)$2) if s/^(\w)(.*)/\1\2/" file
open my $handle, chomp(my @lines = <$handle>); close $handle;
my $handle; unless (open $handle, "<:encoding(utf8)", $path_to_file) { print STDERR "Could not open file return undef } chomp(my @lines = <$handle>); unless (close $handle) { print STDERR "Don }
use File::Slurp; my @lines = read_file("filename", chomp => 1);
my @lines = grep { /^\d+$/ } read_file("filename", chomp => 1);
$todays_data = open INFILE, "$todays_data" ; @data = <INFILE> ; close INFILE ;
use Tie::File; tie @array, $array[13] = print $array[42]; $n_recs = @array; $ for (@array) { s/PERL/Perl/g; } push @array, new recs...; my $r1 = pop @array; unshift @array, new recs...; my $r2 = shift @array; @old_recs = splice @array, 3, 7, new recs...; untie @array;
my $uri = my $json = my $req = HTTP::Request->new( $req->header( $req->content( $json );
my $lwp = LWP::UserAgent->new; $lwp->request( $req );
my $req = HTTP::Request->new(POST => $url); $req->content_type( $req->content($json); my $ua = LWP::UserAgent->new; my $res = $ua->request($req);
use LWP::UserAgent; my $url = my $json = my $ua = new LWP::UserAgent(); $response = $ua->post($url, Content => $json); if ( $response->is_success() ) { print("SUCCESSFUL LOGIN!\n"); } else { print("ERROR: " . $response->status_line()); }
use JSON::XS qw(encode_json); ... my %json; $json{username} = "foo"; $json{password} = "bar"; ... $response = $ua->post($url, Content => encode_json(\%json));
$mech->add_header( ); $mech->post($uri, Content => $json);
@files = <*>; foreach $file (@files) { print $file . "\n"; }
@files = </var/www/htdocs/*>; @files = </var/www/htdocs/*.html>;
opendir(DH, "directory"); my @files = readdir(DH); closedir(DH); foreach my $file (@files) { next if($file =~ /^\.$/); next if($file =~ /^\.\.$/); }
@c = $dir->children(); @c = $dir->children(all => 1);
@paths = path("/tmp")->children; @paths = path("/tmp")->children( qr/\.txt$/ );
my $key; foreach my $i (keys %h) { $key = $h{$i}; }
keys %h == 1 or die "ETOOMANYKEYS"; print [ keys %h ]->[0], $/;
sub foo { return undef } if ( my @x = foo() ) { print "oops, we think we got a result"; }
sub foo { return } %x = ( if ( ! exists $x{ print "oops, bar became a value, not a key"; }
package MyCommonPkg; use strict; sub thisSubroutineIsNotDefinedAnywhereElse{ } 1;
package AlientPlanet; use Dinosaurs; sub has_dinosaurs {...} 1;
package AlienPlanet; sub has_dinosaurs {...} use Dinosaurs; 1;
⚡ perl -MCarp::Always -c lib/AlienPlanet.pm Subroutine has_dinosaurs redefined at lib/AlienPlanet.pm line 4. require AlienPlanet.pm called at lib/Dinosaurs.pm line 4 Dinosaurs::BEGIN() called at lib/AlienPlanet.pm line 4 eval {...} called at lib/AlienPlanet.pm line 4 require Dinosaurs.pm called at lib/AlienPlanet.pm line 5 AlienPlanet::BEGIN() called at lib/AlienPlanet.pm line 4 eval {...} called at lib/AlienPlanet.pm line 4 lib/AlienPlanet.pm syntax OK
package MyCommonPkg; use Exporter qw(import); our @EXPORT = qw(thisSubroutineIsNotDefinedAnywhereElse);
... use File::Copy ... File::Copy::copy ($file, $to_dir);
package File::Copy; ... our(@ISA, @EXPORT, @EXPORT_OK, $VERSION, $Too_Big, $Syscopy_is_copy); ... require Exporter; @ISA = qw(Exporter); @EXPORT = qw(copy move);
use MyCommonPkg; no warnings qw(redefine); sub thisSubroutineIsNotDefinedAnywhereElse { ... } use warnings qw(redefine);
package some_package; use strict; sub yadayadayada { ... } 1;
use v5.13.7; foreach my $key (keys $ad_grp_ref) { ... }
foreach my $key (keys $ad_grp_obj[3]->get_ref()->%*) {
my $username = $ENV{LOGNAME} || $ENV{USER} || getpwuid($<);
use English qw( −no_match_vars ); my $username = getpwuid $UID;
if ($output) { open(OUTPUT, } else { *OUTPUT = *STDOUT; }
if ($output) { open(OUTPUT, } else { open(OUTPUT, }
my $fh; if ($output) { open($fh, } else { $fh = \*STDOUT; }
my $fh; if ($output) { open($fh, } else { open($fh, }
use autodie qw(:all); use Getopt::Long qw(GetOptions); GetOptions(\my %opt, die open my $handle, ">$opt{out}";
open my $fp, while (<$fp>) { my $line = $_; if ($line =~ /$regex/) { } } close $fp;
package MyPackage; @EXPORT = qw(do_awesome_thing); sub do_awesome_thing { ... } sub be_awesome { ... }
use MyPackage; do_awesome_thing(); be_awesome(); MyPackage::be_awesome();
package MyOtherPackage; @EXPORT_OK = qw(do_awesome_thing); sub do_awesome_thing { ... } sub be_awesome { ... }
use MyOtherPackage; do_awesome_thing(); MyOtherPackage::do_awesome_thing();
my $str = "abcd"; substr($str, 3) = ""; print "$str\n";
use Text::Format; print Text::Format->new({columns => 50})->format($string);
use strict; my $str = "abcd"; $str =~ /(\w{0,3})/; print $1;
use List::Util "min"; substr($string, min($n, length($string))) =
eval { something() }; if ($@) { warn "Oh no! [$@]\n"; }
my $result; eval { $result= something(); 1; } or do { my $eval_error= $@ || "error"; die $eval_error; };
my $str = "5 and 4 and a 3 and 2 1 BLAST OFF!!!"; my $count =()= $str =~ /\d/g; print "There are $count numbers in your countdown...\n\n";
naive: 10 iterative: 10 goatse: 10 for 0 items: Rate iterative goatse naive iterative 4365983/s -- -7% -12% goatse 4711803/s 8% -- -5% naive 4962920/s 14% 5% -- for 1 items: Rate naive goatse iterative naive 749594/s -- -32% -69% goatse 1103081/s 47% -- -55% iterative 2457599/s 228% 123% -- for 10 items: Rate naive goatse iterative naive 85418/s -- -33% -82% goatse 127999/s 50% -- -74% iterative 486652/s 470% 280% -- for 100 items: Rate naive goatse iterative naive 9309/s -- -31% -83% goatse 13524/s 45% -- -76% iterative 55854/s 500% 313% -- for 1000 items: Rate naive goatse iterative naive 1018/s -- -31% -82% goatse 1478/s 45% -- -75% iterative 5802/s 470% 293% -- for 10000 items: Rate naive goatse iterative naive 101/s -- -31% -82% goatse 146/s 45% -- -75% iterative 575/s 470% 293% --
use strict; use warnings; use Benchmark; my $s = "a" x 10; my %subs = ( naive => sub { my @matches = $s =~ /a/g; return scalar @matches; }, goatse => sub { my $count =()= $s =~ /a/g; return $count; }, iterative => sub { my $count = 0; $count++ while $s =~ /a/g; return $count; }, ); for my $sub (keys %subs) { print "$sub: @{[$subs{$sub}()]}\n"; } for my $n (0, 1, 10, 100, 1_000, 10_000) { $s = "a" x $n; print "\nfor $n items:\n"; Benchmark::cmpthese -1, \%subs; }
my $str = "5 and 4 and a 3 and 2 1 BLAST OFF!!!"; use Benchmark cmpthese -2 => { goatse => sub { my $count =()= $str =~ /\d/g; $count == 5 or die }, while => sub { my $count; $count++ while $str =~ /\d/g; $count == 5 or die }, };
Rate goatse while goatse 285288/s -- -57% while 661659/s 132% --
sub make_list {map {$_**2} 0 .. 1000} sub count {scalar @_} use Benchmark cmpthese -2 => { goatse => sub {my $count =()= make_list; $count == 1001 or die}, count => sub {my $count = count make_list; $count == 1001 or die}, };
Rate goatse count goatse 3889/s -- -26% count 5276/s 36% --
lrwxrwxrwx 1 jleffler rd 26 Mar 6 2008 v5.10.0 -> v5.10.0-32bit-multiplicity drwxr-xr-x 3 jleffler rd 512 Jan 10 2008 v5.10.0-32bit drwxr-xr-x 6 jleffler rd 512 Mar 7 2008 v5.10.0-32bit-multiplicity drwxr-xr-x 3 jleffler rd 512 Jan 10 2008 v5.10.0-64bit lrwxrwxrwx 1 jleffler rd 13 Jan 29 21:07 v5.10.1 -> v5.10.1-64bit drwxr-xr-x 6 jleffler rd 512 Jan 29 21:43 v5.10.1-64bit drwxr-xr-x 5 jleffler rd 512 May 6 2003 v5.5.3 lrwxrwxrwx 1 jleffler RAND 11 Mar 21 2007 v5.6.1 -> v5.6.1-full drwxr-xr-x 5 jleffler rd 512 May 6 2003 v5.6.1-full drwxr-xr-x 5 jleffler rd 512 Feb 5 2008 v5.8.7-multi lrwxrwxrwx 1 jleffler rd 19 Mar 24 2007 v5.8.8 -> v5.8.8-32bit-sun-cc drwxr-xr-x 6 jleffler rd 512 Mar 25 2007 v5.8.8-32bit-sun-cc drwxr-xr-x 5 jleffler rd 512 Feb 13 2006 v5.8.8-64bit-thread-multi drwxr-xr-x 3 jleffler rd 512 Mar 20 2008 v5.8.8-gcc-3.4.6
-rw-r--r-- 1 jleffler rd 2171936 Apr 12 2001 perl-5.004_04.tar.bz2 -rw-r--r-- 1 jleffler rd 3023320 Aug 31 1999 perl-5.005_03.tar.bz2 -rw-r--r-- 1 jleffler rd 12426022 Dec 18 2007 perl-5.10.0.tar.bz2 -rw-r--r-- 1 jleffler rd 11608061 Jan 29 12:32 perl-5.10.1.tar.bz2 -rw-r--r-- 1 jleffler rd 4430438 Mar 29 2000 perl-5.6.0.tar.bz2 -rw-r--r-- 1 jleffler rd 4864306 Apr 8 2001 perl-5.6.1.tar.bz2 -rw-r--r-- 1 jleffler rd 5142605 Aug 16 2005 perl-5.6.2.tar.bz2 -rw-r--r-- 1 jleffler rd 8618487 Jul 18 2002 perl-5.8.0.tar.bz2 -rw------- 1 jleffler rd 9410641 Sep 29 2003 perl-5.8.1.tar.bz2 -rw-r--r-- 1 jleffler rd 9424944 Nov 5 2003 perl-5.8.2.tar.bz2 -rw-r--r-- 1 jleffler rd 9509716 Jan 14 2004 perl-5.8.3.tar.bz2 -rw-r--r-- 1 jleffler rd 9598489 Apr 21 2004 perl-5.8.4.tar.bz2 -rw-r--r-- 1 jleffler rd 9464689 Jul 19 2004 perl-5.8.5.tar.bz2 -rw-r--r-- 1 jleffler rd 9693085 Nov 27 2004 perl-5.8.6.tar.bz2 -rw-r--r-- 1 jleffler rd 9839086 Jun 15 2005 perl-5.8.7.tar.bz2 -rw-r--r-- 1 jleffler rd 10123359 Feb 13 2006 perl-5.8.8.tar.bz2 -rw-r--r-- 1 jleffler rd 11121414 Dec 14 2008 perl-5.8.9.tar.bz2
for perl in /usr/perl/v5.*.? do echo $(basename $perl) $perl/bin/perl "$@" done
if $perl/bin/perl "$@" >/dev/null 2>&1 then echo ok $perl else echo not ok $perl fi
test=0 max=$(ls -d /usr/perl/v5.*.? | wc -l | sed echo 1..$max for perl in /usr/perl/v5.*.? do ((test = test + 1)) if $perl/bin/perl "$@" >/dev/null 2>&1 then echo ok $test - $perl else echo not ok $test - $perl fi done
$ ksh test.perl -e 1..6 ok 1 - /usr/perl/v5.10.0 ok 2 - /usr/perl/v5.10.1 ok 3 - /usr/perl/v5.5.3 ok 4 - /usr/perl/v5.6.1 ok 5 - /usr/perl/v5.8.8 not ok 6 - /usr/perl/v5.8.8-gcc-3.4.6 $
while (something ) { last if $some_condition; blah, blah, blah ... }
if ( some_condition ) { blah, blah, blah last if $some_other_condition; blah, blah, blah ... }
} if ( some_condition ) { ... last if $some_other_condition; blah, blah, blah ... } }
if ( some_condition ) { run_subroutine(); } sub run_subroutine { blah, blah, blah return if $some_other_condition; blah, blah, blah ... }
if ( $condition1 ) { blah, blah, blah; if ( not $condition2 ) { blah, blah, blah; if ( not $condition3 ) { blah, blah, blah; } } }
if ( $condition1 ) { last if $condition2; blah, blah, blah; last if $condition3; blah, blah, blah; }
IF-UNDER-CONDITION1: { if ( $condition1 ) { last if $condition2; blah, blah, blah; last if $condition3; blah, blah, blah; } }
if ($condition) {EXIT_IF:{ last EXIT_IF; print "never get }}
EXIT_IF: { if ($condition) { last EXIT_IF; print "never get } }
for (;;) { if (condition) { last if another_condition; } last; }
if (some_condition) { blah, blah, blah if (!$some_other_condition) { blah, blah, blah ... } }
if( $true_condition ){ (sub{ return if $true_condition; ... })->(); }
if ( $condition1 ) { blah, blah, blah; if ( not $condition2 ) { blah, blah, blah; if ( not $condition3 ) { blah, blah, blah; } } }
my $ok = $condition1; if ($ok) { blah, blah, blah; $ok = not $condition2; } if ($ok) { blah, blah, blah; $ok = not $condition3; } if ($ok) { blah, blah, blah; }
my $loop_once = 1; while ( $loop_once-- and some_condition ) { blah, blah, blah last if $some_other_condition; blah, blah, blah ... }
for( ; some_condition ; last ) { blah, blah, blah last if $some_other_condition; blah, blah, blah }
while (some_condition) { blah, blah, blah last if $some_other_condition; blah, blah, blah } continue { last; }
perl -E for(;$cond;last) { say "hello"; last if $other; say "goodbye" }'
X Y Prints ----------------------- 0 0 (nothing) 0 1 (nothing) 1 0 hello, goodbye 1 1 hello
use strict; use warnings; no diagnostics; use Carp qw( carp croak );
BEGIN { require diagnostics.pm; diagnostics->unimport; }
BEGIN { require diagnostics; diagnostics->unimport; }
use strict; use warnings; $/ = \1; open 0; my @r = map rand,<0>; print "@r\n";
use strict; use warnings; my @rand; NOTLOOP: push @rand, rand; sleep 1; goto NOTLOOP if 100 > time - $^T; print 0 + @rand, "\n";
use strict; use warnings; my $s = $s =~ s/(-)/rand() . $1/eg; my @rand = $s=~ m/([^-]+)/g;
use strict; use warnings; my $s = my @rand = eval $s;
use strict; use warnings; $/ = \1; my @rand; seek \*DATA, 0, 0; NOTLOOP: scalar <DATA>; push @rand, rand; goto NOTLOOP if $. < 100; __DATA__
use strict; use warnings; use autodie; $/ = \1; open my $F, my @rand or &notloop; sub notloop { my $t = <$F>; $t or return; push @rand, rand; goto \&notloop; }
use strict; use warnings; use autodie; local $/ = \1; open my $F, my @rand; eval << my $self = (caller(0))[6]; <$F> or die; push @rand, rand; eval $self; NOLOOP ;
my @rands = (rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand, rand);
($_=(120.44.32)x(2+2*2**2)**2)=~s/\170/114.97.110.100/gee; s/(.*)/64.95.61.40.$1.41.35.89.65.78.69.84.85.84/ee; print "@_\n";
0.636939813223766 0.349175195300148 0.692949079946754 0.230945990743699 0.61873698433654 0.940179094890468 0.435165707624346 0.721205126535175 0.0322560847184015 0.91310500801842 0.31596325316222 0.788125484008084 0.802964232426337 0.417745170032291 0.155032810595454 0.146835982654117 0.181850358582611 0.932543988687968 0.143043972615896 0.415793094159206 0.576503681784647 0.996621492832261 0.382576007897708 0.090130958455255 0.39637315568709 0.928066985272665 0.190092542303415 0.518855656633185 0.797714758118492 0.130660731025571 0.534763929837762 0.136503767441518 0.346381958112605 0.391661401050982 0.498108766062398 0.478789295276393 0.882380841033143 0.852353540653993 0.90519922056134 0.197466335156797 0.820753004050889 0.732284103461893 0.738124358455405 0.250301496672911 0.88874926709342 0.0647566487704268 0.733226696403218 0.186469206795884 0.837423290530243 0.578047704593843 0.776140208497122 0.375268613243982 0.0128391627800006 0.872438613450569 0.636808174464274 0.676851978312946 0.192308731231467 0.401619465269903 0.977516959116411 0.358315250197542 0.726835710856381 0.688046044314845 0.870742340556202 0.58832098735666 0.552752229159754 0.170767637182252 0.683588677743852 0.0603160539059857 0.892022266162105 0.10206962926371 0.728253338154527 0.800910562860132 0.628613236438159 0.742591620029089 0.602839705915397 0.00926448179027517 0.182584549347883 0.53561587562946 0.416667072500555 0.479173194613729 0.78711818598828 0.017823873107119 0.824805088282755 0.302367196288522 0.0677539595682397 0.509467036447674 0.906839536492864 0.804383046648944 0.716848992363769 0.450693083312729 0.786925293921154 0.078886787987166 0.417139859647296 0.9574382550514 0.581196777508975 0.75882630076142 0.391754631502298 0.370189654004974 0.80290625532508 0.38016959549288
@_=(*100=sub{$_[0]?(rand,(*{--$_[0]}=*{$_[0]})->(@_)):()})->($==100);
use 5.010; say for &{ sub { "\U\x{fb01}\x{fb03}" =~ m((?mix-poop) .{0,2} .{0,3} .{0,3} .{0,4} +(?{ $_ [++$ }) (*FAIL) )poop || pop @{ (*_{ARRAY}) } ; @{ (*_{ARRAY}) } } }
(*100 = sub { $_[0] ? ( rand, ( *{ --$_[0] } = *{ $_[0] } )->(@_) ) : ( ) } )->( $= = 100 );
(*100 = sub { $_[0] ? ( rand, ( *{ $_[0] - 1 } = *{ $_[0] } )->( $_[0] - 1 ) ) : ( ) } )->( 100 );
@vi = 6->(6); @vi = &6( 6); $dozen = 12; @dozen = $dozen->($dozen); @baker @_ = 100; print &0;
my @random = (5, 2, 1, 3, 4, 3, 3, 4, 1, 6, 3, 2, 4, 2, 1, 1, 1, 1, 4, 1, 3, 6, 4, 6, 2, 6, 6, 1, 4, 5, 1, 1, 5, 6, 6, 5, 1, 4, 1, 2, 3, 1, 2, 2, 6, 6, 6, 5, 3, 3, 6, 3, 4, 3, 1, 2, 1, 2, 3, 3, 3, 4, 4, 1, 5, 5, 5, 1, 1, 5, 6, 3, 2, 2, 1, 1, 5, 2, 5, 3, 3, 3, 5, 5, 1, 6, 5, 6, 3, 2, 6, 3, 5, 6, 1, 4, 3, 5, 1, 2);
BEGIN { my @buffer; my $add_to_buffer = sub { my $fetch = shift; $fetch ||= 100; $fetch = 100 if $fetch < 100; require LWP::Simple; push @buffer, split /\s+/, LWP::Simple::get( "http: ); }; my $many = sub ($) { print "Fetching $_[0] numbers\n"; $add_to_buffer->($_[0]) if @buffer < $_[0]; my @fetched = splice @buffer, 0, $_[0], (); my $count = @fetched; print "Fetched [$count] @fetched\n"; @fetched }; *CORE::GLOBAL::rand = sub (;$$) { my $max = $_[0] || 1; my $fetch = $_[1] || ( wantarray ? 10 : 1 ); my @fetched = map { $max * $_ / 100 } $many->( $fetch ); wantarray ? @fetched : $fetched[-1]; }; } my @rand = rand(undef, 5); print "Numbers are @rand\n\n"; @rand = rand(87); print "Numbers are @rand\n\n"; $rand = rand(undef, 4); print "Numbers are $rand\n\n"; $rand = rand(); print "Numbers are $rand\n\n"; $rand = rand(undef, 200); print "Numbers are $rand\n\n";
sub f { my $n = shift; if( $n == 0 ) { return @_; } else { return f( $n-1, rand, @_ ); } } my @random_array = f(100);
my @rand = map&$_($_),sub{@_<=100&&goto&{push@_,rand;$_[0]};shift;@_};
my @rand = sub{&{$_[0]}}->(sub{@_<=100&&goto&{(@_=(rand,@_))[-1]};pop;@_});
my @rand = do{local*_=sub{(push@_,rand)<100?goto&_:@_};&_};
my @rand = map&$_,sub{(100^push@_,rand)?goto&$_:@_};
. . ( | .( .( . ;$,= = = | ( ( ($,))= |"\!"; $:=( = ($/)= |(( ;( ($\))= (( (( |+ "\!";$:= (( =(( ;($,)= ( "\~";$\=
( | ).( ( ( ( ( | . ( .( | ^ ( ( ( "\ | ($~) = ($/) = ($\) = ($~) =
).( (( ((( .( +( | .( (( ).( . .+( (( ( (( . ^(( ( (( ( (( ( ^ ).( ^(( ))). (( ))^ (( ).( ).+( ).( (( (( .( (( ))| (( ((( . | (( ( (( ( .(( ).( (( ))) .(( ))).+( (( | +( .( );( $:)= =( ;
rand 1 of 100=0.625268682212667 rand 2 of 100=0.30160434879096 ... rand 100 of 100=0.584811321826528
use strict; use warnings; my @foo; my $random; ($random = sub { push @{$_[0]}, rand; return if @{$_[0]} == $_[1]; goto \&$random; })->(\@foo, 100); print "@foo\n"; print scalar @foo, "\n";
use strict; use warnings; sub randoms { my $num = shift; my $foo; CARRYON: push @$foo, rand; goto ( ( STOP: return @$foo; } my @foo = randoms(100); print "@foo\n"; print scalar(@foo)."\n";
use strict; use warnings; my @bar = sub { return &{$_[0]} }-> ( sub { push @{$_[1]}, rand; goto \&{$_[0]} unless scalar(@{$_[1]}) == $_[2]; return @{$_[1]}; }, [], 100 ); print "@bar\n"; print scalar(@bar), "\n";
use strict; use warnings; my $x = 99; my @rands = (rand,(*x=sub{rand,(map{*x->($x,sub{*x})}($x)x!!--$x)})->($x,*x)); use feature say for @rands;
use strict; use warnings; @ARGV=q!echo chomp(my @array=<>);
open my $slf, $0; undef $/; (my $s = <$slf>) =~ s/./rand()." "/eggs; $s .= rand();
use strict; use warnings; package Tie::RandArray; use Tie::Array; our @ISA = ( sub FETCH { rand; } package main; my @rand; my $object = tie @rand, $ my @a= @somearray; warn "@a";
sub fill_rand { my ($array, $count) = @_; if ($count >= 1) { unshift @$array, rand(); fill_rand ($array, --$count); } } my @array; fill_rand (\@array, 100);
sub fill_rand { my $array = shift; my $count = shift; unshift @$array, rand(); if ($count > 1) { $count--; @_ = ($array, $count); goto &fill_rand; } } my @array; fill_rand(\@array, 100);
my @array; eval("\@array = (" . ("rand(), " x 100) . ");");
open FILE, __FILE__ or die "Can my $string; read FILE, $string, 100; close FILE; my @array = map { ord } split
rand1(); $idx = 1; foreach $item (@array) { print "$idx - $item\n"; $idx++; } exit; sub rand1() { rand2(); rand2(); rand2(); rand2(); } sub rand2() { rand3(); rand3(); rand3(); rand3(); rand3(); } sub rand3() { push @array, rand; push @array, rand; push @array, rand; push @array, rand; push @array, rand; }
my $u; open(URAND, "/dev/urandom") || die $!; read(URAND, $u, 100); close URAND; my @array = split(/ */, $u);
$s="D" x 100; $s=~s/D/rand()." "/ge; @s=split(/ /,$s);
use warnings; use strict; my @rands; my $i=1; sub push_rand { return if $ push @rands, rand; push_rand(); } push_rand(); for (@rands) { print "$i: $_\n"; $i++; }
sub two{ my $y=shift; ($y->(), $y->()) } sub five{my $y=shift; ($y->(), $y->(), $y->(), $y->(), $y->()) }
my @array = five(sub{five(sub{two(sub{two(sub{rand()})})})});
use strict; use warnings; use IPC::System::Simple qw(system capture); system($^X, "yourscript.pl", @ARGS); my $results = capture($^X, "yourscript.pl", @ARGS);
system( [0,1,2], $^X, "yourscript.pl", @ARGS ); capture( [0,1,2, $^X, "yourscript.pl", @ARGS );
open PERLFILE, "<somePerlScript.pl"; undef $/; my $program = <PERLFILE>; eval $program;
`myscript.pl &`; system ( `start myscript.pl`; system ( exec (
use strict; open(OUTPUT, "date|") or die "Failed to create process: $!\n"; while (<OUTPUT>) { print; } close(OUTPUT); print "Process exited with value " . ($? >> 8) . "\n";
sub getcode($) { my @list; my $filename = shift; open (INFILE, "< $filename"); @list = <INFILE>; close (INFILE); return \@list; } my $codelist = []; $codelist = getcode( eval join ("", @$codelist);
if (condition) myObject.doSomething(); else myObject.doSomethingElse();
if (condition) myObject.doSomething(); myObject.doSomethingMore(); else myObject.doSomethingElse();
if (condition) myObject.doSomething(); else myObject.doSomethingElse(); myObject.doSomethingMore();
my $a = 1; if ($a == 1) { print "one\n"; } print "one\n" if ($a == 1);
if ($model->test) { $review = "1" } else { $review = }
( defined($model->test) ? $review="1" : $review ) =
my $review = do { if( ... ) { elsif( ... ) { elsif( ... ) { else { };
if (defined($model->test) { $review = "1"; } else { $review = ""; }
if (defined($model->test) { $review = "1"; } else { $review = ""; }
my $review = $model->test; $review = !1 unless defined $review;
use warnings; use strict; my @array = (1, 2, 3, 4); foreach (@array) { print $_."\n" } print "no, this cant be true"
@holder = split /\./,"hello.world"; print @holder[0];
print (...) interpreted as function at test.pl line 3. syntax error at test.pl line 3, near ")["
print (...) interpreted as function at test.pl line 3. syntax error at test.pl line 3, near ")["
sub search { my ($a, @a_list) = @_; foreach (@a_list) { if($_ == $a) return TRUE; } return FALSE; }
if ($_ == $a) { return TRUE; } elsif (...) { ... } else { ... }
sub search { my ($a, @a_list) = @_; foreach (@a_list) { return TRUE if $_ == $a; last if $_ > $a; next if $ptom != LAST_QUARTER; ... } return FALSE; }
use strict; use warnings; use 5.010; my @a_list = (1, 2, 3); my $a = 2; say $a ~~ @a_list; use List::MoreUtils qw(any); say any { $a == $_ } @a_list; use List::Util qw(first); say defined first { $a == $_ } @a_list; say grep { $a == $_ } @a_list > 0;
sub search { my $key = shift; foreach (@_) { return 1 if $_ == $key; } return (); }
use warnings; use strict; my ($id) = (split /=/, print "$id\n"; __END__ id123
say $obj; say "object is: $obj"; if ($obj =~ /xyz/) {...} say join if (length $obj > 10) {...} $hash{$obj}++; ...
{package Sum; use List::Util (); sub new {my $class = shift; bless [@_] => $class} use overload fallback => 1, sub add {push @{$_[0]}, @_[1 .. $ } my $sum = Sum->new(1 .. 10); say ref $sum; say $sum; $sum->add(100, 1000); say $sum;
$ perl -MO=Deparse -e while (defined($_ = <ARGV>)) { print 42; } -e syntax OK
> cat temp.pl use strict; use warnings; my $count=<>; print "$count"."\n"; >
%boss = ( "Allan" => "George", "Bob" => "George", "George" => "lisa" ); %status = ( "Allan" => "Contractor", "Bob" => "Part-time", "George" => "Full-time" );
~> more test.pl %chums = ( "Allan" => {"Boss" => "George", "Status" => "Contractor"}, "Bob" => {"Boss" => "Peter", "Status" => "Part-time"} ); print $chums{"Allan"}{"Boss"}."\n"; print $chums{"Bob"}{"Boss"}."\n"; print $chums{"Bob"}{"Status"}."\n"; $chums{"Bob"}{"Wife"} = "Pam"; print $chums{"Bob"}{"Wife"}."\n"; ~> perl test.pl George Peter Part-time Pam
package Employee; use Moose; has has has is => isa => default => undef, ); package main; use strict; use warnings; my %employees; $employees{George} = Employee->new( name => status => ); $employees{Allan} = Employee->new( name => status => superior => $employees{George}, ); print $employees{Allan}->superior->name, "\n";
my %employees = ( "Allan" => { "Boss" => "George", "Status" => "Contractor" }, ); print $employees{"Allan"}{"Boss"}, "\n";
> if ( "0" ) { say "True" } else { say "False" } False
eval { local $SIG{ALRM} = sub { die "alarm\n" }; alarm $timeout; $nread = sysread SOCKET, $buffer, $size; alarm 0; }; if ($@) { die unless $@ eq "alarm\n"; } else { }
use Time::Out qw(timeout) ; timeout $nb_secs => sub { }; if ($@){ }
for(0..4){ my $command="sleep $_"; print "$command, "; system("timeout 1.1s $command"); if ($? == -1 ){ printf "failed to execute: $!" } elsif($?&127 ){ printf "died, signal %d, %scoredump", $?&127, $?&128? elsif($?>>8==124){ printf "timed out" } else { printf "child finished, exit value %d", $? >> 8 } print "\n"; }
sleep 0, child finished, exit value 0 sleep 1, child finished, exit value 0 sleep 2, timed out sleep 3, timed out sleep 4, timed out
sub list_module { my $module = shift; no strict return grep { defined &{"$module\::$_"} } keys %{"$module\::"} }
use B qw/svref_2object/; sub in_package { my ($coderef, $package) = @_; my $cv = svref_2object($coderef); return if not $cv->isa( return $cv->GV->STASH->NAME eq $package; } sub list_module { my $module = shift; no strict return grep { defined &{"$module\::$_"} and in_package(\&{*$_}, $module) } keys %{"$module\::"} }
my $sniff = Class::Sniff->new({class => print $sniff->report;
no warnings local %ENV = %ENV; local $/ = $/; local @INC = @INC; local %INC = %INC; local $_ = $_; local $| = $|; local %SIG = %SIG; use warnings
sub run_with_env { my ($sub, @args) = @_; no warnings local %ENV = %ENV; local $/ = $/; local @INC = @INC; local %INC = %INC; local $_ = $_; local $| = $|; local %SIG = %SIG; use warnings $sub->(@args); } run_with_env(sub { }); run_with_env(sub { });
The "Alias" module implements localization of the basic types within the caller things in the containing scope should take a look there too.
my $arr = []; for my $i (0..$n-1) { push @$arr, ""; }
f([@$some_tab, n_elems("", $column_number - scalar(@$some_tab))]);
my $str = my %hash = (a => 1, b => 2); my @array = (1..4); my $strref = \$str; my $hashref = \%hash; my $arrayref = \@array; print "String value is $$strref\n"; print "Hash values are either $$hashref{a} or $hashref->{b}\n"; print "Array values are accessed by either $$arrayref[0] or $arrayref->[2]\n";
my $str = my $ref = \$str; my $val = ${$ref}; my $same_val = $$ref;
use Carp; $SIG{ __DIE__ } = sub { Carp::confess( @_ ) };
for q in file1.uniqc file2.uniqc ; do perl -ne done | sort | uniq -c
$ export LC_COLLATE=en_US.UTF-8 $ perl -Mlocale -e ( ($1 1 $ perl -MPOSIX=strcoll -e ( ($1 1 $ sort data ( 1 ($1
use XML::Twig; my %hash; my $twig = XML::Twig->new( twig_handlers => { testcase => sub { my ($t, $e) = @_; my $testcase = $e->att("name"); my $error = $e->field("error") || $e->field("failure"); my $ok = defined $error ? "not ok" : "ok"; $hash{$testcase}{result} = $ok; $hash{$testcase}{error} = $error; } } ); $twig->parsefile("test.xml"); $twig->purge(); print "1..", scalar(keys(%hash)), "\n"; foreach my $testcase (keys %hash) { }
my $str = "Foooooobar"; $str =~ /(\w)(\1+)/; print $1; print $1 . $2;
use strict; use warnings; while (<DATA>) { chomp; if (/([^\W_0-9])\1+/) { print "$_: dup [$1]\n"; } else { print "$_: nope\n"; } } __DATA__ 100 food créé a::b
if ( ($str ^ substr($str,1) ) =~ /\0+/ ) { print "found ", substr($str, $-[0], $+[0]-$-[0]+1), " at offset ", $-[0]; }
my $file = my @data; open(my $fh, while (my $line = <$fh>) { chomp $line; my @fields = split(/,/, $line); push @data, \@fields; }
sub csvsplit { my $line = shift; my $sep = (shift or return () unless $line; my @cells; $line =~ s/\r?\n$ my $re = qr/(?:^|$sep)(?:"([^"]*)"|([^$sep]*))/; while($line =~ /$re/g) { my $value = defined $1 ? $1 : $2; push @cells, (defined $value ? $value : } return @cells; }
while(my $line = <FILE>) { my @cells = csvsplit($line); }
my $data = stupid_required_interface_that_reads_the_entire_giant_file(); open my $text_handle, or die "Failed to open the handle: $!";
my $csv = Text::CSV->new ( { binary => 1 } ) or die "Cannot use CSV: ".Text::CSV->error_diag (); while (my $row = $csv->getline($text_handle)) { ... }
while (my $line = <$text_handle>) { my @csv = split /,/, $line; ... }
open FILE, $filename while (<FILE>) { @csv = split /,/ }
my $result=[[]]; while($csv=~s/(.*?)([,\n]|$) push @{$result->[-1]}, $1; push @$result, [] if $2 eq "\n"; last unless $2; }
local $_; my $result=[[]]; foreach($csv=~/(?:(?<=[,\n])|^)(.*?)(?:,|(\n)|$)/gs) { next unless defined $_; if($_ eq "\n") { push @$result, []; } else { push @{$result->[-1]}, $_; } }
open(my $fh, my @all_lines = <$fh>; for my $line (@all_lines) { chomp $line; my @fields = split process_fields(@fields); }
@result = (dothis $foo, $bar); @result = (dothis($foo), $bar); @result = dothis($foo, $bar);
SKIP: { skip $why, $how_many if $condition; ...normal testing code goes here... }
$coderef = sub { my $arg = shift; isa_ok $arg, do(@args, $coderef);
inoremap <tab> <c-r>=InsertTabWrapper()<cr> function! InsertTabWrapper() let col = col( if !col || getline( return "\<tab>" else return "\<c-p>" endif endfunction
mkdir -p ~/.cpan/CPAN touch ~/.cpan/CPAN/MyConfig.pm
require 5.013002; print "bla: ", $myvar =~ s/a/b/r, "\n";
print "bla: ", do { (my $tmp = $myvar) =~ s/a/b/; $tmp }, "\n";
print "bla: ", $_, "\n" if ($_ = $myvar) =~ s/a/b/g or 1;
use strict; main(); sub main{ my $foo = "blahblahblah"; print } sub replace { my ($from,$to,$string) = @_; $string =~s/$from/$to/ig; return $string; }
import Text.ParserCombinators.PArrow data Atom = QuotedString String | Symbol String deriving (Show, Eq) data Sexp = Sexp [Sexp] | Atom Atom deriving (Eq) quotedString :: Char -> Char -> MD a Atom quotedString quoteChar escapeChar = between q q inside >>^ QuotedString where q = char quoteChar inside = many $ (char escapeChar >>> anyChar) <+> notChar quoteChar doubleQuotedString, symbol :: MD a Atom doubleQuotedString = quotedString symbol = word >>^ Symbol atom, sexp :: MD a Sexp atom = (doubleQuotedString <+> symbol) >>^ Atom sexp = atom <+> (between (char where sexp
sub proc { my $pattern = shift; my $txt = "foo baz"; $txt =~ $pattern; } my $pattern = proc($pattern);
sub modify { my($text, $code) = @_; $code->($text); return $text; } my $new_text = modify(
$pattern = qr/foo/; print "match!\n" if $text =~ $pattern;
proc( sub proc { my $code = shift; ... eval $code; }
proc(sub {my $text = shift; $text =~ s/foo/bar}); sub proc { my $code = shift; ... $code->("some text"); }
sub proc { my($match, $subst) = @_; my $txt = "foo baz"; $txt =~ s/$match/$subst/; print "$txt\n"; } my $matcher = qr/foo/; my $sub_str = "bar"; proc($matcher, $sub_str);
input: datetime year to second,decimal(16,6), integer
use strict; while (<>) { chomp; print "Read: <$_>\n"; my($r1) = qr%^input\s*:\s*%i; if ($_ =~ $r1) { print "Found input:\n"; s%$r1%%; print "Residue: <$_>\n"; my($r3) = qr%(?:year|month|day|hour|minute|second|fraction(?:\([1-5]\))?)%; my($r2) = qr% (?:\s*,?\s*)? ( (?:money|numeric|decimal)(?:\(\d+(?:,\d+)?\))? | int(?:eger)? | smallint | datetime\s+$r3\s+to\s+$r3 ) %ix; while ($_ =~ m/$r2/) { print "Got type: <$1>\n"; s/$r2 } print "Residue 2: <$_>\n"; } else { print "No match:\n"; } print "Next?\n"; }
sub replace { my($string, $find, $replace, $global) = @_; unless($global) { $string =~ s($find){ $replace->() }e; } else { $string =~ s($find){ $replace->() }ge; } return $string; }
sub apply_regex { my $regex = shift; my $subst = shift || while (defined($_ = <$some_filehandle>)) { s/$regex/$subst/g; } }
apply_regex(qr{(foo|bar)}, apply_regex(qr/[ab]+/, apply_regex(qr|\d+|);
sub oops { die "Usage : sednames s/old/new [files ..]\n"; } oops if ($ $regex = eval sub regex_rename { foreach (<$_[0]>) { rename("$_", &$regex($_)); } } if ($ else { regex_rename(@ARGV); }
sub proc { my ($pattern, $replacement) = @_; my $txt = "foo baz"; $txt =~ s/$pattern/$replacement/g; } my $pattern = qr/foo/; my $replacement = proc($pattern, $replacement);
sub proc { my ($pattern, $replacement, $flags) = @_; my $txt = "foo baz"; eval( } proc(qr/foo/,
use IPC::System::Simple qw(capture); my $result = capture("some_command");
use Encode qw/encode decode/; $utf8 = decode( $header = encode(
decode() encode() MIME-Header Both B and Q =?UTF-8?B?....?= MIME-B B only; Q croaks =?UTF-8?B?....?= MIME-Q Q only; B croaks =?UTF-8?Q?....?=
use Encode qw(decode); my $decoded = decode("MIME-Header", $encoded);
use MIME::Words qw(:all); $decoded = decode_mimewords( );
%first_hash = gen_first_hash(); %second_hash = gen_second_hash(); do_stuff_with_hashes(%first_hash, %second_hash); sub do_stuff_with_hashes { my %first_hash = shift; my %second_hash = shift; }
Odd number of elements in hash assignment at ./gen.pl line 85. Odd number of elements in hash assignment at ./gen.pl line 86. Use of uninitialized value in concatenation (.) or string at ./gen.pl line 124. Use of uninitialized value in concatenation (.) or string at ./gen.pl line 143.
sub do_stuff_with_hashes { my %first_hash = %{shift()}; my %second_hash = %{shift()}; };
do_stuff_with_hashes( { gen_first_hash() }, { gen_second_hash() } );
use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep clock_gettime clock_getres clock_nanosleep clock stat );
print "$query executed successfully at ",localtime; print "$query executed successfully at ",(localtime); print "$query executed successfully at ".(localtime);
executed successfully at 355516731103960 executed successfully at 355516731103960 executed successfully at Wed Apr 7 16:55:35 2010
print "$query executed successfully at ", localtime, "\n"; print "$query executed successfully at ",(localtime),"\n"; print "$query executed successfully at ". localtime, "\n"; print "$query executed successfully at ".(localtime),"\n"; print "$query executed successfully at ", scalar localtime, "\n"; print "$query executed successfully at ", scalar (localtime),"\n";
my $time = localtime; print "$query executed successfully at $time\n"; my @time = localtime; print "$query executed successfully at @time\n";
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime; my $now_string = localtime;
@list = ($sec,$min,$hour,$day,$mon,$year_1900,$wday,$yday,$isdst)=localtime; print join("\n",@list);
C:\Git\bin\perl.exe: ** unable to remap C:\Git\bin\msys-ssl-0.9.8.dll to same address as parent -- 0x678F0000 0 [main] perl 1300 sync_with_child: child 7092(0x324) died before initialization with status code 0x1 567 [main] perl 1300 sync_with_child: *** child state child loading dlls
Rebase to free regions via: (execute as Administrator) rebase -b 0x64000000 bin/libsvn_repos-1-0.dll rebase -b 0x64200000 bin/libneon-25.dll
package My::Module; use strict; use warnings; use Exporter; our @ISA = our @EXPORT = qw(@a @b); our (@a, @b); @a = 1..3; @b = "a".."c";
use strict; use warnings; use My::Module; print @a; print @b;
BEGIN { require "My/Module.pm"; My::Module->import(); }
use strict; use warnings; our (@a, @b); @a = 1..3; @b = "a".."c";
use strict; use warnings; require "first.pl"; our (@a,@b); print @a; print @b;
use Fcntl open my $self, flock $self, LOCK_EX | LOCK_NB or die "This script is already running";
while (($key, $value) = each %hash) { $hash2{$value}=$key; } %hash=%hash2;
use Data::Dumper; my %hash = ( print Dumper \%hash; %hash = reverse %hash; print Dumper \%hash;
my %inverse; push @{ $inverse{ $original{$_} } }, $_ for keys %original;
my %orig_hash = (...); my %new_hash; %new_hash = map { $orig_hash{$_} => $_ } keys(%orig_hash);
use experimental qw(postderef); sub invert { use Hash::MultiValue; my $mvh = Hash::MultiValue->from_mixed(shift); my $inverted; $mvh->each( sub { push $inverted->{ $_[1] }->@* , $_[0] } ) ; return $inverted; }
my %test_hash = ( q => [qw/1 2 3 4/], w => [qw/4 6 5 7/], e => ["8"], r => ["9"], t => ["10"], y => ["11"], ); my $wow = invert(\%test_hash); my $wow2 = invert($wow); use DDP; print "\n \%test_hash:\n\n" ; p %test_hash; print "\n \%test_hash inverted as:\n\n" ; p $wow ; map { $test_hash{$_} = [ sort { $a cmp $b || $a <=> $b } @{ $test_hash{$_} } ] } keys %test_hash ; map { $wow2->{$_} = [ sort { $a cmp $b || $a <=> $b } @{ $wow2->{$_} } ] } keys %$wow2 ; use Test::More ; is_deeply(\%test_hash, $wow2, "double inverted hash == original"); done_testing;
for ( keys %test_hash ) { if ( ref $test_hash{$_} ne $test_hash{$_} = [ $test_hash{$_} ] } }
$scalarref = \$foo; $constref = \186_282.42; $arrayref = \@ARGV; $hashref = \%ENV; $coderef = \&handler; $globref = \*STDOUT;
@reflist = (\$s, \@a, \%h, \&f); @reflist = \($s, @a %h, &f);
@reflist = \(@x, (@y)); @reflist = (\@x, map { \$_ } @y);
@envrefs = \@ENV{"HOME", "TERM"}; @envrefs = \@ENV{ qw<HOME TERM> }; @envrefs = \( $ENV{HOME}, $ENV{TERM} ); @envrefs = ( \$ENV{HOME}, \$ENV{TERM} );
@reflist = \fx(); @reflist = map { \$_ } fx(); @reflist = \( fx(), fy(), fz() ); @reflist = ( \fx(), \fy(), \fz() ); @reflist = map { \$_ } fx(), fy(), fz();
my $str = $str =~ s/e/___eee___/g; $str =~ s/o/e/g; $str =~ s/___eee___/o/g;
my $str = my %words = ( foo => bar => baz => ); my $wordlist_re = $str =~ s/\b($wordlist_re)\b/$words{$1}/eg;
my @matches; while ($string =~ /\<img\ssrc\="(.*)"/g) { push(@matches, $1); }
baabo caaco daado caac(*FAIL)|aa.|caaco|co [0] => aab [1] => caaco [2] => aad
baabo caaco daado caa(*SKIP)c(*FAIL)|aa.|caaco|co [0] => aab [1] => co [2] => aad
baabo caaco daado caa(*PRUNE)c(*FAIL)|aa.|caaco|co [0] => aab [1] => aac [2] => aad
my $foo; my (@wid, %get); my $foo = "flurp"; my @oof = @bar; my $x : Foo = $y;
use strict; my $input = "one:two:three:four"; my ($out) = split(/:/,$input); print $out,"\n"; my $new_out = split(/:/,$input); print $new_out,"\n";
perl -e [1 2 3] perl -e [0] perl -e [123] perl -e [123]
while ($ARGV = shift @ARGV) { open ARGV, $ARGV; LINE: while (defined($_ = <ARGV>)) { $seen{$_} .= @ARGV; print $_ if $seen{$_} =~ /10$/; } }
$v = 5; say "$v"; $@ = 6; say "$@"; @a = (1,2); say "@a";
sub read_handle { while (<HANDLE>) { ... } } for (1 .. 10) { print "$_: \n"; read_handle; print "done with $_\n"; }
use 5.014; use strict; use warnings; use utf8; use Unicode::Collate; binmode STDOUT, my $str = "Îñţérñåţîöñåļîžåţîöñ" x 2; my $look = "Nation"; my $Collator = Unicode::Collate->new( normalization => undef, level => 1 ); my @match = $Collator->match($str, $look); if (@match) { my $found = $match[0]; my $f_len = length($found); say "match result: $found (length is $f_len)"; my $offset = 0; while ((my $start = index($str, $found, $offset)) != -1) { my $end = $start + $f_len; say sprintf("found at: %s,%s", $start, $end); $offset = $end + 1; } }
$str = Unicode::Normalize::NFD($str); $str =~ s/\pM
use 5.014; use utf8; use Unicode::Normalize; binmode STDOUT, my $str = "Îñţérñåţîöñåļîžåţîöñ"; my $look = "Nation"; say "before: $str\n"; $str = NFD($str); $str =~ s/\pM say "after: $str";¬ say "is_match: ", $str =~ /$look/i || 0;
use 5.014; use utf8; use Unicode::Collate; binmode STDOUT, my $str = "Îñţérñåţîöñåļîžåţîöñ" x 2; my $look = "Nation"; my $Collator = Unicode::Collate->new( normalization => undef, level => 1 ); my @match = $Collator->match($str, $look); say "match ok!" if @match;
use strict; use warnings; use UTF8; use Unicode::Normalize; my $str = "Îñtérñåtîöñålîžåtîöñ"; for ( $str ) { $_ = NFD( $_ ); s/\pM s/[^\0-\x80] } if ($str =~ /nation/) { print $str . "\n"; }
<%class> has use Excel::Writer::XLSX; </%class> <%init> my $file = $m->path_info; $file =~ s/[^\w\.] my $cell = lc join if( $.dwl ) { my $excel; open my $fh, my $workbook = Excel::Writer::XLSX->new( $excel ); my $worksheet = $workbook->add_worksheet(); $worksheet->write(0, 0, $cell); $workbook->close(); $m->clear_buffer; $m->res->content_type("application/vnd.ms-excel"); $m->print($excel); $m->abort(); } </%init> <table border=1> <tr><td><% $cell %></td></tr> </table> <a href="?dwl=yes">download <% $file %></a>
+----------------------------+ | ÅngstrÖm in the hello.xlsx | +----------------------------+ download hello.xlsx
+--------------------------+ | ÅngstrÖm in the hll.xlsx | +--------------------------+ download hll.xlsx
+--------------------------+ | �ngstr�m in the hll.xlsx | +--------------------------+ download hll.xlsx
+----------------------------+ | �ngstr�m in the h�ll�.xlsx | +----------------------------+ download h�ll�.xlsx
<%filter uencode><% Encode::encode_utf8($yield->()) %></%filter>
% $.uencode {{ <table border=1> <tr><td><% $cell %></td></tr> </table> <a href="?dwl=yes">download <% $file %></a> % }}
override return join("\n", super(), qq( use 5.014; use utf8; use Encode; ) ); };
use Encode; override my($self, $path, $args) = @_; foreach my $k (keys %$args) { $args->set($k, decode_utf8($args->get($k))); } my $result = super(); $result->output( encode_utf8($result->output()) ); return $result; };
diff -ruN orig/my/comps/Base.mc new/my/comps/Base.mc --- orig/my/comps/Base.mc 2015-05-20 21:48:34.515625000 -0700 +++ new/my/comps/Base.mc 2015-05-20 21:57:34.703125000 -0700 @@ -2,9 +2,10 @@ has </%class> -<%augment wrap> - <html> +<%augment wrap><!DOCTYPE html> + <html lang="en-US"> <head> + <meta charset="utf-8"> <link rel="stylesheet" href="/static/css/style.css"> % $.Defer {{ <title><% $.title %></title> diff -ruN orig/my/comps/xls/dhandler.mc new/my/comps/xls/dhandler.mc --- orig/my/comps/xls/dhandler.mc 1969-12-31 16:00:00.000000000 -0800 +++ new/my/comps/xls/dhandler.mc 2015-05-20 21:53:42.796875000 -0700 @@ -0,0 +1,30 @@ +<%class> + has + use Excel::Writer::XLSX; +</%class> +<%init> + my $file = $m->path_info; + $file = decode_utf8( $file ); + $file =~ s/[^\w\.] + my $cell = lc join + if( $.dwl ) { + + my $excel; + open my $fh, + my $workbook = Excel::Writer::XLSX->new( $fh ); + my $worksheet = $workbook->add_worksheet(); + $worksheet->write(0, 0, $cell); + $workbook->close(); + + + $m->clear_buffer; + $m->res->content_type("application/vnd.ms-excel"); + $m->print($excel); + $m->abort(); + } +</%init> +<table border=1> +<tr><td><% $cell %></td></tr> +</table> +<p> <a href="%c3%85%4e%47%53%54%52%c3%96%4d%20%68%c3%a9%6c%6c%c3%b3">ÅNGSTRÖM hélló</a> +<p> <a href="?dwl=yes">download <% $file %></a> diff -ruN orig/my/lib/My/Mason/Compilation.pm new/my/lib/My/Mason/Compilation.pm --- orig/my/lib/My/Mason/Compilation.pm 2015-05-20 21:48:34.937500000 -0700 +++ new/my/lib/My/Mason/Compilation.pm 2015-05-20 21:49:54.515625000 -0700 @@ -5,11 +5,13 @@ extends -# - -# - - - - +override + return join("\n", + super(), qq( + use 5.014; + use utf8; + use Encode; + ) + ); +}; 1; \ No newline at end of file diff -ruN orig/my/lib/My/Mason/Request.pm new/my/lib/My/Mason/Request.pm --- orig/my/lib/My/Mason/Request.pm 2015-05-20 21:48:34.968750000 -0700 +++ new/my/lib/My/Mason/Request.pm 2015-05-20 21:55:03.093750000 -0700 @@ -4,20 +4,27 @@ extends - -# - -# - - -# - -# - -# - -# - - +use Encode qw/ encode_utf8 decode_utf8 /; -1; \ No newline at end of file +override + my($self, $path, $args) = @_; + foreach my $k (keys %$args) { + my $v = $args->get($k); + $v=decode_utf8($v); + $args->set($k, $v); + } + my $result = super(); + my( $ctype, $charset ) = $self->res->headers->content_type_charset; + if( ! $ctype ){ + $ctype = + $charset = + $self->res->content_type( "$ctype; $charset"); + $result->output( encode_utf8( + } elsif( ! $charset and $ctype =~ m{text/(?:plain|html)} ){ + $charset = + $self->res->content_type( "$ctype; $charset"); + $result->output( encode_utf8( + } + return $result; +}; +1;
package Mason::Plugin::UTF8; use Moose; with 1; package Mason::Plugin::UTF8::Request; use Mason::PluginRole; use Encode; # after my ($self, $outref) = @_; $$outref = encode_utf8( $$outref ); }; # around my $orig = shift; my $self = shift; my %params = @_; while (my ($key, $value) = each(%params)) { $value = decode_utf8($value); } $self->$orig(%params); } 1;
package Mason::Plugin::UTF8::Compilation; use Mason::PluginRole; override return(super() . }; 1;
</Directory> ErrorLog ${APACHE_LOG_DIR}/error.log LogLevel warn CustomLog ${APACHE_LOG_DIR}/ssl_access.log combined
x_FILE=$1 if [ -z $x_FILE ];then echo echo " $0 : Sin Argumento^G"; echo echo "USO: $0 ARCHIVO"; echo exit 1 fi grep -v
$ perl -MO=Concise,-exec -E 1 <0> enter 2 <;> nextstate(main 48 -e:1) v:%,2048 3 <0> pushmark s 4 <$> const(IV 1) s 5 <$> const(IV 3) s 6 <$> gv(*_) s 7 <{> enteriter(next->c last->f redo->8) lKS/8 d <0> iter s e <|> and(other->8) vK/1 8 <;> nextstate(main 47 -e:1) v:%,2048 9 <0> pushmark s a <$> const(PV "Hello, World!") s b <@> say vK c <0> unstack v goto d f <2> leaveloop vK/2 g <@> leave[1 ref] vKP/REFC -e syntax OK
use Crypt::Eksblowfish::Bcrypt; use Crypt::Random; $password = $encrypted = encrypt_password($password); print "$password is encrypted as $encrypted\n"; print "Yes the password is $password\n" if check_password($password, $encrypted); print "No the password is not smalltest\n" if !check_password( sub encrypt_password { my $password = shift; my $salt = shift || salt(); my $settings = return Crypt::Eksblowfish::Bcrypt::bcrypt($password, $settings); } sub check_password { my ($plain_password, $hashed_password) = @_; if ($hashed_password =~ m!^\$2a\$\d{2}\$([A-Za-z0-9+\\.]{22})!) { return encrypt_password($plain_password, $1) eq $hashed_password; } else { return 0; } } sub salt { return Crypt::Eksblowfish::Bcrypt::en_base64(Crypt::Random::makerandom_octet(Length=>16)); }
if ($some_variable > 11 && ($some_other_bigexpression < $another_variable || $my_flag eq "Y") && $this_is_too_bloody_wide == 1 && $ace > my_func() && $another_answer == 42 && $pi == 3) {
if ($some_variable > 11 && ($some_other_bigexpression < $another_variable || $my_flag eq "Y") && $this_is_too_bloody_wide == 1 && $ace > my_func() && $another_answer == 42 && $pi == 3) {
if ( $some_variable > 11 && ($some_other_bigexpression < $another_variable || $my_flag eq "Y") && $this_is_too_bloody_wide == 1 && $ace > my_func() && $another_answer == 42 && $pi == 3) {
if ( $some_variable > 11 && ($some_other_bigexpression < $another_variable || $my_flag eq "Y") && $this_is_too_bloody_wide == 1 && $ace > my_func() && $another_answer == 42 && $pi == 3 ) {
return join sort hashmap {$a =~ /^server_/ ? $b : +()} %configuration_hash;
print "@_\n"; 4109 4121 6823 12967 12971 14003 20186
my @articles = sort {$a <=> $b} @files; my @articles = sort {$b <=> $a} @files;
@l = (4109, 4121, 6823, 12967, 12971, 14003, 20186, 1, 3, 4); @l = sort { $a <=> $b } @l; print "@l\n";
sub byage { $age{$a} <=> $age{$b}; } @sortedclass = sort byage @class;
@sorted_array = sort { $a <=> $b } @unsorted_array;
use strict; use warnings; my @other_array = (0,0,0,1,2,2,3,3,3,4); my %tallies; $tallies{$_} ++ for @other_array; print "$_ => $tallies{$_}\n" for sort {$a <=> $b} keys %tallies;
my @zeroes = (0) x 5; my @zeroes = (0) x @other_array;
use strict; use warnings; my @other_array = (0,0,0,1,2,2,3,3,3,4); my @array; my %uniqs; $uniqs{$_}++ for @other_array; foreach (keys %uniqs) { $array[$_]=$uniqs{$_} } print "array[$_] = $array[$_]\n" for (0..$
array[0] = 3 array[1] = 1 array[2] = 2 array[3] = 3 array[4] = 1
my %config = ( group => { item1 => { foo => bar => }, item2 => { foo => bar => }, item3 => { foo => bar => }, }, );
use Benchmark qw(:all) ; use Storable qw(dclone); use Clone qw(clone); my %config = ( group => { item1 => { foo => bar => }, item2 => { foo => bar => }, item3 => { foo => bar => }, }, ); my $ref = $config{ timethese(100000, { });
use Storable qw(dclone); $group2 = dclone(\%group);
my $copy = clone (\@array); my %copy = %{ clone (\%hash) };
use Storable; my $serialized = freeze \%config; my %newconfig = %{ thaw($serialized) };
owner = "Peter Palfrader" email = "peter@peter@palfrader.org" ...
package Conf; use strict; our $AUTOLOAD; my $default_environment = "production"; my @valid_environments = qw( development production ); sub set_vars { my ($self) = @_; $self->{"access_token"} = if ( $self->env eq "development" ) { $self->{"root_dir"} = "/Users/patrickcollins/Documents/workspace/SysG_perl"; $self->{"server_base"} = "http: } elsif ($self->env eq "production" ) { $self->{"root_dir"} = "/mnt/SysG-production/current/lib"; $self->{"server_base"} = "http: $self->{"log_dir"} = "/mnt/SysG-production/current/log" } else { die "No environment defined\n"; } my $r = $self->{ my $b = $self->{ $self->{"working_dir"} ||= "$r/working"; $self->{"bin_dir"} ||= "$r/bin"; $self->{"log_dir"} ||= "$r/log"; $self->{"new_contract_url"} = "$b/SysG-training-center/v1/contract/new"; $self->{"new_documents_url"} = "$b/SysG-training-center/v1/documents/new"; } sub new { my ($class,$env) = @_; my $self = {}; bless ($self,$class); if ($env) { $self->env($env); } else { $self->env($default_environment); } $self->set_vars; return $self; } sub AUTOLOAD { my ($self,$val) = @_; my $type = ref ($self) || die "$self is not an object"; my $field = $AUTOLOAD; $field =~ s/.*: unless (exists $self->{$field} || $field =~ /DESTROY/ ) { die "ERROR: {$field} does not exist in object/class $type\n"; } $self->{$field} = $val if ($val); return $self->{$field}; } sub env { my ($self,$in) = @_; if ($in) { die ("Invalid environment $in") unless (grep($in,@valid_environments)); $self->{"_env"} = $in; } return $self->{"_env"}; } 1;
Byte order is not compatible at ../../lib/Storable.pm (autosplit into ../../lib/auto/Storable/_retrieve.al) line 380, at /usr/lib/perl5/5.10/Memoize/Storable.pm line 21
$ perl --version This is perl, v5.10.1 (*) built for i686-cygwin-thread-multi-64int (with 12 registered patches, see perl -V for more detail)
% mv .git/svn .git/svn.bak % git svn fetch Migrating from a git-svn v1 layout... Data from a previous version of git-svn exists, but .git/svn (required for this version (1.7.1) of git-svn) does not exist. Done migrating from a git-svn v1 layout Rebuilding .git/svn/refs/remotes/bg-threads-1.1/.rev_map.a5d90c62-d51d-0410-9f91-bf5351168976 ... r5758 = 545e176a13e87d44a2750ff5f06959088efc9e5b ...
for ($i = 0; $i < @ARGV; $i++) { printf("%d\t= 0x%x\t= 0b%b\n", $ARGV[$i], $ARGV[$i], $ARGV[$i]); }
for ($i = 0; $i < @ARGV; $i++) { $val = hex($ARGV[$i]); printf("0x%x\t= %d\t= 0b%b\n", $val, $val, $val); }
for ($i = 0; $i < @ARGV; $i++) { $val = oct($ARGV[$i]); printf("0b%b\t= %d\t= 0x%x\n", $val, $val, $val); }
@rainbow = ("a".."z"); @slice = @rainbow[1..-5]; print "@slice\n";
my @indices = 1 .. -5; print "Indices are [@indices]\n";
"2011-04-11 00:39:28,736::[main]::INFO (Main.java:73) Test.Main::main() Total Successful Transactions = 195".
while (<>) { if (/Total Successful Transactions = (\d+)/) { print "$1\n"; } }
while (<>) { print "$1\n" if /Total Successful Transactions = (\d+)/; }
$ perl -e print ( ( $str =~ /(Xy = (\d))/ )[1] ); print "\n";' 3
$ echo "some data IN 123 OUT some more data is about to follow: IN 256 OUT done with data out" | perl -e IN 123 OUT IN 256 OUT
print $string =~ /Total Successful Transactions = (\d+)/;
use strict; use warnings; my $string = q{"2011-04-11 00:39:28,736::[main]::INFO (Main.java:73) Test.Main::main() Total Successful Transactions = 195".}; my ($number) = $string =~ m{ (\d+) " \. \z}x; print "Matched number: $number\n" if defined $number;
my $str = $str =~ /Total Successful Transactions = (\d+)/; print $1;
if ("2011-04-11 00:39:28,736::[main]::INFO (Main.java:73) Test.Main::main() Total Successful Transactions = 195" =~ /(\d+)$/) { print $1; }
use strict; use warnings; use 5.010; { package A; sub new { my $class = shift; bless \$class => $class } sub hello { say } { package B; use Data::Dumper; sub new { my $class = shift; bless { @_ } => $class } sub hello { say sub dump { Dumper $_[0] } } $_->hello for A->new, B->new( foo =>
use strict; use warnings; { package A; use Exporter; our @ISA = qw(Exporter); our @EXPORT_OK = qw(a_sub); our @EXPORT = qw(a_sub); sub a_sub { } } { package B; use Exporter; our @ISA = qw(Exporter); our @EXPORT_OK = qw(b_sub); our @EXPORT = qw(b_sub); sub b_sub { } } use boolean; use Data::Dumper; import A qw(a_sub); import B qw(b_sub); a_sub(); b_sub();
$array_ref->[$i] $hash_ref->{$k} $code_ref->(@args)
{ package Foo::Baz; sub new { my ($class, $arg) = @_; my $self = bless({}, $class); $self->{arg} = $arg; return $self; } sub mysub1 { my ($self) = @_; print($self->{arg}, "\n"); } } { package Foo::Bar; our @ISA = sub mysub2 { my ($self) = @_; print(uc($self->{arg}), "\n"); } } my $o = Foo::Bar->new( $o->mysub1(); $o->mysub2();
use FOO; $FOO = new FOO(); $FOO->SetAge(21); print $FOO->GetAge(); print FOO::GetAge();
sub _user_agent_get_basic_credentials_patch { return ($username, $password); } my $agent = LWP::UserAgent->new(); $agent->get_basic_credentials = _user_agent_get_basic_credentials_patch;
MONKEY_PATCH_INSTANCE: { my $counter = 1; sub monkey_patch_instance { my($instance, $method, $code) = @_; my $package = ref($instance) . no strict @{$package . *{$package . bless $_[0], $package; } }
package Dog; sub new { bless {}, shift } sub speak { print "woof!\n" } ... package main; my $dog1 = Dog->new; my $dog2 = Dog->new; monkey_patch_instance($dog2, speak => sub { print "yap!\n" }); $dog1->speak; $dog2->speak;
local *LWP::UserAgent::get_basic_credentials = sub { return ( $username, $password ); };
{ package My::LWP::UserAgent; our @ISA = qw/LWP::UserAgent/; sub get_basic_credentials { return ( $username, $password ); }; $agent = bless $agent; }
use strict; use warnings; { package Monkey; sub new { return bless {}, shift } sub bar { return } use Scalar::Util qw(refaddr); my $f = Monkey->new; my $g = Monkey->new; my $h = Monkey->new; print $f->bar, "\n"; monkey_patch( $f, monkey_patch( $g, print $f->bar, "\n"; print $g->bar, "\n"; print $h->bar, "\n"; my %originals; my %monkeys; sub monkey_patch { my ( $obj, $method, $new ) = @_; my $package = ref($obj); $originals{$method} ||= $obj->can($method) or die "no method $method in $package"; no strict no warnings $monkeys{ refaddr($obj) }->{$method} = $new; *{ $package . if ( my $monkey_patch = $monkeys{ refaddr( $_[0] ) }->{$method} ) { return $monkey_patch->(@_); } else { return $originals{$method}->(@_); } }; }
sub _user_agent_get_basic_credentials_patch { return ($username, $password); } my $agent = LWP::UserAgent->new(); $agent->get_basic_credentials = _user_agent_get_basic_credentials_patch;
( $agent->get_basic_credentials() ) = _user_agent_get_basic_credentials_patch();
assign the result of to the value that was returned from
{ package FooBar; sub foo(){ return 5; } 1; } my $x = bless( {}, "FooBar" ); sub baz(){ return 1; } $x->foo() = baz();
$agent->{get_basic_credentials} = _user_agent_get_basic_credentials_patch;
1. Dereference $agent, which is a HashRef 2. Set the hash-key
{ package FooBar; sub foo(){ return 5; } 1; } my $x = bless( {}, "FooBar" ); sub baz(){ return 1; } $x->{foo} = baz();
MONKEY_PATCH_INSTANCE: { my $counter = 1; sub monkey_patch_instance { my($instance, $method, $code) = @_; my $package = ref($instance) . no strict my $oldFunction = \&{ref($instance). @{$package . *{$package . my ($self, @args) = @_; $code->($self, $oldFunction, @args); }; bless $_[0], $package; } } monkey_patch_instance($dbh, prepare => sub { my ($self, $oldFunction, @args) = @_; print "Monkey patch (before)\n"; my $output = $oldFunction->(($self, @args)); print "Monkey patch (after)\n"; return $output; });
$agent->{get_basic_credentials} = _user_agent_get_basic_credentials_patch;
my %feature_bundle = ( "5.10" => [qw(switch say state)], "5.11" => [qw(switch say state unicode_strings)], "5.12" => [qw(switch say state unicode_strings)], "5.13" => [qw(switch say state unicode_strings)], "5.14" => [qw(switch say state unicode_strings)], );
if (PL_compcv && vcmp(sv, sv_2mortal(upg_version(newSVnv(5.011000), FALSE))) >= 0) { PL_hints |= (HINT_STRICT_REFS | HINT_STRICT_SUBS | HINT_STRICT_VARS); }
Unquoted string "say" may clash with future reserved word at foo line 5. String found where operator expected at foo line 5, near "say "hello world!"" (Do you need to predeclare say?) syntax error at foo line 5, near "say "hello world!"" Execution of foo aborted due to compilation errors.
$ cpan XML::Simple /home/gabor/perl5/perlbrew/perls/perl-5.12.3/bin/perl: symbol lookup error: /home/gabor/perl5/lib/perl5/x86_64-linux-gnu-thread-multi/auto/Cwd/Cwd.so: undefined symbol: Perl_Gthr_key_ptr
$ which cpan /home/gabor/perl5/perlbrew/perls/perl-5.12.3/bin/cpan
distro=lsb_release -d|cut -f2|tr arch=`uname -m` platform="$distro-$arch" export PERLBREW_ROOT=/net/share/perlbrew/$platform source $PERLBREW_ROOT/etc/bashrc perl5base=/net/share/perl perl5=$perl5base/$platform/$PERLBREW_PERL export PERL5LIB=`echo -n $PERL5LIB|sed "s|${perl5base}[^:]*||g"` export PATH=`echo -n $PATH|sed "s|${perl5base}[^:]*||g"` lib=$perl5/lib/perl5 mkdir -p $lib eval $(perl -I"$lib" -Mlocal::lib="$perl5")
$ perlswitch perl-5.18.4 Setting new perl /var/www/perl5/perlbrew/perls/perl-5.18.4/bin/perl... Using user perl (site_perl) instead of local::lib $ perlbrew list perl-5.16.3 * perl-5.18.4 perl-5.20.2
print "Is NaN\n" if $a eq print "Is Inf\n" if $a eq
my $inf = 9**9**9; my $neginf = -9**9**9; my $nan = -sin(9**9**9); sub isinf { $_[0]==9**9**9 || $_[0]==-9**9**9 } sub isnan { ! defined( $_[0] <=> 9**9**9 ) } sub signbit { substr( sprintf( for my $num ( $inf, $neginf, $nan ) { printf("%s:\tisinf: %d,\tisnan: %d,\tsignbit: %d\n", $num, isinf($num), isnan($num), signbit($num)); }
inf: isinf: 1, isnan: 0, signbit: 0 -inf: isinf: 1, isnan: 0, signbit: 1 nan: isinf: 0, isnan: 1, signbit: 0
die "This perl does not support NaN!\n" if "NaN" == "NaN";
C:\> perl -i -ape "splice (@F, 2, 0, q(inserted text)); $_ = qq(@F\n);" file1.txt Can
perl -i.bak -ape "splice...." file1.txt && del file1.bak
$ find . -name "*.xml" -print0 | xargs -0 perl -p -i.bak -e $ find . -name "*.bak" -print0 | xargs -0 rm
use Encode::Detect::Detector; my $unknown = "\x{54}\x{68}\x{69}\x{73}\x{20}\x{79}\x{65}\x{61}\x{72}\x{20}". "\x{49}\x{20}\x{77}\x{65}\x{6e}\x{74}\x{20}\x{74}\x{6f}\x{20}". "\x{b1}\x{b1}\x{be}\x{a9}\x{20}\x{50}\x{65}\x{72}\x{6c}\x{20}". "\x{77}\x{6f}\x{72}\x{6b}\x{73}\x{68}\x{6f}\x{70}\x{2e}"; my $encoding_name = Encode::Detect::Detector::detect($unknown); print $encoding_name; use Encode; my $string = decode($encoding_name, $unknown);
use utf8; use Text::Unidecode; my $string = print unidecode($string);
use utf8; use Encode qw(encode PERLQQ XMLCREF); my $string = print encode( print encode(
use Encode; my $a_with_ring = eval { decode( or die "Could not decode string: $@";
sub ENCRYPT_DECRYPT() { my $Str_Message=$_[0]; my $Len_Str_Message=length($Str_Message); my $Str_Encrypted_Message=""; for (my $Position = 0;$Position<$Len_Str_Message;$Position++){ my $Key_To_Use = (($Len_Str_Message+$Position)+1); $Key_To_Use =(255+$Key_To_Use) % 255; my $Byte_To_Be_Encrypted = substr($Str_Message, $Position, 1); my $Ascii_Num_Byte_To_Encrypt = ord($Byte_To_Be_Encrypted); my $Xored_Byte = $Ascii_Num_Byte_To_Encrypt ^ $Key_To_Use; my $Encrypted_Byte = chr($Xored_Byte); $Str_Encrypted_Message .= $Encrypted_Byte; } return $Str_Encrypted_Message; } my $var=&ENCRYPT_DECRYPT("hai"); print &ENCRYPT_DECRYPT($var);
my $regex = join "|", map quotemeta, @prefixes; $regex = qr/^($regex)/;
use strict; use warnings; use Benchmark qw(timethese cmpthese); my $count = shift || 10; our @items = map unpack("H8", pack "V", $_), 0..99999; our $nA = 16382; our $reA = join "|", @items[1 .. $nA]; our $nB = 16383; our $reB = join "|", @items[1 .. $nB]; $_ = qr/^($_)/ for $reA, $reB; my $results = timethese( $count, { $nA => q{ our (@items, $nA, $reA); $nA == grep /$reA/, @items or die; }, $nB => q{ our (@items, $nB, $reB); $nB == grep /$reB/, @items or die; }, } ); cmpthese( $results );
use strict; use warnings; my $continue = 1; $SIG{ $SIG{ my $i = 0; while ($continue) { print "Hello, I am running " . ++$i . "\n"; sleep 3; }
# . /etc/rc.d/init.d/functions pname="synpipe_server" exe="/usr/sbin/synpipe_server" pidfile="/var/run/${pname}.pid" lockfile="/var/lock/subsys/${pname}" [ -x $exe ] || exit 0 RETVAL=0 start() { echo -n "Starting $pname : " daemon ${exe} RETVAL=$? PID=$! echo [ $RETVAL -eq 0 ] && touch ${lockfile} echo $PID > ${pidfile} } stop() { echo -n "Shutting down $pname : " killproc ${exe} RETVAL=$? echo if [ $RETVAL -eq 0 ]; then rm -f ${lockfile} rm -f ${pidfile} fi } restart() { echo -n "Restarting $pname : " stop sleep 2 start } case "$1" in start) start ;; stop) stop ;; status) status ${pname} ;; restart) restart ;; *) echo "Usage: $0 {start|stop|status|restart}" ;; esac exit 0
[root@master init.d] Starting synpipe_server : Hello, I am running 1 Hello, I am running 2 Hello, I am running 3 Hello, I am running 4 Caught INT signal [ OK ] [root@master init.d]
start() { echo -n "Starting $pname : " if [ -s ${pidfile} ]; then RETVAL=1 echo -n "Already running !" && warning echo else nohup ${exe} >/dev/null 2>&1 & RETVAL=$? PID=$! [ $RETVAL -eq 0 ] && touch ${lockfile} && success || failure echo echo $PID > ${pidfile} fi }
Can lib/Spreadsheet/ParseExcel/Stream/XLS.pm line 31.
my ($wb, $idx, $row, $col, $cell); my $tmp = my $handler = sub { ($wb, $idx, $row, $col, $cell) = @_; $parser->transfer($main); XXX here }; my $tmp_p = $parser = Coro::State->new(sub { $xls->Parse($file); undef $xls; $parser->transfer($main) }); weaken($parser);
parser is undefined at lib/Spreadsheet/ParseExcel/Stream/XLS.pm line 29. Spreadsheet::ParseExcel::Stream::XLS::__ANON__ \ ( /usr/share/perl5/Spreadsheet/ParseExcel.pm line 2152 Spreadsheet::ParseExcel::_NewCell( \ called at /usr/share/perl5/Spreadsheet/ParseExcel.pm line 896 Spreadsheet::ParseExcel::_subLabelSST( \ called at /usr/share/perl5/Spreadsheet/ParseExcel.pm line 292 Spreadsheet::ParseExcel::parse( \ called at lib/Spreadsheet/ParseExcel/Stream/XLS.pm line 35 Spreadsheet::ParseExcel::Stream::XLS::__ANON__ \ called at new_importer.pl line 0
stream1 = open first excel stream sheet1 = stream1.sheet if in verbose mode: stream2 = open second excel stream sheet2 = stream2.sheet count++ while sheet2.get_row say "We have $count records"
use strict; use warnings; use Carp qw/longmess cluck confess/; sub foo { &bar; } sub bar { &baz; } sub baz { shift->(); } my %tests = ( ); while (my ($name, $sub) = each %tests) { print "$name - before eval:\n"; eval { foo($sub); }; print "$name - before if:\n"; if ($@) { print "caught: $@"; } print "$name - done\n\n"; }
my $i = 1; print "Stack Trace:\n"; while ( (my @call_details = (caller($i++))) ){ print $call_details[1].":".$call_details[2]." in function ".$call_details[3]."\n"; }
use HTML::Entities; my $html = "Snoopy &amp; Charlie Brown"; print decode_entities($html), "\n";
use Text::Unidecode qw(unidecode); use HTML::Entities qw(decode_entities); my $source = print unidecode(decode_entities($source));
$string = join " ", map { ucfirst } split " ", $string;
eval "&verify_precondition_TEST$n"; print $@ if $@;
if (eval "defined(&verify_precondition_TEST$n)") { eval "&verify_precondition_TEST$n"; print $@ if $@; } else { print "verify_precondition_TEST$n does not exist\n"; }
if (defined(&{"verify_precondition_TEST$n"}) { &{"verify_precondition_TEST$n"}; print $@ if $@; } else { print "verify_precondition_TEST$n does not exist\n"; }
sub function_exists { no strict my $funcname = shift; return \&{$funcname} if defined &{$funcname}; return; } if (my $subref = function_exists("verify_precondition_TEST$n") { ... }
my %symbols = (); my $package =__PACKAGE__; { no strict; %symbols = %{$package . "::"}; } print "$funcname not defined\n" if (! defined($symbols{$funcname});
my @keys = sort { $h{$a} <=> $h{$b} } keys(%h); my @vals = @h{@keys};
my @keys = sort { $h->{$a} <=> $h->{$b} } keys(%$h); my @vals = @{$h}{@keys};
my @keys = sort { $a cmp $b } keys %hash; foreach my $key ( @keys ) { printf "%-20s %6d\n", $key, $hash{$key}; }
my @keys = sort { $hash{$a} <=> $hash{$b} } keys %hash;
my @keys = sort { $hash{$a} <=> $hash{$b} or "\L$a" cmp "\L$b" } keys %hash;
my ( @nums, @words ); do { push @nums, shift @$_; push @words, shift @$_; } foreach sort { $a->[0] <=> $b->[0] } map { [ $h->{ $_ }, $_ ] } keys %$h ;
use strict; use warnings; my %hash = ( small => 1, medium => 5, largest => 10, large => 8, tiny => 0.1, );
sub largest_value (\%) { my $hash = shift; keys %$hash; my ($large_key, $large_val) = each %$hash; while (my ($key, $val) = each %$hash) { if ($val > $large_val) { $large_val = $val; $large_key = $key; } } $large_key } print largest_value %hash;
sub largest_value_mem (\%) { my $hash = shift; my ($key, @keys) = keys %$hash; my ($big, @vals) = values %$hash; for (0 .. $ if ($vals[$_] > $big) { $big = $vals[$_]; $key = $keys[$_]; } } $key } print largest_value_mem %hash;
10 keys: Rate largest_with_sort largest_value largest_value_mem largest_with_sort 111565/s -- -8% -13% largest_value 121743/s 9% -- -5% largest_value_mem 127783/s 15% 5% -- 50 keys: Rate largest_with_sort largest_value largest_value_mem largest_with_sort 24912/s -- -37% -40% largest_value 39361/s 58% -- -6% largest_value_mem 41810/s 68% 6% -- 100 keys: Rate largest_with_sort largest_value largest_value_mem largest_with_sort 9894/s -- -50% -56% largest_value 19680/s 99% -- -12% largest_value_mem 22371/s 126% 14% -- 1,000 keys: Rate largest_with_sort largest_value largest_value_mem largest_with_sort 668/s -- -69% -71% largest_value 2183/s 227% -- -7% largest_value_mem 2341/s 250% 7% -- 10,000 keys: Rate largest_with_sort largest_value largest_value_mem largest_with_sort 46.5/s -- -79% -81% largest_value 216/s 365% -- -11% largest_value_mem 242/s 421% 12% --
use List::Util qw( reduce ); my $max_val_key = reduce { $hash{$a} > $hash{$b} ? $a : $b } keys %hash;
my $key_for_max_value; my $max_value = -1; while ((my $key, my $value) = each %hash) { if ($value > $max_value) { $max_value = $value; $max_key = $key; } }
reverse sort { $hash{$a} <=> $hash{$b} } keys %hash
(reverse sort { $hash{$a} <=> $hash{$b} } keys %hash)[0]
my ($max_key, $max_val) = each %hash or die "hash is empty"; while (my ($key, $val) = each %hash) { $max_key = $key, $max_val = $val if $val > $max_val; }
my $highest_val = (sort { $hash{$a} <=> $hash{$b} } keys %hash)[0];
my @array = map {[$hash{$_},$_]} keys %hash; my $key_with_highest_value = (sort { $a->[0] <=> $b->[0] } @array)[0]->[1]
my $highest_val = (keys {$hash{$b} <=> $hash{$a}} keys %hash)[0];
if (ref $var eq ref {}) { print "$var is a hash\n"; } use Scalar::Util qw/reftype/; if (reftype $var eq reftype {}) { print "$var is a hash\n"; }
ref($hash_ref) eq ref($array_ref) eq ref( $hash{$key} ) eq
use Params::Util qw<_HASH _HASH0 _HASHLIKE>; print "$ref is a hash\n" if _HASH( $ref ); print "$ref is a hash\n" if _HASH0( $ref ); print "$ref is hashlike\n" if _HASHLIKE( $ref );
$/ = undef; $file = <>; $file =~ s/START\s+STOP/REPLACE/sg; print $file;
perl -ni -e if ( $a =~ s/START\s+STOP/REPLACE/s ) { print $a; $a=""; } \ END{$a && print $a}
perl -i -ne { print $x; $last = ""; } else { print $last; $last = $_; } \ print $last if eof ARGV
print+pack+q,c*,,map$.+=$_,74,43,-2,1,-84, 65,13,1,5,-12,-3, 13,-82,44,21, 18,1,-70,56, 7,-77,72,-7,2, 8,-6,13,-70,-34
print(+pack(+q,c*,, map{$.+=$_} (74,43,-2,1,-84, 65,13,1,5,-12,-3, 13,-82,44,21, 18,1,-70,56, 7,-77,72,-7,2, 8,-6,13,-70,-34)))
print(+pack(+ map{$.+=$_} (74,43,-2,1,-84, 65,13,1,5,-12,-3, 13,-82,44,21, 18,1,-70,56, 7,-77,72,-7,2, 8,-6,13,-70,-34)))
@list_accumulator = (); for $n in (74, …, -34) { $. += $n; push @list_accumulator, chr($.) } print(join("", @list_accumulator))
q/Literal $1 String/ q!Another literal String! q,Third literal string,
use strict; use warnings; my $prev_value = 0; my @relative = (74,43,-2,1,-84, 65,13,1,5,-12,-3, 13,-82,44,21, 18,1,-70,56, 7,-77,72,-7,2, 8,-6,13,-70,-34); my @absolute = map($prev_value += $_, @relative); print pack("c*", @absolute);
for module in $(perldoc -u perllocal | grep -F cpanp uninstall "$module" done
$ cpanm --uninstall Apache::DBI Attempt to reload Scalar/Util.pm aborted. Compilation failed in require at /usr/share/perl5/vendor_perl/File/Temp.pm line 18. ...
$ mv /usr/local/lib64/perl5 /root/usr-local-lib64-perl5
use Your::Class; Your::Class->new(args => \@ARGV)->run;
my $myargs = CmdLineOptions->new( args=>\@ARGV ); if ($myargs->was_given(option=>"-test")) { &tests; } sub tests { require "Test/More.pm"; Test::More->import( is(1,1,"my tests go here"); exit; }
$ perl -E' %::x = ( "%::x" => 1 ); %::_ = ( "%::_" => 1 ); %Foo::x = ( "%Foo::x" => 1 ); %Foo::_ = ( "%Foo::_" => 1 ); package Foo; say "%x = ", keys(%x); say "%_ = ", keys(%_); say "%::x = ", keys(%::x); say "%::_ = ", keys(%::_); say "%Foo::x = ", keys(%Foo::x); say "%Foo::_ = ", keys(%Foo::_); ' %x = %Foo::x %_ = %::_ <-- surprise! %::x = %::x %::_ = %::_ %Foo::x = %Foo::x %Foo::_ = %Foo::_
${ *main::foo{SCALAR} } @{ *main::foo{ARRAY} } %{ *main::foo{HASH} }
The special symbol __PACKAGE__ contains the current package, but cannot (easily) be used to construct variable names.
package Report; sub gen_report { my $report = "This report is generated for ".caller().".\n"; ... } package MyModule; Report::gen_report();
perl -d:DebugHooks::Terminal script.pl perl -d:Trepan script.pl
$ PERLDB_OPTS="RemotePort=localhost:12345" perl -d test
Connection from 127.0.0.1:42994 Loading DB routines from perl5db.pl version 1.49 Editor support available. Enter h or main::(test:2): say 1; DB<1> n main::(test:3): say 2; DB<1> select $DB::OUT DB<2> n 2 main::(test:4): say 3; DB<2> n 3 Debugged program terminated. Use q to quit or R to restart, use o inhibit_exit to avoid stopping after program termination, h q, h R or h o to get additional info. DB<2>
my $txt = "abc3de"; while( $txt =~ /\G[a-z]/g ) { print "$&"; } while( $txt =~ /\G./g ) { print "$&"; }
my $txt = "abc3de"; while( $txt =~ /\G[a-z]/gc ) { print "$&"; } while( $txt =~ /\G./g ) { print "$&"; }
my $ua = LWP::UserAgent->new; my $can_accept = HTTP::Message::decodable; my $response = $ua->get( ); print $response->decoded_content;
use strict; use warnings; my %a = ( a => 1, b => 2, c => d => undef, r => 1, br => 2, cr => dr => ); my $c = %a; print $c;
use strict; use warnings; use 5.010; my %a = ( a => 1, b => 2, c => d => undef, r => 1, br => 2, cr => dr => ); my $c = %a; say $c; %a = ( a => 1, b => 21, c => br => 2, cr => dr => ); $c = %a; say $c; %a = ( a => 1, b => 2, c => d => undef, r => 1, br => 2, cr => dr => drr => ); $c = %a; say $c;
if (%h) { print "Entries in hash:\n"; for my $k (sort keys %h) { print "$k: $h{$k}\n"; } }
package Point; sub new { my ($class) = @_; my $self = { _x => 0, _y => 0, }; return bless $self => $class; } sub X { my ($self, $x) = @_; $self->{_x} = $x if defined $x; return $self->{_x}; } sub Y { my ($self, $y) = @_; $self->{_y} = $y if defined $y; return $self->{_y}; } 1;
use JSON; use Point; Point $p = new Point; $p->X(20); $p->Y(30); my $json = encode_json $p;
my $object = bless( JSON->new->decode( $json_string ),
use JSYNC; use Point; my $p = Point->new; $p->X(20); $p->Y(30); my $jsync = JSYNC::dump($p, {pretty => 1});
{ "!" : "!perl/hash:Point", "_x" : "20", "_y" : "30" }
sub foo : method ; my ($x,@y,%z) : Bent = 1; my $s = sub : method { ... }; use attributes (); my @attrlist = attributes::get(\&foo); use attributes my @attrlist = get \&foo;
use Attribute::Handlers; sub UNIVERSAL::loud : ATTR(CODE) { my ( $pkg, $sym, $code ) = @_; no warnings *{$sym} = sub { return uc $code->(@_); }; } sub foo : loud { return "this is $_[0]"; } say foo("a spoon"); say foo("a fork");
my $x : Bent $x = 1; my @y : Bent @y = 1; my %Z : Bent %z = 1;
use Attribute::Handlers; use Tie::Toggle; sub UNIVERSAL::Toggle : ATTR(SCALAR) { my ($package, $symbol, $referent, $attr, $data, $phase) = @_; my @data = ref $data eq tie $$referent, } my $x : Toggle; say "x is ", $x; say "x is ", $x; say "x is ", $x;
use strict; use warnings; use Runner; sub func_a : RUNNR(2) {return "You called func_a !"}; sub func_b : RUNNR(1) {return "You called func_b !"}; sub func_c : RUNNR(3) {return "You called func_c !"}; sub run { foreach my $func (@$Runner::schedule) { if ( defined $func ) { print "Running : $func --> ", $func->(), "\n"; } } } print "Starting ...\n\n"; run(); print "\nDone !\n";
package Runner; use strict; use warnings; use attributes; BEGIN { use Exporter (); our (@ISA, @EXPORT); @ISA = qw(Exporter); @EXPORT = qw(&MODIFY_CODE_ATTRIBUTES); } sub MODIFY_CODE_ATTRIBUTES { my ($pckg, $code_ref, @attr) = @_; foreach my $attr (@attr) { if ( $attr =~ /^RUNNR\((\d+)\)$/ ) { $Runner::schedule->[$1] = $code_ref; } } return(); } 1;
Starting ... Running : CODE(0x129c288) --> You called func_b ! Running : CODE(0x129c2b8) --> You called func_a ! Running : CODE(0x12ed460) --> You called func_c ! Done !
use Tie::Hash::Cannabinol; my %hash; tie %hash, my %hash : Stoned;
use strict; use Carp::Assert; sub callable { my ($func) = @_; return defined(&$func); } sub get_stash_and_crtash { my $stash = eval("\\%" . __PACKAGE__ . "::"); my %coderef_to_sym; while (my ($k, $v) = each(%$stash)) { $coderef_to_sym{$v} = $k if (callable($v)); } return ($stash, \%coderef_to_sym); } sub insert_context { my ($inner, $outer) = @_; my $args_pat = qr/\((.*)\)$/; $outer .= $outer =~ /$args_pat/; $1 ? $outer =~ s/$args_pat/($inner, $1)/ : $outer =~ s/$args_pat/($inner)/; return $outer; } sub MODIFY_CODE_ATTRIBUTES { my ($cls, $ref, @attrs) = @_; assert($cls eq assert(ref($ref) eq for (@attrs) { assert(/^appender_d\(.*\)$/ || $_ eq } my @non_decorators = grep { !/^\w+_d\b/ } @attrs; return @non_decorators if (@non_decorators); my ($stash, $crtash) = get_stash_and_crtash(); my $sym = $crtash->{$ref}; $stash->{$sym} = sub { my $ref = $ref; my $curr = for my $attr (@attrs) { $curr = insert_context($curr, $attr); } eval("${curr}->()"); }; return (); } sub appender_d { my ($func, $chars) = @_; return sub { $func->() . $chars }; } sub upper_d { my ($func) = @_; return sub { uc($func->()) }; } sub foo : upper_d appender_d( return "foo"; } sub main { print(foo()); } main();
use strict; use warnings; use Test::More; use TestClass; *STDIN = "1\n"; foreach my $file (@files) { my $test = TestClass->new( file=> @files ); isa_ok( $test, } done_testing;
package TestClass; use strict; use warnings; sub new { my $class = shift; return unless <STDIN> eq "1\n"; bless {} => $class; } package main; use strict; use warnings; use Test::More tests => 1; { open my $stdin, or die "Cannot open STDIN to read from string: $!"; local *STDIN = $stdin; my $test = TestClass->new; isa_ok( $test, }
use strict; use warnings; use Test::More; *STDIN = *DATA; my @a = <STDIN>; is_deeply \@a, ["foo\n", "bar\n", "baz\n"], "can read from the DATA section"; my $fakefile = "1\n2\n3\n"; open my $fh, "<", \$fakefile or die "could not open fake file: $!"; *STDIN = $fh; my @b = <STDIN>; is_deeply \@b, ["1\n", "2\n", "3\n"], "can read from a fake file"; done_testing; __DATA__; foo bar baz
$ locale LANG=de_DE.UTF-8 LC_CTYPE="de_DE.UTF-8" LC_NUMERIC="de_DE.UTF-8" LC_TIME="de_DE.UTF-8" LC_COLLATE="de_DE.UTF-8" LC_MONETARY="de_DE.UTF-8" LC_MESSAGES="de_DE.UTF-8" LC_PAPER="de_DE.UTF-8" LC_NAME="de_DE.UTF-8" LC_ADDRESS="de_DE.UTF-8" LC_TELEPHONE="de_DE.UTF-8" LC_MEASUREMENT="de_DE.UTF-8" LC_IDENTIFICATION="de_DE.UTF-8" LC_ALL=de_DE.UTF-8
$ perldoc perl/MyMod.pm <standard input>:72: warning: can <standard input>:72: warning: can MyMod(3) User Contributed Perl Documentation MyMod(3) NAME MyMod.pm - Just a Test: Ã¤Ã¶Ã¼ÃÃÃ perl v5.10.0 2008-10-16 MyMod(3)
sub make_saying { my $salute = shift; my $newfunc = sub { my $target = shift; print "$salute, $target!\n"; }; return $newfunc; } $f = make_saying("Howdy"); $g = make_saying("Greetings"); $f->("world"); $g->("earthlings");
my $f = \&make_saying; my $other_f = $f->("Howdy"); $other_f->("world");
$word =~ /^[[:alnum:]]+$/ $word =~ /^[[:alnum:]]+$/a { use locale; $word =~ /^[[:alnum:]]+$/; }
use warnings; use strict; use utf8; use v5.14; use POSIX qw(locale_h); use Encode; binmode STDOUT, "utf8"; sub codepoint { my $inputp = $_[0]; return unpack( } sub verify { my($inputp, $code) = @_; if (codepoint($inputp) != $code) { die sprintf( } } sub getlocale { return setlocale(LC_ALL); } my $rowindex = 0; my $origlocale = getlocale(); verify( verify( verify( sub tryWith { my ($input) = @_; matchWith( matchWith( matchWith( matchWith( matchWith( } sub matchWith { my ($pattern, $input) = @_; my @locales_to_test = ($origlocale, for my $testlocale (@locales_to_test) { use locale; setlocale(LC_ALL, $testlocale); printResult($pattern, $input, printResult($pattern, $input, printResult($pattern, $input, printResult($pattern, $input, }; no locale; setlocale(LC_ALL, $origlocale); printResult($pattern, $input, printResult($pattern, $input, printResult($pattern, $input, printResult($pattern, $input, } sub printResult{ no warnings my ($pattern, $input, $flags) = @_; my $regexp = qr/$pattern/; $regexp = qr/$pattern/u if ($flags eq $regexp = qr/$pattern/l if ($flags eq printf("%2d: %s\t%03d\t%-20s\t%-25s\t%-10s\t%-5s\n", $rowindex, $input, codepoint($input), getlocale(), $flags, $pattern, (($input =~ $regexp) ? $rowindex = $rowindex + 1; } tryWith( tryWith( tryWith(
function match(pattern, input) { try { var re = new RegExp(pattern, "u"); return input.match(re) !== null; } catch(e) { return } } function regexptest() { var chars = [ String.fromCodePoint(118), String.fromCodePoint(353), String.fromCodePoint(382) ]; for (var i = 0; i < chars.length; i++) { var char = chars[i]; console.log( char + + char.codePointAt(0) + +(match("[a-z]", char)) + +(match("\\w", char)) + +(match("[[:alpha:]]", char)) + +(match("\\p{Alpha}", char)) + +(match("\\p{L}", char)) ); } } regexptest();
$ echo xuzvöä | LC_ALL=C grep [a-z] xuzvöä $ echo xuzvöä | LC_ALL=et_EE.utf8 grep [a-z] xuzvöä $ echo xuzvöä | LC_ALL=C grep [[:alpha:]] xuzvöä $ echo xuzvöä | LC_ALL=et_EE.utf8 grep [[:alpha:]] xuzvöä $ echo xuzvöä | LC_ALL=C grep \\w xuzvöä $ echo xuzvöä | LC_ALL=et_EE.utf8 grep \\w xuzvöä
val oranges:Stream[Oranges] = ... oranges.filter(_.isNotRotten).grouped(10).foreach{ o => {(new Box).fillBox(o)}}
my $current_container; my $more_objects; do { my $object = get_next_object(); $more_objects = more_objects($object) if (!$more_objects || can_not_pack_more($current_container) { close_container($current_container); $current_container = open_container() if $more_objects; } pack($object, $current_container) if $more_objects; } while ($more_objects);
my $current_container; while (my $more_objects = more_objects(my $object = get_next_object())) { if (can_not_pack_more($current_container)) { close_container($current_container); } $current_container = open_container_if_closed($current_container); pack($object, $current_container); } close_container($current_container);
use List::MoreUtils qw(part natatime); my ($good, $bad) = part { $_->is_rotten() } @oranges; $_->dispose() foreach @$bad; my $it = natatime 10, @$good; while (my @batch = $it->()) { my $box = Box->new(); $box->add(@batch); $box->close(); $box->stack(); }
while( <> ) { study; $count++ if /PATTERN/; $count++ if /OTHER/; $count++ if /PATTERN2/; }
# use strict; use warnings; use Benchmark; my $dna = join ( agatggcggcgctgaggggtcttgggggctctaggccggccacctactgg tttgcagcggagacgacgcatggggcctgcgcaataggagtacgctgcct gggaggcgtgactagaagcggaagtagttgtgggcgcctttgcaaccgcc tgggacgccgccgagtggtctgtgcaggttcgcgggtcgctggcgggggt cgtgagggagtgcgccgggagcggagatatggagggagatggttcagacc cagagcctccagatgccggggaggacagcaagtccgagaatggggagaat gcgcccatctactgcatctgccgcaaaccggacatcaactgcttcatgat cgggtgtgacaactgcaatgagtggttccatggggactgcatccggatca ctgagaagatggccaaggccatccgggagtggtactgtcgggagtgcaga gagaaagaccccaagctagagattcgctatcggcacaagaagtcacggga gcgggatggcaatgagcgggacagcagtgagccccgggatgagggtggag ggcgcaagaggcctgtccctgatccagacctgcagcgccgggcagggtca gggacaggggttggggccatgcttgctcggggctctgcttcgccccacaa atcctctccgcagcccttggtggccacacccagccagcatcaccagcagc agcagcagcagatcaaacggtcagcccgcatgtgtggtgagtgtgaggca tgtcggcgcactgaggactgtggtcactgtgatttctgtcgggacatgaa gaagttcgggggccccaacaagatccggcagaagtgccggctgcgccagt gccagctgcgggcccgggaatcgtacaagtacttcccttcctcgctctca ccagtgacgccctcagagtccctgccaaggccccgccggccactgcccac ccaacagcagccacagccatcacagaagttagggcgcatccgtgaagatg agggggcagtggcgtcatcaacagtcaaggagcctcctgaggctacagcc acacctgagccactctcagatgaggaccta )); my $protein = join( MNIDDKLEGLFLKCGGIDEMQSSRTMVVMGGVSGQSTVSGELQD SVLQDRSMPHQEILAADEVLQESEMRQQDMISHDELMVHEETVKNDEEQMETHERLPQ GLQYALNVPISVKQEITFTDVSEQLMRDKKQIR )); my $count = 1000; print "DNA pattern matches without timethis($count, $dna =~ /aggtc/; $dna =~ /aatggccgt/; $dna =~ /gatcgatcagctagcat/; $dna =~ /gtatgaac/; $dna =~ /[ac][cg][gt][ta]/; $dna =~ /ccccccccc/; } ' ); print "\nDNA pattern matches with timethis($count, for(my $i=1 ; $i < 10000; ++$i) { $dna =~ /aggtc/; $dna =~ /aatggccgt/; $dna =~ /gatcgatcagctagcat/; $dna =~ /gtatgaac/; $dna =~ /[ac][cg][gt][ta]/; $dna =~ /ccccccccc/; } ' ); print "\nProtein pattern matches without timethis($count, $protein =~ /PH.EI/; $protein =~ /KFTEQGESMRLY/; $protein =~ /[YAL][NVP][ISV][KQE]/; $protein =~ /DKKQIR/; $protein =~ /[MD][VT][HQ][ER]/; $protein =~ /NVPISVKQEITFTDVSEQL/; } ' ); print "\nProtein pattern matches with timethis($count, for(my $i=1 ; $i < 10000; ++$i) { $protein =~ /PH.EI/; $protein =~ /KFTEQGESMRLY/; $protein =~ /[YAL][NVP][ISV][KQE]/; $protein =~ /DKKQIR/; $protein =~ /[MD][VT][HQ][ER]/; $protein =~ /NVPISVKQEITFTDVSEQL/; } ' );
if (len == 0 || len > I32_MAX || !SvPOK(sv) || SvUTF8(sv) || SvVALID(sv)) { RETPUSHNO; }
package MyApp::Meta::Class::Trait::HasTable; use Moose::Role; sub foo { warn package Moose::Meta::Class::Custom::Trait::HasTable; sub register_implementation { package MyApp::User; use Moose -traits => __PACKAGE__->foo();
package MyApp::Meta::Class::Trait::HasTable; use Moose::Role; sub foo { warn package Moose::Meta::Class::Custom::Trait::HasTable; sub register_implementation { package MyApp::User; use Moose; with __PACKAGE__->foo();
package MyApp::Meta::Class::Trait::HasTable; use Moose::Role; sub foo { warn package Moose::Meta::Class::Custom::Trait::HasTable; sub register_implementation { package MyApp::User; use Moose -traits => __PACKAGE__->meta->foo();
package MyApp::Meta::Class::Trait::HasTable; use Moose::Role; has table => ( is => isa => ); package Moose::Meta::Class::Custom::Trait::HasTable; sub register_implementation { package MyApp::User; use Moose -traits => __PACKAGE__->meta->table(
my $receiverEmail = "receiver\@yahoo.com"; my $pubDataDirectory = "../goliath"; my $privDataDirectory = "../../cgi-data/donationNet"; my $donationLogFile = "$privDataDirectory/donationLog.txt"; my $overallSumFile = "$pubDataDirectory/overallSum.html"; my $overallCountFile = "$pubDataDirectory/donationCount.html"; my $topSiteListFile = "$pubDataDirectory/topSiteList.html"; my $siteTrackingFile = "$privDataDirectory/siteTracking.txt"; my $logFile = "$privDataDirectory/log.txt"; my $paypalNotifyIP = "216.113.188.202"; use CGI::Carp qw( carpout ); BEGIN { my $errorLogLocation = "../../cgi-data/donationNet/errors.log"; use CGI::Carp qw( carpout ); open( LOG, ">>$errorLogLocation" ) or die( "Unable to open $errorLogLocation: $!\n" ); carpout( LOG ); } use strict; use CGI; if( not doesFileExist( $overallSumFile ) ) { writeFile( $overallSumFile, "0" ); } if( not doesFileExist( $overallCountFile ) ) { writeFile( $overallCountFile, "0" ); } if( not doesFileExist( $topSiteListFile ) ) { writeFile( $topSiteListFile, "" ); } if( not doesFileExist( $siteTrackingFile ) ) { writeFile( $siteTrackingFile, "" ); } umask( oct( "02" ) ); my $cgiQuery = CGI->new(); print $cgiQuery->header( -type=> -Cache_control=> my $remoteAddress = $cgiQuery->remote_host(); my $action = $cgiQuery->param( "action" ) || if( $action eq "checkResults" ) { my $sum = readTrimmedFileValue( $overallSumFile ); my $count = readTrimmedFileValue( $overallCountFile ); print "$count \$$sum"; } elsif( $remoteAddress eq $paypalNotifyIP ) { my $donorName; my $customField = $cgiQuery->param( "custom" ) || ( my $siteURL ) = ( $customField =~ /(\S+)/ ); my $amount = $cgiQuery->param( "mc_gross" ) || my $currency = $cgiQuery->param( "mc_currency" ) || my $fee = $cgiQuery->param( "mc_fee" ) || my $date = $cgiQuery->param( "payment_date" ) || my $transactionID = $cgiQuery->param( "txn_id" ) || my $payerFirstName = $cgiQuery->param( "first_name" ) || my $payerLastName = $cgiQuery->param( "last_name" ) || my $payerEmail = $cgiQuery->param( "payer_email" ) || if( $currency eq "USD" ) { my $status = $cgiQuery->param( "payment_status" ) || my $completed = $status eq "Completed"; my $pending = $status eq "Pending"; my $refunded = $status eq "Refunded"; if( $completed or $pending or $refunded ) { addToFile( $donationLogFile, "$transactionID $date\n" . "From: $payerFirstName $payerLastName " . "($payerEmail)\n" . "Amount: \$$amount\n" . "Fee: \$$fee\n" . "Status: $status\n\n" ); my $netDonation; if( $refunded ) { my $oldSum = readTrimmedFileValue( $overallSumFile ); $netDonation = $amount - $fee; my $newSum = $oldSum + $netDonation; my $newSumString = sprintf( "%.2f", $newSum ); writeFile( $overallSumFile, $newSumString ); my $oldCount = readTrimmedFileValue( $overallCountFile ); my $newCount = $oldCount - 1; writeFile( $overallCountFile, $newCount ); } if( $completed and $amount > 0 ) { my $oldSum = readTrimmedFileValue( $overallSumFile ); $netDonation = $amount - $fee; my $newSum = $oldSum + $netDonation; my $newSumString = sprintf( "%.2f", $newSum ); writeFile( $overallSumFile, $newSumString ); my $oldCount = readTrimmedFileValue( $overallCountFile ); my $newCount = $oldCount + 1; writeFile( $overallCountFile, $newCount ); } if( $siteURL =~ /http:\/\/\S+/ ) { my $siteTrackingText = readFileValue( $siteTrackingFile ); my @siteDataList = split( /\n/, $siteTrackingText ); my $newSiteData = ""; my $exists = 0; foreach my $siteData ( @siteDataList ) { ( my $url, my $siteSum ) = split( /\s+/, $siteData ); if( $url eq $siteURL ) { $exists = 1; $siteSum += $netDonation; } $newSiteData = $newSiteData . "$url $siteSum\n"; } if( not $exists ) { $newSiteData = $newSiteData . "$siteURL $netDonation"; } trimWhitespace( $newSiteData ); writeFile( $siteTrackingFile, $newSiteData ); sub highestTotal { ( my $url_a, my $total_a ) = split( /\s+/, $a ); ( my $url_b, my $total_b ) = split( /\s+/, $b ); return $total_b <=> $total_a; } my @newSiteDataList = split( /\n/, $newSiteData ); my @sortedList = sort highestTotal @newSiteDataList; my $listHTML = "<TABLE BORDER=0>\n"; foreach my $siteData ( @sortedList ) { ( my $url, my $siteSum ) = split( /\s+/, $siteData ); my $siteSumString = sprintf( "%.2f", $siteSum ); $listHTML = $listHTML . "<TR><TD><A HREF=\"$url\">$url</A></TD>". "<TD ALIGN=RIGHT>\$$siteSumString</TD></TR>\n"; } $listHTML = $listHTML . "</TABLE>"; writeFile( $topSiteListFile, $listHTML ); } } else { addToFile( $logFile, "Payment status unexpected\n" ); addToFile( $logFile, "status = $status\n" ); } } else { addToFile( $logFile, "Currency not USD\n" ); addToFile( $logFile, "currency = $currency\n" ); } } else { my $customField = $cgiQuery->param( "custom" ) || my $date = $cgiQuery->param( "payment_date" ) || my $transactionID = $cgiQuery->param( "txn_id" ) || my $amount = $cgiQuery->param( "mc_gross" ) || my $payerFirstName = $cgiQuery->param( "first_name" ) || my $payerLastName = $cgiQuery->param( "last_name" ) || my $payerEmail = $cgiQuery->param( "payer_email" ) || my $fee = $cgiQuery->param( "mc_fee" ) || my $status = $cgiQuery->param( "payment_status" ) || addToFile( $donationLogFile, "WARNING: got IPN from unexpected IP address\n" . "IP address: $remoteAddress\n" . "$transactionID $date\n" . "From: $payerFirstName $payerLastName " . "($payerEmail)\n" . "Amount: \$$amount\n" . "Fee: \$$fee\n" . "Status: $status\n\n" ); print "Request blocked."; } # # # sub readFileValue { my $fileName = $_[0]; open( FILE, "$fileName" ) or die( "Failed to open file $fileName: $!\n" ); flock( FILE, 1 ) or die( "Failed to lock file $fileName: $!\n" ); my @lineList = <FILE>; my $value = join( "", @lineList ); close FILE; return $value; } # # # sub readTrimmedFileValue { my $returnString = readFileValue( $_[0] ); trimWhitespace( $returnString ); return $returnString; } # # sub writeFile { my $fileName = $_[0]; my $stringToPrint = $_[1]; open( FILE, ">$fileName" ) or die( "Failed to open file $fileName: $!\n" ); flock( FILE, 2 ) or die( "Failed to lock file $fileName: $!\n" ); print FILE $stringToPrint; close FILE; } # # # sub doesFileExist { my $fileName = $_[0]; if( -e $fileName ) { return 1; } else { return 0; } } # sub trimWhitespace { $_[0] =~ s/^\s+ $_[0] =~ s/\s+$ } # # sub addToFile { my $fileName = $_[0]; my $stringToPrint = $_[1]; open( FILE, ">>$fileName" ) or die( "Failed to open file $fileName: $!\n" ); flock( FILE, 2 ) or die( "Failed to lock file $fileName: $!\n" ); print FILE $stringToPrint; close FILE; } # # sub makeDirectory { my $fileName = $_[0]; my $permissionMask = $_[1]; mkdir( $fileName, $permissionMask ); }
my $templateFile = "buttonTemplate.html"; use CGI::Carp qw( carpout ); BEGIN { my $errorLogLocation = "../../cgi-data/donationNet/errors.log"; use CGI::Carp qw( carpout ); open( LOG, ">>$errorLogLocation" ) or die( "Unable to open $errorLogLocation: $!\n" ); carpout( LOG ); } use strict; use CGI; my $cgiQuery = CGI->new(); print $cgiQuery->header( -type=> -Cache_control=> my $siteURL = $cgiQuery->param( "site_url" ) || print "Paste this HTML into your website:<BR>\n"; print "<FORM><TEXTAREA COLS=40 ROWS=10>\n"; my $buttonTemplate = readFileValue( $templateFile ); $buttonTemplate =~ s/SITE_URL/$siteURL/g; $buttonTemplate =~ s/&/&amp;/g; $buttonTemplate =~ s/</&lt;/g; $buttonTemplate =~ s/>/&gt;/g; print $buttonTemplate; print "\n</TEXTAREA></FORM>"; # # # sub readFileValue { my $fileName = $_[0]; open( FILE, "$fileName" ) or die( "Failed to open file $fileName: $!\n" ); flock( FILE, 1 ) or die( "Failed to lock file $fileName: $!\n" ); my @lineList = <FILE>; my $value = join( "", @lineList ); close FILE; return $value; } # # # sub readTrimmedFileValue { my $returnString = readFileValue( $_[0] ); trimWhitespace( $returnString ); return $returnString; } # # sub writeFile { my $fileName = $_[0]; my $stringToPrint = $_[1]; open( FILE, ">$fileName" ) or die( "Failed to open file $fileName: $!\n" ); flock( FILE, 2 ) or die( "Failed to lock file $fileName: $!\n" ); print FILE $stringToPrint; close FILE; } # # # sub doesFileExist { my $fileName = $_[0]; if( -e $fileName ) { return 1; } else { return 0; } } # sub trimWhitespace { $_[0] =~ s/^\s+ $_[0] =~ s/\s+$ } # # sub addToFile { my $fileName = $_[0]; my $stringToPrint = $_[1]; open( FILE, ">>$fileName" ) or die( "Failed to open file $fileName: $!\n" ); flock( FILE, 2 ) or die( "Failed to lock file $fileName: $!\n" ); print FILE $stringToPrint; close FILE; } # # sub makeDirectory { my $fileName = $_[0]; my $permissionMask = $_[1]; mkdir( $fileName, $permissionMask ); }
use constant { DIR_PRIVATE_DATA => "/paths/of/glory", FILE_DONATION_LOG => "donationLog.txt" }; open( FILE, ">>".DIR_PRIVATE_DATA."/".FILE_DONATION_LOG );
use strict; use warnings; use 5.10.1; use feature qw my $str = "testing 123"; given( $str ){ when(/(\d+)/){ say $1; } when( [0..10] ){ say $_, } }
use 5.010; if( $item ~~ @array ) { say "The array contains $item" } if( $item ~~ %hash ) { say "The hash contains $item" }
@blues = qw/azure cerulean teal turquoise lapis-lazuli/; %is_blue = (); for (@blues) { $is_blue{$_} = 1 }
@primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31); @is_tiny_prime = (); for (@primes) { $is_tiny_prime[$_] = 1 }
@articles = ( 1..10, 150..2000, 2017 ); undef $read; for (@articles) { vec($read,$_,1) = 1 }
sub first (&@) { my $code = shift; foreach (@_) { return $_ if &{$code}(); } undef; }
use List::Util qw/first/; my @a = qw(foo bar baz); if ( first { $_ eq
use List::MoreUtils qw/any/; my @array = qw(foo bar baz); print "Exist\n" if any {($_ eq "foo")} @array;
my %hash; map { $hash{$_}++ } @a; print $hash{$val};
$ perl -e if (grep{$_ eq $val} @a) { print "found" } else { print "not found" }'
sub first (&@) { my $code = shift; $code->() and return $_ foreach @_; undef } sub any (&@) { my $code = shift; $code->() and return 1 foreach @_; undef }
Customary Generic Meaning Interpolates "" qq{} Literal yes `` qx{} Command yes* qw{} Word list no qr{} Pattern yes* s{}{} Substitution yes* tr{}{} Transliteration no (but see below) <<EOF here-doc yes* * unless the delimiter is
for (my $i = 0; $i < @a; $i++) { &do_something_with($array[$i]); }
use integer;@A=split ==$i/9||$_%9==$i%9||$_/27==$i/27&&$_%9/3==$i%9/3?$A[$_]:0=>1}0..80;R($A[ $i]=$_)for grep{!$t{$_}}1..9;return$A[$i]=0}die@A}R
my $mech = WWW::Mechanize->new(); $mech->get( $some_url ); my @links = $mech->links(); for my $link ( @links ) { printf "%s, %s\n", $link->text, $link->url; }
if($ print "$0: Need URL argument.\n"; exit 1; } my @content = split(/\n/,`wget -qO- $ARGV[0]`); my @links = grep(/<a.*href=.*>/,@content); foreach my $c (@links){ $c =~ /<a.*href="([\s\S]+?)".*>/; $link = $1; $c =~ /<a.*href.*>([\s\S]+?)<\/a>/; $title = $1; print "$title, $link\n"; }
use pQuery; pQuery( sub { say $_->innerHTML . q{, } . $_->getAttribute( } );
my $tree=HTML::TreeBuilder::XPath->new_from_content($c); my $nodes=$tree->findnodes(q{ while (my $node=$nodes->shift) { my $t=$node->attr( }
use XML::LibXML; my $doc = XML::LibXML->load_html(IO => \*DATA); for my $anchor ( $doc->findnodes(" { printf "%15s -> %s\n", $anchor->textContent, $anchor->getAttribute("href"); } __DATA__ <html><head><title/></head><body> <a href="http: <a href="http: </body></html>
use HTML::LinkExtractor; my $input = q{If <a href="http: my $LX = new HTML::LinkExtractor(undef,undef,1); $LX->parse(\$input); for my $Link( @{ $LX->links } ) { if( $$Link{_TEXT}=~ m/Apple/ ) { print "\n LinkText $$Link{_TEXT} URL $$Link{href}\n"; } }
local $/ = my $a = <DATA>; while( $a =~ m/<a[^>]*?href=\"([^>]*?)\"[^>]*?>\s*([\w\W]*?)\s*<\/a>/igs ) { print "Link:$1 \t Text: $2\n"; } __DATA__ <a href="http: <a href="http:
my $output = qx(powercfg -l); open my $OUTPUT, print $OUTPUT $output; close $OUTPUT foreach my $line (split /[\r\n]+/, $output) { }
use strict; use warnings; open(my $fh, while (my $line = <$fh>) { }
my $output_file = system "powercfg -l > $output_file"; open my $fh, or die "Cannot open while ( my $line = <$fh> ) { } close $fh;
use strict; use warnings; use Win32::Process; if( my $pid = start_foo_bar_baz() ) { print "Started with $pid"; } :w sub start_foo_bar_baz { my $process_object; my $command = my $command_line = join my $inherit_flags = DETACHED_PROCESS; my $creation_flags = NORMAL_PRIORITY_CLASS; my $working_directory = my $ok = Win32::Process::Create( $process_object, $command, $command_line, $inherit_flags, $creation_flags, $working_directory, ); my $pid; if ( $ok ) { $pid = $wpc->GetProcessID; } else { warn "Unable to create process: " . Win32::FormatMessage( Win32::GetLastError() ) ; return; } return $pid; }
use strict; my @output = `powercfg -l`; chomp(@output); my $linecounter = 0; my $combined_line; foreach my $line(@output){ print $linecounter++.")"; print $line."\n"; $combined_line .= $line; } print "\n"; print "This is all on one line:\n"; print ">".$combined_line."<";
0) 1)Existing Power Schemes (* Active) 2)----------------------------------- 3)Power Scheme GUID: 381b4222-f694-41f0-9685-ff5bb260df2e (Balanced) * 4)Power Scheme GUID: 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c (High performance) 5)Power Scheme GUID: a1841308-3541-4fab-bc81-f71556f20b4a (Power saver) This is all on one line: >Existing Power Schemes (* Active)-----------------------------------Power Scheme GUID: 381b4222-f694-41f0-9685-ff5bb260df2e (Balanced) *Power Scheme GUID: 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c (High performance)Power Scheme GUID: a1841308-3541-4fab-bc81-f71556f20b4a (Power saver)<
sub openfile{ (my $filename) = @_; open FILE,"$filename" or die $!; my @lines = <FILE>; return @lines; }
my @lines = Module::File::Read("c:\some\folder\structure\file.txt");
my @array = do { open my $fh, "<", $filename or die "could not open $filename: $!"; <$fh>; };
my @lines = slurp my @lines_chomped = slurp my @lines_utf8 = slurp
use 5.010; use strict; my @rows = do { use warnings FATAL => @ARGV= <>; }; say q(Not gettin
use strict; use warnings; use IO::File; my $fh = IO::File->new("< $file"); foreach ($fh->getlines) { do_something($_); } $fh->close
s{ < (?>/?) (?: [^pP] | [pP][^\s>/] ) [^>]* > }{}gx;
use strict; use HTML::TokeParser; my $parser = HTML::TokeParser->new( or die "Could not open /some/file.html - $!"; while(my $t = $parser->get_token) { next if(($t->[0] eq if($t->[0] eq { print $t->[1]; } else { print $t->[-1]; } }
<html> <head> <title> &gt; </title> </head> <body> <p> &gt; </p> </body> </html>
<(?!\/?p(?=>|\s.*>))\/?.*?> x/ < (?! \/? p (?= > | \s .* > ) ) \/? .*? > /
$regex = $subject = ($replaced = $subject) =~ s/$regex/$1/eg; print $replaced . "\n";
$old_fh = select(OUTPUT_HANDLE); $| = 1; select($old_fh);
sub append_new_line{ my $linedata = shift; open my $fh, print $fh $linedata,"\n"; close $fh; }
open (MYFILE, $| = 1; print MYFILE "$thisCardReadingContentTemplate\n\n"; close (MYFILE); MYFILE->autoflush(1);
my (%count, $line, @array_1, @array_2); while ($line = <DATA>) { $count{$line}++ if ( $line =~ /\S/ ); } @array_1 = keys(%count); @array_2 = values(%count); for(my $i=0; $i<$ { print "$array_1[$i]\t $array_2[$i]"; }
use Tie::IxHash; my %count; tie %count, while ($line = <DATA>) { $count{$line}++ if ( $line =~ /\S/ ); } while( my( $key, $value)= each %count) { print "$key\t $value"; }
my (%count, $line, @display_order); while ($line = <DATA>) { chomp $line; if ($line =~ /\S/) { if ($count{$line}++ == 0) { push @display_order, $line; } } } foreach my $key (@display_order) { print "$key\t $count{$key}\n"; }
use Tie::IxHash; tie my %myhash, for (my $i=0; $i<20; $i++) { $myhash{$i} = 2*$i; } my @keys = keys %myhash;
my (%count, @order); while(<DATA>) { chomp; push @order, $_ unless $count{$_}++; } print "$_ $count{$_}\n" for @order; __DATA__ a b e a c d a c d b
my %count; while (my $line = <DATA>) { chomp $line; if ($line =~ /\S/) { $count{$line} ||= { order => scalar(keys(%count)) }; $count{$line}{count}++; } } for my $line (sort { $count{$a}{order} <=> $count{$b}{order} } keys %count ) { print "$line $count{$line}{count}\n"; }
use warnings; my @pairs = ( "fred bill", "hello bye", "hello fred", "foo bar", "fred foo"); my @ccomp = connected_component(@pairs); use Data::Dumper; print Dumper \@ccomp; sub connected_component { my @arr = @_; my %links; foreach my $arrm ( @arr ) { my ($x,$y) = split(/\s+/,$arrm);; $links{$x}{$y} = $links{$y}{$x} = 1; } my %marked; my @stack; my @all_ccomp; for my $node (sort keys %links) { next if exists $marked{$node}; @stack = (); connected($node); print "@stack\n"; push @all_ccomp, [@stack]; } sub connected { no warnings my $node = shift; return if exists $marked{$node}; $marked{$node} = 1; push @stack, $node; my $children = $links{$node}; connected($_) for keys %$children; } return @all_ccomp; }
Variable "%marked" will not stay shared at mycode.pl line 43. Variable "@stack" will not stay shared at mycode.pl line 45. Variable "%links" will not stay shared at mycode.pl line 46.
use warnings; my @pairs = ( "fred bill", "hello bye", "hello fred", "foo bar", "fred foo"); my @ccomp = connected_component(@pairs); use Data::Dumper; print Dumper \@ccomp; sub connected_component { my @arr = @_; my %links; foreach my $arrm ( @arr ) { my ($x,$y) = split(/\s+/,$arrm);; $links{$x}{$y} = $links{$y}{$x} = 1; } my %marked; my @stack; my @all_ccomp; my $connected_sub; $connected_sub = sub { no warnings my $node = shift; return if exists $marked{$node}; $marked{$node} = 1; push @stack, $node; my $children = $links{$node}; &$connected_sub($_) for keys %$children; }; for my $node (sort keys %links) { next if exists $marked{$node}; @stack = (); &$connected_sub($node); push @all_ccomp, [@stack]; } return @all_ccomp; }
my $connected_sub; $connected_sub = sub { no warnings my $node = shift; return if exists $marked{$node}; $marked{$node} = 1; push @stack, $node; my $children = $links{$node}; &$connected_sub($_) for keys %$children; }; for my $node (sort keys %links) { next if exists $marked{$node}; @stack = (); &$connected_sub($node); push @all_ccomp, [@stack]; }
use vars qw(%types %colors); my %types = (...); %colors = (...);
$sudo cpanm XML::LibXML --> Working on XML::LibXML Fetching http: Configuring XML-LibXML-2.0014 ... N/A ! Configure failed for XML-LibXML-2.0014. See /home/kahmed/.cpanm/build.log for details.
Unpacking XML-LibXML-2.0014.tar.gz Entering XML-LibXML-2.0014 Checking configure dependencies from META.yml Checking if you have ExtUtils::MakeMaker 0 ... Yes (6.55_02) Configuring XML-LibXML-2.0014 Running Makefile.PL enable native perl UTF8 running xml2-config...ok (2.9.0) Checking for ability to link against xml2...no Checking for ability to link against libxml2...libxml2, zlib, and/or the Math library (-lm) have not been found. Try setting LIBS and INC values on the command line Or get libxml2 from http: If you install via RPMs, make sure you also install the -devel RPMs, as this is where the headers (.h files) are. Also, you may try to run perl Makefile.PL with the DEBUG=1 parameter to see the exact reason why the detection of libxml2 installation failed or why Makefile.PL was not able to compile a test program. -> N/A -> FAIL Configure failed for XML-LibXML-2.0014. See /home/kahmed/.cpanm/build.log for details.
sudo apt-get install libxml2-dev Reading package lists... Done Building dependency tree Reading state information... Done libxml2-dev is already the newest version. 0 upgraded, 0 newly installed, 0 to remove and 78 not upgraded.
lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 11.04 Release: 11.04 Codename: natty
Checking for ability to link against libxml2...libxml2, zlib, and/or the Math library (-lm) have not been found.
sudo apt-get install --reinstall zlibc zlib1g zlib1g-dev
use List::Util qw(first); $idx = first { $array[$_] eq
use List::MoreUtils qw(firstidx); $idx = firstidx { $_ eq
my @matches = grep { $array[$_] ~~ $element } 0 .. $
my ($index) = grep { $array[$_] ~~ $element } 0 .. $
use autobox::Core; my @things = qw/blue black green red green yellow/; my $first_green = @things->first_index( sub{ $_[0] eq my $last_green = @things->last_index ( qr/^green$/ ); say $first_green; say $last_green;
sub array_search { my ($arr, $elem) = @_; my $idx; for my $i (0..$ if ($arr->[$i] eq $elem) { $idx = $i; last; } } return $idx; }
use HTML::Entities; my $encoded = encode_entities( "foo & bar & <baz>" );
Benchmark: timing 10000 iterations of html_entities, html_escape... html_entities: 14 wallclock secs (14.09 usr + 0.01 sys = 14.10 CPU) @ 709.22/s (n=10000) html_escape: 1 wallclock secs ( 0.68 usr + 0.00 sys = 0.68 CPU) @ 14705.88/s (n=10000)
Benchmark: timing 10000 iterations of html_entities, html_escape... html_entities: 14 wallclock secs (13.79 usr + 0.01 sys = 13.80 CPU) @ 724.64/s (n=10000) html_escape: 7 wallclock secs ( 7.57 usr + 0.01 sys = 7.58 CPU) @ 1319.26/s (n=10000)
my $file = "test.exe"; my ($ext) = $file =~ /(\.[^.]+)$/; print "$ext\n";
use File::Basename; ($name,$path,$suffix) = fileparse("test.exe.bat",qr"\..[^.]*$"); print $suffix;
use strict; use warnings; use File::Basename; my $ext = (fileparse("/foo/bar/baz.exe", qr/\.[^.]*/))[2]; print "$ext";
my $file1 = "filename.tar.gz.bak"; my ($ext1) = $file1 =~ /((\.[^.\s]+)+)$/; my $file2 = "filename.exe"; my ($ext2) = $file2 =~ /((\.[^.\s]+)+)$/; my $file3 = "filename. exe"; my ($ext3) = $file3 =~ /((\.[^.\s]+)+)$/; my $file4 = "filename.............doc"; my ($ext4) = $file4 =~ /((\.[^.\s]+)+)$/; print "1) $ext1\n"; print "2) $ext2\n"; print "3) $ext3\n"; print "4) $ext4\n";
sub create_hash() { my @files = @_; foreach(@files){ if(/.text/) { open($files_list{$_},">>$_") || die("This file will not open!"); } } }
This is perl, v5.8.4 built for i86pc-solaris-64int (with 36 registered patches, see perl -V for more detail)
sub create_hash { my ($files) = @_; foreach(@{$files)){ ... } } create_hash(\@files2);
use List::Util my $maxkey = max keys %hash; my @array = @hash{0 .. $maxkey};
my $maxkey = max keys %$hashref; my @array = @{$hashref}{0 .. $maxkey};
my %hash; @hash{0 .. 9} = ( use Data::Dumper; print Dumper(\%hash); print Dumper(\@array); $VAR1 = { }; $VAR1 = [ ];
my @sorted_vals = @hash{sort { $a <=> $b } keys %hash};
my @array = map { $hash{$_} } sort { $a<=>$b } keys %hash;
my $n = keys(%hash) - 1; my @keys_and_values = map { $_ => $hash{$_} } 0 .. $n; my @just_values = @hash{0 .. $n};
my @keys_arr = (undef) x scalar %hashed_keys; @keys_arr[(keys %hashed_keys)] = @hashed_keys{(keys %hashed_keys)};
@{$keys_arr}[(keys %{$hashed_keys})] = @{$hashed_keys}{(keys %{$hashed_keys})};
@keys_arr = @hashed_keys{(sort {$a <=> $b} keys %hashed_keys)};
$Hash_value = { }; while (my ($key,$value) = each %{$Hash_value}) { print "\n $key > $value"; }
my @array = map {$hash{$_}} sort {$a <=> $b} keys %hash;
my @array; keys %hash; while (my ($k, $v) = each %hash) { $array[$k] = $v }
$j =0; while(($a1,$b1)=each(%hash1)){ $arr[$j][0] = $a1; ($arr[$j][1],$arr[$j][2],$arr[$j][3],$arr[$j][4],$arr[$j][5],$arr[$j][6]) = values($b1); $j++; }
my %hash = ( "0" => "zero", "1" => "one", "2" => "two", "3" => "three", "4" => "four", "5" => "five", "6" => "six", "7" => "seven", "8" => "eight", "9" => "nine", "10" => "ten", ); my @array = %hash;
opendir(my $DH, $DIR) or die "Error opening $DIR: $!"; my @files = map { [ stat "$DIR/$_", $_ ] } grep(! /^\.\.?$/, readdir($DH)); closedir($DH); sub rev_by_date { $b->[9] <=> $a->[9] } my @sorted_files = sort rev_by_date @files;
my @newest = @{$sorted_files[0]}; my $name = pop(@newest);
my @files; opendir(my $DH, $DIR) or die "Error opening $DIR: $!"; while (defined (my $file = readdir($DH))) { my $path = $DIR . next unless (-f $path); push(@files, [ stat(_), $path ]); } closedir($DH);
{ opendir my $dh, $dir or die "Could not open $dir: $!"; my( $newest_name, $newest_time ) = ( undef, 2**31 -1 ); while( defined( my $file = readdir( $dh ) ) ) { my $path = File::Spec->catfile( $dir, $file ); next if -d $path; ( $newest_name, $newest_time ) = ( $file, -M _ ) if( -M $path < $newest_time ); } print "Newest file is $newest_name\n"; }
opendir(my $DH, $DIR) or die "Error opening $DIR: $!"; my %files = map { $_ => (stat("$DIR/$_"))[9] } grep(! /^\.\.?$/, readdir($DH)); closedir($DH); my @sorted_files = sort { $files{$b} <=> $files{$a} } (keys %files);
use Class::CSV; my $csv = Class::CSV->new( fields => [qw/userid username/] ); $csv->add_line([2063, $csv->add_line({ userid => 2064, username => }); $csv->print();
my @table = ( [ [ 1, 2, 3 ], [ 2, 4, 6 ], ); for my $row ( @table ) { print join( }
my @nums = (-1, 0, 10, 22, 1e10, 1e-10, 99, 101, 1.001e2); print join /^(.+)$(??{$^N>=0 && $^N<=100 ? @nums
use strict; my $file = shift; open(IN, $file) || die "Unable to open $file\n"; open(OUT, ">$file.$$") or die $!;
my @array = (1, 2, 3); my $value = shift @array; print $value;
use strict; use warnings; sub pass_by_ref { $_[0] = 2; } sub pass_by_value { my $x = shift @_; $x = 3; } my $x = 1; print $x, "\n"; pass_by_ref($x); print $x, "\n"; pass_by_value($x); print $x, "\n";
use Fcntl qw(LOCK_EX LOCK_NB); use File::NFSLock; my $lock = File::NFSLock->new($0, LOCK_EX|LOCK_NB); die "$0 is already running!\n" unless $lock;
use strict; use warnings; use File::Pid; my $pidfile = File::Pid->new({file => /var/run/myscript}); exit if $pidfile->running(); $pidfile->write(); $pidfile->remove(); exit;
use warnings; use strict; use Fcntl qw/ :DEFAULT :flock :seek /; my $PIDFILE = "/tmp/my-program.pid"; sub take_lock { sysopen my $fh, $PIDFILE, O_RDWR | O_CREAT or die "$0: open $PIDFILE: $!"; flock $fh => LOCK_EX or die "$0: flock $PIDFILE: $!"; my $pid = <$fh>; if (defined $pid) { chomp $pid; if (kill 0 => $pid) { close $fh; exit 1; } } else { die "$0: readline $PIDFILE: $!" if $!; } sysseek $fh, 0, SEEK_SET or die "$0: sysseek $PIDFILE: $!"; truncate $fh, 0 or die "$0: truncate $PIDFILE: $!"; print $fh "$$\n" or die "$0: print $PIDFILE: $!"; close $fh or die "$0: close: $!"; } take_lock; print "$0: [$$] running...\n"; sleep 2;
use Fcntl open SELF, "< $0" or die("Cannot run two instances of this program"); unless ( flock SELF, LOCK_EX | LOCK_NB ) { print "You cannot run two instances of this program , a process is still running"; exit 1; }
$mode = (stat($filename))[2]; printf "Permissions are %04o\n", $mode & 07777;
use strict; use warnings; use Fcntl my $perldoc_f_stat = q( S_IRWXU S_IRUSR S_IWUSR S_IXUSR S_IRWXG S_IRGRP S_IWGRP S_IXGRP S_IRWXO S_IROTH S_IWOTH S_IXOTH S_ISUID S_ISGID S_ISVTX S_ISTXT S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR S_IFIFO S_IFSOCK S_IFWHT S_ENFMT ); my %mask; foreach my $sym ($perldoc_f_stat =~ /\b(S_I\w+)\b/g) { my $val = eval { no strict if (defined $val) { $mask{$sym} = $val; } else { printf "%-10s - undefined\n", $sym; } } my @descending = sort { $mask{$b} <=> $mask{$a} } keys %mask; printf "%-10s - %9o\n", $_, $mask{$_} for @descending;
my $mode = 33188; print "\nBits set in mode $mode:\n"; foreach my $sym (@descending) { if (($mode & $mask{$sym}) == $mask{$sym}) { print " - $sym\n"; $mode &= ~$mask{$sym}; } } printf "extra bits: %o\n", $mode if $mode;
(dec) (oct) (bin) 34285 102755 1000010111101101 & 4095 = & 7777 = & 111111111111 ------- -------- ------------------ 1517 = 2755 = 10111101101
void S_IMODE(...) PREINIT: dXSTARG; SV *mode; PPCODE: if (items > 0) mode = ST(0); else { mode = &PL_sv_undef; EXTEND(SP, 1); } PUSHu(SvUV(mode) & 07777);
S_ISREG($mode) S_ISDIR($mode) S_ISLNK($mode) S_ISBLK($mode) S_ISCHR($mode) S_ISFIFO($mode) S_ISSOCK($mode) S_ISENFMT($mode) S_ISWHT($mode)
Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a "%o" if you want to see the real permissions.
perl -lwe 1000000110100100 perl -lwe 0000000110100100
my %fileno2path; sub myopen { my($path) = @_; open my $fh, "<", $path or die "$0: open: $!"; $fileno2path{fileno $fh} = $path; $fh; } sub myclose { my($fh) = @_; delete $fileno2path{fileno $fh}; close $fh or warn "$0: close: $!"; } sub path { my($fh) = @_; $fileno2path{fileno $fh}; }
my $filename= open my $fh, my $fd = fileno $fh; print readlink("/proc/$$/fd/$fd");
not exp log srand xor s qq qx xor s x x length uc ord and print chr ord for qw q join use sub tied qx xor eval xor print qq q q xor int eval lc q m cos and print chr ord for qw y abs ne open tied hex exp ref y m xor scalar srand print qq q q xor int eval lc qq y sqrt cos and print chr ord for qw x printf each return local x y or print qq s s and eval q s undef or oct xor time xor ref print chr int ord lc foreach qw y hex alarm chdir kill exec return y s gt sin sort split
not exp log srand xor s xor s/ / length uc ord and print chr ord for qw q join use sub tied q/ xor eval
not srand xor s qq qx xor s x x length uc ord and print uc chr ord for qw q join qx xor eval xor lc eval qq x abs cos ord and print chr ord for qw q use substr tied qx xor print qq q q xor int eval lc qq m cos and print chr ord for qw y abs ne or tied hex exp ref y m xor scalar srand print qq q q xor sin abs eval q x log srand ord or printf uc chr ord foreach qw q package qx xor sqrt eval lc qq y sqrt cos and printf chr ord for qw x each return local x y or print qq s s and uc exp eval q s undef or oct xor time xor ref print chr int ord lc for qw y hex alarm chdir kill exec return y s xor log exp eval q x print chr length join qw y length for map substr chr shift y x or sqrt abs ord lc and eval print q q q and s q q lcfirst chr eval log shift qx
not exp log srand xor s qq qx xor s x x length uc ord and print chr ord for qw q find redo ord helpme eval scalar qx xor eval xor print q q q xor int eval lc q m cos and print chr ord for qw y flock each s tell y m gt sin ref study split
use Encode qw(decode encode); my $octets = decode( my $good_utf8 = encode(
perl -MDateTime -E' say DateTime->new( year => 2013, month => 10, day => 20 ) ->subtract( days => 1 ) ->set( hour => 23, minute => 59 ) ->set_time_zone("America/Sao_Paulo") ->add( minutes => 1 ) ->strftime("%H:%M"); ' 01:00
use strict; use warnings; use DateTime qw( ); use DateTime::TimeZone qw( ); sub day_start { my $tz = shift; my $dt = shift; my $local_rd_days = ( $dt->local_rd_values() )[0]; my $seconds = $local_rd_days * 24*60*60; my $min_idx; if ( $seconds < $tz->max_span->[DateTime::TimeZone::LOCAL_END] ) { $min_idx = 0; } else { $min_idx = @{ $tz->{spans} }; $tz->_generate_spans_until_match( $dt->utc_year()+1, $seconds, } my $max_idx = $ my $utc_rd_days; my $utc_rd_secs; while (1) { my $current_idx = int( ( $min_idx + $max_idx )/2 ); my $current = $tz->{spans}[$current_idx]; if ( $seconds < $current->[DateTime::TimeZone::LOCAL_START] ) { $max_idx = $current_idx - 1; } elsif ( $seconds >= $current->[DateTime::TimeZone::LOCAL_END] ) { $min_idx = $current_idx + 1; } else { my $offset = $current->[DateTime::TimeZone::OFFSET]; if ($current->[DateTime::TimeZone::IS_DST] && $current_idx) { my $prev = $tz->{spans}[$current_idx-1]; $offset = $prev->[DateTime::TimeZone::OFFSET] if $seconds >= $prev->[DateTime::TimeZone::LOCAL_START] && $seconds < $prev->[DateTime::TimeZone::LOCAL_END]; } $utc_rd_days = $local_rd_days; $utc_rd_secs = -$offset; DateTime->_normalize_tai_seconds($utc_rd_days, $utc_rd_secs); last; } if ($min_idx > $max_idx) { $current_idx = $min_idx; $current = $tz->{spans}[$current_idx]; if (int( $current->[DateTime::TimeZone::LOCAL_START] / (24*60*60) ) != $local_rd_days) { my $err = $err .= " in time zone: " . $tz->name; $err .= "\n"; die $err; } $utc_rd_secs = $current->[DateTime::TimeZone::UTC_START] % (24*60*60); $utc_rd_days = int( $current->[DateTime::TimeZone::UTC_START] / (24*60*60) ); last; } } my ($year, $month, $day) = DateTime->_rd2ymd($utc_rd_days); my ($hour, $minute, $second) = DateTime->_seconds_as_components($utc_rd_secs); return $dt ->_new_from_self( year => $year, month => $month, day => $day, hour => $hour, minute => $minute, second => $second, time_zone => ) ->set_time_zone($tz); }
sub new_date { my $y = shift; my $m = shift; my $d = shift; return DateTime->new( year => $y, month => $m, day => $d, @_, hour => 0, minute => 0, second => 0, nanosecond => 0, time_zone => ); } { my $tz = DateTime::TimeZone->new( name => my $dt = day_start($tz, new_date(2013, 10, 20)); print($dt->iso8601(), "\n"); $dt->subtract( seconds => 1 ); print($dt->iso8601(), "\n"); } { my $tz = DateTime::TimeZone->new( name => my $dt = day_start($tz, new_date(2013, 11, 3)); print($dt->iso8601(), "\n"); $dt->subtract( seconds => 1 ); print($dt->iso8601(), "\n"); }
sub today_as_floating { return DateTime ->now( @_ ) ->set_time_zone( ->truncate( to => } { my $tz = DateTime::TimeZone->new( name => my $dt = today_as_floating( time_zone => $tz ); $dt = day_start($tz, $dt); print($dt->iso8601(), "\n"); }
$ zdump -v America/Sao_Paulo | fgrep 2014 America/Sao_Paulo Sun Feb 16 01:59:59 2014 UTC = Sat Feb 15 23:59:59 2014 BRST isdst=1 gmtoff=-7200 America/Sao_Paulo Sun Feb 16 02:00:00 2014 UTC = Sat Feb 15 23:00:00 2014 BRT isdst=0 gmtoff=-10800 America/Sao_Paulo Sun Oct 19 02:59:59 2014 UTC = Sat Oct 18 23:59:59 2014 BRT isdst=0 gmtoff=-10800 America/Sao_Paulo Sun Oct 19 03:00:00 2014 UTC = Sun Oct 19 01:00:00 2014 BRST isdst=1 gmtoff=-7200
$ TZ=America/Sao_Paulo perl -MTime::Local -E Sun Oct 19 01:00:00 2014
$ TZ=America/Sao_Paulo perl -MTime::Local -E Sat Oct 18 23:59:59 2014
use POSIX qw( mktime tzset ); $ENV{TZ} = tzset(); my $epoch = mktime( 0, 0, 0, 20, 10-1, 2013-1900 ); print localtime($epoch)."\n";
sub day_start { my ($y, $m, $d, $tz) = @_; $tz = DateTime::TimeZone->new( name => $tz ) if !ref($tz); my $dt = DateTime->new( year => $y, month => $m, day => $d ); my $target_day = ( $dt->utc_rd_values )[0]; my $min_epoch = int($dt->epoch()/60) - 24*60; my $max_epoch = int($dt->epoch()/60) + 24*60; while ($max_epoch > $min_epoch) { my $epoch = ( $min_epoch + $max_epoch ) >> 1; $dt = DateTime->from_epoch( epoch => $epoch*60, time_zone => $tz ); if (( $dt->local_rd_values )[0] < $target_day) { $min_epoch = $epoch; } else { $max_epoch = $epoch; } } return DateTime->from_epoch(epoch => $max_epoch*60, time_zone => $tz); }
{ my $tz = DateTime::TimeZone->new( name => my $dt = day_start(2013, 10, 20, $tz); print($dt->epoch, " ", $dt->iso8601, "\n"); $dt->subtract( seconds => 1 ); print($dt->epoch, " ", $dt->iso8601, "\n"); } { my $tz = DateTime::TimeZone->new( name => my $dt = day_start(2013, 11, 3, $tz); print($dt->epoch, " ", $dt->iso8601, "\n"); $dt->subtract( seconds => 1 ); print($dt->epoch, " ", $dt->iso8601, "\n"); }
my $dt = DateTime->new( time_zone => $tz, year => $year, month => $month, day => $day, hour => 23, minute => 59, second => 0, ); while($dt->year == $year && $dt->month == $month && $dt->day == $day) { $dt->add(seconds => 1); }
use DateTime; use DateTime::TimeZone; my $zone = DateTime::TimeZone->new(name => my $dt = DateTime->new(year => 2013, month => 10, day => 20); sub valid_local_time { eval { $zone->offset_for_local_datetime($dt) }; return $@ !~ /^Invalid local time/; } while (!valid_local_time()) { $dt->add(minutes => 15); } $dt->set_time_zone($zone); sub local_time_lt { my ($x, $y) = @_; return $x->local_rd_as_seconds < $y->local_rd_as_seconds; } sub local_time_eq { my ($x, $y) = @_; return $x->local_rd_as_seconds == $y->local_rd_as_seconds; } my $copy = $dt->clone->subtract(seconds => 1); if (local_time_lt($dt, $copy)) { my $delta = $copy->local_rd_as_seconds - $dt->local_rd_as_seconds; local_time_eq($dt, $copy->subtract(seconds => $delta)) or die qq/Could not determine start of day ($dt [${\$zone->name}])/; $dt = $copy; } print $dt->strftime(
string= time perl -e ' ($n,$string,$needle) = @ARGV; for ($i=0;$i<$n;$i++) { index($string, $needle) == 0 }
string="aaaaabaaaaabaaaaabaaaaabaaaaabaaaaab" needle="aaaaaa"
sub begins_with { return substr($_[0], 0, length($_[1])) eq $_[1]; }
use warnings; use strict; use Test::LeakTrace; use Symbol leaktrace { package test; our $x = 1; package main; delete_package };
leaked ARRAY(0x81c930) from /lib/perl5/5.10.1/Symbol.pm line 166. leaked HASH(0x827760) from /lib/perl5/5.10.1/Symbol.pm line 166. leaked SCALAR(0x821920) from /lib/perl5/5.10.1/Symbol.pm line 166.
leaked ARRAY(0x81cd10) from so.pl line 32. leaked SCALAR(0x81c930) from so.pl line 32. leaked ARRAY(0x8219d0) from so.pl line 32. leaked HASH(0x8219c0) from so.pl line 32. leaked SCALAR(0x8219b0) from so.pl line 32. leaked HASH(0x8219a0) from so.pl line 32. leaked SCALAR(0x821970) from /lib/perl5/5.10.1/Symbol.pm line 161. leaked HASH(0x821950) from so.pl line 32. leaked SCALAR(0x821940) from so.pl line 32.
my $num = 0; while (1) { no strict @{$num. delete_package $num++; }
@array = qw(one two three four five six seven eight); <Some command here> print @array;
my $cnt = 0; @array = map { ++$cnt < 5 ? ( ) : $_ } @array;
use strict; use warnings; use feature my @array = qw(one two three four five six seven eight); my @new_array = grep {state $count; ++$count > 5} @array; print "$_\n" for @new_array;
use strict; use warnings; my @array = qw/yes no maybe true false false perhaps no/; my %seen; foreach my $string (@array) { next unless $seen{$string}++; print " }
use strict; use warnings; my %count; my %dups; for(@array) { $dups{$_}++ if $count{$_}++; }
@array = sort @array; my $last; my %dups; for my $entry (@array) { $dups{$entry}++ if defined $last and $entry eq $last; $last = $entry; }
use strict; use warnings; use List::MoreUtils my @array = qw(1 1 2 3 fibonacci!); my @array_uniq = uniq @array; print ((scalar(@array) == scalar(@array_uniq)) ? "no dupes" : "dupes") . " found!\n";
my %uniq_elements; foreach my $element (@array) { die "dupe found!" if $uniq_elements{$element}++; }
import collections counts = collections.Counter(mylist) uniq = [i for i,c in counts.iteritems() if c==1] dupes = [i for i, c in counts.iteritems() if c>1]
use strict; use warnings; my @arr = ( my %count; my @arr_no_dups = grep { !$count{$_}++ } @arr; print @arr_no_dups, "\n";
use strict; use warnings; @_ = sort { print "dup = $a$/" if $a eq $b; $a cmp $b } @ARGV;
my $file = "test~"; my $regex1 = my $regex2 = print int($file =~ m/$regex1/)."\n"; print int($file =~ m/$regex2/)."\n"; print int($file =~ m/^.+\Q~\E$/)."\n";
$re = qr/$pattern/; $string =~ /foo${re}bar/; $string =~ $re; $string =~ /$re/;
use Data::Dumper; $Data::Dumper::Useperl = 1; print Dumper([ $VAR1 = [ 1, 1 ];
use B qw( svref_2object SVf_IOK ); sub create_data_dumper_literal { my ($x) = @_; return "undef" if !defined($x); my $sv = svref_2object(\$x); my $iok = $sv->FLAGS & SVf_IOK; return "$x" if $iok; $x =~ s/([ return " }
perl -MDevel::Peek -e ' $x = 1; print Dump $x; $x eq "a"; print Dump $x; $x .= q(); print Dump $x; ' SV = IV(0x794c68) at 0x794c78 REFCNT = 1 FLAGS = (IOK,pIOK) IV = 1 SV = PVIV(0x7800b8) at 0x794c78 REFCNT = 1 FLAGS = (IOK,POK,pIOK,pPOK) IV = 1 PV = 0x785320 "1"\0 CUR = 1 LEN = 16 SV = PVIV(0x7800b8) at 0x794c78 REFCNT = 1 FLAGS = (POK,pPOK) IV = 1 PV = 0x785320 "1"\0 CUR = 1 LEN = 16
use autobox::universal qw(type); say type("42"); say type(42); say type(42.0); say type(undef);
use Data::Dumper; my $foo = print Dumper $foo; my $bar = $foo + 0; print Dumper $foo; $bar = $foo . print Dumper $foo; $foo = $foo . print Dumper $foo;
if ($foo =~ /^\d+$/) { print "positive integer" } if ($foo =~ /^-?\d+$/) { print "integer" } if ($foo =~ /^\d+\.\d+$/) { print "Decimal" }
use Params::Util qw<_NUMBER>; unless ( _NUMBER( $scalar ) or $scalar =~ /^ $scalar =~ s/ $scalar = " }
my $class = shift; my $a = shift; my $b = shift; my $self = $class->SUPER::new($a, $b); return $self;
package Gamma; use base Alpha; use base Beta; sub new { } 1;
package Mother; use strict; use warnings; sub new { my ($class, @args) = @_; my $self = bless {}, $class; return $self->_init(@args); } sub _init { my ($self, @args) = @_; return $self; } package Father; use strict; use warnings; sub new { my ($class, @args) = @_; my $self = bless {}, $class; return $self->_init(@args); } sub _init { my ($self, @args) = @_; return $self; } package Child; use strict; use warnings; use base qw(Mother Father); sub _init { my ($self, @args) = @_; $self->Mother::_init(@args); $self->Father::_init(@args); return $self; }
package Parent; use strict; use warnings; sub new { my ($class, @args) = @_; return bless {}, $class; } 1;
package Child; use strict; use warnings; use parent sub new { my ($class, @args) = @_; my $self = $class->SUPER::new(@args); return $self; } 1;
sub new { my ($class) = @_; return $class->next::method(@_); }
use Data::Dumper; sub dump{ my($self) = @_; print "<pre>",Dumper($self),"</pre>"; }
$Data::Dumper::Sortkeys = 1; print Dumper($obj); $Data::Dumper::Sortkeys = sub { [reverse sort keys %{$_[0]}] }; $Data::Dumper::Sortkeys = sub { [sort {$b cmp $a} keys %{$_[0]}] }; print Dumper($obj);
use Data::Dumper::Concise; my $pantsToWear = { pony => unicorn => marsupials => {kangaroo => }; warn Dumper($pantsToWear);
use Data::Dumper; { local $Data::Dumper::Terse = 1; local $Data::Dumper::Indent = 1; local $Data::Dumper::Useqq = 1; local $Data::Dumper::Deparse = 1; local $Data::Dumper::Quotekeys = 0; local $Data::Dumper::Sortkeys = 1; warn Dumper($var); }
$Data::Dumper::Sortkeys or $OBJ->Sortkeys([NEWVAL]) Can be set to a boolean value to control whether hash keys are dumped in sorted order. A true value will cause the keys of all hashes to be dumped in Perl Can also be set to a subroutine reference which will be called for each hash that is dumped. In this case Data::Dumper will call the subroutine once for each hash, passing it the reference of the hash. The purpose of the subroutine is to return a reference to an array of the keys that will be dumped, in the order that they should be dumped. Using this feature, you can control both the order of the keys, and which keys are actually used. In other words, this subroutine acts as a filter by which you can exclude certain keys from being dumped. Default is 0, which means that hash keys are not sorted.
use Data::Dumper; $Data::Dumper::Sortkeys = 1; my $hashref = { bob => jerry =>, nested => {one => print Dumper($hashref), "\n";
$Data::Dumper::Sortkeys = sub { [ sort { $_[0]->{$a} <=> $_[0]->{$b} } keys %{ $_[0] } ] };
$Data::Dumper::Sortkeys = sub { my %h = %{$_[0]}; [ sort { $h{$a} cmp $h{$b} } keys %h ]; };
my @arr = (0, 1, 2); my $iter = getPermIter(@arr); while (my @perm = $iter->next() ){ print "@perm\n"; }
use Algorithm::Permute; my @array = my $p_iterator = Algorithm::Permute->new ( \@array ); while (my @perm = $p_iterator->next) { print "next permutation: (@perm)\n"; }
use Algorithm::Permute; my @array = Algorithm::Permute::permute { print "next permutation: (@array)\n"; } @array;
sub permute (&@) { my $code = shift; my @idx = 0..$ while ( $code->(@_[@idx]) ) { my $p = $ --$p while $idx[$p-1] > $idx[$p]; my $q = $p or return; push @idx, reverse splice @idx, $p; ++$q while $idx[$p-1] > $idx[$q]; @idx[$p-1,$q]=@idx[$q,$p-1]; } } permute { print "@_\n" } split;
use Algorithm::Loops qw(NextPermuteNum); my @list= 0..9; do { print "@list\n" } while NextPermuteNum @list;
use List::Permutor; my $permutor = List::Permutor->new( 0, 1, 2); while ( my @permutation = $permutor->next() ) { print "@permutation\n"; }
use strict; use warnings; print "Enter the length of the string - "; my $n = <> + 0; my %hash = map { $_ => 1 } glob "{0,1,2}" x $n; foreach my $key ( keys %hash ) { print "$key\n"; }
$ perl permute_perl.pl Enter the length of the string - 3 101 221 211 100 001 202 022 021 122 201 002 212 011 121 010 102 210 012 020 111 120 222 112 220 000 200 110
my %hash; $hash{ $hash{ $hash{ &printInfo(%hash); sub printInfo{ my (%hash) = %_; foreach my $key (keys %_{ my $a = $_{$key}{ my $b = $_{$key}{ print "$a $b\n"; } }
printInfo(\%hash); sub PrintInfo { my %hash = %{$_[0]}; ... }
my %hash; $hash{ $hash{ $hash{ printInfo(%hash); sub printInfo{ my %hash = @_; foreach my $key (keys %hash){ my $a = $hash{$key}{ my $b = $hash{$key}{ print "$a $b\n"; } }
my $hash_ref = \%hash; my $array_ref = \@array; my $scalar_ref = \$scalar;
my %hash1 = ( this => 1, that => 2, the => 3, other => 4 ); my %hash2 = ( tom => 10, dick => 20, harry => 30 ); my %hash3 = ( no => 100, man => 200, is => 300, an => 400, island => 500 );
my $hash_ref1 = \%hash1; my $hash_ref2 = \%hash2; my $hash_ref3 = \%hash3;
sub mysub { my $sub_hash_ref1 = shift; my $sub_hash_ref2 = shift; my $sub_hash_ref3 = shift;
my %sub_hash1 = %{ $sub_hash_ref1 }; my %sub_hash2 = %{ $sub_hash_ref2 }; my %sub_hash3 = %{ $sub_hash_ref3 };
sub mysub { my $hash_ref = shift; if ( ref $hash_ref ne "HASH" ) { croak qq(You need to pass in a hash reference); }
my %hash = (this => 1, is => 2, a => 3 test => 4); print "$hash{test}\n"; sub mysub ( \%hash ); print "$hash{test}\n"; sub mysub { my $hash_ref = shift; $hash_ref->{test} = "foo"; This is modifying the original hash! }
sub do_hash_thing { my %hash = @_; ... } do_hash_thing( %hash );
sub do_hash_thing { my $hash_ref = shift; ... } do_hash_thing( \%hash, @other_args );
sub do_hash_thing (\%@) { my $hash_ref = shift; ... } do_hash_thing( %hash => qw(other args) ); do_hash_thing %hash => qw(other args);
use warnings; use strict; use CGI qw/ :standard -debug /; print "Content-type: text/plain\n\n", map { $_ . " => " . param($_) . "\n" } param;
export HTTP_COOKIE=... export HTTP_HOST=test.example.com export HTTP_REFERER=... export HTTP_USER_AGENT=... export PATH_INFO= export QUERY_STRING=$(cat query_string); export REQUEST_METHOD=GET perl program.cgi
export CONTENT_LENGTH=$(perl -e "print -s q/post_data/"); export HTTP_COOKIE=... export HTTP_HOST=test.example.com export HTTP_REFERER=... export HTTP_USER_AGENT=... export PATH_INFO=... export QUERY_STRING=$(cat query_string); export REQUEST_METHOD=POST perl program.cgi < post_data
your_script.pl keyword1 keyword2 keyword3 or this: your_script.pl keyword1+keyword2+keyword3 or this: your_script.pl name1=value1 name2=value2 or this: your_script.pl name1=value1&name2=value2 To turn off this feature, use the -no_debug pragma.
shell$ QUERY_STRING=limit=20 REQUEST_METHOD=GET ./events_html.pl
Dim XMLHttp : Set XMLHttp = CreateObject("Microsoft.XMLHTTP") On Error Resume Next strIPAddress = WScript.Arguments(0) strMACAddress = WScript.Arguments(1) strSubnetMask = WScript.Arguments(2) On Error Goto 0 WScript.Echo "Attempting to wake host " & strIPAddress & " on NIC " & strMACAddress & "using netmask " & strSubnetMask strGetUrl = http: strIPAddress & "&macAddress=" & strMACAddress & "&subnetMask=" & strSubnetMask XMLHttp.Open "GET", strGetUrl, False XMLHttp.Send "" WScript.Echo XMLHttp.ResponseText
sub by_position { $a->start <=> $b->start || $a->end <=> $b->end } my @sorted_intervals = sort by_position (@$intervals);
$ perl -E v5.18.2 $ perl -MO=Concise -e 8 <@> leave[1 ref] vKP/REFC ->(end) 1 <0> enter ->2 2 <;> nextstate(main 1 -e:1) v:{ ->3 3 <0> padav[@arr:1,2] vM/LVINTRO ->4 4 <;> nextstate(main 2 -e:1) v:{ ->5 - <1> ex-aassign vKS/64 ->8 - <1> ex-list lK ->- 5 <0> pushmark s ->6 7 <@> sort lK/INPLACE ->8 6 <0> padrange[@arr:1,2] l/1 ->7 - <0> padav[@arr:1,2] lRM* ->7 - <1> ex-list lK ->- - <0> ex-pushmark s ->- - <0> ex-padav lRM* ->- -e syntax OK
$ perl -MO=Concise -e e <@> leave[1 ref] vKP/REFC ->(end) 1 <0> enter ->2 2 <;> nextstate(main 1 -e:1) v:{ ->3 3 <0> padsv[$ref:1,2] vM/LVINTRO ->4 4 <;> nextstate(main 2 -e:1) v:{ ->5 d <2> aassign[t4] vKS/COMMON ->e - <1> ex-list lK ->a 5 <0> pushmark s ->6 9 <@> sort lK ->a 6 <0> pushmark s ->7 8 <1> rv2av[t3] lK/1 ->9 7 <0> padsv[$ref:1,2] s ->8 - <1> ex-list lK ->d a <0> pushmark s ->b c <1> rv2av[t2] lKRM*/1 ->d b <0> padsv[$ref:1,2] sM/DREFAV ->c -e syntax OK
perl -MData::Alias -MO=Concise -e e <@> leave[1 ref] vKP/REFC ->(end) 1 <0> enter ->2 2 <;> nextstate(main 1 -e:1) v:{ ->3 3 <0> padsv[$ref:1,3] vM/LVINTRO ->4 4 <;> nextstate(main 2 -e:1) v:{ ->5 - <1> entersub vKS/INARGS ->a ... a <;> nextstate(main 3 -e:1) v:{ ->b - <1> ex-aassign vKS/64 ->e - <1> ex-list lK ->- b <0> pushmark s ->c d <@> sort lK/INPLACE ->e c <0> padrange[@arr:2,3] l/1 ->d - <0> padav[@arr:2,3] lRM* ->d - <1> ex-list lK ->- - <0> ex-pushmark s ->- - <0> ex-padav lRM* ->- -e syntax OK
+ /* optimiser converts "@a = sort @a" to "sort \@a"; + * in case of tied @a, pessimise: push (@a) onto stack, then assign + * result back to @a at the end of this function */
$ perl -MDevel::Peek -MList::Util=first -e SV = IV(0x1094e20) at 0x1094e28 REFCNT = 1 FLAGS = (TEMP,ROK) RV = 0x11183b0 SV = PVCV(0x10ff1f0) at 0x11183b0 REFCNT = 3 FLAGS = (POK,pPOK) PROTOTYPE = "&@" COMP_STASH = 0x0 XSUB = 0x7f7ecbdc61b0 XSUBANY = 0 GVGV::GV = 0x11183c8 "List::Util" :: "first" FILE = "ListUtil.c" DEPTH = 0 FLAGS = 0x800 OUTSIDE_SEQ = 0 PADLIST = 0x0 OUTSIDE = 0x0 (null)
=head2 C<CvGV_name_or_bust> I<coderef> Calls L<Devel::Peek> to try to find the glob the ref lives in; returns C<undef> if L<Devel::Peek> can find a glob for this ref. Returns C<< I<package>::I<glob name> >> if the code ref is found in a glob. =cut sub CvGV_name_or_bust { my $in = shift; return unless ref $in; $in = \&$in; eval { require Devel::Peek; 1 } or return; my $gv = Devel::Peek::CvGV($in) or return; *$gv{PACKAGE} . }
use warnings; use strict; package Foo; sub bar {} package main; BEGIN { *baz = \&Foo::bar } sub CvGV_name_or_bust { ... } print CvGV_name_or_bust(\&baz), "\n";
use Sub::Identify qw/sub_fullname/; sub foo { print sub_fullname( \&foo ); print sub_fullname( sub{} ); } foo();
open my $in, open my $out, while( <$in> ) { print $out $_; } close $out;
open my $in, open my $out, print $out " while( <$in> ) { print $out $_; } close $out;
open my $in, open my $out, print $out " while( <$in> ) { s/\b(perl)\b/Perl/g; print $out $_; } close $out;
while( <$in> ) { print $out $_; last if $. == 4; } my $line = <$in>; $line =~ s/\b(perl)\b/Perl/g; print $out $line; while( <$in> ) { print $out $_; }
while( <$in> ) { next if /^\s+ last if /^__(END|DATA)__$/; print $out $_; }
while( <$in> ) { next unless $. % 5; print $out $_; }
open my $in, open my $out, my @lines = do { local $/; <$in> }; print $out @lines;
use strict; use warnings; while (<>) { if ($. == 2) { print "new data", "\n"; next; } if ($. == 3) { print "very new data", "\n"; next; } print; } print "more data", "\n";
my open $in_fh, or die "Can my open $out_fh, or die "Can while (my $line = <$in_fh>) { next if ( $. == 2 or $. == 3 or $. == 4 ); print $out_fh $line; } print $out_fh "...whatever\n";
use File::Copy; copy("/file1.txt","/file1_old.txt"); open(FILEHANDLE,">file1.txt"); open(FILEHANDLE1,"<file1_old.txt"); my $linecount=1; while(<FILEHANDLE1>) { print $_."\n"; if($linecount>4) { print FILEHANDLE "$_"; } $linecount++; } { } close(FILEHANDLE1); close(FILEHANDLE);
use strict; use warnings; use List::MoreUtils qw my @x = ( 1 .. 5); my @y = (11 .. 15); my @sums = pairwise { $a + $b } @x, @y;
my @sums = pairwise { no warnings qw(once); $a + $b } @x, @y; my @sums = pairwise { our $a + our $b } @x, @y;
{ no warnings return join("_", @monsters) if @monsters && List::Util::reduce { $a && $b }
use strict; use warnings; use Data::Dumper; $Data::Dumper::Deparse = 1; my $sub_ref = \&inigo_montoya; print Dumper $sub_ref; sub inigo_montoya { print <<end_quote; I will go up to the six-fingered man and say, "Hello. My name is Inigo Montoya. You killed my father. Prepare to die." end_quote }
use strict; use warnings; my $sub_ref = \&inigo_montoya; use B qw(svref_2object); my $cv = svref_2object ( $sub_ref ); my $gv = $cv->GV; print "name: " . $gv->NAME . "\n"; sub inigo_montoya { print "...\n"; }
use strict; use warnings; use feature use Sub::Identify my $sub_ref = \&inigo_montoya; say "Sub Name: ", sub_name($sub_ref); say "Stash Name: ", stash_name($sub_ref); say "Full Name: ", sub_fullname($sub_ref); sub inigo_montoya { print << I will go up to the six-fingered man and say, "Hello. My name is Inigo Montoya. You killed my father. Prepare to die." end_quote }
$ ./sub_identify.pl Sub Name: inigo_montoya Stash Name: main Full Name: main::inigo_montoya
use B qw(svref_2object); sub sub_name { return unless ref( my $r = shift ); return unless my $cv = svref_2object( $r ); return unless $cv->isa( and my $gv = $cv->GV ; my $name = if ( my $st = $gv->STASH ) { $name = $st->NAME . } my $n = $gv->NAME; if ( $n ) { $name .= $n; if ( $n eq $name .= } } return $name; }
sub Foo {print "foo!\n";return (caller(0))[3];} $function_name=Foo(); print "Called $function_name\n";
for ( my $loops = 0; $loops < 100000; $loops++ ) { my @arr; for ( my $foo = 0; $foo < 50; $foo++ ) { push @arr, } }
for ( my $loops = 0; $loops < 100000; $loops++ ) { my @arr; $arr[49] = 0; for ( my $foo = 0; $foo < 50; $foo++ ) { $arr[$foo] = } }
while (my $date_string = <DATA>) { chomp($date_string); next if not length $date_string; print "$date_string ist Unixtime ", $lang_date->str2time($date_string), " und ", $lang_date->time2str( "\n"; } __DATA__ 1.3.1999 1 Marz 1999 1. Marz 1999 1/3/1999
s{%([a-fA-F0-9]{2})}{ pack ("C", hex ($1)) }eg; s{%u([0-9A-F]{4})}{ pack ( utf8::decode $_;
Content-Type: text/html; charset=UTF-8 <meta http-equiv="content-type" content="text/html;charset=UTF-8">
use Encode qw(decode); use URI::Escape::XS qw(decodeURIComponent); $_ = decode(
package Foo; use Moose; has isa => reader => ); sub set_bar { my ($self, $bar) = @_; $self->{bar} = "modified: $bar"; }
package Foo; use Moose; use Moose::Util::TypeConstraints; subtype => as => where { /^modified: /}; coerce => from => via { "modified: $_" }; has isa => is => coerce => 1, );
has isa => reader => writer => ); around my ($next, $self, $bar) = @_; $self->$next( "Modified: $bar" ); };
package Foo; use Moose; has isa => is => trigger => sub { $_[0]->{bar} = "modified: $_[1]" }, );
package Foo; use Moose; has isa => reader => writer => ); sub set_bar { my $self = shift; my @args = @_; return $self->_set_bar(@args); }
1 2 3 4 5 6 %fruit = ( 7 8 9 10 ); 11 12 print "The apple is @{$fruit{apple}}.\n"; 13 print "The kiwi is $fruit{kiwi}.\n"; 14 print "What is yellow? ";
my @all_matches = grep { $fruit{$_} eq print("$_ ") foreach @matching_keys; my ($any_match) = grep { $fruit{$_} eq
%fruit = ( ); %antifruit = ( ); print "The apple is @{$fruit{ print "The kiwi is $fruit{ print "A yellow thing is $antifruit{
sub find_key { my ( $h, $value ) = @_; while ( my ( $k, $v ) = each %$h ) { return $k if $v eq $value; } return; }
sub getfruit { my ($fruit, $col) = @_; my @result; for my $key (keys %$fruit) { if (ref $fruit->{$key} eq for (@{$fruit->{$key}}) { push @result, $key if /^$col$/i; } } else { push @result, $key if $fruit->{$key} =~ /^$col$/i; } } return @result; }
my %fruit = ( ); print "The apple is @{$fruit{apple}}.\n"; print "The kiwi is $fruit{kiwi}.\n"; print "What is yellow? "; my $ele; my $search = my @match = (); foreach $ele (keys(%fruit)) { if(ref($fruit{$ele}) eq grep { $_ eq $search } @{ $fruit{$ele} }) { push(@match, $ele); } elsif(!ref($fruit{$ele}) and $fruit{$ele} eq $search) { push(@match, $ele); } } print join(", ", @match) . "\n";
$? The status returned by the last pipe close, backtick ("``") command, successful call to wait() or waitpid(), or from the system() operator. This is just the 16-bit status word returned by the traditional Unix wait() system call (or else is made up to look like it). Thus, the exit value of the subprocess is really ("$? >> 8"), and "$? & 127" gives which signal, if any, the process died from, and "$? & 128" reports whether there was a core dump. (Mnemonic: similar to sh and ksh.) Additionally, if the "h_errno" variable is supported in C, its value is returned via $? if any "gethost*()" function fails. If you have installed a signal handler for "SIGCHLD", the value of $? will usually be wrong outside that handler. Inside an "END" subroutine $? contains the value that is going to be given to "exit()". You can modify $? in an "END" subroutine to change the exit status of your program. For example: END { $? = 1 if $? == 255; } Under VMS, the pragma "use vmsish POSIX status; see "$?" in perlvms for details. Also see "Error Indicators".
pv1 = tpv = (char*)bytes_to_utf8((const U8*)pv1, &cur1);
const I32 retval = memcmp((const void*)pv1, (const void*)pv2, cur1 < cur2 ? cur1 : cur2);
const I32 retval = memcmp((const void*)pv1, (const void*)pv2, cur1 < cur2 ? cur1 : cur2);
use strict; use warnings; use Carp; use Encode qw( encode ); use Symbol; use Win32; use Win32API::File qw( CreateFileW OsFHandleOpen FILE_GENERIC_READ FILE_GENERIC_WRITE OPEN_EXISTING CREATE_ALWAYS FILE_SHARE_READ ); use Win32::API; use File::Spec::Functions qw(catfile); Win32::API->Import( Kernel32 => qq{BOOL CreateDirectoryW(LPWSTR lpPathNameW, VOID *p)} ); my %modes = ( access => FILE_GENERIC_READ, create => OPEN_EXISTING, mode => }, access => FILE_GENERIC_WRITE, create => CREATE_ALWAYS, mode => }, ); use ex::override open => sub(*;$@) { $_[0] = gensym; my %mode = %{ $modes{$_[1]} }; my $os_fh = CreateFileW( encode( $mode{access}, FILE_SHARE_READ, [], $mode{create}, 0, [], ) or do {$! = $^E; return }; OsFHandleOpen($_[0], $os_fh, $mode{mode}) or return; return 1; }; my $path = my @comps = ( my $dir = mk_long_dir($path, \@comps); my $file = my $str = "This is a test\n"; write_test_file($dir, $file, $str); $str eq read_test_file($dir, $file) or die "Read failure\n"; sub write_test_file { my ($dir, $file, $str) = @_, my $path = catfile $dir, $file; open my $fh, or croak "Cannot open print $fh $str or die "Cannot print: $!"; close $fh or die "Cannot close: $!"; return; } sub read_test_file { my ($dir, $file) = @_, my $path = catfile $dir, $file; open my $fh, or croak "Cannot open my $contents = do { local $/; <$fh> }; close $fh or die "Cannot close: $!"; return $contents; } sub mk_long_dir { my ($path, $comps) = @_; for my $comp ( @$comps ) { $path = catfile $path, $comp; my $ucs_path = encode( CreateDirectoryW($ucs_path, undef) or croak "Failed to create directory: } return $path; }
use Win32::API; $cd = Win32::API->new( $dir = $res = 1; do { print $dirname = pack( $res = $cd->Call($dirname, 0); print "$res\n"; $dir .= } while ( $res );
use strict; use warnings; use File::Path qw(make_path); use File::Slurp; use Path::Class; my $top = dir( my @comps = ( my $path = dir($top, @comps); make_path $path, { verbose => 1 }; my $file = file($path, write_file "$file" => print read_file "$file";
sub get_user { my $user = __PACKAGE__->{user}; if (!defined $user) { __PACKAGE__->{user} = $user; } return $user; }
use strict; use warnings; use 5.012; { package X::Y; our $user = 10; say $user; say __PACKAGE__; } --output:-- 10 X::Y
use strict; use warnings; use 5.012; { package X::Y; our $user = 10; say $user; say __PACKAGE__; say $X::Y::{user}; } --output:-- 10 X::Y *X::Y::user
use strict; use warnings; use 5.012; { package X::Y; our $user = 10; say $user; say __PACKAGE__; say $X::Y::{user}; say __PACKAGE__->{user}; } --output:-- 10 X::Y *X::Y::user Use of uninitialized value in say at 2.pl line 13.
use strict; use warnings; use 5.012; %X::Y = (); $X::Y{user} = { package X::Y; sub get_user { say __PACKAGE__->{user}; } get_user; } --output:-- hello
use strict; use warnings; use 5.012; { package X::Y; sub get_user {say say $X::Y::{get_user}; } --output:-- *X::Y::get_user
use strict qw(vars subs); for ( $_->(); } sub function { require Inline; Inline->bind(C => << void foo() { } __CODE__ }
my @fibs := (0, 1, -> $a, $b { $a + $b } ... *); my @fibs := (0, 1, { $^a + $^b } ... *); my @fibs := (0, 1, *+* ... *);
my $command = "\x{11}\x{22}\x{33}\x{44}\x{55}\x{66}\x{77}\x{88}\x{00}\x{00}\x{00}\x{00}\x{00}\x{00}\x{00}\x{00}\x{00}\x{00}\x{00}\x{00}"; my $bytesWritten = $device->bulk_write(0x01, $command, 1000);
0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0010 00 00 00 00 00 00 00 00 11 22 33 44
my $h = << line1 line2 line3 END_TXT my $h = <<"END_TXT"; line1 line2 line3 END_TXT
my $i = q/line1 line2 line3 /; my $i = qq{line1 line2 line3 };
$heredoc = <<END; Some multiline text and stuff END
use strict; use warnings; my $name = my $message = << Dear $name, this is a message I plan to send to you. regards the Perl Maven END_MESSAGE print $message;
Dear $name, this is a message I plan to send to you. regards the Perl Maven
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($unix_timestamp);
use 5.010; use Time::Piece; my $unix_timestamp = 1e9; my $date = localtime($unix_timestamp)->strftime( say $date;
my ($S, $M, $H, $d, $m, $Y) = localtime($time); $m += 1; $Y += 1900; my $dt = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $Y,$m, $d, $H, $M, $S);
use POSIX qw( strftime ); my $dt = strftime("%Y-%m-%d %H:%M:%S", localtime($time));
sub wanted { if (-d) { print $File::Find::name." is a directory\n"; } } find(\&wanted, $mydir);
use File::Next; my $iterator = File::Next::files( while ( defined ( my $file = $iterator->() ) ) { print $file, "\n"; } /tmp/foo.txt /tmp/bar.pl /tmp/baz/1 /tmp/baz/2.txt /tmp/baz/wango/tango/purple.txt
my @files = grep { -f } @all; my @dirs = grep { -d } @all;
my %hash_slice; for(@keys) { $hash_slice{$_} = %hash{$_}; }
my @keys = qw(a b); my %hash = (a => 1, b => 2, c => 3); my %hash_copy; @hash_copy{@keys} = @hash{@keys};
use List::MoreUtils qw(zip); %hash = qw(a 1 b 2 c 3); @keys = qw(a b); @values = @hash{@keys}; %hash = zip @keys, @values;
sub zip { my $max = -1; $max < $ map { my $ix = $_; map $_->[$ix], @_; } 0..$max; } %hash = zip \@keys, [@hash{@keys}];
%hash = qw(a 1 b 2 c 3); %keep = map +($_ => 1), qw(a b); $keep{$a} or delete $hash{$a} while ($a, $b) = each %hash;
my $hash = { a => 1, b => 2, c => 3, d => 4 }; $hash->hslice([qw/a b/])
my %population = ( my @slice_values = @population{ my %slice_hash = %population{
sub outer { my $a = 123; sub inner { print $a, "\n"; } inner(); $a = 456; } outer(); outer();
sub outer { my $a = 123; my $inner = sub { print $a, "\n"; }; $inner->(); $a = 456; } outer(); outer();
sub find_files { my @files; my $wanted = sub { if($something) { push @files, $File::Find::name; } }; find({ wanted => $wanted }, $directory); return @files; }
use strict; use warnings; sub generate_multiplier { my ($coef) = @_; return sub { my ($val) = @_; $coef * $val; } } my $doubler = generate_multiplier(2); my $tripler = generate_multiplier(3); for my $i ( 1 .. 10 ) { printf "%4d%4d%4d\n", $i, $doubler->($i), $tripler->($i); } __END__ C:\Temp> v 1 2 3 2 4 6 3 6 9 4 8 12 5 10 15 6 12 18 7 14 21 8 16 24 9 18 27 10 20 30
sub Foo { stuff() } BEGIN { *Foo = sub { stuff() } }
use 5.010; use strict; use warnings; sub make_iterator { my @list = @_; return sub { shift @list }; } my $iter1 = make_iterator( 0 .. 10 ); my $iter2 = make_iterator( say $iter1->(); say $iter1->(); say $iter2->();
use strict; use warnings; sub xx { my $zz=1; sub yy { print $zz; } } perl tmp.pl Variable "$zz" will not stay shared at tmp.pl line 8.
my %jump = ( id => xid => hex_id => h => \&h, mac => \&mac, sed => \&sed, make => \&make, nsis => \&nsis, perl => \&perl, dump => \&perl, yaml => \&yaml, yml => \&yaml, json => \&json, js => \&json, help => \&help, usage => sub{ require Pod::Usage; Pod::Usage::pod2usage( "run perldoc $0 or pod2text $0 for more information" ); } );
my ($index) = grep { $array[$_] eq $search_for } 0..$
my $x = grep {/foo/} @array; my ($x) = grep {/foo/} @array; my @foo = grep {/foo/} @array; my (@foo) = grep {/foo/} @array;
use List::MoreUtils qw( first_index ); my $index = first_index { $_ eq $search_for } @array;
sub my_grep { my $sub = shift; my @return; for my $item (@_) { push @return if $sub->($item); } return @return if wantarray; return scalar @return; }
my ($index, $foo, $bar) = grep { $array[$_] eq $search_for } 0..$
$ cat test.pl my $pid = 5892; my $not = system("top -H -p $pid -n 1 | grep myprocess | wc -l"); print "not = $not\n"; $ perl test.pl 11 not = 0 $
$exit_status = system("mail-users"); $output_string = `ls`;
my $pid = 5892; my $var = `top -H -p $pid -n 1 | grep myprocess | wc -l`; print "not = $var\n";
chomp($host = `hostname`); chomp($domain = `domainname`); $fqdn = $host.".".$domain;
use strict; use warnings; use Term::ReadKey; my $key = 0; my $password = ""; print "\nPlease input your password: "; ReadMode(4); while(ord($key = ReadKey(0)) != 10) { if(ord($key) == 127 || ord($key) == 8) { chop($password); print "\b \b"; } elsif(ord($key) < 32) { } else { $password = $password.$key; print "*(".ord($key).")"; } } ReadMode(0); print "\n\nYour super secret password is: $password\n";
use IO::Prompt; my $password = prompt( print "$password\n";
sub passwordDisplay() { my $password = ""; ReadMode(4); my $count = 0; while(ord($key = ReadKey(0)) != 10) { if(ord($key) == 127 || ord($key) == 8) { if ($count > 0) { $count--; chop($password); print "\b \b"; } } elsif(ord($key) >= 32) { $count++; $password = $password.$key; print "*"; } } ReadMode(0); return $password; }
$ cat array.pl %ages = ( print "Rikke is $ages{Rikke} years old\n"; $ perl array.pl Rikke is 29 years old $
use Readonly; Readonly my $infilename => "input_56_12.txt";
use constant FOO => "something"; my %h = ( FOO => 23 );
%hash = ( $key => $value ); login( $username => $password );
sub foo_1($) { my $name = shift; my $f; run_something(); open($f, $name) or die ("Couldn while (<$f>) { } close($f); do_something_else(); }
sub higher_order_fn (&@) { my $code = \&{shift @_}; for (@_) { $code->($_); } }
higher_order_fn {$_ * 2} 1, 2, 3; higher_order_fn(sub {$_ * 2}, 1, 2, 3);
sub higher_order_method { my $self = shift; my $code = \&{shift @_}; ... $code->() for @_; } ... $obj->higher_order_method(sub {...},
sub bar { my ($coderef) = @_; ⁝ $coderef->($f, @arguments); ⁝ } bar(sub { my ($f) = @_; while … }, @other_arguments);
my $while_sub = sub { my ($f) = @_; while … ⁝ }; bar($while_sub, @other_arguments);
sub foo(&@) { my ($callback) = shift; ... $callback->(...); ... }
use 5.12.2; use strict; use warnings; use Benchmark qw(cmpthese); my @hits = qw(A B C); my @base = qw(one two three four five six) x ( $ARGV[0] || 1 ); my @at_end = ( @base, @hits ); my @at_beginning = ( @hits, @base ); my @in_middle = @base; splice @in_middle, int( @in_middle / 2 ), 0, @hits; my @random = @base; foreach my $item ( @hits ) { my $index = int rand @random; splice @random, $index, 0, $item; } sub count { my( $hits, $candidates ) = @_; my $count; foreach ( @$hits ) { when( $candidates ) { $count++ } } $count; } cmpthese(-5, { hits_beginning => sub { my $count = count( \@hits, \@at_beginning ) }, hits_end => sub { my $count = count( \@hits, \@at_end ) }, hits_middle => sub { my $count = count( \@hits, \@in_middle ) }, hits_random => sub { my $count = count( \@hits, \@random ) }, control => sub { my $count = count( [], [] ) }, } );
my %old_hash = map {$_,1} @in_middle; cmpthese(-5, { ..., new_hash => sub { my %h = map {$_,1} @in_middle; my $count = 0; foreach ( @hits ) { $count++ if exists $h{$_} } $count; }, old_hash => sub { my $count = 0; foreach ( @hits ) { $count++ if exists $old_hash{$_} } $count; }, control_hash => sub { my $count = 0; foreach ( @hits ) { $count++ } $count; }, } );
use 5.12.0; use Benchmark qw(cmpthese); my @hits = qw(one two three); my @candidates = qw(one two three four five six); my %hash; @hash{@hits} = (); sub count_hits_hash { my $count = 0; for (@_) { $count++ if exists $hash{$_}; } $count; } sub count_hits_smartmatch { my $count = 0; for (@_) { $count++ when @hits; } $count; } say count_hits_hash(@candidates); say count_hits_smartmatch(@candidates); cmpthese(-5, { hash => sub { count_hits_hash((@candidates) x 1000) }, smartmatch => sub { count_hits_smartmatch((@candidates) x 1000) }, } );
Rate smartmatch hash smartmatch 404/s -- -65% hash 1144/s 183% --
use strict; use warnings; { package Simple; use base } { package Simple::Controllers; use Squatting our @C = ( C( Index => [ get => sub { my ($self) = @_; my $v = $self->v; $v->{hello} = $self->render( }, ), ); } { package Simple::Views; use Squatting use HTML::AsSubs; our @V = ( V( layout => sub { my ($self, $v, @yield) = @_; html( head( title( body( @yield ), )->as_HTML; }, hello => sub { my ($self, $v) = @_; p( $v->{hello} ); }, ), ); }
<Perl> use Simple Simple->init </Perl> <Location /> SetHandler perl-script PerlHandler Simple->mp20 </Location>
my $string = "string"; $short = substr($string, 0, -3); printf $short . "\n";
use strict; use warnings; my $str = <<EO_STR; Name=Value1 Name=Value2 Name=Value3 EO_STR my @matches = $str =~ /=(\w+)/g; print "@matches\n";
my @values; while(<DATA>){ chomp; push @values, /Name=(.+?)$/; } print join " " => @values,"\n"; __DATA__ Name=Value1 Name=Value2 Name=Value3
use strict; use warnings; use 5.010; my $text = q{ Name=Value1 Name = Value2 Name=Value3 }; my $grammar = do { use Regexp::Grammars; qr{ <[VariableDeclare]>* <rule: VariableDeclare> <Var> \= <Value> <token: Var> Name <rule: Value> <MATCH= ([\w]+) > }xms; }; if ( $text =~ $grammar ) { my @Name_values = map { $_->{Value} } @{ $/{VariableDeclare} }; say "@Name_values"; }
$data->{key3}{key4}{key6} = delete $data->{key3}{key4}{key5}
$data->{key3}{key4}{key6} = $data->{key3}{key4}{key5}; delete $data->{key3}{key4}{key5};
sub hash_replace (\%$$) { $_[0]->{$_[2]} = delete $_[0]->{$_[1]}; }
hash_replace %{$data->{key3}{key4}}, "key5", "key6";
hash_replace %{$data->{key3}{key4}}, key5 => "key6";
use strict; my $data = { }, } }, }; print "$data->{key3}->{key4}->{key5}\n"; my $save = $data->{key3}->{key4}->{key5}; delete $data->{key3}->{key4}->{key5}; $data->{key3}->{key4}->{key6} = $save; print "$data->{key3}->{key4}->{key6}\n";
@array ~~ $scalar is true when $scalar is in @array
use POSIX qw(strftime); print strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())) . "\n";
use DateTime; print DateTime->now()->strftime("%a, %d %b %Y %H:%M:%S %z"); use DateTime::Format::Mail; print DateTime::Format::Mail->format_datetime( DateTime->now() ); print DateTime->now( formatter => DateTime::Format::Mail->new() );
day = "Mon" / "Tue" / "Wed" / "Thu" / "Fri" / "Sat" / "Sun" month = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun" / "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"
use POSIX qw(strftime locale_h); my $old_locale = setlocale(LC_TIME, "C"); my $date_rfc822 = strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())); setlocale(LC_TIME, $old_locale); print "$date_rfc822\n";
sub rfc822_local { my ($epoch) = @_; my @time = localtime $epoch; use integer; my $tz_offset = (Time::Local::timegm(@time) - $now) / 60; my $tz = sprintf( $tz_offset < 0 ? $tz_offset / 60, $tz_offset % 60); my @month_names = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec); my @day_names = qw(Sun Mon Tue Wed Thu Fri Sat Sun); return sprintf( $day_names[$time[6]], $time[3], $month_names[$time[4]], $time[5] + 1900, $time[2], $time[1], $time[0], $tz); }
sub rfc822_gm { my ($epoch) = @_; my @time = gmtime $epoch; my @month_names = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec); my @day_names = qw(Sun Mon Tue Wed Thu Fri Sat Sun); return sprintf( $day_names[$time[6]], $time[3], $month_names[$time[4]], $time[5] + 1900, $time[2], $time[1], $time[0]); }
use feature qw(say); my $foo = "bar"; say $foo; say \$foo;
my @switch_ports = (); my %port = ( data1 => 0, data2 => 0, changed => 0 ); my $port_ref = \%port; push( @switch_ports, $port_ref );
my @switch_ports = (); my %port = ( data1 => 0, data2 => 0, changed => 0 ); push( @switch_ports, \%port );
$port_ref = $switch_ports[0]; %port = %{$port_ref}; print "$port{data1} $port{data2} $port{changed}\n";
%port = %{$port[0]}; print "$port{data1} $port{data2} $port{changed}\n";
print ${$port[0]}{data1} . " " . ${$port[0]}{data2} . " " . ${$port[0]}{changed} . "\n";
print $port[0]->{data1} . " " . $port[0]->{data2} . " " . $port[0]->{changed} . "\n";
%port = (data1 => 0, data2 => 0, changed => 0); push @switch_ports, %port;
push @switch_ports, "data1", 0, "data2", 0, "changed", 0;
push @array, { data1 => 0, data2 => 0, changed => 0 } for 1 .. 50;
for my $port (@switchport) { print $port->{data1}; }
my @my_hashes = (); my @$rows = ... if( @$rows ) { foreach $row ( @$rows ) { push @my_hashes, { id => $row->{ id }, name => $row->{ name }, value => $row->{ value }, }; } }
for my $i ( 0 .. $ print "$my_hashes[$i]{ id }\n "; print "$my_hashes[$i]{ name }\n "; print "$my_hashes[$i]{ value }\n "; }
for my $i ( 0 .. $ for my $type ( keys %{ $my_hashes[$i] } ) { print "$type=$my_hashes[$i]{$type} "; }
foreach my $x (@x) { foreach my $y (@z) { foreach my $z (@z) { if (something()) { } } } }
OUTER: foreach my $x (@x) { foreach my $y (@z) { foreach my $z (@z) { if (something()) { last OUTER; } } } }
print "We have 12\n" if exists $h{twelve}; print "We have some teens\n" if exists $h{/.*teen$/};
$a $b Type of Match Implied Matching Code ====== ===== ===================== ============= ... Regex Hash hash key grep grep /$a/, keys %$b ...
print "We have some teens\n" if grep {/.*teen/} keys %h;
use List::Util qw<first>; my $value = $hash{ ( first { m/teen/ } keys %hash ) ||
my $value = $hash{ ( first { m/teen/ } sort keys %hash ) ||
use Scalar::Util qw<reftype>; sub values_for_keys_like (\[%$]$) { my $ref = reftype( $_[0] ) eq return unless my @keys = keys %$ref; my $regex = shift; $regex = qr/$regex/ unless my $typ = ref( $regex ); my $test = $typ eq if ( wantarray ) { return unless my @k = grep { defined $test->( $_ ) } @keys; return @$ref{ @k }; } else { return unless my $key = first { defined $test->( $_ ) } @keys; return $ref->{ $key }; } }
my $key = values_for_keys_like( %hash => qr/teen/ );
my $key = values_for_keys_like( $base->{level_two}{level_three} => qr/teen/ );
use strict; use Data::Dumper; use File::Find::Rule; my $dir = shift; my $level = shift my @files = File::Find::Rule->file() ->name("*.txt") ->maxdepth($level) ->in($dir); print Dumper(\@files);
my $ffr_obj = File::Find::Rule->file() ->name("*.txt") ->maxdepth($level) ->start($dir); while (my $file = $ffr_obj->match()) { print "$file\n" }
use File::Find::Closures qw( find_by_regex ); use File::Find qw( find ); my( $wanted, $reporter ) = File::Find::Closures::find_by_regex( qr/\.txt\z/ ); find( $wanted, @dirs ); my @files = $reporter->();
% find2perl my_dir -name "*.txt" eval if 0; use strict; use File::Find (); use vars qw/*name *dir *prune/; *name = *File::Find::name; *dir = *File::Find::dir; *prune = *File::Find::prune; sub wanted; File::Find::find({wanted => \&wanted}, exit; sub wanted { /^.*\.txt\z/s && print("$name\n"); }
use File::Find ; use Cwd ; my $currentWorkingDir = getcwd; my @filesToRun = (); my $filePattern = find( sub { push @filesToRun, $File::Find::name if ( m/^(.*)$filePattern$/ ) }, $currentWorkingDir) ; foreach my $file ( @filesToRun ) { print "$file\n" ; }
$ curl "${JENKINS_URL}/job/${JOB_NAME}/lastBuild/consoleText"
print "about to loop\n"; while(<STDIN>) { s/2010/2009/; print; } print "done!\n";
my $err = $soap_response->code, " ", $soap_response->string, "\n"; return $err;
my $err = $soap_response->code. " ". $soap_response->string. "\n"; my $err = join
my $err = $soap_response->code, " ", $soap_response->string, "\n";
(my $err = $soap_response->code), " ", $soap_response->string, "\n";
my $err = $soap_response->code. " ". $soap_response->string. "\n";
return sprintf "%s %s\n", $soap_response->code, $soap_response->string;
my @array2d; while(<FILE>){ push(@array2d[$i], $_); }
my @array = (); foreach my $i ( 0 .. 10 ) { foreach my $j ( 0 .. 10 ) { push @{ $array[$i] }, $j; } }
fopen(FILE,"<somefile.txt"); @array = <FILE>; close (FILE);
sub import { no strict my $caller = caller; while (my ($name, $symbol) = each %{__PACKAGE__ . next if $name eq next if $name eq next unless *{$symbol}{CODE}; my $imported = $caller . *{ $imported } = \*{ $symbol }; } }
package Expo; use base "Exporter"; seek DATA, 0, 0; our @EXPORT = map { /^sub\s+([^({\s]+)/ ? $1 : () } <DATA>; my $sub = sub {}; sub foo($) { print shift, "\n"; } sub bar ($) { print shift, "\n"; } sub baz{ print shift,"\n"; } sub quux { print shift,"\n"; } 1; __DATA__
use strict; use warnings; use Expo; print map { "[$_]\n" } @Expo::EXPORT; foo("foo"); bar("bar"); baz("baz"); quux("quux");
package Exporter::AutoOkay; # # # use warnings; use strict; no strict require Exporter; sub import { my $package = $_[0]. my @export_ok = (@{$package. foreach (keys %{$package}) { next unless defined &{$package.$_}; push @export_ok, $_; } @{$package. goto &Exporter::import; } 1;
package mycommon; use strict; use warnings; sub onefunctionthatyoumadeonlibary() { } 1;
use strict; use warnings; use mycommon; common::onefunctionthatyoumadeonlibary()
package mycommon; use strict; use warnings; use base our @EXPORT = qw(onefunctionthatyoumadeonlibary); sub onefunctionthatyoumadeonlibary() { } 1;
use strict; use warnings; use mycommon qw(onefunctionthatyoumadeonlibary); onefunctionthatyoumadeonlibary()
use File::Path; use File::Copy; my $path = "tardir/dest1/dest2/"; my $file = "test.txt"; if (! -d $path) { my $dirs = eval { mkpath($path) }; die "Failed to create $path: $@\n" unless $dirs; } copy($file,$path) or die "Failed to copy $file: $!\n";
use File::Basename qw/dirname/; use File::Copy; sub mkdir_recursive { my $path = shift; mkdir_recursive(dirname($path)) if not -d dirname($path); mkdir $path or die "Could not make dir $path: $!" if not -d $path; return; } sub mkdir_and_copy { my ($from, $to) = @_; mkdir_recursive(dirname($to)); copy($from, $to) or die "Couldn return; }
use Path::Class; my $destination_file = file( $destination_file->dir->mkpath;
use SomePackage; SomePackage::some_subroutine( ... );
package SomeClass; sub class_method { my( $class, @args ) = @_; ... } sub instance_method { my( $self, @args ) = @_; ... }
use SomeClass; my $i = SomeClass->class_method( ... );
Name Education Fav_Car MoneyInBank josh High School Porche 500 SomeOtherName PHD Hyundai 50000
printf FILE ("%s%20s%20s\n", "Name", "Ed", "Car"); while (($name, $ed, $car) = $sth->fetchrow_array) { printf FILE ("%s>>>>>>>>>>>>>%40s%40s\n", $name, $ed, $car); };
printf("%-15s %-15s %-10s %9s\n", $name, $edu, $car, $cash);
printf FILE ("%*s%*s%*s\n", 20, "Name", length($blah), "Ed", 20, "Car");
printf("%20s%20s%20s$20S\n",$name,$ed,$car,$money);
sub CheckPrintOutput { my @output = @_; foreach my $value (@output) { Log->log($value) if $value =~ /warning|error|notice|attention/i; } }
package IO::Override; use base qw<Tie::Handle>; use Symbol qw<geniosym>; sub TIEHANDLE { return bless geniosym, __PACKAGE__ } sub PRINT { shift; print $OLD_STDOUT join( } tie *PRINTOUT, our $OLD_STDOUT = select( *PRINTOUT );
sub PRINTF { shift; my $format = shift; print $OLD_STDOUT join( }
open my $fh, ">log.txt"; print "test1\n"; my $current_fh = select $fh; print "test2\n"; select $current_fh; print "test3\n";
package PsychicSTDOUT; use strict; my $c = 0; my $malformed_header = 0; open(TRUE_STDOUT, tie *STDOUT, __PACKAGE__, (*STDOUT); sub TIEHANDLE { my $class = shift; my $handles = [@_]; bless $handles, $class; return $handles; } sub PRINT { my $class = shift; if (!$c++ && @_[0] !~ /^content-type/i) { my (undef, $file, $line) = caller; print STDERR "Missing content-type in $file at line $line!!\n"; $malformed_header = 1; } return 0 if ($malformed_header); return print TRUE_STDOUT @_; } 1;
use PsychicSTDOUT; print "content-type: text/html\n\n"; print "<html>\n"; print "</html>\n";
my ($ids,$nIds); while (<myFile>){ chomp; $ids.= $_ . " "; $nIds++; }
print "Number of lines: $nids\n"; print "Content: $ids\n";
if ($something) { my $var = "something happened!"; } print $var;
print "$var1 $var2"; print $var1 . $var2; print $var1, $var2;
use strict; use warnings; open my $fh, chomp(my @file = <$fh>); close $fh; my $ids = join( my $nIds = scalar @file; print "Number of lines: $nIds\n"; print "Text:\n$ids\n";
open my $fh, my $ids; while (<$fh>) { chomp; $ids .= "$_ "; } my $nIds = $.;
our %months = qw / x01 1 x02 2 x03 3 x04 4 x05 5 x06 6 x07 7 x08 8 x09 9 x0a 10 x0b 11 x0c 12 /; ... my $month = $months{$text};
use strict; use warnings; my @months = map hex, qw/x01 x02 x03 x04 x05 x06 x07 x08 x09 x0a x0b x0c/; print "$_\n" for @months;
my $in = "\x0a"; print length($in), "\n"; my ($out) = unpack("c", $in); print length($out), "\n", $out, "\n"
On Ubuntu: apt-get install nginx fcgiwrap On Arch: pacman -S nginx fcgiwrap Example Nginx config (Ubuntu: /etc/nginx/sites-enabled/default): server { listen 80; server_name localhost; access_log /var/log/nginx/access.log; location / { root /srv/static; autoindex on; index index.html index.htm; } location ~ ^/cgi { root /srv/my_cgi_app; rewrite ^/cgi/(.*) /$1 break; include fastcgi_params; fastcgi_pass unix:/var/run/fcgiwrap.socket; fastcgi_param SCRIPT_FILENAME /srv/my_cgi_app$fastcgi_script_name; } }
foo/ foo/bar/ for/bar/test.pm foo.pm foo/bar.pm test.pl
$ perl -d -e ... main::(-e:1): use CGI; CGI->new DB<1> b CGI::new DB<2> r CGI::new(.../CGI.pm:337): 337: my($class,@initializer) = @_; DB<2> q
$cat a.sh for d in 1 2 do grep -q "hdisk$d" someFile && echo "$d : ok" done
$cat b.sh export d for d in 1 2 do cat someFile | perl -lane done
use strict; local $/ = my $file = <> ; for my $d ( 1 .. 2 ) { print "$d: OK\n" if $file =~ /hdisk$d\s+/ }
set dateVariable=`perl -e "use POSIX qw(strftime); print strftime(
my ($a, $b) = @_; defined $a or croak !ref $a or croak ... @_ == 2 or croak "Too many arguments!";
sub looks_like_a_number { $_[0] !~ /\D/ } sub is_a_dog { eval { $_[0]->DOES(
sub revise { my ($file, $options) = @_; my $tmpl = { test_mode => { allow => [0,1], verbosity => { allow => qw/^\d+$/, force_update => { allow => [0,1], required_fields => { create_backup => { allow => [0,1], }; my $args = check($tmpl, $options, 1) or croak "Could not parse arguments: " . Params::Check::last_error(); ... }
my $pdf = CAM::PDF->new($filename); my $pageone_tree = $pdf->getPageContentTree(1); print CAM::PDF::PageText->render($pageone_tree);
!/usr/bin/perl use strict; use warnings; use PDF::OCR::Thorough; my $filename = "pdf.pdf"; my $pdf = PDF::OCR::Thorough->new($filename); my $text = $pdf->get_text(); print "$text";
my $bucketname = "test"; my $bucket = $s3->add_bucket( { bucket => "$bucketname" } ) or die $s3->err . ": " . $s3->errstr;
my $apple = Apple->new({ color => "red", type => "delicious", });
my $apple = Apple->new({ color => "red", type => "delicious", });
my $json->{"entries"} = \@entries; my $json_text = to_json($json); print $json_text;
$.ajax({ type: url: dataType: data: { action: "request", last_ts: lastTimestamp }, success: function(data){ lastTs = data.last_mod; for (var entryNumber in data.entries) { } }, error: function(){ alert("Handle Errors here"); }, complete: function() { } });
$.getJSON("http: alert(json["aKey"]["anotherOne"]); });
<%init> use JSON; my %hash = { a => my @list = ( 1, 2, \%hash ); $r->content_type( my $json = new JSON; print $json->encode(\@list); </%init>
var req = new Ajax.Request( method: parameters: { whatever: }, onCreate: function() { }, onSuccess: function(response) { var json = response.responseJSON; json.each(function(item) { if (item instanceof Object) { item = new Hash(item); } else if (item instanceof Array) { } else { } }); }, onFailure: function() { } });
use strict; use warnings; use Getopt::Long; my $foo; GetOptions( print
$ cat my_script.pl use Getopt::Long; Getopt::Long::Configure("pass_through"); use Data::Dumper; my %args; GetOptions(\%args, "foo") or die "GetOption returned 0\n"; print Data::Dumper->Dump([\@ARGV],["ARGV"]); $ ./my_script.pl -foo -WHATEVER $ARGV = [ ];
use strict; use warnings; use Getopt::Long; use Data::Dumper; my $foo; my $result = GetOptions ("foo" => \$foo); print Dumper([ $foo, \@ARGV ]);
>>> a = ["foo","bar","baz"] >>> map(lambda c: len(filter(lambda w: w.startswith(c), a)), ( [0, 2, 0, 0, 0, 1]
@a = ("foo", "bar", "baz"); map length(grep $_ =~ /^$_/, @a), (
@a = qw(foo bar baz); map {my $ch = $_; scalar grep $_ =~ /^$ch/, @a} qw(a b c d e f)
$mech->eval( q{$(tr.edit td[data-attribute="name"] input).val(
package MyLang; use strict; use warnings; use Filter::Util::Call; sub import { my ($type, @args) = @_; my %p = @args; no strict my $caller = caller; *{"${caller}::_mylang_defaultmethod"} = sub { my ($a, $op, $b) = @_; $p{nomethod}->($a, $b, 0, $op); }; my ($ref) = []; filter_add(bless $ref); } sub filter { my ($self) = @_; my ($status); if ($status = filter_read() > 0) { $_ =~ s/([^=]+)(=~)([^;]+)/ _mylang_defaultmethod($1, } $status; } 1;
use MyLang nomethod => \&mywrap; my $a = "foo"; my $b = "bar"; $x = $a =~ $b; sub mywrap { my ($a, $b, $inv, $op) = @_; print "$a\n"; }
def helloworld(name): print "Hello, %s" % name import module module.helloworld("Jim")
package A::Module; use strict; use warnings; use Sub::Exporter -setup => { exports => [ qw/foo bar/ ], }; sub foo { ... } sub bar { ... } 1;
use strict; use warnings; use FindBin qw($Bin); use lib "$Bin/../lib"; use Class; use A::Module qw(foo bar); print Class->new; print foo(), bar();
use strict; use warnings; use Carp; use Yourmodulename;
package MyModule; sub helloworld { my ( $name ) = @_; print "Hello, $name\n"; } 1; use MyModule; MyModule::helloworld(
use strict; use warnings; MyModule::helloworld( AnotherModule::helloworld( package MyModule; sub helloworld { my ( $name ) = @_; print "Hello, $name\n"; } package AnotherModule; sub helloworld { my $name = shift; print "Another hello to $name\n"; }
package Foo::Bar; our @ISA = qw(Exporter); our @EXPORT = qw(sub1 sub2 sub3); our @EXPORT_OK = qw(sub4 sub5); 1;
package My::Module; use 5.008008; use strict; use warnings; require Exporter; our @ISA = qw(Exporter); our %EXPORT_TAGS = ( ) ] ); our @EXPORT_OK = ( @{ $EXPORT_TAGS{ our @EXPORT = qw( ); our $VERSION = 1; __END__ =head1 NAME My::Module - Perl extension for blah blah blah
cpanm Module::Starter::PBP perl -MModule::Starter::PBP=setup module-starter --module=My::Module
package SampleObject; use strict; use warnings; sub new { my ($class, %args) = @_; return bless { %args }, $class; } sub sample_method { my ($self) = @_; print $self->{sample_data}; }
my $obj = SampleObject->new( sample_data => more_data => $obj->sample_method();
package Person; use strict; use warnings; use Carp; sub new { my $class = shift; my $self = { @_ }; croak "bad arguments" unless defined $self->{firstname} and defined $self->{lastname}; return bless $self, $class; } sub name { my $self = shift; return "$self->{firstname} $self->{lastname}"; } package main; my $person = Person->new(firstname => "Chas.", lastname => "Owens"); print $person->name, "\n";
package Person; use Moose; has firstname => ( is => has lastname => ( is => sub name { my $self = shift; return $self->firstname . " " . $self->lastname; } package main; my $person = Person->new(firstname => "Chas.", lastname => "Owens"); print $person->name, "\n";
use MooseX::Declare; class Person { has firstname => ( is => has lastname => ( is => method name { return $self->firstname . " " . $self->lastname; } } package main; my $person = Person->new(firstname => "Chas.", lastname => "Owens"); print $person->name, "\n";
class Person { char* firstname; char* lastname; public: Person(char* first, char* last) { firstname = first; lastname = last; } char* name(void) { int len = strlen(firstname) + strlen(lastname) + 1; char* name = new char[len]; name[0] = strcat(name, firstname); strcat(name, " "); strcat(name, lastname); return name; } }; int main(void) { Person* p = new Person("Chas.", "Owens"); char* name = p->name(); printf("%s\n", name); delete name; delete p; return 0; }
eval "use ExtUtils::MakeMaker::Coverage"; if( !$@ ) { print "Adding testcover target\n"; }
do { my $qry = $self->getHTMLQuery(undef, $mech->content()); next if (!defined($qry)); push( @prods, map { $qry->query( ); $qry->delete(); $TEST++; last if ($TEST >= 10); } while(eval { $mech->follow_link(class => print "WHILE ENDED\n";
do { my $qry = $self->getHTMLQuery(undef, $mech->content()); next if (!defined($qry)); push( @prods, map { $qry->query( ); $qry->delete(); $TEST++; } while(eval { $mech->follow_link(class => print "WHILE ENDED\n";
do { ... } while condition; while (1) { ... } continue { last unless condition };
use POSIX qw/strftime/; print strftime("%Y-%m-%d", localtime), "\n";
my @t = localtime; $t[5] += 1900; $t[4]++; printf "%04d-%02d-%02d", @t[5,4,3];
my ($day, $mon, $year) = (localtime)[3..5]; printf "%04d-%02d-%02d\n", 1900+$year, 1+$mon, $day;
use strict; use warnings; use Time::Piece; my $today = localtime->ymd(); my $todayUtc = gmtime->ymd();
printf "%d-%02d-%02d", map { $$_[5]+1900, $$_[4]+1, $$_[3] } [localtime];
tail -f /var/log/nagios/nagios.log | ~/bin/nagiostime.pl
LINE: while (defined($_ = <ARGV>)) { s/(\d+)/localtime($1);/e; } continue { print $_; }
LINE: while (<>) { ... } continue { print or die "-p destination: $!\n"; }
use strict; while (<>) { s/(\d+)/localtime($1)/e } continue { print or die "-p destination: $!\n"; }
BEGIN { die "Usage: $0 [ nagios-log ]\n" if @ARGV > 1; my $log = @ARGV ? shift : "/var/log/nagios/nagios.log"; @ARGV = ("tail -f } s/(\d+)/localtime($1)/e
for (my $i = 0; $i < @ary1; $i++) { for (my $j = 0; $j < @ary2; $j++) { if ($ary1[$i] > $ary2[$j]) { last; } $ary1[$i] += $ary2[$j]; } }
OUTER: for my $wid (@ary1) { INNER: for my $jet (@ary2) { next OUTER if $wid > $jet; $wid += $jet; } }
OUTER: for my $wid (@ary1) { INNER: for my $jet (@ary2) { next OUTER if $wid > $jet; $wid += $jet; } }
for my $wid (@ary1) { for my $jet (@ary2) { last if $wid > $jet; $wid += $jet; } }
OUTER: for my $wid (@ary1) { INNER: for my $jet (@ary2) { next OUTER if $wid > $jet; $wid += $jet; } } continue { }
FOO: while (1) { BAR: while (1) { next FOO; } stuff; }
use strict; my @ar = (1, 2, 3); foreach my $a (@ar) { $a = $a + 1; } print join ", ", @ar;
use strict; use warnings; use List::MoreUtils qw(apply); my @array = qw( cat dog horse kanagaroo ); foo(@array); print join "\n", my @mapped = map { s/oo/ee/g } @array; print join "\n", print join "\n", my @applied = apply { s/fee print join "\n", print join "\n", sub foo { $_ .= }
my @foo = map { my $f = $_; $f =~ s/foo/bar/ } @bar;
my @src = 1 .. 10; for my $x (@src) { } for (@src) { my $x = $_; }
our @global = 1 .. 10; my @subs; for my $x (@global) { push @subs, sub {++$x} } $subs[5]();
my @row = (1..10); my @col = (1..10); foreach (@row){ print $_; foreach(@col){ print $_; } }
foreach my $x (@row){ print $x; foreach my $y (@col){ print $y; } }
use strict; use warnings; for( my $value = eval; my $zero_plus = 0 + $value; print join "\n", "\nExpression: $_", "Value: "Defined: " . defined $value, "Length: " . length($value), "Plus: " . +$value, "Plus Zero: } print "\nTest addition for a literal null string: "; print 0+ use Scalar::Util qw(dualvar); { my $value = dualvar 0, my $zero_plus = 0+$value; print join "\n", "\nExpression: dualvar", "Value: "Defined: " . defined $value, "Length: " . length($value), "Plus: " . +$value, "Plus Zero: }
Argument "" isn Expression: !1 Value: Defined: 1 Length: 0 Plus: Plus Zero: Expression: not 1 Value: Defined: 1 Length: 0 Plus: Plus Zero: Expression: ~0 Value: Defined: 1 Length: 10 Plus: 4294967295 Plus Zero: Test addition for a literal null string: 0 Expression: dualvar Value: Defined: 1 Length: 0 Plus: Plus Zero:
{ local $" = my @arr = (1, 2, 3); my $scalar = "@arr"; }
use Scalar::Util blessed $ref && $ref->isa($class);
my $self = shift if UNIVERSAL::isa($_[0], __PACKAGE__)
use CGI; my $a = CGI->new(); my $b = "CGI"; print UNIVERSAL::isa($a,"CGI"); print UNIVERSAL::isa($b,"CGI");
use autobox; use CGI; my $x = 5; my $y = CGI->new; print "\$x is a CGI object\n" if $x->isa( print "\$y is a CGI object\n" if $y->isa(
if (ref $_[0]) { my $self = shift; } else { my $class = shift; }
isIncreasingArray(1,2,3,4); isIncreasingArray(1,2,3,1); isIncreasingArray(0,9,1); isIncreasingArray(-2,-1,0); isIncreasingArray(1,1,1,1);
sub isIncreasingArray { my $last; foreach $n (@_) { return 0 if defined($last) && $last != $n - 1; $last = int($n); } return 1; }
use strict; use warnings; use Carp qw(croak); use Test::More; ok( isSimplyIncreasingSequence( [ 1298 ] ) ); ok( isSimplyIncreasingSequence( [1,2,3,4] ) ); ok( not isSimplyIncreasingSequence( [1,2,3,1] ) ); ok( not isSimplyIncreasingSequence( [0,9,1] ) ); ok( isSimplyIncreasingSequence( [-2,-1,0] ) ); ok( not isSimplyIncreasingSequence( [1,1,1,1] ) ); done_testing(); sub isSimplyIncreasingSequence { my ($seq) = @_; unless (defined($seq) and ( croak } return 1 if @$seq < 2; my $first = $seq->[0]; for my $n (1 .. $ return unless $seq->[$n] == $first + $n; } return 1; }
use strict; use warnings; use Benchmark qw( cmpthese ); use Carp qw( croak ); my %cases = ( ordered_large => [1 .. 1_000_000], ordered_small => [1 .. 10], unordered_large_beg => [5, 1 .. 999_000], unordered_large_mid => [1 .. 500_000, 5, 500_002 .. 1_000_000], unordered_large_end => [1 .. 999_999, 5], ); for my $case (keys %cases) { print "=== Case: $case\n"; my $seq = $cases{$case}; cmpthese -3, { }; } sub isSimplyIncreasingSequence { my ($seq) = @_; unless (defined($seq) and ( croak } return 1 if @$seq < 2; my $first = $seq->[0]; for my $n (1 .. $ return unless $seq->[$n] == $first + $n; } return 1; } sub isIncreasingArray { my $last; foreach my $n (@_) { return 0 if defined($last) && $last != $n - 1; $last = int($n); } return 1; }
use strict; use warnings; use 5.010; sub is_simply_increasing { @_ < 2 || @_ ~~ [$_[0] .. $_[-1]] } say ( is_simply_increasing(1,2,3,4) ? say ( is_simply_increasing(1,2,3,1) ? say ( is_simply_increasing(0,9,1) ? say ( is_simply_increasing(-2,-1,0) ? say ( is_simply_increasing(1,1,1,1) ? say ( is_simply_increasing(1,4,1,-1) ? say ( is_simply_increasing( say ( is_simply_increasing( say ( is_simply_increasing(2) ? say ( is_simply_increasing() ?
use strict; use warnings; use 5.010; use Test::More; sub is_increasing_array { return unless @_; return 1 if @_ == 1; foreach (1 .. $ return if $_[$_] != $_[$_ - 1] + 1; } return 1; } ok(is_increasing_array(1,2,3,4)); ok(!is_increasing_array(1,2,3,1)); ok(!is_increasing_array(0,9,1)); ok(is_increasing_array(-2,-1,0)); ok(!is_increasing_array(1,1,1,1)); done_testing;
sub is_increasing_list { use List::MoreUtils qw<none>; my $a = shift; return none { ( my $v, $a ) = (( $_ - $a != 1 ), $_ ); $v; } @_; }
return none { [ ( $a, undef ) = ( $_, ( $_ - $a - 1 )) ]->[-1]; } @_;
sub is_increasing_list { use List::MoreUtils qw<all>; my $a = shift; return all { [ ( $a, undef ) = ( $_, ( $_ - $a == 1 )) ]->[-1]; } @_; }
sub isIncreasingArray { return 1 if @_ <= 1; return (pop(@_) - $_[-1] == 1) && isIncreasingArray(@_); }
print isIncreasingArray(1,2,3),"\n"; print isIncreasingArray(1,2,1),"\n"; print isIncreasingArray(1,2),"\n"; print isIncreasingArray(1),"\n"; sub isIncreasingArray { $i = $_[0]; (scalar grep { 1 == $_ } map { $i++ == $_ } @_) == scalar(@_) || 0; }
sub isSimplyIncreasingSequence { return 1 if @_ < 2; return 0 if $_[-1] - $_[0] != $ ... }
use WWW::Mechanize::Firefox; use Path::Class qw/file/; my $mech = WWW::Mechanize::Firefox->new( bufsize => 10_000_000, ); $mech->get( my $fh = file( print $fh $mech->content_as_png();
use strict; use warnings; use WWW::Selenium; my $sel = WWW::Selenium->new( host => "localhost", port => 4444, browser => "*iexplore", browser_url => "http: ); $sel->start; $sel->open("http: $sel->capture_entire_page_screenshot("screenshot.png"); $sel->close;
use strict; use warnings; use Data::Dumper; my @bl = qw(red green blue); my @a = qw(green yellow purple blue pink); print Dumper [grep {not @bl} @a];
my %in_bl = map {$_ => 1} @bl; my @diff = grep {not $in_bl{$_}} @a;
use strict; use warnings; use Data::Dumper; my @bl = qw(red green blue); my @a = qw(green yellow purple blue pink); my %h; @h{@bl} = @bl; print Dumper [grep {!exists $h{$_}} @a];
use warnings; use 5.012; my @bl = qw(red green blue); my @a = qw(green yellow purple blue pink); my @s = grep{ not $_ ~~ @bl } @a; say "@s";
use perl5i::2; my @bl = qw(red green blue); my @a = qw(green yellow purple blue pink); my @diff = @a->diff(\@bl); say @diff->mo->perl;
use strict; use warnings; use Data::Dumper; use Acme::Tools qw(minus); my @bl = qw(red green blue); my @a = qw(green yellow purple blue pink); my @diff = minus(\@a, \@bl); print Dumper(\@diff); __END__ $VAR1 = [ ];
List::Compare CPAN module use List::Compare ; ... my $compare_obj = List::Compare->new(\@a , \@b1) ; @diff = $compare_obj->get_Lonly() ; ...
cat in.txt | perl -ne "s/abc/def/; s/fgh/hij/; print;" > out.txt
LINE: while (<>) { ... } continue { print or die "-p destination: $!\n"; }
BEGIN { @ARGV = ("/etc/services") unless @ARGV; open STDOUT, "|-", "head" or die "$0: head failed"; } print $F[1] if $F[1] =~ /udp/
$ cat my-input.txt git 111 HERE 2222 voila 333 any 444 HERE none start 555 HERE 6 svn 777 aaaa 8888 nothing two 222 HERE 9999 HERE 0000 $ perl -nle 2222 6 9999
if (scalar keys %cache > $maxSize) { %cache = (); }
use Devel::Size qw(size total_size); my $size = size("A string"); my @foo = (1, 2, 3, 4, 5); my $other_size = size(\@foo); my $foo = {a => [1, 2, 3], b => {a => [1, 3, 4]} }; my $total_size = total_size($foo);
use Cache::Memory; my $cache = Cache::Memory->new( namespace => default_expires => ); my $size = $cache->size() my $limit = $cache->size_limit();
{ use Carp; local $SIG{__DIE__} = \&Carp::confess; .... }
$b{"x"} = [@a]; $b{"x"} = \@a; $b{"x"} = [\@a]; $b{"x"} = %a; $b{"x"} = $a; $b{"x"} = [$a]; $b{"x"} = @{@a};
use Data::Dumper; my %hash = (); $hash{currency_symbol} = $hash{currency_name} = print Dumper(%hash);
use Data::Dumper; my %hash = (); my @fields = ( my @array = ( @hash{@array} = @fields x @array;
use strict; use warnings; my @fields = ( my @array = ( my %hash; @hash{@fields} = @array;
use strict; use warnings; use Data::Dumper; my %hash; my @keys = ("a","b"); my @values = ("1","2"); @hash{@keys} = @values; print Dumper(\%hash);'
my %hash = (); my @fields = ( my @array = ( @hash{@fields} = @array x @fields;
my %hash = ( "currency_symbol" => "BRL", "currency_name" => "Real" ); print Dumper(\%hash);
use strict; use warnings; use 5.010; my @keys = qw/abel baker charlie dog easy fox/; my @values = qw/a b c d e f/; # my %hash = zipper( \@keys, \@values ); while ( my ( $k, $v ) = each %hash ) { say "$k=$v"; } # sub zipper { my $k_ref = shift; my $v_ref = shift; die "Arrays must be equal length" if @$k_ref != @$v_ref; my $i = 0; return map { $k_ref->[ $i++ ], $_ } @$v_ref; }
$ ./zipper.pl easy=e dog=d fox=f charlie=c baker=b abel=a
use strict; use warnings; my @keys = qw/abel baker charlie dog easy fox/; my @values = qw/a b c d e f/; my %hash; @hash{@keys} = @values; use Data::Dumper; print Dumper \%hash;
use strict; use warnings; use List::MoreUtils qw/zip/; use Benchmark qw/cmpthese/; my @keys = qw/abel baker charlie dog easy fox/; my @values = qw/a b c d e f/; cmpthese( 100000, { zip => sub { my %hash = zip @keys, @values; }, slice => sub { my %hash; @hash{@keys} = @values; }, });
Rate zip slice zip 51282/s -- -34% slice 78125/s 52% --
use List::MoreUtils qw(zip); my @keys = qw/abel baker charlie dog easy fox/; my @values = qw/a b c d e f/; my @zipped = zip @keys, @values;
abel, a, baker, b, charlie, c, dog, d, easy, e, fox, f
sub zipper (++) { my ($k, $v) = @_; die "Arrays must be equal length" if @$k != @$v; my $i; return map { $k->[$i++], $_ } @$v } %hash = zipper @keys, @values; %hash = zipper \@keys, \@values; %hash = zipper $key_aref, $value_aref;
$ perl --version This is perl, v5.10.1 (*) built for x86_64-linux-gnu-thread-multi $ echo -e "foo\nbar" > baz.txt $ perl -p -e foo bar
my $s= $n == 0 ? "$n ain : $n == 1 ? "$n is not a lot" : $n < 100 ? "$n is more than 1..." : $n < 1000 ? "$n is in triple digits" : "Wow! $n is thousands!" ;
my $t = do { if ($n == 0) { "$n ain elsif ($n == 1) { "$n is not a lot" } elsif ($n < 100) { "$n is more than 1..." } elsif ($n < 1000) { "$n is in triple digits" } else { "Wow! $n is thousands!" } };
my $salute; if ($name eq $EMPTY_STR) { $salute = } elsif ($name =~ m/\A ((?:Sir|Dame) \s+ \S+)/xms) { $salute = "Dear $1"; } elsif ($name =~ m/([^\n]*), \s+ Ph[.]?D \z/xms) { $sa1ute = "Dear Dr $1"; } else { $salute = "Dear $name"; }
my $salute = $name eq $EMPTY_STR ? : $name =~ m/ \A((?:Sir|Dame) \s+ \S+) /xms ? "Dear $1" : $name =~ m/ (.*), \s+ Ph[.]?D \z /xms ? "Dear Dr $1" : "Dear $name" ;
my $s = $n == 0 ? "$n ain : $n == 1 ? "$n is not a lot" : $n < 100 ? "$n is more than 1..." : $n < 1000 ? "$n is in triple digits" : "Wow! $n is thousands!";
if ($n == 0) { $t = "$n ain elsif ($n == 1) { $t = "$n is not a lot"; } elsif ($n < 100) { $t = "$n is more than 1..."; } elsif ($n < 1000) { $t = "$n is in triple digits"; } else { $t = "Wow! $n is thousands!" ; }
given ($n) { when (0) { $t = "$_ ain when (1) { $t = "$_ is not a lot" } when ($_ < 100) { $t = "$_ is more than 1..." } when ($_ < 1000) { $t = "$_ is in triple digits" } default { $t = "Wow! $_ is thousands!" } }
my $t = do { given ($n) { when (0) { "$_ ain when (1) { "$_ is not a lot" } when ($_ < 100) { "$_ is more than 1..." } when ($_ < 1000) { "$_ is in triple digits" } default { "Wow! $_ is thousands!" } } };
my @cases = ( [sub { $_ == 0 }, sub { "$_ ain [sub { $_ == 1 }, sub { "$_ is not a lot" }], [sub { $_ < 100 }, sub { "$_ is more than 1..." }], [sub { $_ < 1000 }, sub { "$_ is in triple digits" }], [sub { 1 }, sub { "Wow! $_ is thousands!" }], ); for my $case (@cases) { local $_ = $n; next unless $case->[0]->(); $t = $case->[1]->(); last; }
my $t = do { if ($n == 0) { "$n ain elsif ($n == 1) { "$n is not a lot" } elsif ($n < 100) { "$n is more than 1..." } elsif ($n < 1000) { "$n is in triple digits" } else { "Wow! $n is thousands!" } };
my $t = sub { return "$n ain return "$n is not a lot" if $n == 1; return "$n is more than 1..." if $n < 100; return "$n is in triple digits" if $n < 1000; return "Wow! $n is thousands!"; }->();
use strict; use warnings; unless (caller) { } sub foo { ... }
package Tests::Script; use strict; use warnings; do
use File::Slurp "read_file"; eval "package Script; sub {" . read_file("script") . "}"; is(Script::foo(), "foo");
use strict; use warnings; use Devel::Peek; my $t = 5 > 4; my $f = 5 < 4; Dump $t; Dump $f;
SV = PVNV(0x100802c20) at 0x100827348 REFCNT = 1 FLAGS = (PADMY,IOK,NOK,POK,pIOK,pNOK,pPOK) IV = 1 NV = 1 PV = 0x100201e60 "1"\0 CUR = 1 LEN = 16 SV = PVNV(0x100802c40) at 0x100827360 REFCNT = 1 FLAGS = (PADMY,IOK,NOK,POK,pIOK,pNOK,pPOK) IV = 0 NV = 0 PV = 0x100208ca0 ""\0 CUR = 0 LEN = 16
use strict; use warnings; use Scalar::Util qw/dualvar/; BEGIN { &Internals::SvREADONLY(\!!0, 0); ${\!!0} = dualvar 0, "false"; } if (5 < 4) { print "oops\n"; }
&Internals::SvREADONLY( \ !!1, 0); ${ \ !!1 } = &Internals::SvREADONLY( \ !!1, 1); print 42 == (6*7); &Internals::SvREADONLY( \ !!0, 0); ${ \ !!0 } = &Internals::SvREADONLY( \ !!0, 1); print 42 == (6*6);
while(<STDIN>) { if( /^hello/ ){ print "Hello back to ya!\n"; } } foo hello Hello back to ya! #
use Encode qw(decode encode); my $foo = $ARGV[0]; $foo = decode("utf-8", $foo);
use I18N::Langinfo qw(langinfo CODESET); my $codeset = langinfo(CODESET);
use Encode qw(decode); @ARGV = map { decode $codeset, $_ } @ARGV;
use utf8; use Modern::Perl; use Encode::Locale qw(decode_argv); if (-t) { binmode(STDIN, ":encoding(console_in)"); binmode(STDOUT, ":encoding(console_out)"); binmode(STDERR, ":encoding(console_out)"); } Encode::Locale::decode_argv();
perl -C ppixregexplain.pl qr/\bмама\b/i > ex1.html 2>&1
@last_n = ($n >= @source) ? @source : @source[-$n..-1];
@a = (a .. z); @last_five = @a[ $ say join " ", @last_five;
@a = reverse @a; @a = splice(@a, 0, $elements_to_keep); @a = reverse @a;
my @last_n = ($n >= @source) ? @source : splice(@source, -$n);
my $ua = LWP::UserAgent->new( ssl_opts => { verify_hostname => 0 }, );
my $ua = LWP::UserAgent->new( ssl_opts => { verify_hostname => 0 }, );
my $ua = LWP::UserAgent->new( ssl_opts => { SSL_verify_mode => );
my %HoH = ( flintstones => { husband => "fred", pal => "barney", }, jetsons => { husband => "george", wife => "jane", "his boy" => "elroy", }, simpsons => { husband => "homer", wife => "marge", kid => "bart", }, );
%foo = ( "key1", "value1", "key2", "value2", ... ); %foo = ( key1 => "value1", key2 => "value2", ... );
$foo = { key1 => "value1", key2 => "value2", ... };
$foo = { key1 => "value1", key2 => "value2" }; %bar = ( key3 => $foo ); %baz = ( key4 => { key5 => "value5", key6 => "value6" } );
my %hash = ( a => 1 , b => 2 ) ; my $hash_ref = { a => 1 , b => 2 } ;
sub f { return ( a => 1, b => 2 ) } my %hash = f(); sub f { return a => 1, b => 2 } my %hash = f();
my %HoH = ( flintstones => { husband => "fred", pal => "barney", }, jetsons => { husband => "george", wife => "jane", "his boy" => "elroy", }, simpsons => { husband => "homer", wife => "marge", kid => "bart", }, );
my %flintstones = ( husband => "fred", pal => "barney", ); my %jetsons = ( husband => "george", wife => "jane", "his boy" => "elroy", ); my %simpsons = ( husband => "homer", wife => "marge", kid => "bart", ); my %HoH = ( flintstones => \%flinstones, jetsons => \%jetsons, simpsons => \%simpsons, );
use strict; use warnings; use CGI; my $q = CGI->new; my %headers = map { $_ => $q->http($_) } $q->http(); print $q->header( print "Got the following headers:\n"; for my $header ( keys %headers ) { print "$header: $headers{$header}\n"; }
$ curl http: Got the following headers: HTTP_HEADERATTRIBUTE: value HTTP_ACCEPT: */* HTTP_HOST: localhost HTTP_USER_AGENT: curl/7.21.0 (i686-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
my $header = if (exists $ENV{$header} && lc $ENV{$header} eq _do_some_ajaxian_stuff(); }
use File::Spec; ... my $rel_path = my $abs_path = File::Spec->rel2abs( $rel_path ) ;
use Cwd; my $dir = getcwd; use Cwd my $abs_path = abs_path($file);
$start_path = "/abc/def/"; @files = <$start_path*/myfile.txt> foreach $file(@files) { print $file; }
$path= $path =~ tr /\\/\ chomp($path); print "$path";
has is => lazy => 1, builder => init_arg => undef, );
sub called { my $self = shift; $self->_set_call_counter( $self->call_counter + 1 ); ... }
has config => ( is => isa => traits => [qw/Private/], );
my $c1 = CountingObject->new(); printf( "%s\n", $c1->get_count() );
package CountingObject; use Moose; my %cntr; sub BUILD { my $self = shift; $cntr{$self} = 0 } sub add_one { my $self = shift; $cntr{$self}++; } sub get_count { my $self = shift; return $cntr{$self}; } 1;
package CountingObject; use Moose; my %cntr; sub add_one { $cntr{$_[0]}++ } sub get_count { return $cntr{$_[0]}||0 } 1;
package CountingObject; use Moose; my $cntr = 0; sub add_one { $cntr++; } sub get_count { return $cntr; } 1;
use CountingObject; my $co = CountingObject->new(); printf( "%s\n", $co->get_count() ); for (1..10) { $co->add_one(); } printf( "%s\n", $co->get_count() );
cpan> o conf init /proxy/ Your ftp_proxy? [] ftp: Your http_proxy? [] http: Your no_proxy? []
use warnings; use strict; $_ = foreach my $ascii (32 .. 126) { my $delim = chr $ascii; next if $delim eq foreach my $m ( my $code = $m . $delim . my $match; { no warnings ($match) = eval $code; } print "[$delim] didn if (defined $match and $match ne print "[$delim] didn } } }
while (<>) { print "line $. : ", $_; close ARGV if eof; }
while ($ARGV = shift @ARGV) { open ARGV, $ARGV or do{ warn "Can next; }; while (<ARGV>) { ...; } }
my %filename_positions = map { ( $ARGV[$_] => $_ ) } 0..$ while (<>) { my $file_number = $filename_positions{$ARGV}; }
use warnings; use strict; use Net::SMTP; my $smtpserver = my $smtpport = 25; my $smtpuser = my $smtppassword = my $smtp = Net::SMTP->new($smtpserver, Port=>$smtpport, Timeout => 10, Debug => 1); die "Could not connect to server!\n" unless $smtp; $smtp->auth($smtpuser, $smtppassword); $smtp->to( $smtp->data(); $smtp->datasend("To: mymail\@gmail.com\n"); $smtp->quit;
Net::SMTP>>> Net::SMTP(2.31) Net::SMTP>>> Net::Cmd(2.29) Net::SMTP>>> Exporter(5.65) Net::SMTP>>> IO::Socket::INET(1.31) Net::SMTP>>> IO::Socket(1.32) Net::SMTP>>> IO::Handle(1.31) Net::SMTP=GLOB(0x273faf0)<<< 220 server GMX Mailservices E Net::SMTP=GLOB(0x273faf0)>>> EHLO localhost.localdomain Net::SMTP=GLOB(0x273faf0)<<< 250-server GMX Mailservices Net::SMTP=GLOB(0x273faf0)<<< 250-8BITMIME Net::SMTP=GLOB(0x273faf0)<<< 250-ENHANCEDSTATUSCODES Net::SMTP=GLOB(0x273faf0)<<< 250-SIZE Net::SMTP=GLOB(0x273faf0)<<< 250-AUTH=LOGIN PLAIN Net::SMTP=GLOB(0x273faf0)<<< 250-AUTH LOGIN PLAIN Net::SMTP=GLOB(0x273faf0)<<< 250 STARTTLS Net::SMTP=GLOB(0x273faf0)>>> RCPT TO:<mymail@gmail.com> Net::SMTP=GLOB(0x273faf0)<<< 503 5.5.1 MAIL first {mp-eu001} Net::SMTP=GLOB(0x273faf0)>>> DATA Net::SMTP=GLOB(0x273faf0)<<< 503 5.5.1 MAIL first {mp-eu001} Net::SMTP=GLOB(0x273faf0)>>> To: mymail@gmail.com Net::SMTP=GLOB(0x273faf0)>>> . Net::SMTP=GLOB(0x273faf0)<<< 502 5.5.2 Unimplemented {mp-eu001} Net::SMTP=GLOB(0x273faf0)>>> QUIT Net::SMTP=GLOB(0x273faf0)<<< 502 5.5.2 Unimplemented {mp-eu001}
$smtp->auth($smtpuser, $smtppassword); $smtp->mail( $smtp->to(
use strict; use warnings; use Email::Sender::Simple qw(sendmail); use Email::Sender::Transport::SMTP (); use Email::Simple (); use Email::Simple::Creator (); my $smtpserver = my $smtpport = 25; my $smtpuser = my $smtppassword = my $transport = Email::Sender::Transport::SMTP->new({ host => $smtpserver, port => $smtpport, sasl_username => $smtpuser, sasl_password => $smtppassword, }); my $email = Email::Simple->create( header => [ To => From => Subject => ], body => "This is my message\n", ); sendmail($email, { transport => $transport });
use strict; use warnings; use Email::Sender::Simple qw(sendmail); use Email::Sender::Transport::SMTPS; use Email::Simple (); use Email::Simple::Creator (); my $smtpserver = my $smtpport = 587; my $smtpuser = my $smtppassword = my $transport = Email::Sender::Transport::SMTPS->new({ host => $smtpserver, ssl => port => $smtpport, sasl_username => $smtpuser, sasl_password => $smtppassword, debug => 1, }); my $email = Email::Simple->create( header => [ To => From => Subject => ], body => "This is my message\n", ); sendmail($email, { transport => $transport });
my $msg = MIME::Lite ->new ( From => To => Subject => Data => Type => ); my $USERNAME = my $PASSWORD = my $smtps = Net::SMTPS->new("smtp.mail.att.net", Port => 587, doSSL => $smtps->auth ( $USERNAME, $PASSWORD ) or die("Could not authenticate with bellsouth.\n"); $smtps ->mail( $smtps->to( $smtps->data(); $smtps->datasend( $msg->as_string() ); $smtps->dataend(); $smtps->quit;
Compiling REx `.*' size 3 Got 28 bytes for offset annotations. first at 2 1: STAR(3) 2: REG_ANY(0) 3: END(0) anchored(MBOL) implicit minlen 0 Offsets: [3] 2[1] 1[1] 3[0] Matching REx ".*" against "a" Setting an EVAL scope, savestack=5 0 <> <a> | 1: STAR REG_ANY can match 1 times out of 2147483647... Setting an EVAL scope, savestack=5 1 <a> <> | 3: END Match successful! Matching REx ".*" against "" Setting an EVAL scope, savestack=7 1 <a> <> | 1: STAR REG_ANY can match 0 times out of 2147483647... Setting an EVAL scope, savestack=7 1 <a> <> | 3: END Match successful! Matching REx ".*" against "" Setting an EVAL scope, savestack=7 1 <a> <> | 1: STAR REG_ANY can match 0 times out of 2147483647... Setting an EVAL scope, savestack=7 1 <a> <> | 3: END Match possible, but length=0 is smaller than requested=1, failing! failed... Match failed foofoo Freeing REx: `".*"'
try: import Module except: print "You need module Module to run this program."
eval "use Module; 1" or die "you need Module to run this program".
require Module or die "you need Module to run this program"; Module->import;
use Module::Load; eval { load Module; 1 } or die "you need Module to run this program";
use Module::Load::Conditional qw[can_load check_install requires]; my $use_list = { CPANPLUS => 0.05, LWP => 5.60, }; if(can_load( modules => $use_list )) { print } else { print }
use strict; use utf8; use warnings qw(all); use Class::Load qw(try_load_class); try_load_class( or die "You need module Module to run this program.";
sub do_optional_thing { init_special_support(); Module::Special::wow(); } sub init_special_support { return if defined $INC{ eval { require Module::Special; Module::Special->import(); }; croak "Special feature not supported: Module::Special not available" if $@; }
$ echo hello1 > file1 $ echo hello2 > file2 $ echo hello3 > file3 $ perl -e file1:hello1 file2:hello2 file3:hello3
while (<>) { next if /^\s* print "$.\t$_"; } continue { close ARGV if eof; }
unshift(@ARGV, while ($ARGV = shift) { open(ARGV, $ARGV); while (<ARGV>) { ... } }
my @closures; foreach (1..3) { push @closures, sub { say "I will remember $_"; }; } foreach (@closures) { &{$_}(); }
I will remember 1 I will remember 2 I will remember 3
use strict; use warnings; use 5.010; my @closures; foreach my $_ (1..3) { push @closures, sub { say "I will remember $_"; }; } foreach (@closures) { &{$_}(); }
use strict; my @closures; foreach (1..3) { my $var = $_; push @closures, sub { print "I will remember $var"; }; } foreach (@closures) { $_->(); print "\n"; }
sub total { my $running_sum; while (@_) { $running_sum += shift; } $running_sum; } sub avg { calculate the mean of given arguments if (@_ == 0) { return } my $sum = &total; $sum / @_ }
sub total { my $total = 0; $total += $_ for @_; $total; }
use List::Util qw(sum); sub avg { @_ ? sum(@_) / @_ : 0 }
sub login { my $user = shift; my $passphrase = shift; return 0; }
sub login { my ($user, $passphrase) = @_; return 0; }
sub login { my user = $_[0]; my user = $_[1]; return 0; }
sub login($$) { my ($user, $passphrase) = @_; return 0; }
return unless defined $user; return unless defined $passphrase;
unless (defined($user) && defined($passphrase)) { carp "Input error: user or passphrase not defined"; return -1; }
sub get_temp { my $location = @_ % 2 ? shift : undef; my %options = @_; $location ||= $options{location}; ... }
use strict; use warnings; package Unusual; use Carp; sub new { my $class = shift; return bless { @_ }, $class; } sub dispatch_dirty { my $self = shift; my $name = shift; my $method = $self->can($name) or confess "No method named $name"; $self->$method(@_); } sub dispatch_clean { my $self = shift; my $name = shift; my $method = $self->can($name) or confess "No method named $name"; unshift @_, $self; goto $method; } sub death { my ($self, $message) = @_; $message ||= confess "$self->{name}: $message"; } package main; use Getopt::Long; GetOptions my $obj = Unusual->new(name => $name); if ($clean) { $obj->dispatch_clean(@ARGV); } else { $obj->dispatch_dirty(@ARGV); }
$ ./test.pl death Goodbye Robot: Goodbye at ./test.pl line 32 Unusual::death( Unusual::dispatch_dirty(
$ ./test.pl -c death Adios Robot: Adios at ./test.pl line 33 Unusual::death(
sub refWay{ my ($refToArray,$secondParam,$thirdParam) = @_; } refWay(\@array,
sub hashWay{ my $refToHash = shift; return undef unless exists $refToHash->{ return undef unless exists $refToHash->{ for (qw(user password etc)){ return undef unless exists $refToHash->{$_}; } } hashWay({
use strict; sub total { my $sum = 0; while(@_) { $sum = $sum + shift; } return $sum; } sub total1 { my ($a, $aa, $aaa) = @_; return ($a + $aa + $aaa); } my $s; $s = total(10, 20, 30); print $s; $s = total1(10, 20, 30); print "\n$s";
C:\Program Files> cpan Win32::IE::Mechanize CPAN: LWP::UserAgent loaded ok (v5.835) CPAN: Time::HiRes loaded ok (v1.9721) Fetching with LWP: http: LWP failed with code[500] message[Can Warning: no success downloading Fetching with LWP: ftp: LWP failed with code[500] message[LWP::Protocol::MyFTP: Bad hostname Fetching with Net::FTP: ftp: Could not connect to host Fetching with Net::FTP ftp: Could not connect to host Warning: no success downloading Warning: no success downloading As a last resort we now switch to the external ftp command to get Doing so often leads to problems that are hard to diagnose. If you ftp config variable with o conf ftp "" o conf commit Issuing "C:\WINDOWS\system32\ftp.EXE -n" Trying with external ftp to get ftp: Going to send the dialog open mirror.teklinks.com user anonymous win32-vanilla@perl.org lcd C:\strawberry\cpan\sources\authors cd / cd CPAN cd authors bin passive get 01mailrc.txt.gz 01mailrc.txt.gz.tmp5264 quit Unknown host mirror.teklinks.com. Not connected. Local directory now C:\strawberry\cpan\sources\authors. Not connected. Not connected. Not connected. Not connected. Invalid command. Not connected. Bad luck... Still failed! Can Fetching with LWP: http: LWP failed with code[500] message[Can Warning: no success downloading Warning: no success downloading Fetching with LWP: ftp: LWP failed with code[500] message[LWP::Protocol::MyFTP: Bad hostname Fetching with Net::FTP: ftp: Could not connect to host Fetching with Net::FTP ftp: Could not connect to host Warning: no success downloading Warning: no success downloading As a last resort we now switch to the external ftp command to get Doing so often leads to problems that are hard to diagnose. If you ftp config variable with o conf ftp "" o conf commit Issuing "C:\WINDOWS\system32\ftp.EXE -n" Trying with external ftp to get ftp: Going to send the dialog open mirror.teklinks.com user anonymous win32-vanilla@perl.org lcd C:\strawberry\cpan\sources\authors cd / cd CPAN cd authors bin passive get 01mailrc.txt.gz 01mailrc.txt.gz.tmp5264 quit Unknown host mirror.teklinks.com. Not connected. Local directory now C:\strawberry\cpan\sources\authors. Not connected. Not connected. Not connected. Not connected. Invalid command. Not connected. Bad luck... Still failed! Can CPAN: YAML loaded ok (v0.73) Please check, if the URLs I found in your configuration file (http: valid. The urllist can be edited. E.g. with ftp: Could not fetch authors/01mailrc.txt.gz
http_proxy proxy host for http requests ftp_proxy proxy host for ftp requests
C:\> set http_proxy=http: C:\> set ftp_proxy=http: C:\> cpan
sub my_sub { my $ref_array = shift; my @array = @$ref_array; }
sub my_sub { my $ref_array = shift; for (@$ref_array) { }; }
no strict; sub F { local *array = shift; print "\@array = @array\n"; print "\$array = $array\n"; print "\%array = ",%array,"\n"; print "------------------\n"; } $array = "original scalar"; %array = ("original" => "hash"); @array = ("orignal","array"); $foo = "foo"; @foo = ("foo","bar"); %foo = ("FOO" => "foo"); F ["new","array"]; F \"new scalar"; F {"new" => "hash"}; F *foo; F F F ();
my $print_something = sub { print "Something\n" }; sub do_something { my ($function) = @_; $function->(); } do_something($print_something);
sub make_hello_printer { my $message = "Hello, world!"; return sub { print $message; } } my $print_hello = make_hello_printer(); $print_hello->()
use strict; use warnings; sub do_it { print join( ":", @_ ); } my $dispatch = { }; $dispatch->{
sub check_config { my ( $class, $obj ) = @_; my $separator = my $message = join $separator, ( split my $object = $obj || $class->new; return sub { my $attribute = shift; is $object->config->{$attribute}, $object->$attribute, join $separator, ( $message, $attribute ); } } sub check_config_attributes { my ( $class, $obj ) = @_; return sub { my $attributes = shift; check_config( $class, $obj )->($_) for (@$attributes); } }
@a = (undef, 0); @b = (); $b[1] = 0; print Dumper(@a), "\n", Dumper(@b);
$VAR1 = undef; $VAR2 = 0; $VAR1 = undef; $VAR2 = 0;
sub change { $_[0] = 1 } change(@a); change(@b); print Dumper(@a), "\n", Dumper(@b);
say "index $_ ", exists $array[$_] ? "exists" : "doesn
index 0 doesn index 1 doesn index 2 exists index 3 doesn index 4 doesn
sub crazy { say 1*exists $_[0]; $_[0] = 1; say 1*exists $_[0]; } my @array; $array[2] = 0; crazy @array; say 1*exists $array[0];
package Foo; our $x = 1; package main; $::x = 42; say $x;
package Foo { our $x = 1; } package main { $::x = 42; say $x; }
package wblock1; my $a =10; sub wbmethod1{ print "in wb $a"; } package wblock; sub wbmethod{ print "in wb1 $a"; } 1;
package wblock1 { my $a =10; sub wbmethod1{ print "in wb $a"; } 1; } package wblock { sub wbmethod{ print "in wb1 $a"; } 1; }
use 5.010; use 5.010_001; use 5.10.0; use v5.10; use v5.10.0;
sub class_method { my ($class, @args) = @_; die "class method invoked on object" if ref $class; }
use 5.010; $_ = s/(?<!\.)(?:\b|\G)\d+?\K(?=(?:\d\d\d)+\b)/,/g; say;
s/ (?<!\.) (?: \b | \G ) \d+? \K (?= (?:\d\d\d)+ \b ) /,/xg;
s/ (?: (?<=\d) (?=(?:\d\d\d)+\b) | ( \d{0,3} \. \d+ ) ) / $1 ? $1 :
$ perl -e' print "A"; for (8,9) { print "B"; print map { print "C"; next; print "D"; $_ } 1,2,3; print "E"; } print "F\n"; ' ABCBCF
$ perl -wE $ perl -wE Exiting subroutine via last at -e line 1.
print "A"; print map { print "B"; last; print "C";} 1,2,3; print "Z";
use ExtUtils::MakeMaker; WriteMakefile ( NAME => AUTHOR => ..., ..., PREREQ_PM => { ... }, ... );
use Module::Build; ... my $builderclass = Module::Build->subclass( ... customizations ... ); my $builder = $builderclass->new( module_name => ..., build_requires => { }, ... ); $builderclass->create_build_script();
use inc::Module::Install; ... requires requires test_requires ... WriteAll;
20 testRead( 21 22 23 # 24 25 # 26 ++$test; 27 testRead( 28
my $i = 0; when (1) { print $i, "\n"; } continue { if ($i < 10) { $i++; } else { last; } }
given ("abc") { when (/z/) { print qq{Found a "z"\n}; continue; } when (/a/) { print qq{Found a "a"\n}; continue; } when (/b/) { print qq{Found a "b"\n}; continue; } }
my $TIMEOUT_IN_SECONDS = 5; eval { local $SIG{ALRM} = sub { die "alarm\n" }; alarm($TIMEOUT_IN_SECONDS); alarm(0); }; if ($@) { }
use Time::HiRes qw(sleep); sub timeout { my $timeout = shift; my $poll_interval = shift; my $test_condition = shift; until ($test_condition->() || $timeout <= 0) { $timeout -= $poll_interval; sleep $poll_interval; } return $timeout > 0; } my $success = timeout(30, 0.1, \&some_condition_is_met);
$\="\n"; $s=`curl -s --request GET --url https: print $s;
use 5.024; use strictures; use Time::HiRes qw(sleep); sub mock_connect { my $how_long_it_takes = 3 + rand; sleep $how_long_it_takes; return $how_long_it_takes; } sub main { state $db_handle = mock_connect($dsn); return sub { [200, [], ["connect took $db_handle seconds\n"]] }; } my $dsn = my $app = main($dsn);
› perl -MBenchmark=timeit,timestr,:hireswallclock -E"say timestr timeit 10, sub { system q(curl http: connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds connect took 3.0299610154043 seconds 2.93921 wallclock secs ( 0.03 usr + 0.06 sys = 0.09 CPU) @ 107.53/s (n=10)
› perl -MBenchmark=timeit,timestr,:hireswallclock -E"say timestr timeit 10, sub { system q(curl http: connect took 3.77111188120125 seconds connect took 3.15455510265111 seconds connect took 3.77111188120125 seconds connect took 3.15455510265111 seconds connect took 3.77111188120125 seconds connect took 3.64333342488772 seconds connect took 3.15455510265111 seconds connect took 3.77111188120125 seconds connect took 3.85268922343767 seconds connect took 3.64333342488772 seconds 17.4764 wallclock secs ( 0.02 usr + 0.09 sys = 0.11 CPU) @ 90.91/s (n=10)
use strict; use warnings; use JSON; use XML::Simple; my $data; { open( my $file, $data = XMLin($file); close $file; } { open( my $file, print $file to_json( $data ); close $file; }
CATEGORY1=youknow_<PREF> CATEGORY2=your/<PREF>/goes/here/
use strict; open(FILE, "</tmp/yourfile.txt") || die "File not found"; my @lines = <FILE>; close(FILE); my @newlines; foreach(@lines) { $_ =~ s/<PREF>/ABCD/g; push(@newlines,$_); } open(FILE, ">/tmp/yourfile.txt") || die "File not found"; print FILE @newlines; close(FILE);
use strict; use warnings; $^I = while (<>) { s/<PREF>/ABCD/g; print; }
my @db = `mysql -u XXXXX -pXXXXX --skip-column-names -e "show databases;"`; foreach my $db_name (@db) { chomp($db_name); my @tables = `mysql -u XXXXX -pXXXXX --skip-column-names -e "use $db_name; show tables;"`; $_ =~ s/\n unless ( -e "$db_name.pm") { open(DBFILE, print DBFILE "package mysql::schemes::$db_name;\n"; print DBFILE "use base qw/DBIx::Class::Schema/;\n\n"; print DBFILE print DBFILE "1;"; close(DBFILE); } mkdir $db_name unless ( -d $db_name or -e $db_name ); foreach my $table_name (@tables) { my @columns = `mysql -u XXXX -pXXXX --skip-column-names -e "USE $db_name; desc \\\`$table_name\\\`;"`; $_ =~ s/\n$ my (@names, $primary_key); foreach (@columns) { my ($name, $type, $null, $key, $default) = split(/\t/, $_); chomp($default); push(@names, $name); $primary_key = $name if($key ne } unless ( -e "$db_name/$table_name.pm" ) { open(TBFILE, print TBFILE "package mysql::schemes::" . $db_name . "::" . $table_name . ";\n"; print TBFILE "use base qw/DBIx::Class/;\n\n"; print TBFILE "__PACKAGE__->load_components(qw/PK::Auto Core/);\n"; print TBFILE "__PACKAGE__->table( print TBFILE "__PACKAGE__->add_columns(qw/" . join( print TBFILE "__PACKAGE__->set_primary_key( print TBFILE "1;"; close(TBFILE); } } }
* Its a quine (when executed, prints an exact copy of itself) * Turns other programs into quines * Plays Conway * Animates a marquee banner
my $rows = $dbh->selectall_arrayref($sql, { Slice => {} }); my $rows = $db->query($sql)->hashes;
sub someFunction($$@) { my ( $oblig_param1, $oblig_param2, $option_param ) = @_; ... }
sub someFunction($$;$) { my ( $oblig_param1, $oblig_param2, $option_param ) = @_; ... }
sub someFunction { my ( $oblig_param1, $oblig_param2, $option_param ) = @_; ... }
sub someFunction { my ( $oblig_param1, $oblig_param2, $option_param ) = @_; if (defined $option_param) { } $option_param .... }
--------------------------+------------------------- --------------------------+------------------------- someFunc( $oblig1, | sub { $oblig2, | my ( $oblig1, $option1 ); | $oblig2, | $option1 ) = @_; | } --------------------------+------------------------- --------------------------+------------------------- --------------------------+------------------------- someFunc( $oblig1, | sub { $oblig2, | my ( $oblig1, $oblig3, | $oblig2, $option1 ); | $oblig3, | $option1 ) = @_; | } --------------------------+-------------------------
--------------------------+------------------------- --------------------------+------------------------- someFunc({ oblig1 => 1 | sub { oblig2 => 2 | my ( $params ) = @_; option1 => 1 | oblig3 => 7 | }); | } | --------------------------+-------------------------
for ( qw/ a b c / ) { die "Missing unless exists $mandatory_parameters->{$_}; }
use Cwd qw(abs_path); my $path = abs_path($0); print "$path\n";
use Cwd qw( abs_path ); use File::Basename qw( dirname ); say dirname(abs_path($0));
use Cwd qw( abs_path ); use Path::Class qw( file ); say file(abs_path($0))->dir;
use Cwd qw(); my $path = Cwd::cwd(); print "$path\n";
use Cwd qw(); my $path = Cwd::abs_path(); print "$path\n";
use File::Basename qw(); my ($name, $path, $suffix) = File::Basename::fileparse($0); print "$path\n";
use Cwd qw(abs_path); my $path = abs_path(); print "$path\n";
use Cwd; my $cwd = cwd(); print "Current working directory:
root@srv apache /services/apache root@srv apache /services/apache2225
@array = <>; print "Enter the word you what to match\n"; chomp($match = <STDIN>); if (grep($match, @array)) { print "found it\n"; }
if (my ($matched) = grep $_ eq $match, @array) { print "found it: $matched\n"; }
my %hash = map {$_ => 1} @array; if (defined $hash{$match}) { print "found it\n"; }
use List::Util qw/first/; my @array = qw/foo bar baz/; print first { $_ eq
if (grep /$match/, @array, @array_one, @array_two, @array_Three) { print "found it\n"; }
sub for_hash { my ($hash, $fn) = @_; while (my ($key, $value) = each %$hash) { if ( for_hash $value, $fn; } else { $fn->($value); } } } my $example = { for_hash $example, sub { my ($value) = @_; };
use strict; use warnings; sub hash_walk { my ($hash, $key_list, $callback) = @_; while (my ($k, $v) = each %$hash) { push @$key_list, $k; if (ref($v) eq hash_walk($v, $key_list, $callback); } else { $callback->($k, $v, $key_list); } pop @$key_list; } } my %data = ( a => { ab => 1, ac => 2, ad => { ada => 3, adb => 4, adc => { adca => 5, adcb => 6, }, }, }, b => 7, c => { ca => 8, cb => { cba => 9, cbb => 10, }, }, ); sub print_keys_and_value { my ($k, $v, $key_list) = @_; printf "k = %-8s v = %-4s key_list = [%s]\n", $k, $v, "@$key_list"; } hash_walk(\%data, [], \&print_keys_and_value);
foreach my $key (keys %hash) { foreach my $key2 (keys %{ $hash{$key} }) { foreach my $key3 (keys %{ $hash{$key}{$key2} }) { $value = $hash{$key}{$key2}->{$key3}; } } }
sub hash_walk { my $self = shift; my ($hash, $key_list, $callback) = @_; while (my ($k, $v) = each %$hash) { push @$key_list, $k; if (ref($v) eq $self->hash_walk($v, $key_list, $callback); } else { $callback->($k, \$v, $key_list); } pop @$key_list; $hash->{$k} = $v; } } hash_walk(\%prj, [], \&replace_all_val_strings); sub replace_all_val_strings { my ($k, $v, $key_list) = @_; printf "k = %-8s v = %-4s key_list = [%s]\n", $k, $$v, "@$key_list"; $$v =~ s/oldstr/newstr/; printf "k = %-8s v = %-4s key_list = [%s]\n", $k, $$v, "@$key_list"; }
while ( ($family, $roles) = each %HoH ) { print "$family: "; while ( ($role, $person) = each %$roles ) { print "$role=$person "; } print "\n"; }
foreach my $keyname (keys(%foo) { my $subhash = $foo{$keyname}; }
use Data::Traverse qw(traverse); my %test_hash = ( q => [qw/1 2 3 4/], w => [qw/4 6 5 7/], e => ["8"], r => { r => "9" , t => "10" , y => "11" , } , ); traverse { next if /ARRAY/; print "$a => $b\n" if /HASH/ && $b > 8 } \%test_hash;
my $test = \split( /,/, foreach $k (@$test) { print "k is $k\n"; }
$ perl -MDevel::Peek -we SV = IV(0x23b18e8) at 0x23b18f0 REFCNT = 1 FLAGS = (TEMP,ROK) RV = 0x23acd28 SV = PVHV(0x23890b0) at 0x23acd28 REFCNT = 2 FLAGS = (PADMY,SHAREKEYS) ARRAY = 0x23b5d38 KEYS = 0 FILL = 0 MAX = 63 RITER = -1 EITER = 0x0 SV = IV(0x23b18e8) at 0x23b18f0 REFCNT = 1 FLAGS = (TEMP,ROK) RV = 0x23acd28 SV = PVHV(0x23890b0) at 0x23acd28 REFCNT = 2 FLAGS = (PADMY,SHAREKEYS) ARRAY = 0x0 KEYS = 0 FILL = 0 MAX = 7 RITER = -1 EITER = 0x0
my @arr = ("Field3","Field1","Field2","Field5","Field4");
%hash = map { $arr[$_] => $_ } 0..$ print Dumper(\%hash) $VAR1 = { };
sub get_bumper { my $i = 0; sub { $i++ }; } my $bump = get_bumper; map { $_ => $bump->(); } @arr;
use 5.012; my %hash; while(my ($index, $value) = each @arr) { $hash{$value} = $index; }
{ package FooObj; sub new { ... } sub add_data { ... } } { package BarObj; use FooObj; sub new { ... my $self = ( myFoo => FooObj->new() ); ... } sub some_method { ... } } my $bar = BarObj->new();
{ package FooObj; sub new { bless { _count => 0 }, $_[0] } sub add_data { $_[0]->{_count}++ } } { package BarObj; use Data::Dumper; sub new { bless { myFoo => FooObj->new }, $_[0]; } sub foo { $_[0]->{myFoo} } sub some_method { print Dumper( $_[0] ) } } my $bar = BarObj->new; $bar->some_method;
{ package FooObj; use Data::Dumper; sub new { bless { _count => 0 }, $_[0] } sub add_data { $_[0]->{_count}++ } use Exporter qw(import); our @EXPORT = qw(dumper); sub dumper { print Dumper( $_[0] ) } } { package BarObj; FooObj->import; sub new { bless { myFoo => FooObj->new }, $_[0]; } sub foo { $_[0]->{myFoo} } sub some_method { dumper( $_[0] ) } } my $bar = BarObj->new; $bar->some_method;
use strict; use warnings; package FooObj; sub new { my $this = shift; my $class = ref($this) || $this; my $self = {}; bless $self, $class; $self->initialize(); return $self; } sub initialize { } sub add_data { } package BarObj; sub new { my $this = shift; my $class = ref($this) || $this; my $self = { myFoo => FooObj->new() }; bless $self, $class; $self->initialize(); return $self; } sub initialize { } sub some_method { } sub myFoo { return $_[0]->{myFoo} } package main; use Test::More; my $bar = BarObj->new(); isa_ok( $bar, isa_ok( $bar->myFoo, done_testing(); __DATA__ ok 1 - bar is a BarObj isa BarObj ok 2 - bar->myFoo is a FooObj isa FooObj 1..2
@$arr_ref = sort { $a->{brand} cmp $b->{brand} or $a->{supplier} cmp $b->{supplier} or $a->{PO} <=> $b->{PO} } @$arr_ref;
$arr_ref = [sort by_brand_supplier_PO @$arr_ref]; sub by_brand_supplier_PO { $a->{brand} cmp $b->{brand} || $a->{supplier} cmp $b->{supplier} || $a->{PO} <=> $b->{PO} }
use Sort::Key::Multi qw(ssikeysort); @$arr_ref = ssikeysort { $_->{brand}, $_->{supplier}, $_->{PO} } @$arr_ref;
use Sort::Key::Multi qw(ssikeysort_inplace); ssikeysort_inplace { $_->{brand}, $_->{supplier}, $_->{PO} } @$arr_ref;
use strict; use warnings; $|=1;$\="\n"; print "Test";
$x = 1234; $DB::single = 1; enter_problematic_sub_now();
$var1 = $var2 = "\("; $res1 = ($matchStr =~ m/$var1/); $res2 = ($matchStr =~ m/$var2/);
my $var1 = my $var2 = "$var1"; my $var3 = print $var2; print "\n"; print $var3; print "\n";
my $matchStr = "("; my $var1 = qr/\(/; my $res1 = ($matchStr =~ m/$var1/);
perl: warning: Setting locale failed. perl: warning: Please check that your locale settings: LANGUAGE = (unset), LC_ALL = (unset), LANG = "en_CA.UTF-8" are supported and installed on your system. perl: warning: Falling back to the standard locale ("C").
root@hostname:~ root@hostname:~ root@hostname:~ root@hostname:~
use strict; use warnings; use Algorithm::Combinatorics qw(combinations); my $strings = [qw(AAA BBB CCC DDD EEE)]; my $iter = combinations($strings, 2); while (my $c = $iter->next) { print "@$c\n"; }
use strict; use warnings; my $strings = [qw(AAA BBB CCC DDD EEE)]; sub combine; print "@$_\n" for combine $strings, 5; sub combine { my ($list, $n) = @_; die "Insufficient list members" if $n > @$list; return map [$_], @$list if $n <= 1; my @comb; for my $i (0 .. $ my @rest = @$list; my $val = splice @rest, $i, 1; push @comb, [$val, @$_] for combine \@rest, $n-1; } return @comb; }
use strict; use warnings; my $strings = [qw(AAA BBB CCC DDD EEE)]; sub combine; print "@$_\n" for combine $strings, 2; sub combine { my ($list, $n) = @_; die "Insufficient list members" if $n > @$list; return map [$_], @$list if $n <= 1; my @comb; for (my $i = 0; $i+$n <= @$list; ++$i) { my $val = $list->[$i]; my @rest = @$list[$i+1..$ push @comb, [$val, @$_] for combine \@rest, $n-1; } return @comb; }
use Math::Combinatorics; my @n = qw(a b c); my $combinat = Math::Combinatorics->new(count => 2, data => [@n], ); print "combinations of 2 from: ".join(" ",@n)."\n"; print "------------------------".("--" x scalar(@n))."\n"; while(my @combo = $combinat->next_combination){ print join( } print "\n"; print "permutations of 3 from: ".join(" ",@n)."\n"; print "------------------------".("--" x scalar(@n))."\n"; while(my @permu = $combinat->next_permutation){ print join( } output: combinations of 2 from: a b c ------------------------------ a b a c b c permutations of 3 from: a b c ------------------------------ a b c a c b b a c b c a c a b c b a
use strict; use warnings; use Data::Dump qw(dump); my @in = qw(AAA BBB CCC DDD EEE); my @list; while(my $first = shift @in) { last unless @in; my $rest = join push @list, glob("{$first}{$rest}"); } dump @list;
( "AAABBB", "AAACCC", "AAADDD", "AAAEEE", "BBBCCC", "BBBDDD", "BBBEEE", "CCCDDD", "CCCEEE", "DDDEEE", )
my @list = qw(AAA BBB CCC DDD EEE); for my $i (0..$ print join "\n", glob sprintf "{ join ",", @list[$i+1..$ print "\n"; }
AAA BBB AAA CCC AAA DDD AAA EEE BBB CCC BBB DDD BBB EEE CCC DDD CCC EEE DDD EEE
my @myArray = $self->{myArray}; foreach my $foo (@myArray){ ... }
my $myArray = $self->{myArray}; for my $foo (@$myArray){ }
$ cat Foo.pm package Foo; return "Basset hounds got long ears"; $ cat test.plx print require Foo, "\n"; print require Foo, "\n"; $ perl -I. test.plx Basset hounds got long ears 1
$ sudo service mysql stop $ sudo service nginx stop
$ cpan install CPAN $ cpan install MIME::Lite::TT::HTML
$env_path= Shell::Source->new(shell=>"tcsh",file=>"../path/to/file/temp.csh"); $env_path->inherit; print "Your env path: $ENV{HOME}";
(ssh) fabio@s2 : ~ [0] % ls -1 / bin boot ... sys tmp usr var vmlinuz (ssh) fabio@s2 : ~ [0] % ls -1 / | sed usr var vmlinuz (ssh) fabio@s2 : ~ [0] % ls -1 / | sed
sub get_count { my $sth = $dbh->prepare("SELECT COUNT(*) FROM table WHERE..."); $sth->execute( @params ); my $($count) = $sth->fetchrow_array; $sth->finish; return $count; }
sub get_count_2 { my $ar = $dbh->selectall_arrayref("SELECT ...", undef, @params) return $ar->[0][0]; }
sub get_count { return $dbh->selectall_arrayref("SELECT ...", undef, @params)->[0][0]; }
sub DBD::SQLite::db::count { my($dbh, $table, $where) = @_; my($stmt) = "SELECT COUNT(*) FROM $table"; $stmt .= " WHERE $where" if $where; my($count) = $dbh->selectrow_array($stmt); return $count; }
use UUID::Generator::PurePerl; sub create_search_id { my $this =shift; my $args=shift; my $ug = UUID::Generator::PurePerl->new(); my $uuid1 = $ug->generate_v1(); return $uuid1; }
use Data::UUID; $ug = Data::UUID->new; $uuid1 = $ug->create();
use Data::GUID; my $guid = Data::GUID->new; my $uniqueIdString = guid->as_string;
use Data::GUID; my $uniqueIdString = Data::GUID->new->as_string;
use Data::Uniqid qw ( suniqid uniqid luniqid ); $id = suniqid; $id = uniqid; $id = luniqid;
my $string1 = "Hi. My name is Vlad. It is snowy outside."; my @array = split(
> temp.pl use: Command not found. use: Command not found. print: Command not found. >
use: Command not found. use: Command not found. print: Command not found.
if( my $file = shift @ARGV ) { $parser->parse( Source => {SystemId => $file} ); } else { my $input = ""; while( <STDIN> ) { $input .= $_; } $parser->parse( Source => {String => $input} ); } exit;
my $string = "foo"; $string .= "bar"; print $string; foobar
sub position { my @list = @{$_[0]}; my $target = $_[1]; my ($low,$high) = (0, (scalar @list)-1); while ($low <= $high) { $mid = int(($high + $low)/2); if ( $list[$mid] == $target ) { return $mid; } elsif ( $target < $list[$mid] ) { $high = $mid - 1; } else { $low = $mid + 1; } } $low; } sub max { $_[0] > $_[1] ? $_[0] : $_[1]; } sub min { $_[0] > $_[1] ? $_[1] : $_[0]; } $ans = 10_000_000_000; @numbers = (234, 56, 1, 34...123); ($max,$min) = @num[0, 0]; @sorted = ($numbers[0]); for ( @num[1 .. $ $pos = position(\@sorted, $_); if ( $sorted[$pos] == $_ ) { $ans = 0; last; } splice @sorted, $pos, 0, $_; if ( $ $ans = min($_-$sorted[-2], $ans); } elsif ( 0 == $pos ) { $ans = min($sorted[1]-$_, $ans); } else { $ans = min(min(abs($sorted[$pos-1]-$_), abs($sorted[$pos+1]-$_)), $ans); } $max = max($_, $max); $min = min($_, $min); } print "$ans\n";
time perl -e' @array = map {rand} 1..100000; $lastdiff=10**11; for(sort {$a <=> $b} @array){ unless(defined $last){ $last=$_; next } $difference = abs($last - $_); $last = $_; $lastdiff = $lastdiff < $difference ? $lastdiff : $difference; last if $lastdiff == 0; } print $lastdiff, "\n" '
use HTTP::Request::Common qw(POST); use LWP::UserAgent; $ua = LWP::UserAgent->new(); my $req = POST maxlength=> name=> size=> title=> value=> name=> type=> value=> ]; $content = $ua->request($req)->as_string; print "Content-type: text/html\n\n"; print $content;
maxlength: 2048 name: term size: 55 title: md5 hash to crack value: 098f6bcd4621d373cade4e832627b4f6 name: crackbtn type: submit value: Crack that hash baby!
use strict; use warnings; use LWP::UserAgent; use HTTP::Request::Common qw{ POST }; use CGI; my $md5 = my $url = my $ua = LWP::UserAgent->new(); my $request = POST( $url, [ my $content = $ua->request($request)->as_string(); my $cgi = CGI->new(); print $cgi->header(), $content;
use strict; use warnings; use LWP::UserAgent; use CGI; my $md5 = my $url = my $ua = LWP::UserAgent->new(); my $response = $ua->post( $url, { my $content = $response->decoded_content(); my $cgi = CGI->new(); print $cgi->header(), $content;
package a; sub func { print 1; } package main; a::->func;
package a; our $fh; use IO::File; sub s { return $fh = IO::File->new(); } package a::s; sub binmode { print "BINMODE\n"; } package main; a::s->binmode; a::s->binmode; a::s::->binmode;
a->func() "a"->func() a::->func() v97->func() chr(97)->func()
my $comma_separated = "a,b,c"; my $a = split (/,/, $comma_separated)[0];
package My::Package; sub xx { print while <stdin>; }
$ENV{TZ} = my $now = scalar localtime; print "It is now $now\n";
localtime(); $ENV{TZ} = my $now = scalar localtime; print "It is now $now\n";
use POSIX qw(tzset); my $was = localtime; print "It was $was\n"; $ENV{TZ} = $was = localtime; print "It is still $was\n"; tzset; my $now = localtime; print "It is now $now\n";
use strict; use warnings; use DateTime; my $dt = DateTime->now(); my $clone1 = $dt->clone; $clone1->set_time_zone( print "$clone1\n"; print "$dt\n";
use POSIX qw[tzset]; $ENV{ tzset(); print scalar localtime();
use Time::Zone; my $TZ = my $now = scalar localtime time() + tz_offset($TZ); print "It is now $now\n";
use Time::Piece; @tz = ( foreach $tz (@tz) { $ENV{TZ} = $tz if $tz; Time::Piece::_tzset() if $tz; printf("T%s, ENV->TZ=%s\n", scalar localtime, $ENV{TZ} || }
P:\br1\sxsw.2015\sx-2015.0318\done>bb | sort Running c:/bin/bb.pl Tue Apr 14 21:43:56 2015 TTue Apr 14 16:43:56 2015, ENV->TZ=/*&+000000000005 TTue Apr 14 16:43:56 2015, ENV->TZ=/*&+005 TTue Apr 14 16:43:56 2015, ENV->TZ=/*&+05 TTue Apr 14 16:43:56 2015, ENV->TZ=/*&+5 TTue Apr 14 16:43:56 2015, ENV->TZ=___+5 TTue Apr 14 16:43:56 2015, ENV->TZ=123+5 TTue Apr 14 16:43:56 2015, ENV->TZ=CDT+5 TTue Apr 14 16:43:56 2015, ENV->TZ=CST+5 TTue Apr 14 16:43:56 2015, ENV->TZ=FKU+5 TTue Apr 14 16:43:56 2015, ENV->TZ=XYZ+5 TTue Apr 14 16:43:56 2015, ENV->TZ=ZZ1+5 ABOVE ALL WORKED Below most failed with UTC or +1 hour??? TTue Apr 14 20:43:56 2015, ENV->TZ=SSS+1 TTue Apr 14 21:43:56 2015, ENV->TZ=-01:00 TTue Apr 14 21:43:56 2015, ENV->TZ=+01:00 TTue Apr 14 21:43:56 2015, ENV->TZ=+05 TTue Apr 14 21:43:56 2015, ENV->TZ=+05:00 TTue Apr 14 21:43:56 2015, ENV->TZ=+0500 TTue Apr 14 21:43:56 2015, ENV->TZ=+5 TTue Apr 14 21:43:56 2015, ENV->TZ=+5:00 TTue Apr 14 21:43:56 2015, ENV->TZ=5000 TTue Apr 14 21:43:56 2015, ENV->TZ=CDT TTue Apr 14 21:43:56 2015, ENV->TZ=CDT TTue Apr 14 21:43:56 2015, ENV->TZ=CST TTue Apr 14 21:43:56 2015, ENV->TZ=PDT TTue Apr 14 21:43:56 2015, ENV->TZ=PST TTue Apr 14 21:43:56 2015, ENV->TZ=SSS+0 TTue Apr 14 21:43:56 2015, ENV->TZ=UTC TTue Apr 14 22:43:56 2015, ENV->TZ=-05:00ACDT TTue Apr 14 22:43:56 2015, ENV->TZ=+05.00 TTue Apr 14 22:43:56 2015, ENV->TZ=America/Chicago TTue Apr 14 22:43:56 2015, ENV->TZ=America/Los_Angeles TTue Apr 14 22:43:56 2015, ENV->TZ=EASST TTue Apr 14 22:43:56 2015, ENV->TZ=zzz-1
$was = localtime; print "It was $was\n"; $ENV{TZ} = Time::Piece::_tzset(); $was = localtime; print "It is $was\n";
