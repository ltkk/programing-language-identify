import java.util.Arrays; import java.util.Random; public class Main { public static void main(String[] args) { int arraySize = 32768; int data[] = new int[arraySize]; Random rnd = new Random(0); for (int c = 0; c < arraySize; ++c) data[c] = rnd.nextInt() % 256; Arrays.sort(data); long start = System.nanoTime(); long sum = 0; for (int i = 0; i < 100000; ++i) { for (int c = 0; c < arraySize; ++c) { if (data[c] >= 128) sum += data[c]; } } System.out.println((System.nanoTime() - start) / 1000000000.0); System.out.println("sum = " + sum); } }
public static void main(String[] args) throws ParseException { SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String str3 = "1927-12-31 23:54:07"; String str4 = "1927-12-31 23:54:08"; Date sDt3 = sf.parse(str3); Date sDt4 = sf.parse(str4); long ld3 = sDt3.getTime() /1000; long ld4 = sDt4.getTime() /1000; System.out.println(ld4-ld3); }
String str3 = "1927-12-31 23:54:08"; String str4 = "1927-12-31 23:54:09";
import java.util.TimeZone; public class Test { public static void main(String[] args) throws Exception { long startOf1900Utc = -2208988800000L; for (String id : TimeZone.getAvailableIDs()) { TimeZone zone = TimeZone.getTimeZone(id); if (zone.getRawOffset() != zone.getOffset(startOf1900Utc - 1)) { System.out.println(id); } } } }
long difference = (sDt4.getTime() - sDt3.getTime()) / 1000; System.out.println(difference);
DateTimeFormatterBuilder dtfb = new DateTimeFormatterBuilder(); dtfb.append(DateTimeFormatter.ISO_LOCAL_DATE); dtfb.appendLiteral( dtfb.append(DateTimeFormatter.ISO_LOCAL_TIME); DateTimeFormatter dtf = dtfb.toFormatter(); ZoneId shanghai = ZoneId.of("Asia/Shanghai"); String str3 = "1927-12-31 23:54:07"; String str4 = "1927-12-31 23:54:08"; ZonedDateTime zdt3 = LocalDateTime.parse(str3, dtf).atZone(shanghai); ZonedDateTime zdt4 = LocalDateTime.parse(str4, dtf).atZone(shanghai); Duration durationAtEarlierOffset = Duration.between(zdt3.withEarlierOffsetAtOverlap(), zdt4.withEarlierOffsetAtOverlap()); Duration durationAtLaterOffset = Duration.between(zdt3.withLaterOffsetAtOverlap(), zdt4.withLaterOffsetAtOverlap());
ZoneOffset zo3Earlier = zdt3.withEarlierOffsetAtOverlap().getOffset(); ZoneOffset zo3Later = zdt3.withLaterOffsetAtOverlap().getOffset();
ZoneOffset zo4Earlier = zdt4.withEarlierOffsetAtOverlap().getOffset(); ZoneOffset zo4Later = zdt4.withLaterOffsetAtOverlap().getOffset();
ZoneOffsetTransition zot3 = shanghai.getRules().getTransition(ld3.toLocalDateTime); ZoneOffsetTransition zot4 = shanghai.getRules().getTransition(ld3.toLocalDateTime);
public static void main(String[] args) { Dog aDog = new Dog("Max"); Dog oldDog = aDog; foo(aDog); aDog.getName().equals("Max"); aDog.getName().equals("Fifi"); aDog == oldDog; } public static void foo(Dog d) { d.getName().equals("Max"); d = new Dog("Fifi"); d.getName().equals("Fifi"); }
public static void main(String[] args) { Dog aDog = new Dog("Max"); Dog oldDog = aDog; foo(aDog); aDog.getName().equals("Fifi"); aDog == oldDog; } public static void foo(Dog d) { d.getName().equals("Max"); d.setName("Fifi"); }
public void foo(Dog someDog) { someDog.setName("Max"); someDog = new Dog("Fifi"); someDog.setName("Rowlf"); }
public class Main{ public static void main(String[] args){ Foo f = new Foo("f"); changeReference(f); modifyReference(f); } public static void changeReference(Foo a){ Foo b = new Foo("b"); a = b; } public static void modifyReference(Foo c){ c.setAttribute("c"); } }
1. Person person; 2. person = new Person("Tom"); 3. changeName(person); 4. 5. 6. static void changeName(Person anotherReferenceToTheSamePersonObject) { 7. anotherReferenceToTheSamePersonObject.setName("Jerry"); 8. }
int x = 3; float y = 101.1f; boolean amIAwesome = true;
JButton[] marxBros = new JButton[3]; marxBros[0] = new JButton("Groucho"); marxBros[1] = new JButton("Zeppo"); marxBros[2] = new JButton("Harpo");
private static void shout(String name){ System.out.println("There goes " + name + "!"); } public static void main(String[] args){ String hisName = "John J. Jingleheimerschmitz"; String myName = hisName; shout(myName); }
void cppMethod(int val, int &ref, Dog obj, Dog &objRef, Dog *objPtr, Dog *&objPtrRef) { val = 7; ref = 7; obj.SetName("obj"); objRef.SetName("objRef"); objPtr->SetName("objPtr"); objPtr = new Dog("newObjPtr"); objPtrRef->SetName("objRefPtr"); objPtrRef = new Dog("newObjPtrRef"); } int main() { int a = 0; int b = 0; Dog d0 = Dog("d0"); Dog d1 = Dog("d1"); Dog *d2 = new Dog("d2"); Dog *d3 = new Dog("d3"); cppMethod(a, b, d0, d1, d2, d3); }
public static void javaMethod(int val, Dog objPtr) { val = 7; objPtr.SetName("objPtr") objPtr = new Dog("newObjPtr"); } public static void main() { int a = 0; Dog d0 = new Dog("d0"); javaMethod(a, d0); }
private void foo(Object bar) { bar = null; } public static void main(String[] args) { String baz = "Hah!"; foo(baz); System.out.println(baz); }
public static void tricky(Point arg1, Point arg2) { arg1.x = 100; arg1.y = 100; Point temp = arg1; arg1 = arg2; arg2 = temp; } public static void main(String [] args) { Point pnt1 = new Point(0,0); Point pnt2 = new Point(0,0); System.out.println("X1: " + pnt1.x + " Y1: " +pnt1.y); System.out.println("X2: " + pnt2.x + " Y2: " +pnt2.y); System.out.println(" "); tricky(pnt1,pnt2); System.out.println("X1: " + pnt1.x + " Y1:" + pnt1.y); System.out.println("X2: " + pnt2.x + " Y2: " +pnt2.y); }
Point pnt1 = new Point(0,0); Point pnt2 = new Point(0,0);
System.out.println("X1: " + pnt1.x + " Y1: " +pnt1.y); System.out.println("X2: " + pnt2.x + " Y2: " +pnt2.y); System.out.println(" ");
tricky(pnt1,pnt2); public void tricky(Point arg1, Point arg2);
X1: 0 Y1: 0 X2: 0 Y2: 0 X1: 100 Y1: 100 X2: 0 Y2: 0
public class PassByValue { public static void main(String[] args) { Test t = new Test(); t.name = "initialvalue"; new PassByValue().changeValue(t); System.out.println(t.name); } public void changeValue(Test f) { f.name = "changevalue"; } } class Test { String name; }
public class PassByValue { public static void main(String[] args) { Test t = new Test(); t.name = "initialvalue"; new PassByValue().changeRefence(t); System.out.println(t.name); } public void changeRefence(Test f) { f = null; } } class Test { String name; }
(Name)[Location] -> [Value at the Location] --------------------- (Ref2Foo)[223] -> 47 (Foo)[47] -> 5
public static void swap(StringBuffer s1, StringBuffer s2) { StringBuffer temp = s1; s1 = s2; s2 = temp; } public static void main(String[] args) { StringBuffer s1 = new StringBuffer("Hello"); StringBuffer s2 = new StringBuffer("World"); swap(s1, s2); System.out.println(s1); System.out.println(s2); }
public static void appendWorld(StringBuffer s1) { s1.append(" World"); } public static void main(String[] args) { StringBuffer s = new StringBuffer("Hello"); appendWorld(s); System.out.println(s); }
public static void appendWorld(String s){ s = s+" World"; } public static void main(String[] args) { String s = new String("Hello"); appendWorld(s); System.out.println(s); }
class StringWrapper { public String value; public StringWrapper(String value) { this.value = value; } } public static void appendWorld(StringWrapper s){ s.value = s.value +" World"; } public static void main(String[] args) { StringWrapper s = new StringWrapper("Hello"); appendWorld(s); System.out.println(s.value); }
public class PassByValueString { public static void main(String[] args) { new PassByValueString().caller(); } public void caller() { String value = "Nikhil"; boolean valueflag = false; String output = method(value, valueflag); /* * * */ System.out.println("output : " + output); System.out.println("value : " + value); System.out.println("valueflag : " + valueflag); } public String method(String value, boolean valueflag) { value = "Anand"; valueflag = true; return "output"; } }
public class PassByValueNewString { public static void main(String[] args) { new PassByValueNewString().caller(); } public void caller() { String value = new String("Nikhil"); boolean valueflag = false; String output = method(value, valueflag); /* * * */ System.out.println("output : " + output); System.out.println("value : " + value); System.out.println("valueflag : " + valueflag); } public String method(String value, boolean valueflag) { value = "Anand"; valueflag = true; return "output"; } }
public class PassByValueObjectCase1 { private class Student { int id; String name; public Student() { } public Student(int id, String name) { super(); this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return "Student [id=" + id + ", name=" + name + "]"; } } public static void main(String[] args) { new PassByValueObjectCase1().caller(); } public void caller() { Student student = new Student(10, "Nikhil"); String output = method(student); /* * * */ System.out.println("output : " + output); System.out.println("student : " + student); } public String method(Student student) { student.setName("Anand"); return "output"; } }
output : output student : Student [id=10, name=Anand]
public class PassByValueObjectCase2 { public static void main(String[] args) { new PassByValueObjectCase2().caller(); } public void caller() { Student student = new Student(10, "Nikhil"); String output = method(student); /* * * */ System.out.println("output : " + output); System.out.println("student : " + student); } public String method(Student student) { student = new Student(20, "Anand"); return "output"; } }
output : output student : Student [id=10, name=Nikhil]
void getValues(int& arg1, int& arg2) { arg1 = 1; arg2 = 2; } void caller() { int x; int y; getValues(x, y); cout << "Result: " << x << " " << y << endl; }
void getValues(int[] arg1, int[] arg2) { arg1[0] = 1; arg2[0] = 2; } void caller() { int[] x = new int[1]; int[] y = new int[1]; getValues(x, y); System.out.println("Result: " + x[0] + " " + y[0]); }
public void method (String param) {} ... String var = new String("ref"); method(var); method(var.toString()); method(new String("ref"));
public class Test { public static void main(String[] args) { Integer a = new Integer(2); Integer b = new Integer(3); System.out.println("Before: a = " + a + ", b = " + b); swap(a,b); System.out.println("After: a = " + a + ", b = " + b); } public static swap(Integer iA, Integer iB) { Integer tmp = iA; iA = iB; iB = tmp; } }
public void test() { MyClass obj = null; init(obj); } private void init(MyClass objVar) { objVar = new MyClass(); }
public class PassByCopy{ public static void changeName(Dog d){ d.name = "Fido"; } public static void main(String[] args){ Dog d = new Dog("Maxx"); System.out.println("name= "+ d.name); changeName(d); System.out.println("name= "+ d.name); } } class Dog{ public String name; public Dog(String s){ this.name = s; } }
public interface Action { void doSomething(); } public interface Parser { Action findAction(String userInput); }
public class MyParser implements Parser { private static Action DO_NOTHING = new Action() { public void doSomething() { } }; public Action findAction(String userInput) { if ( ) { return DO_NOTHING; } } }
Parser parser = ParserFactory.getParser(); if (parser == null) { } Action action = parser.findAction(someInput); if (action == null) { } else { action.doSomething(); }
ParserFactory.getParser().findAction(someInput).doSomething();
try { ParserFactory.getParser().findAction(someInput).doSomething(); } catch(ActionNotFoundException anfe) { userConsole.err(anfe.getMessage()); }
public Action findAction(final String userInput) { return new Action() { public void doSomething() { userConsole.err("Action not found: " + userInput); } } }
@NotNull public static String helloWorld() { return "Hello World"; }
@Nullable public static String helloWorld() { return "Hello World"; }
public static void main(String[] args) { String result = helloWorld(); if(result != null) { System.out.println(result); } }
@Nullable iWantToDestroyEverything() { return null; }
public void method(Object object) { if (object == null) { throw new IllegalArgumentException("..."); }
public String getFirst3Chars(String text) { return text.subString(0, 3); }
public String getPostcode(Person person) { return person?.getAddress()?.getPostcode(); }
public static Optional<Fruit> find(String name, List<Fruit> fruits) { for (Fruit fruit : fruits) { if (fruit.getName().equals(name)) { return Optional.of(fruit); } } return Optional.empty(); }
Optional<Fruit> found = find("lemon", fruits); if (found.isPresent()) { Fruit fruit = found.get(); String name = fruit.getName(); }
String nameOrNull = find("lemon", fruits) .map(f -> f.getName()) .orElse("empty-name");
String foo; ... if( StringUtils.isBlank( foo ) ) { }
String foo; ... if( StringUtils.isEmpty( foo ) ) { }
public DOCUMENT read(String xml, ValidationEventHandler validationEventHandler) { Validate.notNull(validationEventHandler,"ValidationHandler not Injected"); return read(new StringReader(xml), true, validationEventHandler); }
Assert.notNull(validationEventHandler,"ValidationHandler not Injected");
static <T> T checkNotNull(T e) { if (e == null) { throw new NullPointerException(); } return e; }
... void foo(int a, Person p) { if (checkNotNull(p).getAge() > a) { ... } else { ... } } ...
Objects.requireNonNull(someObject); someObject.doCalc();
Parent(Child child) { if (child == null) { throw new NullPointerException("child"); } this.child = child; }
Parent(Child child) { this.child = Objects.requireNonNull(child, "child"); }
public Photo getPhotoOfThePerson(Person person) { if (person == null) return null; }
public static MyEnum parseMyEnum(String value); public static MyEnum parseMyEnumOrNull(String value);
public Photo getGirlfriendPhoto() { try { return appContext.getPhotoDataSource().getPhotoByName(me.getGirlfriend().getName()); } catch (NullPointerException e) { return null; } }
public SomeValue calculateSomeValueUsingSophisticatedLogic(Predicate predicate) { try { Result1 result1 = performSomeCalculation(predicate); Result2 result2 = performSomeOtherCalculation(result1.getSomeProperty()); Result3 result3 = performThirdCalculation(result2.getSomeProperty()); Result4 result4 = performLastCalculation(result3.getSomeProperty()); return result4.getSomeProperty(); } catch (NullPointerException e) { return null; } } public SomeValue calculateSomeValueUsingSophisticatedLogic(Predicate predicate) { SomeValue result = null; if (predicate != null) { Result1 result1 = performSomeCalculation(predicate); if (result1 != null && result1.getSomeProperty() != null) { Result2 result2 = performSomeOtherCalculation(result1.getSomeProperty()); if (result2 != null && result2.getSomeProperty() != null) { Result3 result3 = performThirdCalculation(result2.getSomeProperty()); if (result3 != null && result3.getSomeProperty() != null) { Result4 result4 = performLastCalculation(result3.getSomeProperty()); if (result4 != null) { result = result4.getSomeProperty(); } } } } } return result; }
public void updatePersonPhoneNumber(Long personId, String phoneNumber) { if (personId == null) return; DataSource dataSource = appContext.getStuffDataSource(); Person person = dataSource.getPersonById(personId); if (person != null) { person.setPhoneNumber(phoneNumber); dataSource.updatePerson(person); } else { Person = new Person(personId); person.setPhoneNumber(phoneNumber); dataSource.insertPerson(person); } }
public void updatePersonPhoneNumber(Long personId, String phoneNumber) { if (personId == null) return; DataSource dataSource = appContext.getStuffDataSource(); Person person = dataSource.getPersonById(personId); if (person == null) throw new SomeReasonableUserException("What are you thinking about ???"); person.setPhoneNumber(phoneNumber); dataSource.updatePerson(person); }
ValidationUtils.getNullValidator().addParam(plans, "plans").addParam(persons, "persons").validate();
class C { private final MyType mustBeSet; public C(MyType mything) { mustBeSet=Contract.notNull(mything); } private String name = "<unknown>"; public void setName(String s) { name = Contract.notNull(s); } } class Contract { public static <T> T notNull(T t) { if (t == null) { throw new ContractException("argument must be non-null"); return t; } }
Optional<Integer> possible = Optional.of(5); possible.isPresent(); possible.get();
public Optional<Service> getRefrigertorControl() { Service s = new RefrigeratorService(); return Optional.ofNullable(s); }
Optional ref = homeServices.getRefrigertorControl(); ref.ifPresent(HomeServices::switchItOn);
public static Optional<HomeServices> get() { service = Optional.of(service.orElse(new HomeServices())); return service; }
import java.util.Optional; public class HomeServices { private static final int NOW = 0; private static Optional<HomeServices> service; public static Optional<HomeServices> get() { service = Optional.of(service.orElse(new HomeServices())); return service; } public Optional<Service> getRefrigertorControl() { Service s = new RefrigeratorService(); return Optional.ofNullable(s); } public static void main(String[] args) { Optional<HomeServices> homeServices = HomeServices.get(); if(homeServices != null) { Optional<Service> refrigertorControl = homeServices.get().getRefrigertorControl(); refrigertorControl.ifPresent(HomeServices::switchItOn); } } public static void switchItOn(Service s){ } }
Optional stringToUse = Optional.of("optional is there"); stringToUse.ifPresent(System.out::println);
Optional<Integer> i = Optional.ofNullable(wsObject.getFoo()) .map(f -> f.getBar()) .map(b -> b.getBaz()) .map(b -> b.getInt());
Optional optionalCarNull = Optional.ofNullable(someNull); optionalCarNull.orElseThrow(IllegalStateException::new);
String lowerVal = Objects.requireNonNull(someVar, "input cannot be null or empty").toLowerCase();
getCustomerAccounts(@NotEmpty String customerId,@Size(min = 1) String accountType)
public class Car { @NotNull private String manufacturer; @NotNull @Size(min = 2, max = 14) private String licensePlate; @Min(2) private int seatCount; }
ArrayList<String> lemmings; String[] names; void checkLemmings() { if (lemmings != null) for(lemming: lemmings) { } } ArrayList<String> lemmings = new ArrayList<String>(); String[] names = {}; void checkLemmings() { for(lemming: lemmings) { } }
static <T> T isNull(someObject e){ if(e == null){ throw new NullPointerException(); } return e; }
public static <T> T ifNull(T toCheck, T ifNull) { if (toCheck == null) { return ifNull; } return toCheck; }
public String convertStreamToString(InputStream is) { }
StringWriter writer = new StringWriter(); IOUtils.copy(inputStream, writer, encoding); String theString = writer.toString();
String theString = IOUtils.toString(inputStream, encoding);
static String convertStreamToString(java.io.InputStream is) { java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A"); return s.hasNext() ? s.next() : ""; }
String result = IOUtils.toString(inputStream, StandardCharsets.UTF_8);
String result = CharStreams.toString(new InputStreamReader( inputStream, Charsets.UTF_8));
Scanner s = new Scanner(inputStream).useDelimiter("\\A"); String result = s.hasNext() ? s.next() : "";
String result = new BufferedReader(new InputStreamReader(inputStream)) .lines().collect(Collectors.joining("\n"));
String result = new BufferedReader(new InputStreamReader(inputStream)).lines() .parallel().collect(Collectors.joining("\n"));
final int bufferSize = 1024; final char[] buffer = new char[bufferSize]; final StringBuilder out = new StringBuilder(); Reader in = new InputStreamReader(inputStream, "UTF-8"); for (; ; ) { int rsz = in.read(buffer, 0, buffer.length); if (rsz < 0) break; out.append(buffer, 0, rsz); } return out.toString();
StringWriter writer = new StringWriter(); IOUtils.copy(inputStream, writer, "UTF-8"); return writer.toString();
ByteArrayOutputStream result = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int length; while ((length = inputStream.read(buffer)) != -1) { result.write(buffer, 0, length); } return result.toString("UTF-8");
String newLine = System.getProperty("line.separator"); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder result = new StringBuilder(); boolean flag = false; for (String line; (line = reader.readLine()) != null; ) { result.append(flag? newLine: "").append(line); flag = true; } return result.toString();
BufferedInputStream bis = new BufferedInputStream(inputStream); ByteArrayOutputStream buf = new ByteArrayOutputStream(); int result = bis.read(); while(result != -1) { buf.write((byte) result); result = bis.read(); } return buf.toString("UTF-8");
int ch; StringBuilder sb = new StringBuilder(); while((ch = inputStream.read()) != -1) sb.append((char)ch); reset(); return sb.toString();
String myString = IOUtils.toString(myInputStream, "UTF-8");
public static String slurp(final InputStream is, final int bufferSize) { final char[] buffer = new char[bufferSize]; final StringBuilder out = new StringBuilder(); try (Reader in = new InputStreamReader(is, "UTF-8")) { for (;;) { int rsz = in.read(buffer, 0, buffer.length); if (rsz < 0) break; out.append(buffer, 0, rsz); } } catch (UnsupportedEncodingException ex) { } catch (IOException ex) { } return out.toString(); }
InputStream in = ; StringBuilder sb = new StringBuilder(); BufferedReader br = new BufferedReader(new InputStreamReader(in)); String read; while ((read=br.readLine()) != null) { sb.append(read); } br.close(); return sb.toString();
InputStream stream = ... String content = CharStreams.toString(new InputStreamReader(stream, Charsets.UTF_8)); Closeables.closeQuietly(stream);
public String readFullyAsString(InputStream inputStream, String encoding) throws IOException { return readFully(inputStream).toString(encoding); } public byte[] readFullyAsBytes(InputStream inputStream) throws IOException { return readFully(inputStream).toByteArray(); } private ByteArrayOutputStream readFully(InputStream inputStream) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int length = 0; while ((length = inputStream.read(buffer)) != -1) { baos.write(buffer, 0, length); } return baos; }
import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.IOException; public static String readInputStreamAsString(InputStream in) throws IOException { BufferedInputStream bis = new BufferedInputStream(in); ByteArrayOutputStream buf = new ByteArrayOutputStream(); int result = bis.read(); while(result != -1) { byte b = (byte)result; buf.write(b); result = bis.read(); } return buf.toString(); }
public static String fromStream(InputStream in) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder out = new StringBuilder(); String newLine = System.getProperty("line.separator"); String line; while ((line = reader.readLine()) != null) { out.append(line); out.append(newLine); } return out.toString(); }
public static String toString(InputStream input) throws IOException { return new String(input.readAllBytes(), StandardCharsets.UTF_8); }
public static String streamToString(final InputStream inputStream) throws Exception { try ( final BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)) ) { return br.lines().parallel().collect(Collectors.joining("\n")); } catch (final IOException e) { throw new RuntimeException(e); } }
String response; String url = "www.blah.com/path?key=value"; GetMethod method = new GetMethod(url); int status = client.executeMethod(method);
InputStream resp = method.getResponseBodyAsStream(); InputStreamReader is=new InputStreamReader(resp); BufferedReader br=new BufferedReader(is); String read = null; StringBuffer sb = new StringBuffer(); while((read = br.readLine()) != null) { sb.append(read); } response = sb.toString();
InputStream iStream = method.getResponseBodyAsStream(); StringWriter writer = new StringWriter(); IOUtils.copy(iStream, writer, "UTF-8"); response = writer.toString();
public String inputStreamToString(InputStream inputStream) throws IOException { try(ByteArrayOutputStream result = new ByteArrayOutputStream()) { byte[] buffer = new byte[1024]; int length; while ((length = inputStream.read(buffer)) != -1) { result.write(buffer, 0, length); } return result.toString(UTF_8); } }
import com.google.common.io.CharStreams; import org.apache.commons.io.IOUtils; import java.io.*; import java.nio.ByteBuffer; import java.nio.channels.Channels; import java.nio.channels.ReadableByteChannel; import java.nio.channels.WritableByteChannel; import java.util.Arrays; import java.util.List; import java.util.Random; import java.util.stream.Collectors; /** * Created by Ilya Gazman on 2/13/18. */ public class InputStreamToString { private static final String UTF_8 = "UTF-8"; public static void main(String... args) { log("App started"); byte[] bytes = new byte[1024 * 1024]; new Random().nextBytes(bytes); log("Stream is ready\n"); try { test(bytes); } catch (IOException e) { e.printStackTrace(); } } private static void test(byte[] bytes) throws IOException { List<Stringify> tests = Arrays.asList( new ApacheStringWriter(), new ApacheStringWriter2(), new NioStream(), new ScannerReader(), new ScannerReaderNoNextTest(), new GuavaCharStreams(), new StreamApi(), new ParallelStreamApi(), new ByteArrayOutputStreamTest(), new BufferReaderTest(), new BufferedInputStreamVsByteArrayOutputStream(), new InputStreamAndStringBuilder(), new Java9ISTransferTo(), new Java9ISReadAllBytes() ); String solution = new String(bytes, "UTF-8"); for (Stringify test : tests) { try (ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes)) { String s = test.inputStreamToString(inputStream); if (!s.equals(solution)) { log(test.name() + ": Error"); continue; } } long startTime = System.currentTimeMillis(); for (int i = 0; i < 20; i++) { try (ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes)) { test.inputStreamToString(inputStream); } } log(test.name() + ": " + (System.currentTimeMillis() - startTime)); } } private static void log(String message) { System.out.println(message); } interface Stringify { String inputStreamToString(InputStream inputStream) throws IOException; default String name() { return this.getClass().getSimpleName(); } } static class ApacheStringWriter implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { StringWriter writer = new StringWriter(); IOUtils.copy(inputStream, writer, UTF_8); return writer.toString(); } } static class ApacheStringWriter2 implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { return IOUtils.toString(inputStream, UTF_8); } } static class NioStream implements Stringify { @Override public String inputStreamToString(InputStream in) throws IOException { ReadableByteChannel channel = Channels.newChannel(in); ByteBuffer byteBuffer = ByteBuffer.allocate(1024 * 16); ByteArrayOutputStream bout = new ByteArrayOutputStream(); WritableByteChannel outChannel = Channels.newChannel(bout); while (channel.read(byteBuffer) > 0 || byteBuffer.position() > 0) { byteBuffer.flip(); outChannel.write(byteBuffer); byteBuffer.compact(); } channel.close(); outChannel.close(); return bout.toString(UTF_8); } } static class ScannerReader implements Stringify { @Override public String inputStreamToString(InputStream is) throws IOException { java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A"); return s.hasNext() ? s.next() : ""; } } static class ScannerReaderNoNextTest implements Stringify { @Override public String inputStreamToString(InputStream is) throws IOException { java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A"); return s.next(); } } static class GuavaCharStreams implements Stringify { @Override public String inputStreamToString(InputStream is) throws IOException { return CharStreams.toString(new InputStreamReader( is, UTF_8)); } } static class StreamApi implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { return new BufferedReader(new InputStreamReader(inputStream)) .lines().collect(Collectors.joining("\n")); } } static class ParallelStreamApi implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { return new BufferedReader(new InputStreamReader(inputStream)).lines() .parallel().collect(Collectors.joining("\n")); } } static class ByteArrayOutputStreamTest implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { try(ByteArrayOutputStream result = new ByteArrayOutputStream()) { byte[] buffer = new byte[1024]; int length; while ((length = inputStream.read(buffer)) != -1) { result.write(buffer, 0, length); } return result.toString(UTF_8); } } } static class BufferReaderTest implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { String newLine = System.getProperty("line.separator"); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder result = new StringBuilder(UTF_8); String line; boolean flag = false; while ((line = reader.readLine()) != null) { result.append(flag ? newLine : "").append(line); flag = true; } return result.toString(); } } static class BufferedInputStreamVsByteArrayOutputStream implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { BufferedInputStream bis = new BufferedInputStream(inputStream); ByteArrayOutputStream buf = new ByteArrayOutputStream(); int result = bis.read(); while (result != -1) { buf.write((byte) result); result = bis.read(); } return buf.toString(UTF_8); } } static class InputStreamAndStringBuilder implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { int ch; StringBuilder sb = new StringBuilder(UTF_8); while ((ch = inputStream.read()) != -1) sb.append((char) ch); return sb.toString(); } } static class Java9ISTransferTo implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); inputStream.transferTo(bos); return bos.toString(UTF_8); } } static class Java9ISReadAllBytes implements Stringify { @Override public String inputStreamToString(InputStream inputStream) throws IOException { return new String(inputStream.readAllBytes(), UTF_8); } } }
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.stream.Collectors; public static String inputStreamToString(InputStream is) throws IOException { try (BufferedReader br = new BufferedReader(new InputStreamReader(is))) { return br.lines().collect(Collectors.joining(System.lineSeparator())); } }
new InputStreamReader(is, Charset.forName("UTF-8"))
String streamToString(InputStream in) throws IOException { StringBuilder out = new StringBuilder(); BufferedReader br = new BufferedReader(new InputStreamReader(in)); for(String line = br.readLine(); line != null; line = br.readLine()) out.append(line); br.close(); return out.toString(); }
public class StringFromFile { public static void main(String[] args) { InputStream is = StringFromFile.class.getResourceAsStream("file.txt"); BufferedReader br = new BufferedReader(new InputStreamReader(is )); final int CHARS_PER_PAGE = 5000; StringBuilder builder = new StringBuilder(CHARS_PER_PAGE); try { for(String line=br.readLine(); line!=null; line=br.readLine()) { builder.append(line); builder.append( } } catch (IOException ignore) { } String text = builder.toString(); System.out.println(text); } }
public class StringFromFileFast { public static void main(String[] args) { InputStream is = StringFromFileFast.class.getResourceAsStream("file.txt"); InputStreamReader input = new InputStreamReader(is ); final int CHARS_PER_PAGE = 5000; final char[] buffer = new char[CHARS_PER_PAGE]; StringBuilder output = new StringBuilder(CHARS_PER_PAGE); try { for(int read = input.read(buffer, 0, buffer.length); read != -1; read = input.read(buffer, 0, buffer.length)) { output.append(buffer, 0, read); } } catch (IOException ignore) { } String text = output.toString(); System.out.println(text); } }
private static final int BUFFER_SIZE = 4 * 1024; public static String inputStreamToString(InputStream inputStream, String charsetName) throws IOException { StringBuilder builder = new StringBuilder(); InputStreamReader reader = new InputStreamReader(inputStream, charsetName); char[] buffer = new char[BUFFER_SIZE]; int length; while ((length = reader.read(buffer)) != -1) { builder.append(buffer, 0, length); } return builder.toString(); }
private String readStream(InputStream iStream) throws IOException { InputStreamReader iStreamReader = new InputStreamReader(iStream); BufferedReader bReader = new BufferedReader(iStreamReader); String line = null; StringBuilder builder = new StringBuilder(); while((line = bReader.readLine()) != null) { builder.append(line); builder.append("\n"); } bReader.close(); iStreamReader.close(); return builder.toString(); }
/** * Reads the stream into a string * @param iStream the input stream * @return the string read from the stream * @throws IOException when an IO error occurs */ private String readStream(InputStream iStream) throws IOException { try (BufferedReader bReader = new BufferedReader(new InputStreamReader(iStream))){ StringBuilder builder = new StringBuilder(); String line; while((line = bReader.readLine()) != null) { builder.append(line); builder.append("\n"); } return builder.toString(); } }
public static String getString( InputStream is) throws IOException { int ch; StringBuilder sb = new StringBuilder(); while((ch = is.read()) != -1) sb.append((char)ch); return sb.toString(); }
import java.io.ByteArrayOutputStream; import java.io.InputStream; ... InputStream is = .... ByteArrayOutputStream baos = new ByteArrayOutputStream(8192); byte[] buffer = new byte[8192]; int count = 0; try { while ((count = is.read(buffer)) != -1) { baos.write(buffer, 0, count); } } finally { try { is.close(); } catch (Exception ignore) { } } String charset = "UTF-8"; String inputStreamAsString = baos.toString(charset);
import java.nio.charset.StandardCharsets; import org.springframework.util.FileCopyUtils; public String convertStreamToString(InputStream is) throws IOException { return new String(FileCopyUtils.copyToByteArray(is), StandardCharsets.UTF_8); }
public static String gobble(InputStream in, String charsetName) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); in.transferTo(bos); return bos.toString(charsetName); }
public static String convertStreamToString(InputStream is) { if (is == null) return null; StringBuilder sb = new StringBuilder(2048); char[] read = new char[128]; try (InputStreamReader ir = new InputStreamReader(is, StandardCharsets.UTF_8)) { for (int i; -1 != (i = ir.read(read)); sb.append(read, 0, i)); } catch (Throwable t) {} return sb.toString(); }
public static String toString(InputStream inputStream) { BufferedReader reader = new BufferedReader( new InputStreamReader(inputStream)); return reader.lines().collect(Collectors.joining( System.getProperty("line.separator"))); }
String convertToString(InputStream in){ String resource = new Scanner(in).useDelimiter("\\Z").next(); return resource; }
String fromFile = new BufferedReader(new InputStreamReader(inputStream)).lines().reduce(String::concat).get();
int a=5; long b=10; a=a+(int)b; System.out.println(a);
synchronized(myMap) { if (!myMap.containsKey("tomato")) myMap.put("tomato", "red"); }
for (Enumeration en = htable.keys(); en.hasMoreElements(); ) { Elem elem = (Elem) en.nextElement(); elem.doSth(); }
Map<String,Integer> map = { "orange" : 12, "apples" : 15 }; map["apples"];
Map m = Collections.synchronizedMap(new HashMap(...));
public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, Serializable { ... } public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable { ... }
+--------------------+-----------+-------------+ | | Iterator | Enumeration | +--------------------+-----------+-------------+ | Hashtable | fail-fast | safe | +--------------------+-----------+-------------+ | HashMap | fail-fast | fail-fast | +--------------------+-----------+-------------+ | ConcurrentHashMap | safe | safe | +--------------------+-----------+-------------+
public static void main(String[] args) { Hashtable<String, Integer> hash = new Hashtable<String, Integer>(); new Thread() { @Override public void run() { try { for (int i = 10; i < 20; i++) { sleepThread(1); System.out.println("T1 :- Key"+i); hash.put("Key"+i, i); } System.out.println( System.identityHashCode( hash ) ); } catch ( Exception e ) { e.printStackTrace(); } } }.start(); new Thread() { @Override public void run() { try { sleepThread(5); for (Enumeration<String> e = hash.keys(); e.hasMoreElements(); ) { sleepThread(1); System.out.println("T2 : "+ e.nextElement()); } /* for (Iterator< Entry<String, Integer> > it = hash.entrySet().iterator(); it.hasNext(); ) { sleepThread(1); System.out.println("T2 : "+ it.next()); } */ /* Set< Entry<String, Integer> > entrySet = hash.entrySet(); Iterator< Entry<String, Integer> > it = entrySet.iterator(); Enumeration<Entry<String, Integer>> entryEnumeration = Collections.enumeration( entrySet ); while( entryEnumeration.hasMoreElements() ) { sleepThread(1); Entry<String, Integer> nextElement = entryEnumeration.nextElement(); System.out.println("T2 : "+ nextElement.getKey() +" : "+ nextElement.getValue() ); } */ } catch ( Exception e ) { e.printStackTrace(); } } }.start(); Map<String, String> unmodifiableMap = Collections.unmodifiableMap( map ); try { unmodifiableMap.put("key4", "unmodifiableMap"); } catch (java.lang.UnsupportedOperationException e) { System.err.println("UnsupportedOperationException : "+ e.getMessage() ); } } static void sleepThread( int sec ) { try { Thread.sleep( 1000 * sec ); } catch (InterruptedException e) { e.printStackTrace(); } }
Map hashmap = new HashMap(); Map map = Collections.SyncronizedMap(hashmap);
import java.util.Map; import java.util.Hashtable; public class TestClass { public static void main(String args[ ]) { Map<Integer,String> states= new Hashtable<Integer,String>(); states.put(1, "INDIA"); states.put(2, "USA"); states.put(3, null); System.out.println(states.get(1)); System.out.println(states.get(2)); } }
import java.util.HashMap; import java.util.Map; public class TestClass { public static void main(String args[ ]) { Map<Integer,String> states = new HashMap<Integer,String>(); states.put(1, "INDIA"); states.put(2, "USA"); states.put(3, null); states.put(null,"UK"); System.out.println(states.get(1)); System.out.println(states.get(2)); System.out.println(states.get(3)); } }
/** * Used to determine whether the user making this call is subject to * teleportations. * @return whether the user making this call is a goat */ public boolean isUserAGoat() { return false; }
/** * Used to determine whether the user making this call is subject to * teleportations. * * <p>As of {@link android.os.Build.VERSION_CODES * now automatically identify goats using advanced goat recognition technology.</p> * * @return Returns true if the user making this call is a goat. */ public boolean isUserAGoat() { return mContext.getPackageManager() .isPackageAvailable("com.coffeestainstudios.goatsimulator"); }
while (1 == 2) { System.out.println("Unreachable code"); }
while (isUserAGoat()) { System.out.println("Unreachable but determined at runtime, not at compile time"); }
int TaskManagerModel::GetGoatsTeleported(int index) const { int seed = goat_salt_ * (index + 1); return (seed >> 16) & 255; }
<message name="IDS_TASK_MANAGER_GOATS_TELEPORTED_COLUMN" desc="The goats teleported column"> Goats Teleported </message>
int TaskManagerModel::GetGoatsTeleported(int index) const { int seed = goat_salt_ * (index + 1); return (seed >> 16) & 255; }
/** * Used to determine whether the user making this call is subject to * teleportations. * * <p>As of {@link android.os.Build.VERSION_CODES * now automatically identify goats using advanced goat recognition technology.</p> * * @return Returns true if the user making this call is a goat. */ public boolean isUserAGoat() { return mContext.getPackageManager() .isPackageAvailable("com.coffeestainstudios.goatsimulator"); }
/** * Used to determine whether the user making this call is subject to * teleportations. * * <p>As of {@link android.os.Build.VERSION_CODES * now automatically identify goats using advanced goat recognition technology.</p> * * @return Returns true if the user making this call is a goat. */ public boolean isUserAGoat() { return mContext.getPackageManager() .isPackageAvailable("com.coffeestainstudios.goatsimulator"); }
Element[] array = {new Element(1), new Element(2), new Element(3)};
Element[] array = new Element[] { new Element(1), new Element(2), new Element(3) };
List<String> il = ImmutableList.of("string", "elements"); List<String> il = ImmutableList.copyOf(aStringArray);
List<String> l1 = Lists.newArrayList(anotherListOrCollection); List<String> l2 = Lists.newArrayList(aStringArray); List<String> l3 = Lists.newArrayList("or", "string", "elements");
List<String> l1 = Collections.unmodifiableList(Arrays.asList(anArrayOfElements)); List<String> l2 = Collections.unmodifiableList(Arrays.asList("element1", "element2"));
List<String> l1 = new ArrayList<String>(Arrays.asList(array)); List<String> l1b = new ArrayList<>(Arrays.asList(array)); List<String> l2 = new ArrayList<String>(Arrays.asList("a", "b")); List<String> l2b = new ArrayList<>(Arrays.asList("a", "b"));
static <T> List<T> arrayToList(final T[] array) { final List<T> l = new ArrayList<T>(array.length); for (final T s : array) { l.add(s); } return (l); } static List arrayToList(final Object[] array) { final List l = new ArrayList(array.length); for (int i = 0; i < array.length; i++) { l.add(array[i]); } return (l); }
List<Element> arraylist = Arrays.asList(new Element(1), new Element(2), new Element(3));
List<Element> elements = List.of(new Element(1), new Element(2), new Element(3));
ArrayList<Element> arrayList = Stream.of(myArray).collect(Collectors.toCollection(ArrayList::new));
List<Element> list = Stream.of(myArray).collect(Collectors.toList());
@SafeVarargs public static <T> List<T> asList(T... a) { return new ArrayList<>(a); } private static class ArrayList<E> private final E[] a; ArrayList(E[] array) { a = array; } .... }
ArrayList<Element> list = new ArrayList<Element>(myArray.length); for (Element element : myArray) { list.add(element); }
List<String> list = List.of("Hello", "World", "from", "Java"); List<Integer> list = List.of(1, 2, 3, 4, 5);
ArrayList<Element> arraylist = new ArrayList<Element>(Arrays.<Element>asList(array));
List<Element> arraylist = Arrays.<Element>asList(array);
import com.google.common.collect.ListsLists ... List<String> list = Lists.newArrayList(aStringArray);
public static <T> List<T> fromArray(T[] array) { return Arrays.stream(array).collect(toList()); }
List<Element> elements = Arrays.stream(array).collect(Collectors.toList());
FXCollections.observableArrayList(new Element(1), new Element(2), new Element(3));
List<String> list = List.of("element 1", "element 2", "element 3");
List<Element> arraylist = Arrays.asList(new Element(1),new Element(2),new Element(3));
public static <T> boolean addAll(Collection<? super T> c, T... a);
ArrayList<Element> list = new ArrayList<>(); for(Element e : array) list.add(e);
int[] array = new int[5]; Arrays.stream(array).boxed().collect(Collectors.toList());
Element[] array = new Element[] { new Element(1), new Element(2), new Element(3) };
ArrayList<Element> arraylist_1 = new ArrayList<>(Arrays.asList(array)); ArrayList<Element> arraylist_2 = new ArrayList<>( Arrays.asList(new Element[] { new Element(1), new Element(2), new Element(3) })); ArrayList<Element> arraylist_3 = new ArrayList<>(); Collections.addAll(arraylist_3, array);
arraylist_1.add(new Element(4)); arraylist_2.add(new Element(4)); arraylist_3.add(new Element(4));
List<Element> listView_1 = (List<Element>) Arrays.asList(array); List<Element> listView_2 = Arrays.asList(array); List<Element> listView_3 = Arrays.asList(new Element(1), new Element(2), new Element(3));
listView_1.add(new Element(4)); listView_2.add(new Element(4)); listView_3.add(new Element(4));
String[] Array1={"one","two","three"}; ArrayList<String> s1= new ArrayList<String>(Arrays.asList(Array1));
package package org.something.util; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Junk { static <T> ArrayList<T> arrToArrayList(T[] arr){ return Arrays.asList(arr) .stream() .collect(Collectors.toCollection(ArrayList::new)); } public static void main(String[] args) { String[] sArr = new String[]{"Hello", "cruel", "world"}; List<String> ret = arrToArrayList(sArr); ret.remove(1); ret.stream() .forEach(System.out::println); } }
ArrayList<Element> list = (ArrayList<Element>)Arrays.stream(array).collect(Collectors.toList());
Arraylist arr = new Arraylist(); arr.addAll(Arrays.asList(asset));
Element[] array = {new Element(1), new Element(2), new Element(3)}; ArrayList<Element> arraylist =Arrays.asList(array);
Element[] array = {new Element(1), new Element(2), new Element(3)}; ArrayList<Element>elementArray=new ArrayList(); for(int i=0;i<array.length;i++) { elementArray.add(array[i]); }
Element[] array = {new Element(1), new Element(2), new Element(3)}; List<Element> elements=Arrays.asList(array);
randomNum = minimum + (int)(Math.random() * maximum);
Random rn = new Random(); int n = maximum - minimum + 1; int i = rn.nextInt() % n; randomNum = minimum + i;
import java.util.concurrent.ThreadLocalRandom; int randomNum = ThreadLocalRandom.current().nextInt(min, max + 1);
import java.util.Random; /** * Returns a pseudo-random number between min and max, inclusive. * The difference between min and max can be at most * <code>Integer.MAX_VALUE - 1</code>. * * @param min Minimum value * @param max Maximum value. Must be greater than min. * @return Integer between min and max, inclusive. * @see java.util.Random */ public static int randInt(int min, int max) { Random rand; int randomNum = rand.nextInt((max - min) + 1) + min; return randomNum; }
Random ran = new Random(); int x = ran.nextInt(6) + 5;
Random r = new Random(); int[] fiveRandomNumbers = r.ints(5, 0, 11).toArray(); int randomNumber = r.ints(1, 0, 11).findFirst().getAsInt();
public final class IntRandomNumberGenerator { private PrimitiveIterator.OfInt randomIterator; /** * Initialize a new random number generator that generates * random numbers in the range [min, max] * @param min - the min value (inclusive) * @param max - the max value (inclusive) */ public IntRandomNumberGenerator(int min, int max) { randomIterator = new Random().ints(min, max + 1).iterator(); } /** * Returns a random number in the range (min, max) * @return a random number in the range (min, max) */ public int nextInt() { return randomIterator.nextInt(); } }
Random rn = new Random(); int range = maximum - minimum + 1; int randomNum = rn.nextInt(range) + minimum;
Random rand = new Random(); randomNum = minimum + rand.nextInt((maximum - minimum) + 1);
int rand = ThreadLocalRandom.current().nextInt(x,y);
Random rand = new Random(); int x = rand.nextInt(10);
String[] i = new String[25]; Random rand = new Random(); int index = 0; index = rand.nextInt( i.length );
index = (int) Math.floor(Math.random() * i.length);
int nextIntInRange(int min, int max, Random rng) { if (min > max) { throw new IllegalArgumentException("Cannot draw random int from invalid range [" + min + ", " + max + "]."); } int diff = max - min; if (diff >= 0 && diff != Integer.MAX_VALUE) { return (min + rng.nextInt(diff + 1)); } int i; do { i = rng.nextInt(); } while (i < min || i > max); return i; }
int max = 10; int min = 5; int diff = max - min; Random rn = new Random(); int i = rn.nextInt(diff + 1); i += min; System.out.print("The Random Number is " + i);
Random rn = new Random(); int result = rn.nextInt(max - min + 1) + min; System.out.println(result);
import java.util.Random; public class RandomRange extends Random { public int nextIncInc(int min, int max) { return nextInt(max - min + 1) + min; } public int nextExcInc(int min, int max) { return nextInt(max - min) + 1 + min; } public int nextExcExc(int min, int max) { return nextInt(max - min - 1) + 1 + min; } public int nextIncExc(int min, int max) { return nextInt(max - min) + min; } }
int[] a = new SplittableRandom().ints(100, 0, 1_001).parallel().toArray();
IntStream stream = new SplittableRandom().ints(100, 0, 1_001);
public static int getRandomNumberBetween(int min, int max) { Random foo = new Random(); int randomNumber = foo.nextInt(max - min) + min; if (randomNumber == min) { return min + 1; } else { return randomNumber; } }
public static int getRandomNumberFrom(int min, int max) { Random foo = new Random(); int randomNumber = foo.nextInt((max + 1) - min) + min; return randomNumber; }
int random = minimum + Double.valueOf(Math.random()*(maximum-minimum )).intValue();
import java.util.Random; /** Generate random integers in a certain range. */ public final class RandomRange { public static final void main(String... aArgs){ log("Generating random integers in the range 1..10."); int START = 1; int END = 10; Random random = new Random(); for (int idx = 1; idx <= 10; ++idx){ showRandomInteger(START, END, random); } log("Done."); } private static void showRandomInteger(int aStart, int aEnd, Random aRandom){ if ( aStart > aEnd ) { throw new IllegalArgumentException("Start cannot exceed End."); } long range = (long)aEnd - (long)aStart + 1; long fraction = (long)(range * aRandom.nextDouble()); int randomNumber = (int)(fraction + aStart); log("Generated : " + randomNumber); } private static void log(String aMessage){ System.out.println(aMessage); } }
Generating random integers in the range 1..10. Generated : 9 Generated : 3 Generated : 3 Generated : 9 Generated : 4 Generated : 1 Generated : 3 Generated : 9 Generated : 10 Generated : 10 Done.
public static Random RANDOM = new Random(System.nanoTime()); public static final float random(final float pMin, final float pMax) { return pMin + RANDOM.nextFloat() * (pMax - pMin); }
Random random = new Random(); int max = 10; int min = 5; int totalNumber = 10; IntStream stream = random.ints(totalNumber, min, max); stream.forEach(System.out::println);
RandomUtils random = new RandomUtils(); random.nextInt(0, 0); random.nextInt(10, 10); random.nextInt(-10, 10); random.nextInt(10, -10);
import junit.framework.Assert; import java.util.Random; public class RandomUtils extends Random { /** * @param min generated value. Can * @param max generated value * @return values in closed range [min, max]. */ public int nextInt(int min, int max) { Assert.assertFalse("min can if (min == max) { return max; } return nextInt(max - min + 1) + min; } }
Random ran = new Random(); int randomInt = min + ran.nextInt(max - min + 1);
import org.apache.commons.math.random.RandomData; import org.apache.commons.math.random.RandomDataImpl; public void method() { RandomData randomData = new RandomDataImpl(); int number = randomData.nextInt(5, 10); }
public static int generateRandomInteger(int min, int max) { SecureRandom rand = new SecureRandom(); rand.setSeed(new Date().getTime()); int randomNum = rand.nextInt((max - min) + 1) + min; return randomNum; }
public class Randomizer { public static int generate(int min,int max) { return min + (int)(Math.random() * ((max - min) + 1)); } public static void main(String[] args) { System.out.println(Randomizer.generate(0,10)); } }
private static Random random = new Random(); public static int getRandomInt(int min, int max){ return random.nextInt(max - min + 1) + min; }
public static int getRandomInt(Random random, int min, int max) { return random.nextInt(max - min + 1) + min; }
public static void main(String[] args) { Object pw = "Password"; System.out.println("String: " + pw); pw = "Password".toCharArray(); System.out.println("Array: " + pw); }
String strPwd = "passwd"; char[] charPwd = new char[]{ System.out.println("String password: " + strPwd ); System.out.println("Character password: " + charPwd );
public static void main(String[] args) { System.out.println("please enter a password"); Scanner in = new Scanner(System.in); String password = in.nextLine(); usePassword(password); clearString(password); System.out.println("password: } private static void usePassword(String password) { } private static void clearString(String password) { try { Field value = String.class.getDeclaredField("value"); value.setAccessible(true); char[] chars = (char[]) value.get(password); Arrays.fill(chars, } catch (Exception e) { throw new AssertionError(e); } }
public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; }
String strPassword="Unknown"; char[] charPassword= new char[]{ System.out.println("String password: " + strPassword); System.out.println("Character password: " + charPassword); String password: Unknown Character password: [C@110b053
char[] passw = request.getPassword().toCharArray() if (comparePasswords(dbPassword, passw) { allowUser = true; cleanPassword(passw); cleanPassword(dbPassword); passw=null; } private static void cleanPassword (char[] pass) { for (char ch: pass) { ch = } }
public static void printMap(Map mp) { Iterator it = mp.entrySet().iterator(); while (it.hasNext()) { Map.Entry pair = (Map.Entry)it.next(); System.out.println(pair.getKey() + " = " + pair.getValue()); it.remove(); } }
Map<String, Object> map = ...; for (String key : map.keySet()) { }
for (Map.Entry<String, Object> entry : map.entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); }
Map<Integer, Integer> map = new HashMap<Integer, Integer>(); for (Map.Entry<Integer, Integer> entry : map.entrySet()) { System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); }
Map<Integer, Integer> map = new HashMap<Integer, Integer>(); for (Integer key : map.keySet()) { System.out.println("Key = " + key); } for (Integer value : map.values()) { System.out.println("Value = " + value); }
Map<Integer, Integer> map = new HashMap<Integer, Integer>(); Iterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry<Integer, Integer> entry = entries.next(); System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); }
Map map = new HashMap(); Iterator entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry entry = (Map.Entry) entries.next(); Integer key = (Integer)entry.getKey(); Integer value = (Integer)entry.getValue(); System.out.println("Key = " + key + ", Value = " + value); }
Map<Integer, Integer> map = new HashMap<Integer, Integer>(); for (Integer key : map.keySet()) { Integer value = map.get(key); System.out.println("Key = " + key + ", Value = " + value); }
for (Map.Entry<String, String> item : params.entrySet()) { String key = item.getKey(); String value = item.getValue(); }
Map<?,?> map = new HashMap<Object, Object>(); for(Entry<?, ?> e: map.entrySet()){ System.out.println("Key " + e.getKey()); System.out.println("Value " + e.getValue()); }
Collection<?> keys = map.keySet(); for(Object key: keys){ System.out.println("Key " + key); System.out.println("Value " + map.get(key)); }
for (String key : hashMap.keySet()) { System.out.println("Key: " + key + ", Value: " + map.get(key)); }
class MemorableClass { static final ArrayList list = new ArrayList(100); }
try { BufferedReader br = new BufferedReader(new FileReader(inputFile)); ... ... } catch (Exception e) { e.printStacktrace(); }
try { Connection conn = ConnectionFactory.getConnection(); ... ... } catch (Exception e) { e.printStacktrace(); }
class BadKey { public final String key; public BadKey(String key) { this.key = key; } } Map map = System.getProperties(); map.put(new BadKey("key"), "value");
void doWork() { try { Connection conn = ConnectionFactory.getConnection(); PreparedStatement stmt = conn.preparedStatement("some query"); ResultSet rs = stmt.executeQuery(); while(rs.hasNext()) { ... process the result set } } catch(SQLException sqlEx) { log(sqlEx); } }
public E remove(int index) { RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); elementData[--size] = null; return oldValue; }
import java.lang.reflect.Constructor; import java.lang.reflect.Field; import sun.misc.Unsafe; public class TestUnsafe { public static void main(String[] args) throws Exception{ Class unsafeClass = Class.forName("sun.misc.Unsafe"); Field f = unsafeClass.getDeclaredField("theUnsafe"); f.setAccessible(true); Unsafe unsafe = (Unsafe) f.get(null); System.out.print("4..3..2..1..."); try { for(;;) unsafe.allocateMemory(1024*1024); } catch(Error e) { System.out.println("Boom :)"); e.printStackTrace(); } } }
public class StringLeaker { private final String muchSmallerString; public StringLeaker() { String veryLongString = "We hold these truths to be self-evident..."; this.muchSmallerString = veryLongString.substring(0, 1); } }
... this.muchSmallerString = new String(veryLongString.substring(0, 1)); ...
... this.muchSmallerString = veryLongString.substring(0, 1).intern(); ...
pubclic class RequestProcessor { private static final Logger logger = Logger.getLogger(RequestProcessor.class); public void doSomething() { .... final List<String> hugeList = new ArrayList<String>(10000); new Thread() { public void run() { logger.info("Child thread spawned") for(String s:hugeList) { .... } } }.start(); } }
public class Example1 { public Example2 getNewExample2() { return this.new Example2(); } public class Example2 { public Example2() {} } }
public class Referencer { public static Example2 GetAnExample2() { Example1 ex = new Example1(); return ex.getNewExample2(); } public static void main(String[] args) { Example2 ex = Referencer.GetAnExample2(); } }
private static final Map<String, Info> myCache = new HashMap<>(); public void getInfo(String key) { Info info = myCache.get(key); if (info != null) return info; info = Database.fetch(key); if (info == null) return null; myCache.put(key, info); return info; }
public class Leaker { private static final Map<String, Object> CACHE = new HashMap<String, Object>(); public static void addToCache(String key, Object value) { Leaker.CACHE.put(key, value); } }
class Leakee { public void check() { if (depth > 2) { Leaker.done(); } } private int depth; public Leakee(int d) { depth = d; } protected void finalize() { new Leakee(depth + 1).check(); new Leakee(depth + 1).check(); } } public class Leaker { private static boolean makeMore = true; public static void done() { makeMore = false; } public static void main(String[] args) throws InterruptedException { while (makeMore) { new Leakee(0).check(); } while (true) { Thread.sleep(1000); System.out.println("memory=" + Runtime.getRuntime().freeMemory() + " / " + Runtime.getRuntime().totalMemory()); } } }
class A { B bRef; } class B { A aRef; } public class Main { public static void main(String args[]) { A myA = new A(); B myB = new B(); myA.bRef = myB; myB.aRef = myA; myA=null; myB=null; } }
public class Main { public static void main(String args[]) { Socket s = new Socket(InetAddress.getByName("google.com"),80); s=null; } }
import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream; public class BigJarCreator { public static void main(String[] args) throws IOException { ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File("big.jar"))); zos.putNextEntry(new ZipEntry("resource.txt")); zos.write("not too much in here".getBytes()); zos.closeEntry(); zos.putNextEntry(new ZipEntry("largeFile.out")); for (int i=0 ; i<10000000 ; i++) { zos.write((int) (Math.round(Math.random()*100)+20)); } zos.closeEntry(); zos.close(); } }
public class MemLeak { public static void main(String[] args) throws InterruptedException { int ITERATIONS=100000; for (int i=0 ; i<ITERATIONS ; i++) { MemLeak.class.getClassLoader().getResourceAsStream("resource.txt"); } System.out.println("finished creation of streams, now waiting to be killed"); Thread.sleep(Long.MAX_VALUE); } }
javac MemLeak.java java -Xmx2m -classpath .:big.jar MemLeak
MemLeak.class.getClassLoader().getResourceAsStream("resource.txt").close();
public class ServiceFactory { private Map<String, Service> services; private static ServiceFactory singleton; private ServiceFactory() { services = new HashMap<String, Service>(); } public static synchronized ServiceFactory getDefault() { if (singleton == null) { singleton = new ServiceFactory(); } return singleton; } public void addService(String name, Service serv) { services.put(name, serv); } public void removeService(String name) { services.remove(name); } public Service getService(String name, Service serv) { return services.get(name); } public Map<String, Service> getAllServices() { return services; } } class Service { }
static void leakMe(final Object object) { new Thread() { public void run() { Object o = object; for (;;) { try { sleep(Long.MAX_VALUE); } catch (InterruptedException e) {} } } }.start(); }
public static void main(String[] args) { while (true) { Element first = new Element(); first.next = new Element(); first.next.next = first; } }
Map<String, String> map = ... for (Map.Entry<String, String> entry : map.entrySet()) { System.out.println(entry.getKey() + "/" + entry.getValue()); }
long i = 0; Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry<Integer, Integer> pair = it.next(); i += pair.getKey() + pair.getValue(); }
long i = 0; for (Map.Entry<Integer, Integer> pair : map.entrySet()) { i += pair.getKey() + pair.getValue(); }
final long[] i = {0}; map.forEach((k, v) -> i[0] += k + v);
long i = 0; for (Integer key : map.keySet()) { i += key + map.get(key); }
long i = 0; Iterator<Integer> itr2 = map.keySet().iterator(); while (itr2.hasNext()) { Integer key = itr2.next(); i += key + map.get(key); }
long i = 0; for (Iterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator(); entries.hasNext(); ) { Map.Entry<Integer, Integer> entry = entries.next(); i += entry.getKey() + entry.getValue(); }
final long[] i = {0}; map.entrySet().stream().forEach(e -> i[0] += e.getKey() + e.getValue());
final long[] i = {0}; map.entrySet().stream().parallel().forEach(e -> i[0] += e.getKey() + e.getValue());
long i = 0; MapIterator<Integer, Integer> it = iterableMap.mapIterator(); while (it.hasNext()) { i += it.next() + it.getValue(); }
final long[] i = {0}; mutableMap.forEachKeyValue((key, value) -> { i[0] += key + value; });
Benchmark Mode Cnt Score Error Units test3_UsingForEachAndJava8 avgt 10 0.308  0.021 s/op test10_UsingEclipseMap avgt 10 0.309  0.009 s/op test1_UsingWhileAndMapEntry avgt 10 0.380  0.014 s/op test6_UsingForAndIterator avgt 10 0.387  0.016 s/op test2_UsingForEachAndMapEntry avgt 10 0.391  0.023 s/op test7_UsingJava8StreamApi avgt 10 0.510  0.014 s/op test9_UsingApacheIterableMap avgt 10 0.524  0.008 s/op test4_UsingKeySetAndForEach avgt 10 0.816  0.026 s/op test5_UsingKeySetAndIterator avgt 10 0.863  0.025 s/op test8_UsingJava8StreamApiParallel avgt 10 5.552  0.185 s/op
Benchmark Mode Cnt Score Error Units test10_UsingEclipseMap avgt 10 37.606  0.790 s/op test3_UsingForEachAndJava8 avgt 10 50.368  0.887 s/op test6_UsingForAndIterator avgt 10 50.332  0.507 s/op test2_UsingForEachAndMapEntry avgt 10 51.406  1.032 s/op test1_UsingWhileAndMapEntry avgt 10 52.538  2.431 s/op test7_UsingJava8StreamApi avgt 10 54.464  0.712 s/op test4_UsingKeySetAndForEach avgt 10 79.016  25.345 s/op test5_UsingKeySetAndIterator avgt 10 91.105  10.220 s/op test8_UsingJava8StreamApiParallel avgt 10 112.511  0.365 s/op test9_UsingApacheIterableMap avgt 10 125.714  1.935 s/op
Benchmark Mode Cnt Score Error Units test1_UsingWhileAndMapEntry avgt 10 1184.767  332.968 s/op test10_UsingEclipseMap avgt 10 1191.735  304.273 s/op test2_UsingForEachAndMapEntry avgt 10 1205.815  366.043 s/op test6_UsingForAndIterator avgt 10 1206.873  367.272 s/op test8_UsingJava8StreamApiParallel avgt 10 1485.895  233.143 s/op test5_UsingKeySetAndIterator avgt 10 1540.281  357.497 s/op test4_UsingKeySetAndForEach avgt 10 1593.342  294.417 s/op test3_UsingForEachAndJava8 avgt 10 1666.296  126.443 s/op test7_UsingJava8StreamApi avgt 10 1706.676  436.867 s/op test9_UsingApacheIterableMap avgt 10 3289.866  1445.564 s/op
100 600 1100 1600 2100 test10 0.333 1.631 2.752 5.937 8.024 test3 0.309 1.971 4.147 8.147 10.473 test6 0.372 2.190 4.470 8.322 10.531 test1 0.405 2.237 4.616 8.645 10.707 test2 0.376 2.267 4.809 8.403 10.910 test7 0.473 2.448 5.668 9.790 12.125 test9 0.565 2.830 5.952 13.220 16.965 test4 0.808 5.012 8.813 13.939 17.407 test5 0.810 5.104 8.533 14.064 17.422 test8 5.173 12.499 17.351 24.671 30.403
Map<String,String> map = new HashMap<>(); map.put("SomeKey", "SomeValue"); map.forEach( (k,v) -> [do something with key and value] ); map.forEach( (k,v) -> System.out.println("Key: " + k + ": Value: " + v));
Iterator entries = myMap.entrySet().iterator(); while (entries.hasNext()) { Entry thisEntry = (Entry) entries.next(); Object key = thisEntry.getKey(); Object value = thisEntry.getValue(); }
Map<String,Thing> map = ...; for (Map.Entry<String,Thing> entry : map.entrySet()) { String key = entry.getKey(); Thing thing = entry.getValue(); ... }
Iterator<Map.Entry<String, String>> entries = myMap.entrySet().iterator(); while (entries.hasNext()) { Map.Entry<String, String> entry = entries.next(); String key = entry.getKey(); String value = entry.getValue(); }
for (Map.Entry<String,Integer> entry : testMap.entrySet()) { entry.getKey(); entry.getValue(); }
for (String key : testMap.keySet()) { testMap.get(key); }
Iterator<Map.Entry<String,Integer>> itr1 = testMap.entrySet().iterator(); while(itr1.hasNext()) { Map.Entry<String,Integer> entry = itr1.next(); entry.getKey(); entry.getValue(); }
Iterator itr2 = testMap.keySet().iterator(); while(itr2.hasNext()) { String key = itr2.next(); testMap.get(key); }
for (String key: map.keySet()) { System.out.println(key + "/" + map.get(key)); }
final MutableBag<String> result = Bags.mutable.empty(); MutableMap<Integer, String> map = Maps.mutable.of(1, "One", 2, "Two", 3, "Three"); map.forEachKeyValue(new Procedure2<Integer, String>() { public void value(Integer key, String value) { result.add(key + value); } }); Assert.assertEquals(Bags.mutable.of("1One", "2Two", "3Three"), result);
MutableBag<String> result = Bags.mutable.empty(); MutableMap<Integer, String> map = Maps.mutable.of(1, "One", 2, "Two", 3, "Three"); map.forEachKeyValue((key, value) -> result.add(key + value)); Assert.assertEquals(Bags.mutable.of("1One", "2Two", "3Three"), result);
for( Iterator entries = myMap.entrySet().iterator(); entries.hasNext();){ Entry entry = (Entry) entries.next(); System.out.println(entry.getKey() + "/" + entry.getValue()); }
myMap.entrySet().stream().forEach((entry) -> { Object currentKey = entry.getKey(); Object currentValue = entry.getValue(); });
HashMap<Integer,Integer> hm = new HashMap<Integer, Integer>(); /* * Logic to put the Key,Value pair in your HashMap hm */ hm.forEach((k,v) -> System.out.println("key: "+k+" value:"+v));
HashMap<Integer,Integer> hm = new HashMap<Integer, Integer>(); Random rand = new Random(47); int i=0; while(i<5){ i++; int key = rand.nextInt(20); int value = rand.nextInt(50); System.out.println("Inserting key: "+key+" Value: "+value); Integer imap =hm.put(key,value); if( imap == null){ System.out.println("Inserted"); } else{ System.out.println("Replaced with "+imap); } } hm.forEach((k,v) -> System.out.println("key: "+k+" value:"+v)); Output: Inserting key: 18 Value: 5 Inserted Inserting key: 13 Value: 11 Inserted Inserting key: 1 Value: 29 Inserted Inserting key: 8 Value: 0 Inserted Inserting key: 2 Value: 7 Inserted key: 1 value:29 key: 18 value:5 key: 2 value:7 key: 8 value:0 key: 13 value:11
map.forEach((k, v) -> System.out.println((k + ":" + v)));
Map<String, Object> map = ...; for (String key : map.keySet()) { }
for (Map.Entry<String, Object> entry : map.entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); }
for (Map.Entry entry : hm.entrySet()) { System.out.print("key,val: "); System.out.println(entry.getKey() + "," + entry.getValue()); } Iterator iter = hm.keySet().iterator(); while(iter.hasNext()) { Integer key = (Integer)iter.next(); String val = (String)hm.get(key); System.out.println("key,val: " + key + "," + val); } Iterator it = hm.entrySet().iterator(); while (it.hasNext()) { Map.Entry entry = (Map.Entry) it.next(); Integer key = (Integer)entry.getKey(); String val = (String)entry.getValue(); System.out.println("key,val: " + key + "," + val); }
public class abcd{ public static void main(String[] args) { Map<Integer, String> testMap = new HashMap<Integer, String>(); testMap.put(10, "a"); testMap.put(20, "b"); testMap.put(30, "c"); testMap.put(40, "d"); for (Integer key:testMap.keySet()) { String value=testMap.get(key); System.out.println(value); } } }
public class abcd { public static void main(String[] args) { Map<Integer, String> testMap = new HashMap<Integer, String>(); testMap.put(10, "a"); testMap.put(20, "b"); testMap.put(30, "c"); testMap.put(40, "d"); for (Entry<Integer, String> entry : testMap.entrySet()) { Integer key=entry.getKey(); String value=entry.getValue(); } } }
Map map = new HashMap(); for (Map.Entry entry : ((Set<Map.Entry>) map.entrySet())) { System.out.println(entry.getKey() + "/" + entry.getValue()); }
Map<String,String> sample = new HashMap<>(); sample.put("A","Apple"); sample.put("B", "Ball");
sample.keySet().forEach((k) -> System.out.println(k));
sample.values().forEach((v) -> System.out.println(v));
sample.forEach((k,v) -> System.out.println(k + "=" + v)); sample.entrySet().stream().forEach((entry) -> { Object currentKey = entry.getKey(); Object currentValue = entry.getValue(); System.out.println(currentKey + "=" + currentValue); });
Iterator iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry element = (Map.Entry)it.next(); LOGGER.debug("Key: " + element.getKey()); LOGGER.debug("value: " + element.getValue()); }
Map<Integer, Integer> map = new HashMap<Integer, Integer>(); Iterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry<Integer, Integer> entry = entries.next(); System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); }
map.entrySet().forEach(entry -> System.out.println(entry.getValue()));
Map<String, String> mapString = new HashMap<>(); mapString.entrySet().stream().map((entry) -> { String mapKey = entry.getKey(); return entry; }).forEach((entry) -> { String mapValue = entry.getValue(); }); Map<String, String> mapString = new HashMap<>(); for (Iterator<Map.Entry<String, String>> it = mapString.entrySet().iterator(); it.hasNext();) { Map.Entry<String, String> entry = it.next(); String mapKey = entry.getKey(); String mapValue = entry.getValue(); } Map<String, String> mapString = new HashMap<>(); for (Map.Entry<String, String> entry : mapString.entrySet()) { String mapKey = entry.getKey(); String mapValue = entry.getValue(); }
map.forEach((k,v) -> { System.out.println(k + ":" + v); });
map.entrySet().forEach((e) -> { System.out.println(e.getKey() + " : " + e.getValue()); });
map.entrySet() .stream() .filter(e-> e.getValue() > 5) .forEach(System.out::println);
public class HMIteration { public static void main(String[] args) { Map<Object, Object> linkedHashMap = new LinkedHashMap<>(); Map<Object, Object> hashMap = new HashMap<>(); for (int i=10; i>=0; i--) { linkedHashMap.put(i, i); hashMap.put(i, i); } System.out.println("LinkedHashMap (1): "); linkedHashMap.forEach((k,v) -> { System.out.print(k + " ( System.out.println("\nLinkedHashMap (2): "); linkedHashMap.entrySet().forEach((e) -> { System.out.print(e.getKey() + " : " + e.getValue() + ", "); }); System.out.println("\n\nHashMap (1): "); hashMap.forEach((k,v) -> { System.out.print(k + " ( System.out.println("\nHashMap (2): "); hashMap.entrySet().forEach((e) -> { System.out.print(e.getKey() + " : " + e.getValue() + ", "); }); } }
package com.test; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; import java.util.Set; public class Test { public static void main(String[] args) { Map<String, String> map = new HashMap<String, String>(); map.put("ram", "ayodhya"); map.put("krishan", "mathura"); map.put("shiv", "kailash"); System.out.println("********* Keys *********"); Set<String> keys = map.keySet(); for (String key : keys) { System.out.println(key); } System.out.println("********* Values *********"); Collection<String> values = map.values(); for (String value : values) { System.out.println(value); } System.out.println("***** Keys and Values (Using for each loop) *****"); for (Map.Entry<String, String> entry : map.entrySet()) { System.out.println("Key: " + entry.getKey() + "\t Value: " + entry.getValue()); } System.out.println("***** Keys and Values (Using while loop) *****"); Iterator<Entry<String, String>> entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry<String, String> entry = (Map.Entry<String, String>) entries .next(); System.out.println("Key: " + entry.getKey() + "\t Value: " + entry.getValue()); } System.out .println("** Keys and Values (Using java 8 using lambdas )***"); map.forEach((k, v) -> System.out .println("Key: " + k + "\t value: " + v)); } }
| | - - - - | | for (Map.Entry<String, Object> entry : map.entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); }
Map<String, Integer> m = new HashMap<String, Integer>();
Iterator<Entry<String, Integer>> me = m.entrySet().iterator(); while(me.hasNext()){ Entry<String, Integer> pair = me.next(); System.out.println(pair.getKey() + ":" + pair.getValue()); } for(Entry<String, Integer> me : m.entrySet()){ System.out.println(me.getKey() + " : " + me.getValue()); } for(String s : m.keySet()){ System.out.println(s + " : " + m.get(s)); } Iterator<String> me = m.keySet().iterator(); while(me.hasNext()){ String key = me.next(); System.out.println(key + " : " + m.get(key)); }
public void transformMap(){ Map<String, Integer> map = new HashMap<>(); map.put("a", 2); map.put("b", 4); Map<String, Integer> result = Maps.transformValues(map, num -> num * 2); result.forEach((key, val) -> print(key, Integer.toString(val))); Map<String, String> result2 = Maps.transformEntries(map, (key, value) -> value + "[" + key + "]"); result2.forEach(this::print); } private void print(String key, String val){ System.out.println("key=" + key + ",value=" + val); }
Algorithm ArrayList LinkedList seek front O(1) O(1) seek back O(1) O(1) seek to index O(1) O(N) insert at front O(N) O(1) insert at back O(1) O(1) insert after an item O(N) O(1)
Operation ArrayList LinkedList AddAll (Insert) 101,16719 2623,29291 Add (Insert-Sequentially) 152,46840 966,62216 Add (insert-randomly) 36527 29193 remove (Delete) 20,56,9095 20,45,4904 contains (Search) 186,15,704 189,64,981
import org.junit.Assert; import org.junit.Test; import java.util.*; public class ArrayListVsLinkedList { private static final int MAX = 500000; String[] strings = maxArray(); @Test public void arrayListAddAll() { Watch watch = new Watch(); List<String> stringList = Arrays.asList(strings); List<String> arrayList = new ArrayList<String>(MAX); watch.start(); arrayList.addAll(stringList); watch.totalTime("Array List addAll() = "); } @Test public void linkedListAddAll() throws Exception { Watch watch = new Watch(); List<String> stringList = Arrays.asList(strings); watch.start(); List<String> linkedList = new LinkedList<String>(); linkedList.addAll(stringList); watch.totalTime("Linked List addAll() = "); } @Test public void arrayListAdd() { Watch watch = new Watch(); List<String> arrayList = new ArrayList<String>(MAX); watch.start(); for (String string : strings) arrayList.add(string); watch.totalTime("Array List add() = "); } @Test public void linkedListAdd() { Watch watch = new Watch(); List<String> linkedList = new LinkedList<String>(); watch.start(); for (String string : strings) linkedList.add(string); watch.totalTime("Linked List add() = "); } @Test public void arrayListInsertOne() { Watch watch = new Watch(); List<String> stringList = Arrays.asList(strings); List<String> arrayList = new ArrayList<String>(MAX + MAX / 10); arrayList.addAll(stringList); String insertString0 = getString(true, MAX / 2 + 10); String insertString1 = getString(true, MAX / 2 + 20); String insertString2 = getString(true, MAX / 2 + 30); String insertString3 = getString(true, MAX / 2 + 40); watch.start(); arrayList.add(insertString0); arrayList.add(insertString1); arrayList.add(insertString2); arrayList.add(insertString3); watch.totalTime("Array List add() = "); } @Test public void linkedListInsertOne() { Watch watch = new Watch(); List<String> stringList = Arrays.asList(strings); List<String> linkedList = new LinkedList<String>(); linkedList.addAll(stringList); String insertString0 = getString(true, MAX / 2 + 10); String insertString1 = getString(true, MAX / 2 + 20); String insertString2 = getString(true, MAX / 2 + 30); String insertString3 = getString(true, MAX / 2 + 40); watch.start(); linkedList.add(insertString0); linkedList.add(insertString1); linkedList.add(insertString2); linkedList.add(insertString3); watch.totalTime("Linked List add = "); } @Test public void arrayListRemove() throws Exception { Watch watch = new Watch(); List<String> stringList = Arrays.asList(strings); List<String> arrayList = new ArrayList<String>(MAX); arrayList.addAll(stringList); String searchString0 = getString(true, MAX / 2 + 10); String searchString1 = getString(true, MAX / 2 + 20); watch.start(); arrayList.remove(searchString0); arrayList.remove(searchString1); watch.totalTime("Array List remove() = "); } @Test public void linkedListRemove() throws Exception { Watch watch = new Watch(); List<String> linkedList = new LinkedList<String>(); linkedList.addAll(Arrays.asList(strings)); String searchString0 = getString(true, MAX / 2 + 10); String searchString1 = getString(true, MAX / 2 + 20); watch.start(); linkedList.remove(searchString0); linkedList.remove(searchString1); watch.totalTime("Linked List remove = "); } @Test public void arrayListSearch() throws Exception { Watch watch = new Watch(); List<String> stringList = Arrays.asList(strings); List<String> arrayList = new ArrayList<String>(MAX); arrayList.addAll(stringList); String searchString0 = getString(true, MAX / 2 + 10); String searchString1 = getString(true, MAX / 2 + 20); watch.start(); arrayList.contains(searchString0); arrayList.contains(searchString1); watch.totalTime("Array List addAll() time = "); } @Test public void linkedListSearch() throws Exception { Watch watch = new Watch(); List<String> linkedList = new LinkedList<String>(); linkedList.addAll(Arrays.asList(strings)); String searchString0 = getString(true, MAX / 2 + 10); String searchString1 = getString(true, MAX / 2 + 20); watch.start(); linkedList.contains(searchString0); linkedList.contains(searchString1); watch.totalTime("Linked List addAll() time = "); } class Watch { private long startTime; private long endTime; public void start() { startTime = System.nanoTime(); } private void stop() { endTime = System.nanoTime(); } public void totalTime(String s) { stop(); System.out.println(s + (endTime - startTime)); } } private String[] maxArray() { String[] strings = new String[MAX]; Boolean result = Boolean.TRUE; for (int i = 0; i < MAX; i++) { strings[i] = getString(result, i); result = !result; } return strings; } private String getString(Boolean result, int i) { return String.valueOf(result) + i + String.valueOf(!result); } }
get O(1) add O(1) contains O(n) next O(1) remove O(n) iterator.remove O(n)
get O(n) add O(1) contains O(n) next O(1) remove O(1) iterator.remove O(1)
get O(1) add O(n) contains O(n) next O(1) remove O(n) iterator.remove O(n)
Latency Comparison Numbers (~2012) ---------------------------------- L1 cache reference 0.5 ns Branch mispredict 5 ns L2 cache reference 7 ns 14x L1 cache Mutex lock/unlock 25 ns Main memory reference 100 ns 20x L2 cache, 200x L1 cache Compress 1K bytes with Zippy 3,000 ns 3 us Send 1K bytes over 1 Gbps network 10,000 ns 10 us Read 4K randomly from SSD* 150,000 ns 150 us ~1GB/sec SSD Read 1 MB sequentially from memory 250,000 ns 250 us Round trip within same datacenter 500,000 ns 500 us Read 1 MB sequentially from SSD* 1,000,000 ns 1,000 us 1 ms ~1GB/sec SSD, 4X memory Disk seek 10,000,000 ns 10,000 us 10 ms 20x datacenter roundtrip Read 1 MB sequentially from disk 20,000,000 ns 20,000 us 20 ms 80x memory, 20X SSD Send packet CA->Netherlands->CA 150,000,000 ns 150,000 us 150 ms
|---------------------|---------------------|--------------------|------------| | Operation | ArrayList | LinkedList | Winner | |---------------------|---------------------|--------------------|------------| | get(index) | O(1) | O(n) | ArrayList | | | | n/4 steps in avg | | |---------------------|---------------------|--------------------|------------| | add(E) | O(1) | O(1) | LinkedList | | |---------------------|--------------------| | | | O(n) in worst case | | | |---------------------|---------------------|--------------------|------------| | add(index, E) | O(n) | O(n) | LinkedList | | | n/2 steps | n/4 steps | | | |---------------------|--------------------| | | | | O(1) if index = 0 | | |---------------------|---------------------|--------------------|------------| | remove(index, E) | O(n) | O(n) | LinkedList | | |---------------------|--------------------| | | | n/2 steps | n/4 steps | | |---------------------|---------------------|--------------------|------------| | Iterator.remove() | O(n) | O(1) | LinkedList | | ListIterator.add() | | | | |---------------------|---------------------|--------------------|------------| |--------------------------------------|-----------------------------------| | ArrayList | LinkedList | |--------------------------------------|-----------------------------------| | Allows fast read access | Retriving element takes O(n) | |--------------------------------------|-----------------------------------| | Adding an element require shifitng | o(1) [but traversing takes time] | | all the later elements | | |--------------------------------------|-----------------------------------| | To add more elements than capacity | | new array need to be allocated | |--------------------------------------|
| highest precedence <---------> lowest precedence *++++ \ xCanBeSeenBy | this | any class | this subclass | any \__________ | class | in same | in another | class \ | nonsubbed | package | package | Modifier of x \ | | | | *+++ public |  |  |  |  ++++ protected |  |  |  |  ++++ package-private | | | | (no modifier) |  |  |  |  ++++ private |  |  |  | 
class Test { public static void main(final String ... args) { System.out.println(Example.leakPrivateClass()); Example.leakPrivateClass().secretMethod(); } } class Example { private static class NestedClass { public void secretMethod() { System.out.println("Hello"); } } public static NestedClass leakPrivateClass() { return new NestedClass(); } }
Test.java:4: secretMethod() in Example.NestedClass is defined in an inaccessible class or interface Example.leakPrivateClass().secretMethod(); ^ 1 error
+-+++ | | Same | Different | | | Package | Packages | ++++ | private | D | | ++++ | package-private | | | | (no modifier) | D R I | | ++++ | protected | D R I | I | ++++ | public | D R I | R I | ++++
package fatherpackage; public class Father { } ------------------------------------------- package sonpackage; public class Son extends Father { }
package fatherpackage; public class Father { protected void foo(){} }
package fatherpackage; public class SomeClass { public void someMethod(Father f, Son s) { f.foo(); s.foo(); } }
package sonpackage; public class Son extends Father { public void sonMethod() { this.foo(); super.foo(); } }
package fatherpackage; public class Father { public void fatherMethod(Father f) { f.foo(); } } ------------------------------------------- package sonpackage; public class Son extends Father { public void sonMethod(Son s) { s.foo(); } }
package fatherpackage; public class Son extends Father { public void sonMethod(Father f) { f.foo(); } }
package sonpackage; public class Son extends Father { public void sonMethod(Father f) { f.foo(); } }
package sonpackage; public class SomeClass { public void someMethod(Son s) throws Exception { s.foo(); } }
package pack; class A{ void msg(){System.out.println("Hello");} } package mypack; import pack.*; class B{ public static void main(String args[]){ A obj = new A(); obj.msg(); } }
package pack; public class A{ public void msg(){System.out.println("Hello");} } package mypack; import pack.*; class B{ public static void main(String args[]){ A obj = new A(); obj.msg(); } }
class A{ private int data = 40; private void msg(){System.out.println("Hello java");} } public class Simple{ public static void main(String args[]){ A obj = new A(); System.out.println(obj.data); obj.msg(); } }
package pack; public class A{ protected void msg(){System.out.println("Hello");} } package mypack; import pack.*; class B extends A{ public static void main(String args[]){ B obj = new B(); obj.msg(); } }
String name = "john"; public int age(){ return age; }
Public class Details{ private String name; public void setName(String n){ this.name = n; } public String getName(){ return this.name; } }
class Van{ protected boolean speed(){ } } class Car{ boolean speed(){ } }
  Modifier  Class  Package  Subclass  World    public  Y  Y  Y  Y   protected  Y  Y  Y  N   no modifier  Y  Y  N  N   private  Y  N  N  N  
Outside world -> Package (SecurityEntryClass ---> Package private classes)
String myString = "1234"; int foo = Integer.parseInt(myString);
Integer x = Integer.valueOf(str); int y = Integer.parseInt(str);
int foo; String StringThatCouldBeANumberOrNot = "26263Hello"; String StringThatCouldBeANumberOrNot2 = "26263"; try { foo = Integer.parseInt(StringThatCouldBeANumberOrNot); } catch (NumberFormatException e) { } try { foo = Integer.parseInt(StringThatCouldBeANumberOrNot2); } catch (NumberFormatException e) { }
public static int strToInt( String str ){ int i = 0; int num = 0; boolean isNeg = false; if (str.charAt(0) == isNeg = true; i = 1; } while( i < str.length()) { num *= 10; num += str.charAt(i++) - } if (isNeg) num = -num; return num; }
int semilastdigitASCII = number.charAt(number.length()-2); int lastdigitASCII = number.charAt(number.length()-1);
double semilastdigit = semilastdigitASCII - 48; double lastdigit = lastdigitASCII - 48;
Integer.parseInt("12"); Integer.valueOf("12"); Integer.decode("12"); Integer.parseInt("12", 8); Integer.valueOf("12", 8); Integer.decode("012"); Integer.parseInt("12",16); Integer.valueOf("12",16); Integer.decode(" Integer.decode("0x12"); Integer.decode("0X12"); Integer.parseInt("11",2); Integer.valueOf("11",2);
private Optional<Integer> tryParseInteger(String string) { try { return Optional.of(Integer.valueOf(string)); } catch (NumberFormatException e) { return Optional.empty(); } }
System.out.println(tryParseInteger("1234").orElse(-1)); System.out.println(tryParseInteger("foobar").orElse(-1));
String strValue = "12345"; Integer intValue = Integer.parseInt(strVal);
String strValue = "12345"; Integer intValue = Integer.valueOf(strValue);
String strValue = "12345"; Integer intValue = NumberUtils.toInt(strValue);
1. Integer.parseInt(s) 2. Integer.parseInt(s, radix) 3. Integer.parseInt(s, beginIndex, endIndex, radix) 4. Integer.parseUnsignedInt(s) 5. Integer.parseUnsignedInt(s, radix) 6. Integer.parseUnsignedInt(s, beginIndex, endIndex, radix) 7. Integer.valueOf(s) 8. Integer.valueOf(s, radix) 9. Integer.decode(s) 10. NumberUtils.toInt(s) 11. NumberUtils.toInt(s, defaultValue)
static public Integer str2Int(String str) { Integer result = null; if (null == str || 0 == str.length()) { return null; } try { result = Integer.parseInt(str); } catch (NumberFormatException e) { String negativeMode = ""; if(str.indexOf( negativeMode = "-"; str = str.replaceAll("-", "" ); if (str.indexOf( str = str.substring(0, str.indexOf( if (str.length() == 0) { return (Integer)0; } } String strNum = str.replaceAll("[^\\d]", "" ); if (0 == strNum.length()) { return null; } result = Integer.parseInt(negativeMode + strNum); } return result; }
@Test public void testStr2Int() { assertEquals("is numeric", (Integer)(-5), Helper.str2Int("-5")); assertEquals("is numeric", (Integer)50, Helper.str2Int("50.00")); assertEquals("is numeric", (Integer)20, Helper.str2Int("$ 20.90")); assertEquals("is numeric", (Integer)5, Helper.str2Int(" 5.321")); assertEquals("is numeric", (Integer)1000, Helper.str2Int("1,000.50")); assertEquals("is numeric", (Integer)0, Helper.str2Int("0.50")); assertEquals("is numeric", (Integer)0, Helper.str2Int(".50")); assertEquals("is numeric", (Integer)0, Helper.str2Int("-.10")); assertEquals("is numeric", (Integer)Integer.MAX_VALUE, Helper.str2Int(""+Integer.MAX_VALUE)); assertEquals("is numeric", (Integer)Integer.MIN_VALUE, Helper.str2Int(""+Integer.MIN_VALUE)); assertEquals("Not is numeric", null, Helper.str2Int("czv.,xcvsa")); /** * Dynamic test */ for(Integer num = 0; num < 1000; num++) { for(int spaces = 1; spaces < 6; spaces++) { String numStr = String.format("%0"+spaces+"d", num); Integer numNeg = num * -1; assertEquals(numStr + ": is numeric", num, Helper.str2Int(numStr)); assertEquals(numNeg + ": is numeric", numNeg, Helper.str2Int("- " + numStr)); } } }
String str = "123"; Integer value = Optional.of(str).map(Integer::valueOf).get(); value = Optional.ofNullable(str).map(Integer::valueOf).orElse(-1);
Integer value = (str == null) ? -1 : Integer.parseInt(str);
Integer fooInt = Ints.tryParse(fooString); if (fooInt != null) { ... }
string mystr = mystr.replaceAll( "[^\\d]", "" ); int number= Integer.parseInt(mystr);
public static int parseIntOrDefault(String value, int defaultValue) { int result = defaultValue; try { result = Integer.parseInt(value); } catch (Exception e) { } return result; } public static int parseIntOrDefault(String value, int beginIndex, int defaultValue) { int result = defaultValue; try { String stringValue = value.substring(beginIndex); result = Integer.parseInt(stringValue); } catch (Exception e) { } return result; } public static int parseIntOrDefault(String value, int beginIndex, int endIndex, int defaultValue) { int result = defaultValue; try { String stringValue = value.substring(beginIndex, endIndex); result = Integer.parseInt(stringValue); } catch (Exception e) { } return result; }
public static void main(String[] args) { System.out.println(parseIntOrDefault("123", 0)); System.out.println(parseIntOrDefault("aaa", 0)); System.out.println(parseIntOrDefault("aaa456", 3, 0)); System.out.println(parseIntOrDefault("aaa789bbb", 3, 6, 0)); }
try { String stringValue = "1234"; int integerValue = Integer.valueOf(stringValue); int integerValue = Integer.ParseInt(stringValue); stringValue = String.valueOf(integerValue); } catch (NumberFormatException ex) { System.out.println("Invalid input string!"); return; }
catch (NumberFormatException ex) { integerValue = 0; }
NumberUtils.toInt("3244", 1) = 3244 NumberUtils.toInt("", 1) = 1 NumberUtils.toInt(null, 5) = 5 NumberUtils.toInt("Hi", 6) = 6 NumberUtils.toInt(" 32 ", 1) = 1 NumberUtils.toInt(StringUtils.trimToEmpty( " 32 ",1)) = 32;
private static int parseInt(String str) { int i, n = 0; for (i = 0; i < str.length(); i++) { n *= 10; n += str.charAt(i) - 48; } return n; }
private static int parseInt(String str) { int i=0, n=0, sign=1; if(str.charAt(0) == i=1; sign=-1; } for(; i<str.length(); i++) { n*=10; n+=str.charAt(i)-48; } return sign*n; }
String str = "8955"; int q = Integer.parseInt(str); System.out.println("Output>>> " + q);
String str = "89.55"; double q = Double.parseDouble(str); System.out.println("Output>>> " + q);
String str="1234"; int number = Integer.parseInt(str); print number;
String myString = "1234"; int i1 = new Integer(myString);
public Integer(String var1) throws NumberFormatException { this.value = parseInt(var1, 10); }
String number = "10"; int result = Integer.parseInt(number); System.out.println(result);
String number = "10"; Integer result = Integer.valueOf(number); System.out.println(result);
private void ConvertToInt(){ String string = txtString.getText(); try{ int integerValue=Integer.parseInt(string); System.out.println(integerValue); } catch(Exception e){ JOptionPane.showMessageDialog( "Error converting string to integer\n" + e.toString, "Error", JOptionPane.ERROR_MESSAGE); } }
import java.util.Scanner; public class StringToInt { public static void main(String args[]) { String inputString; Scanner s = new Scanner(System.in); inputString = s.nextLine(); if (!inputString.matches("([+-]?([0-9]*[.])?[0-9]+)")) { System.out.println("Not a Number"); } else { Double result2 = getNumber(inputString); System.out.println("result = " + result2); } } public static Double getNumber(String number) { Double result = 0.0; Double beforeDecimal = 0.0; Double afterDecimal = 0.0; Double afterDecimalCount = 0.0; int signBit = 1; boolean flag = false; int count = number.length(); if (number.charAt(0) == signBit = -1; flag = true; } else if (number.charAt(0) == flag = true; } for (int i = 0; i < count; i++) { if (flag && i == 0) { continue; } if (afterDecimalCount == 0.0) { if (number.charAt(i) - afterDecimalCount++; } else { beforeDecimal = beforeDecimal * 10 + (number.charAt(i) - } } else { afterDecimal = afterDecimal * 10 + number.charAt(i) - ( afterDecimalCount = afterDecimalCount * 10; } } if (afterDecimalCount != 0.0) { afterDecimal = afterDecimal / afterDecimalCount; result = beforeDecimal + afterDecimal; } else { result = beforeDecimal; } return result * signBit; } }
ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;
public class Car { static final long serialVersionUID = 1L; }
public class MyExample extends ArrayList<String> { public MyExample() { super(); } ... }
public class MyExample { private List<String> myList; public MyExample() { this.myList = new ArrayList<String>(); } ... }
Caused by: java.io.IOException: Mismatched serialization UIDs : Source (Rep. IDRMI:com.hordine.pedra.softbudget.domain.Budget:5CF7CE11E6810A36:04A3FEBED5DA4588) = 04A3FEBED5DA4588 whereas Target (Rep. ID RMI:com.hordine.pedra.softbudget.domain.Budget:7AF5ED7A7CFDFF31:6227F23FA74A9A52) = 6227F23FA74A9A52
import java.io.Serializable; public class Employee implements Serializable { private static final long serialVersionUID = 1L; private String empname; private byte empage; public String getEmpName() { return name; } public void setEmpName(String empname) { this.empname = empname; } public byte getEmpAge() { return empage; } public void setEmpAge(byte empage) { this.empage = empage; } public String whoIsThis() { StringBuffer employee = new StringBuffer(); employee.append(getEmpName()).append(" is ).append(getEmpAge()).append(" years old ")); return employee.toString(); } }
import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; public class Writer { public static void main(String[] args) throws IOException { Employee employee = new Employee(); employee.setEmpName("Jagdish"); employee.setEmpAge((byte) 30); FileOutputStream fout = new FileOutputStream("/users/Jagdish.vala/employee.obj"); ObjectOutputStream oos = new ObjectOutputStream(fout); oos.writeObject(employee); oos.close(); System.out.println("Process complete"); } }
import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; public class Reader { public static void main(String[] args) throws ClassNotFoundException, IOException { Employee employee = new Employee(); FileInputStream fin = new FileInputStream("/users/Jagdish.vala/employee.obj"); ObjectInputStream ois = new ObjectInputStream(fin); employee = (Employee) ois.readObject(); ois.close(); System.out.println(employee.whoIsThis()); } }
private static final long serialVersionUID = **4L**;
Exception in thread "main" java.io.InvalidClassException: com.jagdish.vala.java.serialVersion.Employee; local class incompatible: stream classdesc serialVersionUID = 1, local class serialVersionUID = 4 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:616) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1623) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1518) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1774) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371) at com.krishantha.sample.java.serialVersion.Reader.main(Reader.java:14)
com/abc/ic/api/model/domain/item/BizOrderTransDO.java com/abc/ic/api/model/domain/item/CardPassFeature.java com/abc/ic/api/model/domain/item/CategoryFeature.java com/abc/ic/api/model/domain/item/GoodsFeature.java com/abc/ic/api/model/domain/item/ItemFeature.java com/abc/ic/api/model/domain/item/ItemPicUrls.java com/abc/ic/api/model/domain/item/ItemSkuDO.java com/abc/ic/api/model/domain/serve/ServeCategoryFeature.java com/abc/ic/api/model/domain/serve/ServeFeature.java com/abc/ic/api/model/param/depot/DepotItemDTO.java com/abc/ic/api/model/param/depot/DepotItemQueryDTO.java com/abc/ic/api/model/param/depot/InDepotDTO.java com/abc/ic/api/model/param/depot/OutDepotDTO.java
Random r = new Random(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if(r.nextInt(4) == 0) { System.out.print("O"); } else { System.out.print(" } } System.out.println(""); }
Random r = new Random(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++) { if(r.nextInt(4) == 0) { System.out.print("O"); } else { System.out.print("B"); } } System.out.println(""); }
for (int i = 0; i < 1000; i++) { long t1 = System.nanoTime(); System.out.print("BBB......BBB"); \\<-contain 1000 "B" long t2 = System.nanoTime(); System.out.println(t2-t1); System.out.println(""); }
BBB...31744 BBB...31744 BBB...31744 BBB...31744 BBB...226365807 BBB...31744 BBB...31744 BBB...31744 BBB...31744 BBB...226365807 . . .
ArrayList<String> places = new ArrayList<String>(); places.add("Buenos Aires"); places.add("Crdoba"); places.add("La Plata");
ArrayList<String> places = new ArrayList<String>( Arrays.asList("Buenos Aires", "Crdoba", "La Plata"));
ArrayList<String> list = new ArrayList<String>(); list.add("A"); list.add("B"); list.add("C");
ArrayList<String> list = new ArrayList<String>() {{ add("A"); add("B"); add("C"); }};
List<String> places = Arrays.asList("Buenos Aires", "Crdoba", "La Plata");
List<String> places = Collections.singletonList("Buenos Aires");
ArrayList<String> places = new ArrayList<>(Arrays.asList("Buenos Aires", "Crdoba", "La Plata"));
List<String> strings = List.of("foo", "bar", "baz");
List<String> strings = Arrays.asList("foo", "bar", "baz");
List<String> strings = asList("foo", "bar", "baz");
Stream<String> strings = Stream.of("foo", "bar", "baz");
Stream<String> strings = Stream.concat(Stream.of("foo", "bar"), Stream.of("baz", "qux"));
List<String> strings = Stream.of("foo", "bar", "baz").collect(toList());
List<String> strings = new ArrayList<>(List.of("foo", "bar")); strings.add("baz");
List<String> strings = new ArrayList<>(asList("foo", "bar")); strings.add("baz");
List<String> strings = Stream.of("foo", "bar") .collect(toCollection(ArrayList::new)); strings.add("baz");
Iterable<String> strings = new ArrayList<>(); Collection<String> strings = new ArrayList<>(); List<String> strings = new ArrayList<>(); ArrayList<String> strings = new ArrayList<>(); var strings = new ArrayList<String>();
List<String> strings = new ArrayList<String>(Collections.singletonList("A"));
List<String> strings = new ArrayList<String>(); Collections.addAll(strings,"A","B","C","D");
ArrayList<String> places = Lists.newArrayList("Buenos Aires", "Crdoba", "La Plata");
List<String> places = Stream.of("Buenos Aires", "Crdoba", "La Plata").collect(Collectors.toList());
ArrayList<String> places = Stream.of("Buenos Aires", "Crdoba", "La Plata").collect(Collectors.toCollection(ArrayList::new));
import com.google.common.collect.ImmutableList; .... List<String> places = ImmutableList.of("Buenos Aires", "Crdoba", "La Plata");
List<String> list = List.of("A", "B", "C"); Set<String> set = Set.of("A", "B", "C");
Map<String, String> map = Map.of("k1", "v1", "k2", "v2", "k3", "v3")
public static ArrayList<String> createArrayList(String ... elements) { ArrayList<String> list = new ArrayList<String>(); for (String element : elements) { list.add(element); } return list; } .... ArrayList<String> places = createArrayList( "So Paulo", "Rio de Janeiro", "Braslia");
public static <T> ArrayList<T> createArrayList(T ... elements) { ArrayList<T> list = new ArrayList<T>(); for (T element : elements) { list.add(element); } return list; }
List<String> places = List.of("Buenos Aires", "Crdoba", "La Plata");
List<String> places = new ArrayList<>(List.of("Buenos Aires", "Crdoba", "La Plata"));
Double array[] = { 1.0, 2.0, 3.0}; List<Double> list = Arrays.asList(array);
List<String> list = Lists.mutable.with("Buenos Aires", "Crdoba", "La Plata");
MutableList<String> mList = Lists.mutable.with("Buenos Aires", "Crdoba", "La Plata"); ImmutableList<String> iList = Lists.immutable.with("Buenos Aires", "Crdoba", "La Plata");
Set<String> set = Sets.mutable.with("Buenos Aires", "Crdoba", "La Plata"); MutableSet<String> mSet = Sets.mutable.with("Buenos Aires", "Crdoba", "La Plata"); ImmutableSet<String> iSet = Sets.immutable.with("Buenos Aires", "Crdoba", "La Plata"); Bag<String> bag = Bags.mutable.with("Buenos Aires", "Crdoba", "La Plata"); MutableBag<String> mBag = Bags.mutable.with("Buenos Aires", "Crdoba", "La Plata"); ImmutableBag<String> iBag = Bags.immutable.with("Buenos Aires", "Crdoba", "La Plata");
List<String> values = Stream.of("One", "Two").collect(Collectors.toList());
List<String> list = new ArrayList<String>() {{ add("A"); add("B"); add("C"); }};
String [] arr = {"Sharlock", "Homes", "Watson"}; List<String> names = Arrays.asList(arr);
class A{} class B extends A{} public List<A> getAList(){ return Arrays.asList(new B()); }
List<String> places = Arrays.asList("Buenos Aires", "Crdoba", "La Plata");
ArrayList<String> myPlaces = new ArrayList(places);
String[] places = {"Buenos Aires", "Crdoba", "La Plata"};
ArrayList<String> myPlaces = new ArrayList(Arrays.asList(places));
enum Places { BUENOS_AIRES("Buenos Aires",123), CORDOBA("Crdoba",456), LA_PLATA("La Plata",789); String name; int code; Places(String name, int code) { this.name=name; this.code=code; } }
for (Places p:Places.values()) { System.out.printf("The place %s has code %d%n", p.name, p.code); }
List<String> places = List.of("Buenos Aires", "Crdoba", "La Plata");
List<String> places = new ArrayList<>(List.of("Buenos Aires", "Crdoba", "La Plata"));
List<String> names = Arrays.asList("2","@2234","21","11");
List<String> names = new StickyList<>( "Scott Fitzgerald", "Fyodor Dostoyevsky" );
List<String> strlist= Arrays.asList("aaa", "bbb", "ccc");
ArrayList<String> places = new ArrayList<String>( Arrays.asList("Buenos Aires", "Crdoba", "La Plata"));
List<String> places = new ArrayList<String>() {{ add("x"); add("y"); }};
List<String> places = Arrays.asList(new String[] {"x", "y" });
List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
List<String> list = N.asList("Buenos Aires", "Crdoba", "La Plata"); Set<String> set = N.asSet("Buenos Aires", "Crdoba", "La Plata"); Map<String, Integer> map = N.asMap("Buenos Aires", 1, "Crdoba", 2, "La Plata", 3); ImmutableList.of("Buenos Aires", "Crdoba", "La Plata"); ImmutableSet.of("Buenos Aires", "Crdoba", "La Plata"); ImmutableSet.of("Buenos Aires", 1, "Crdoba", 2, "La Plata", 3); List<String> set = Array.asList("Buenos Aires", "Crdoba", "La Plata");
package main_package; import java.util.ArrayList; public class Stackkkk { public static void main(String[] args) { ArrayList<Object> list = new ArrayList<Object>(); add(list, "1", "2", "3", "4", "5", "6"); System.out.println("I added " + list.size() + " element in one line"); } public static void add(ArrayList<Object> list,Object...objects){ for(Object object:objects) list.add(object); } }
static <A> ArrayList<A> ll(A... a) { ArrayList l = new ArrayList(a.length); for (A x : a) l.add(x); return l; }
ArrayList<String> places = ll("Buenos Aires", "Crdoba", "La Plata");
Arrays.asList(new MyClass[] {new MyClass("arg1"), new MyClass("arg2")})
public static <T> List<T> asList(T... a) { return new ArrayList<T>(a); }
ArrayList<String> arr = (ArrayList<String>) Arrays.asList("1", "2");
URL url = new URL(urlToRssFeed); SAXParserFactory factory = SAXParserFactory.newInstance(); SAXParser parser = factory.newSAXParser(); XMLReader xmlreader = parser.getXMLReader(); RssHandler theRSSHandler = new RssHandler(); xmlreader.setContentHandler(theRSSHandler); InputSource is = new InputSource(url.openStream()); xmlreader.parse(is); return theRSSHandler.getFeed();
class RetrieveFeedTask extends AsyncTask<String, Void, RSSFeed> { private Exception exception; protected RSSFeed doInBackground(String... urls) { try { URL url = new URL(urls[0]); SAXParserFactory factory = SAXParserFactory.newInstance(); SAXParser parser = factory.newSAXParser(); XMLReader xmlreader = parser.getXMLReader(); RssHandler theRSSHandler = new RssHandler(); xmlreader.setContentHandler(theRSSHandler); InputSource is = new InputSource(url.openStream()); xmlreader.parse(is); return theRSSHandler.getFeed(); } catch (Exception e) { this.exception = e; return null; } finally { is.close(); } } protected void onPostExecute(RSSFeed feed) { } }
<uses-permission android:name="android.permission.INTERNET"/>
StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy);
<uses-permission android:name="android.permission.INTERNET"/>
Thread thread = new Thread(new Runnable() { @Override public void run() { try { } catch (Exception e) { e.printStackTrace(); } } }); thread.start();
import android.app.IntentService; import android.app.PendingIntent; import android.content.Intent; import android.util.Log; import java.io.InputStream; import java.net.MalformedURLException; import java.net.URL; public class DownloadIntentService extends IntentService { private static final String TAG = DownloadIntentService.class.getSimpleName(); public static final String PENDING_RESULT_EXTRA = "pending_result"; public static final String URL_EXTRA = "url"; public static final String RSS_RESULT_EXTRA = "url"; public static final int RESULT_CODE = 0; public static final int INVALID_URL_CODE = 1; public static final int ERROR_CODE = 2; private IllustrativeRSSParser parser; public DownloadIntentService() { super(TAG); parser = new IllustrativeRSSParser(); } @Override protected void onHandleIntent(Intent intent) { PendingIntent reply = intent.getParcelableExtra(PENDING_RESULT_EXTRA); InputStream in = null; try { try { URL url = new URL(intent.getStringExtra(URL_EXTRA)); IllustrativeRSS rss = parser.parse(in = url.openStream()); Intent result = new Intent(); result.putExtra(RSS_RESULT_EXTRA, rss); reply.send(this, RESULT_CODE, result); } catch (MalformedURLException exc) { reply.send(INVALID_URL_CODE); } catch (Exception exc) { reply.send(ERROR_CODE); } } catch (PendingIntent.CanceledException exc) { Log.i(TAG, "reply cancelled", exc); } } }
<service android:name=".DownloadIntentService" android:exported="false"/>
PendingIntent pendingResult = createPendingResult( RSS_DOWNLOAD_REQUEST_CODE, new Intent(), 0); Intent intent = new Intent(getApplicationContext(), DownloadIntentService.class); intent.putExtra(DownloadIntentService.URL_EXTRA, URL); intent.putExtra(DownloadIntentService.PENDING_RESULT_EXTRA, pendingResult); startService(intent);
@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == RSS_DOWNLOAD_REQUEST_CODE) { switch (resultCode) { case DownloadIntentService.INVALID_URL_CODE: handleInvalidURL(); break; case DownloadIntentService.ERROR_CODE: handleError(data); break; case DownloadIntentService.RESULT_CODE: handleRSS(data); break; } handleRSS(data); } super.onActivityResult(requestCode, resultCode, data); }
new Thread(new Runnable(){ @Override public void run() { } }).start();
<uses-permission android:name="android.permission.INTERNET"/>
if (android.os.Build.VERSION.SDK_INT > 9) { StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy); }
new Thread(new Runnable(){ @Override public void run() { try { } catch (Exception ex) { ex.printStackTrace(); } } }).start();
new Thread(new Runnable(){ @Override public void run() { try { } catch (Exception ex) { ex.printStackTrace(); } } }).start();
class DemoTask extends AsyncTask<Void, Void, Void> { protected Void doInBackground(Void... arg0) { } protected void onPostExecute(Void result) { } }
private void normal() { doSomething(); } @Background protected void doSomething() }
RSSFeed feed = new RetreiveFeedTask().execute(urlToRssFeed).get();
AsyncHttpClient client = new AsyncHttpClient(); client.get("http: @Override public void onStart() { } @Override public void onSuccess(int statusCode, Header[] headers, byte[] response) { } @Override public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) { } @Override public void onRetry(int retryNo) { } });
<uses-sdk android:minSdkVersion="8" android:targetSdkVersion="10" />
<uses-permission android:name="android.permission.INTERNET"/>
Executors.newSingleThreadExecutor().submit(new Runnable() { @Override public void run() { } });
btnsub.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread(new Runnable() { @Override public void run() { SoapObject request = new SoapObject(NAMESPACE, METHOD_NAME1); request.addProperty("pincode", txtpincode.getText().toString()); request.addProperty("bg", bloodgroup.getSelectedItem().toString()); SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); envelope.setOutputSoapObject(request); envelope.dotNet = true; try { HttpTransportSE androidHttpTransport = new HttpTransportSE(URL); androidHttpTransport.call(SOAP_ACTION1, envelope); SoapObject result = (SoapObject) envelope.getResponse(); Log.e("result data", "data" + result); SoapObject root = (SoapObject) result.getProperty(0); // System.out.println("********Count : " + root.getPropertyCount()); value = new ArrayList<Detailinfo>(); for (int i = 0; i < root.getPropertyCount(); i++) { SoapObject s_deals = (SoapObject) root.getProperty(i); Detailinfo info = new Detailinfo(); info.setFirstName(s_deals.getProperty("Firstname").toString()); info.setLastName(s_deals.getProperty("Lastname").toString()); info.setDOB(s_deals.getProperty("DOB").toString()); info.setGender(s_deals.getProperty("Gender").toString()); info.setAddress(s_deals.getProperty("Address").toString()); info.setCity(s_deals.getProperty("City").toString()); info.setState(s_deals.getProperty("State").toString()); info.setPinecode(s_deals.getProperty("Pinecode").toString()); info.setMobile(s_deals.getProperty("Mobile").toString()); info.setEmail(s_deals.getProperty("Email").toString()); info.setBloodgroup(s_deals.getProperty("Bloodgroup").toString()); info.setAdddate(s_deals.getProperty("Adddate").toString()); info.setWaight(s_deals.getProperty("waight").toString()); value.add(info); } } catch (Exception e) { e.printStackTrace(); } Intent intent = new Intent(getApplicationContext(), ComposeMail.class); startActivity(intent); } }).start(); } });
public interface FinancesApi { @GET("stocks") Call<ResponseWrapper<String>> listStocks(); @GET("stocks/{symbol}") Call<Stock> getStock(@Path("symbol")String tickerSymbol); @GET("stocks/{symbol}/prices") Call<PriceHistory<Stock>> getPriceHistory(@Path("symbol")String tickerSymbol); @GET("currencies") Call<ResponseWrapper<String>> listCurrencies(); @GET("currencies/{symbol}") Call<Currency> getCurrency(@Path("symbol")String currencySymbol); @GET("currencies/{symbol}/values/{compare_symbol}") Call<PriceHistory<Currency>> getComparativeHistory(@Path("symbol")String currency, @Path("compare_symbol")String currencyToPriceAgainst); }
public class FinancesApiBuilder { public static FinancesApi build(String baseUrl){ return new Retrofit.Builder() .baseUrl(baseUrl) .addConverterFactory(GsonConverterFactory.create()) .build() .create(FinancesApi.class); } }
FinancesApi api = FinancesApiBuilder.build("http: api.getStock("INTC").enqueue(new Callback<Stock>(){ @Override public void onResponse(Call<Stock> stockCall, Response<Stock> stockResponse){ Stock stock = stockCall.body(); } @Override public void onResponse(Call<Stock> stockCall, Throwable t){ } }
public class ImageFetch { private static ImageLoader imageLoader = null; private static RequestQueue imageQueue = null; public static ImageLoader getImageLoader(Context ctx){ if(imageLoader == null){ if(imageQueue == null){ imageQueue = Volley.newRequestQueue(ctx.getApplicationContext()); } imageLoader = new ImageLoader(imageQueue, new ImageLoader.ImageCache() { Map<String, Bitmap> cache = new HashMap<String, Bitmap>(); @Override public Bitmap getBitmap(String url) { return cache.get(url); } @Override public void putBitmap(String url, Bitmap bitmap) { cache.put(url, bitmap); } }); } return imageLoader; } }
<com.android.volley.toolbox.NetworkImageView android:id="@+id/profile_picture" android:layout_width="32dp" android:layout_height="32dp" android:layout_alignParentTop="true" android:layout_centerHorizontal="true" app:srcCompat="@android:drawable/spinner_background"/>
NetworkImageView profilePicture = view.findViewById(R.id.profile_picture); profilePicture.setImageUrl("http:
Ion.with(context) .load("http: .asJsonObject() .setCallback(new FutureCallback<JsonObject>() { @Override public void onCompleted(Exception e, JsonObject result) { } });
new Thread() { @Override public void run() { try { } catch (Exception e) { e.printStackTrace(); } } }.start();
Observable<List<String>> musicShowsObservable = Observable.fromCallable(new Callable<List<String>>() { @Override public List<String> call() { return mRestClient.getFavoriteMusicShows(); } }); mMusicShowSubscription = musicShowsObservable .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer<List<String>>() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List<String> musicShows){ listMusicShows(musicShows); } });
HandlerThread handlerThread = new HandlerThread("URLConnection"); handlerThread.start(); handler mainHandler = new Handler(handlerThread.getLooper()); Runnable myRunnable = new Runnable() { @Override public void run() { try { Log.d("Ravi", "Before IO call"); URL page = new URL("http: StringBuffer text = new StringBuffer(); HttpURLConnection conn = (HttpURLConnection) page.openConnection(); conn.connect(); InputStreamReader in = new InputStreamReader((InputStream) conn.getContent()); BufferedReader buff = new BufferedReader(in); String line; while ( (line = buff.readLine()) != null) { text.append(line + "\n"); } Log.d("Ravi", "After IO call"); Log.d("Ravi",text.toString()); }catch( Exception err){ err.printStackTrace(); } } }; mainHandler.post(myRunnable);
public class MyDownloader extends AsyncTask<String,Void,Bitmap> { @Override protected void onPreExecute() { super.onPreExecute(); } @Override protected void onPostExecute(Bitmap bitmap) { super.onPostExecute(bitmap); } @Override protected Bitmap doInBackground(String... params) { return result; } @Override protected void onProgressUpdate(Void... values) { super.onProgressUpdate(values); } } }
String getUrl() { return "SomeUrl"; } private Object makeCallParseResponse(String url) { return null; // } private void processResponse(Object o) { }
rx.Observable.defer(new Func0<rx.Observable<String>>() { @Override public rx.Observable<String> call() { return rx.Observable.just(getUrl()); } }) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.io()) .map(new Func1<String, Object>() { @Override public Object call(final String s) { return makeCallParseResponse(s); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1<Object>() { @Override public void call(Object o) { processResponse(o); } }, new Action1<Throwable>() { @Override public void call(Throwable throwable) { } });
try { something(); return success; } catch (Exception e) { return failure; } finally { System.out.println("i don }
public static void main(String[] args) { System.out.println(Test.test()); } public static int test() { try { return 0; } finally { System.out.println("finally trumps return."); } }
public static int getMonthsInYear() { try { return 10; } finally { return 12; } }
public static int getMonthsInYear() { try { throw new RuntimeException(); } finally { return 12; } }
public static int getMonthsInYear() { try { return 12; } finally { throw new RuntimeException(); } }
public static void main(final String[] args) { System.out.println(test()); } public static int test() { int i = 0; try { i = 2; return i; } finally { i = 12; System.out.println("finally trumps return."); } }
public static void main(String[] args) { System.out.println(Test.test()); } public static int printX() { System.out.println("X"); return 0; } public static int test() { try { return printX(); } finally { System.out.println("finally trumps return... sort of"); } }
class A { public static void main(String args[]){ DataInputStream cin = new DataInputStream(System.in); try{ int i=Integer.parseInt(cin.readLine()); }catch(ArithmeticException e){ }catch(Exception e){ System.exit(0); }finally{ System.out.println("Won System.out.println("No error"); } } }
int foo() { try { return 42; } finally { System.out.println("done"); } }
int foo() { int ret = 42; System.out.println("done"); return 42; }
public static int test() { int i = 0; try { return i; } finally { i = 12; System.out.println("finally trumps return."); return i; } }
try{ int divideByZeroException = 5 / 0; } catch (Exception e){ System.out.println("catch"); return; } finally { System.out.println("finally"); }
public class someTest { private static StringBuilder sb = new StringBuilder(); public static void main(String args[]) { System.out.println(someString()); System.out.println("---AGAIN---"); System.out.println(someString()); } private static String someString() { try { sb.append("-abc-"); return sb.toString(); } finally { sb.append("xyz"); } } }
private static String someString() { StringBuilder sb = new StringBuilder(); try { sb.append("abc"); return sb.toString(); } finally { sb = null; } }
public static final String[] VALUES = new String[] {"AB","BC","CD","AE"};
String[] values = {"AB","BC","CD","AE"}; boolean contains = Arrays.stream(values).anyMatch("s"::equals);
int[] a = {1,2,3,4}; boolean contains = IntStream.of(a).anyMatch(x -> x == 4);
public static final String[] VALUES = new String[] {"AB","BC","CD","AE"};
private static final String[] VALUES = new String[] {"AB","BC","CD","AE"};
private static final Set<String> VALUES = new HashSet<String>(Arrays.asList( new String[] {"AB","BC","CD","AE"} ));
String[] fieldsToInclude = { "id", "name", "location" }; if ( ArrayUtils.contains( fieldsToInclude, "id" ) ) { }
public static <T> boolean contains(final T[] array, final T v) { for (final T e : array) if (e == v || v != null && v.equals(e)) return true; return false; }
public static <T> boolean contains2(final T[] array, final T v) { if (v == null) { for (final T e : array) if (e == null) return true; } else { for (final T e : array) if (e == v || v.equals(e)) return true; } return false; }
public static boolean useList(String[] arr, String targetValue) { return Arrays.asList(arr).contains(targetValue); }
public static boolean useSet(String[] arr, String targetValue) { Set<String> set = new HashSet<String>(Arrays.asList(arr)); return set.contains(targetValue); }
public static boolean useLoop(String[] arr, String targetValue) { for (String s: arr) { if (s.equals(targetValue)) return true; } return false; }
public static boolean binarySearch(String[] arr, String targetValue) { int a = Arrays.binarySearch(arr, targetValue); return a > 0; }
String testValue="test"; String newValueNotInList="newValue"; String[] valueArray = { "this", "is", "java" , "test" }; Arrays.asList(valueArray).contains(testValue); Arrays.asList(valueArray).contains(newValueNotInList);
import java.util.*; public class Test { public static void main(String args[]) { long start = 0; int size = 100000; String[] strings = new String[size]; Random random = new Random(); for (int i = 0; i < size; i++) strings[i] = "" + random.nextInt( size ); start = System.currentTimeMillis(); Arrays.sort(strings); System.out.println(Arrays.binarySearch(strings, "" + (size - 1) )); System.out.println("Sort & Search : " + (System.currentTimeMillis() - start)); start = System.currentTimeMillis(); System.out.println(Arrays.binarySearch(strings, "" + (size - 1) )); System.out.println("Search : " + (System.currentTimeMillis() - start)); start = System.currentTimeMillis(); System.out.println(Arrays.asList(strings).contains( "" + (size - 1) )); System.out.println("Contains : " + (System.currentTimeMillis() - start)); } }
String[] values = {"AB","BC","CD","AE"}; boolean sInArray = Arrays.stream(values).anyMatch("s"::equals);
public static <T> boolean arrayContains(T[] array, T value) { return Arrays.stream(array).anyMatch(value::equals); }
public static final List<String> STRINGS = Arrays.asList("firstString", "secondString" ...., "lastString");
enum Values { AB, BC, CD, AE } try { Values.valueOf(s); return true; } catch (IllegalArgumentException exc) { return false; }
private static final Set<String> VALUES = ImmutableSet.of("AB","BC","CD","AE");
import java.util.Arrays; import java.util.List; public class ArrayContainsElement { public static final List<String> VALUES = Arrays.asList("AB", "BC", "CD", "AE"); public static void main(String args[]) { if (VALUES.contains("AB")) { System.out.println("Contains"); } else { System.out.println("Not contains"); } } }
Set<String> set = new HashSet<String>(Arrays.asList(arr)); return set.contains(targetValue);
for(String s: arr){ if(s.equals(targetValue)) return true; } return false;
List<String> myList = Arrays.asList("a1", "a2", "b1", "c2", "c1"); myList .stream() .filter(s -> s.startsWith("c")) .map(String::toUpperCase) .sorted() .forEach(System.out::println);
boolean useLoop(String[] arr, String targetValue) { for(String s: arr){ if(s.equals(targetValue)) return true; } return false; }
TreeSet myElements = new TreeSet(); myElements.add(nextElement); myElements.addAll(Arrays.asList(myArray));
class MyComparator implements Comparator<ElementClass> { int compareTo(ElementClass element1; ElementClass element2) { } boolean equals(Object otherComparator) { } } TreeSet myElements = new TreeSet(new MyComparator()); myElements.add(nextElement);
boolean containsElement = myElements.exists(someElement);
String[] VALUES = new String[] {"AB","BC","CD","AE"}; String s; for(int i=0; i< VALUES.length ; i++) { if ( VALUES[i].equals(s) ) { } else{ } }
ArrayList<Integer> arrlist = new ArrayList<Integer>(8); arrlist.add(20); arrlist.add(25); arrlist.add(10); arrlist.add(15); boolean retval = arrlist.contains(10); if (retval == true) { System.out.println("10 is contained in the list"); } else { System.out.println("10 is not contained in the list"); }
public boolean findString(String[] strings, String desired){ for (String str : strings){ if (desired.equals(str)) { return true; } } return false; }
public class ObjectUtils{ /** * A null safe method to detect if two objects are equal. * @param object1 * @param object2 * @return true if either both objects are null, or equal, else returns false. */ public static boolean equals(Object object1, Object object2){ return object1==null ? object2==null : object1.equals(object2); } }
public class ArrayUtils{ /** * Find the index of of an object is in given array, starting from given inclusive index. * @param ts Array to be searched in. * @param t Object to be searched. * @param start The index from where the search must start. * @return Index of the given object in the array if it is there, else -1. */ public static <T> int indexOf(final T[] ts, final T t, int start){ for(int i = start; i < ts.length; ++i) if(ObjectUtils.equals(ts[i], t)) return i; return -1; } /** * Find the index of of an object is in given array, starting from 0; * @param ts Array to be searched in. * @param t Object to be searched. * @return indexOf(ts, t, 0) */ public static <T> int indexOf(final T[] ts, final T t){ return indexOf(ts, t, 0); } /** * Detect if the given object is in the given array. * @param ts Array to be searched in. * @param t Object to be searched. * @return If indexOf(ts, t) is greater than -1. */ public static <T> boolean in(final T[] ts, final T t){ return indexOf(ts, t) > -1 ; } }
Arrays.stream(VALUES).anyMatch(s::equalsIgnoreCase);
`if (Array.BinarySearch(str, i) > -1)`  true --exists
public class Foo { private int x; public Foo() { this(1); } public Foo(int x) { this.x = x; } }
public class Cons { public Cons() { this(madeUpArg1Value,madeUpArg2Value,madeUpArg3Value); } public Cons(int arg1, int arg2) { this(arg1,arg2, madeUpArg3Value); } public Cons(int arg1, int arg2, int arg3) { this.arg1 = arg1; this.arg2 = arg2; this.arg3 = arg3; } }
public class Cons { public static Cons newCons(int arg1,...) { Cons c = new Cons(...); c.setArg1(....); return c; } }
public class MyClass { public MyClass(double argument1, double argument2) { this(argument1, argument2, 0.0); } public MyClass(double argument1, double argument2, double argument3) { this.argument1 = argument1; this.argument2 = argument2; this.argument3 = argument3; } }
public class MyClass { public MyClass(double argument1, double argument2) { this(argument1, argument2, getDefaultArg3(argument1, argument2)); } public MyClass(double argument1, double argument2, double argument3) { this.argument1 = argument1; this.argument2 = argument2; this.argument3 = argument3; } private static double getDefaultArg3(double argument1, double argument2) { double argument3 = 0; return argument3; } }
class MyClass { int field; MyClass() { init(0); } MyClass(int value) { if (value<0) { init(0); } else { init(value); } } void init(int x) { field = x; } }
class MyClass { int field; MyClass(int value) { if (value<0) field = 0; else field = value; } MyClass() { this(0); } }
public class Rectangle { private int x, y; private int width, height; public Rectangle() { this(1, 1); } public Rectangle(int width, int height) { this( 0,0,width, height); } public Rectangle(int x, int y, int width, int height) { this.x = x; this.y = y; this.width = width; this.height = height; } }
Class Test { Test() { this(10); } Test(int a) { this(10.5); } Test(double a) { System.out.println("I am a double arg constructor"); } }
class ConstructorDemo { ConstructorDemo() { System.out.println("D.constructor "); } ConstructorDemo(int k) { this(); System.out.println("P.Constructor ="+k); } public static void main(String[] args) { new ConstructorDemo(); ConstructorDemo g=new ConstructorDemo(3);---(3) } }
public class Product { private int productId; private String productName; private double productPrice; private String category; public Product(int id, String name) { this(id,name,1.0); } public Product(int id, String name, double price) { this(id,name,price,"DEFAULT"); } public Product(int id,String name,double price, String category){ this.productId=id; this.productName=name; this.productPrice=price; this.category=category; } }
public Product(int id, String name, double price) { System.out.println("Calling constructor with price"); this(id,name,price,"DEFAULT"); }
public class SuperClass { public SuperClass() { System.out.println("Inside super class constructor"); } } public class SubClass extends SuperClass { public SubClass () { System.out.println("Inside sub class constructor"); } }
class This1 { This1() { this("Hello"); System.out.println("Default constructor.."); } This1(int a) { this(); System.out.println("int as arg constructor.."); } This1(String s) { System.out.println("string as arg constructor.."); } public static void main(String args[]) { new This1(100); } }
class MyConstructorDemo extends ConstructorDemo { MyConstructorDemo() { this("calling another constructor"); } MyConstructorDemo(String arg) { System.out.print("This is passed String by another constructor :"+arg); } }
class Example{ private int a = 1; Example(){ this(5); System.out.println("number a is "+a); } Example(int b){ System.out.println("number b is "+b); }
class LambdaInitedClass { public LamdaInitedClass(Consumer<LambdaInitedClass> init) { init.accept(this); } }
public class SomeClass{ int number; String someString; public SomeClass(){ number = 0; } public SomeClass(int number){ this(); this.setNumber(number); } public SomeClass(int number, String someString){ this(number); } public void setNumber(int number){ this.number = number; } public void setString(String someString){ this.someString = someString; } }
public SomeOtherClass extends SomeClass { public SomeOtherClass(int number, String someString){ super(number, someString); } }
import java.util.*; import java.lang.*; class Test { public static void main(String args[]) { Dog d = new Dog(); Dog cs = new Dog("Bite"); System.out.println("------------------------------"); Cat c = new Cat(); Cat caty = new Cat("10"); System.out.println("------------------------------"); Self ss = new Self("self"); } } class Animal { String i; public Animal() { i = "10"; System.out.println("Animal Constructor :" +i); } public Animal(String h) { i = "20"; System.out.println("Animal Constructor Habit :"+ i); } } class Dog extends Animal { public Dog() { System.out.println("Dog Constructor"); } public Dog(String h) { System.out.println("Dog Constructor with habit"); } } class Cat extends Animal { public Cat() { System.out.println("Cat Constructor"); } public Cat(String i) { super(i); System.out.println("Cat Constructor with habit"); } } class Self { public Self() { System.out.println("Self Constructor"); } public Self(String h) { this(); System.out.println("Slef Constructor with value"); } }
public Omar(){}; public Omar(a){}; public Omar(a,b){}; public Omar(a,b,c){}; public Omar(a,b,c,d){}; ...
public class MyRunnable implements Runnable { public void run() { } }
public class MyThread extends Thread { public MyThread() { super("MyThread"); } public void run() { } }
Future<?> f = new FutureTask<Object>(runnable, null)
ExecutorService es = Executors.newCachedThreadPool(); es.execute(new ThreadA());
class ImplementsRunnable implements Runnable { private int counter = 0; public void run() { counter++; System.out.println("ImplementsRunnable : Counter : " + counter); } } class ExtendsThread extends Thread { private int counter = 0; public void run() { counter++; System.out.println("ExtendsThread : Counter : " + counter); } } public class ThreadVsRunnable { public static void main(String args[]) throws Exception { ImplementsRunnable rc = new ImplementsRunnable(); Thread t1 = new Thread(rc); t1.start(); Thread.sleep(1000); Thread t2 = new Thread(rc); t2.start(); Thread.sleep(1000); Thread t3 = new Thread(rc); t3.start(); ExtendsThread tc1 = new ExtendsThread(); tc1.start(); Thread.sleep(1000); ExtendsThread tc2 = new ExtendsThread(); tc2.start(); Thread.sleep(1000); ExtendsThread tc3 = new ExtendsThread(); tc3.start(); } }
ImplementsRunnable : Counter : 1 ImplementsRunnable : Counter : 2 ImplementsRunnable : Counter : 3 ExtendsThread : Counter : 1 ExtendsThread : Counter : 1 ExtendsThread : Counter : 1
public class Something { public void justAnotherMethod() { ... } } new Thread(new Runnable() { public void run() { instanceOfSomething.justAnotherMethod(); } }).start();
public class DebuggableThread extends Thread { private static String getStackTrace(String name) { Throwable t= new Throwable("DebuggableThread-"+name); ByteArrayOutputStream os = new ByteArrayOutputStream(); PrintStream ps = new PrintStream(os); t.printStackTrace(ps); return os.toString(); } public DebuggableThread(String name) { super(getStackTrace(name)); } public static void main(String[] args) throws Exception { System.out.println(new Thread()); System.out.println(new DebuggableThread("MainTest")); } }
Thread[Thread-1,5,main] Thread[java.lang.Throwable: DebuggableThread-MainTest at DebuggableThread.getStackTrace(DebuggableThread.java:6) at DebuggableThread.<init>(DebuggableThread.java:14) at DebuggableThread.main(DebuggableThread.java:19) ,5,main]
public class WaitPuzzle { public static void main(String[] args) throws InterruptedException { DoNothing doNothing = new DoNothing(); new WaitForever(doNothing).start(); new WaitForever(doNothing).start(); new WaitForever(doNothing).start(); Thread.sleep(100); doNothing.start(); while(true) { Thread.sleep(10); } } static class WaitForever extends Thread { private DoNothing doNothing; public WaitForever(DoNothing doNothing) { this.doNothing = doNothing; } @Override public void run() { synchronized (doNothing) { try { doNothing.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("Unreachable Code"); } } } static class DoNothing extends Thread { @Override public void run() { System.out.println("Do Nothing "); } } }
String url = "http: String charset = "UTF-8"; String param1 = "value1"; String param2 = "value2"; String query = String.format("param1=%s&param2=%s", URLEncoder.encode(param1, charset), URLEncoder.encode(param2, charset));
URLConnection connection = new URL(url + "?" + query).openConnection(); connection.setRequestProperty("Accept-Charset", charset); InputStream response = connection.getInputStream();
try (Scanner scanner = new Scanner(response)) { String responseBody = scanner.useDelimiter("\\A").next(); System.out.println(responseBody); }
URLConnection connection = new URL(url).openConnection(); connection.setDoOutput(true); connection.setRequestProperty("Accept-Charset", charset); connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded;charset=" + charset); try (OutputStream output = connection.getOutputStream()) { output.write(query.getBytes(charset)); } InputStream response = connection.getInputStream();
HttpURLConnection httpConnection = (HttpURLConnection) new URL(url).openConnection(); httpConnection.setRequestMethod("POST");
for (Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) { System.out.println(header.getKey() + "=" + header.getValue()); }
String contentType = connection.getHeaderField("Content-Type"); String charset = null; for (String param : contentType.replace(" ", "").split(";")) { if (param.startsWith("charset=")) { charset = param.split("=", 2)[1]; break; } } if (charset != null) { try (BufferedReader reader = new BufferedReader(new InputStreamReader(response, charset))) { for (String line; (line = reader.readLine()) != null;) { } } } else { }
CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL)); URLConnection connection = new URL(url).openConnection(); connection = new URL(url).openConnection(); connection = new URL(url).openConnection();
URLConnection connection = new URL(url).openConnection(); List<String> cookies = connection.getHeaderFields().get("Set-Cookie"); connection = new URL(url).openConnection(); for (String cookie : cookies) { connection.addRequestProperty("Cookie", cookie.split(";", 2)[0]); }
httpConnection.setFixedLengthStreamingMode(contentLength);
connection.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36");
InputStream error = ((HttpURLConnection) connection).getErrorStream();
String param = "value"; File textFile = new File("/path/to/file.txt"); File binaryFile = new File("/path/to/file.bin"); String boundary = Long.toHexString(System.currentTimeMillis()); String CRLF = "\r\n"; URLConnection connection = new URL(url).openConnection(); connection.setDoOutput(true); connection.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + boundary); try ( OutputStream output = connection.getOutputStream(); PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, charset), true); ) { writer.append("--" + boundary).append(CRLF); writer.append("Content-Disposition: form-data; name=\"param\"").append(CRLF); writer.append("Content-Type: text/plain; charset=" + charset).append(CRLF); writer.append(CRLF).append(param).append(CRLF).flush(); writer.append("--" + boundary).append(CRLF); writer.append("Content-Disposition: form-data; name=\"textFile\"; filename=\"" + textFile.getName() + "\"").append(CRLF); writer.append("Content-Type: text/plain; charset=" + charset).append(CRLF); writer.append(CRLF).flush(); Files.copy(textFile.toPath(), output); output.flush(); writer.append(CRLF).flush(); writer.append("--" + boundary).append(CRLF); writer.append("Content-Disposition: form-data; name=\"binaryFile\"; filename=\"" + binaryFile.getName() + "\"").append(CRLF); writer.append("Content-Type: " + URLConnection.guessContentTypeFromName(binaryFile.getName())).append(CRLF); writer.append("Content-Transfer-Encoding: binary").append(CRLF); writer.append(CRLF).flush(); Files.copy(binaryFile.toPath(), output); output.flush(); writer.append(CRLF).flush(); writer.append("--" + boundary + "--").append(CRLF).flush(); }
static { TrustManager[] trustAllCertificates = new TrustManager[] { new X509TrustManager() { @Override public X509Certificate[] getAcceptedIssuers() { return null; } @Override public void checkClientTrusted(X509Certificate[] certs, String authType) { } @Override public void checkServerTrusted(X509Certificate[] certs, String authType) { } } }; HostnameVerifier trustAllHostnames = new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; } }; try { System.setProperty("jsse.enableSNIExtension", "false"); SSLContext sc = SSLContext.getInstance("SSL"); sc.init(null, trustAllCertificates, new SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); HttpsURLConnection.setDefaultHostnameVerifier(trustAllHostnames); } catch (GeneralSecurityException e) { throw new ExceptionInInitializerError(e); } }
int responseCode = httpURLConnection.getResponseCode(); if (responseCode == HttpURLConnection.HTTP_OK) {
HttpURLConnection.setFollowRedirects(true); String url = "https: URL request_url = new URL(url); HttpURLConnection http_conn = (HttpURLConnection)request_url.openConnection(); http_conn.setConnectTimeout(100000); http_conn.setReadTimeout(100000); http_conn.setInstanceFollowRedirects(true); System.out.println(String.valueOf(http_conn.getResponseCode()));
HttpURLConnection.setFollowRedirects(true); String url = "https: URL request_url = new URL(url); HttpURLConnection http_conn = (HttpURLConnection)request_url.openConnection(); http_conn.setConnectTimeout(100000); http_conn.setReadTimeout(100000); http_conn.setInstanceFollowRedirects(true); http_conn.setDoOutput(true); PrintWriter out = new PrintWriter(http_conn.getOutputStream()); if (urlparameter != null) { out.println(urlparameter); } out.close(); out = null; System.out.println(String.valueOf(http_conn.getResponseCode()));
String response = HttpRequest.get("http: .accept("application/json") .body(); System.out.println("Response was: " + response);
package org.boon.utils; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLConnection; import java.util.Map; import static org.boon.utils.IO.read; public class HTTP {
public static String get( final String url) { Exceptions.tryIt(() -> { URLConnection connection; connection = doGet(url, null, null, null); return extractResponseString(connection); }); return null; } public static String getWithHeaders( final String url, final Map<String, ? extends Object> headers) { URLConnection connection; try { connection = doGet(url, headers, null, null); return extractResponseString(connection); } catch (Exception ex) { Exceptions.handle(ex); return null; } } public static String getWithContentType( final String url, final Map<String, ? extends Object> headers, String contentType) { URLConnection connection; try { connection = doGet(url, headers, contentType, null); return extractResponseString(connection); } catch (Exception ex) { Exceptions.handle(ex); return null; } } public static String getWithCharSet( final String url, final Map<String, ? extends Object> headers, String contentType, String charSet) { URLConnection connection; try { connection = doGet(url, headers, contentType, charSet); return extractResponseString(connection); } catch (Exception ex) { Exceptions.handle(ex); return null; } }
public static String postBody( final String url, final String body) { URLConnection connection; try { connection = doPost(url, null, "text/plain", null, body); return extractResponseString(connection); } catch (Exception ex) { Exceptions.handle(ex); return null; } } public static String postBodyWithHeaders( final String url, final Map<String, ? extends Object> headers, final String body) { URLConnection connection; try { connection = doPost(url, headers, "text/plain", null, body); return extractResponseString(connection); } catch (Exception ex) { Exceptions.handle(ex); return null; } } public static String postBodyWithContentType( final String url, final Map<String, ? extends Object> headers, final String contentType, final String body) { URLConnection connection; try { connection = doPost(url, headers, contentType, null, body); return extractResponseString(connection); } catch (Exception ex) { Exceptions.handle(ex); return null; } } public static String postBodyWithCharset( final String url, final Map<String, ? extends Object> headers, final String contentType, final String charSet, final String body) { URLConnection connection; try { connection = doPost(url, headers, contentType, charSet, body); return extractResponseString(connection); } catch (Exception ex) { Exceptions.handle(ex); return null; } } private static URLConnection doPost(String url, Map<String, ? extends Object> headers, String contentType, String charset, String body ) throws IOException { URLConnection connection; connection = new URL(url).openConnection(); connection.setDoOutput(true); manageContentTypeHeaders(contentType, charset, connection); manageHeaders(headers, connection); IO.write(connection.getOutputStream(), body, IO.CHARSET); return connection; } private static void manageHeaders(Map<String, ? extends Object> headers, URLConnection connection) { if (headers != null) { for (Map.Entry<String, ? extends Object> entry : headers.entrySet()) { connection.setRequestProperty(entry.getKey(), entry.getValue().toString()); } } } private static void manageContentTypeHeaders(String contentType, String charset, URLConnection connection) { connection.setRequestProperty("Accept-Charset", charset == null ? IO.CHARSET : charset); if (contentType!=null && !contentType.isEmpty()) { connection.setRequestProperty("Content-Type", contentType); } } private static URLConnection doGet(String url, Map<String, ? extends Object> headers, String contentType, String charset) throws IOException { URLConnection connection; connection = new URL(url).openConnection(); manageContentTypeHeaders(contentType, charset, connection); manageHeaders(headers, connection); return connection; } private static String extractResponseString(URLConnection connection) throws IOException { HttpURLConnection http = (HttpURLConnection)connection; int status = http.getResponseCode(); String charset = getCharset(connection.getHeaderField("Content-Type")); if (status==200) { return readResponseBody(http, charset); } else { return readErrorResponseBody(http, status, charset); } } private static String readErrorResponseBody(HttpURLConnection http, int status, String charset) { InputStream errorStream = http.getErrorStream(); if ( errorStream!=null ) { String error = charset== null ? read( errorStream ) : read( errorStream, charset ); throw new RuntimeException("STATUS CODE =" + status + "\n\n" + error); } else { throw new RuntimeException("STATUS CODE =" + status); } } private static String readResponseBody(HttpURLConnection http, String charset) throws IOException { if (charset != null) { return read(http.getInputStream(), charset); } else { return read(http.getInputStream()); } } private static String getCharset(String contentType) { if (contentType==null) { return null; } String charset = null; for (String param : contentType.replace(" ", "").split(";")) { if (param.startsWith("charset=")) { charset = param.split("=", 2)[1]; break; } } charset = charset == null ? IO.CHARSET : charset; return charset; }
static class MyHandler implements HttpHandler { public void handle(HttpExchange t) throws IOException { InputStream requestBody = t.getRequestBody(); String body = IO.read(requestBody); Headers requestHeaders = t.getRequestHeaders(); body = body + "\n" + copy(requestHeaders).toString(); t.sendResponseHeaders(200, body.length()); OutputStream os = t.getResponseBody(); os.write(body.getBytes()); os.close(); } } @Test public void testHappy() throws Exception { HttpServer server = HttpServer.create(new InetSocketAddress(9212), 0); server.createContext("/test", new MyHandler()); server.setExecutor(null); server.start(); Thread.sleep(10); Map<String,String> headers = map("foo", "bar", "fun", "sun"); String response = HTTP.postBodyWithContentType("http: System.out.println(response); assertTrue(response.contains("hi mom")); assertTrue(response.contains("Fun=[sun], Foo=[bar]")); response = HTTP.postBodyWithCharset("http: System.out.println(response); assertTrue(response.contains("hi mom")); assertTrue(response.contains("Fun=[sun], Foo=[bar]")); response = HTTP.postBodyWithHeaders("http: System.out.println(response); assertTrue(response.contains("hi mom")); assertTrue(response.contains("Fun=[sun], Foo=[bar]")); response = HTTP.get("http: System.out.println(response); response = HTTP.getWithHeaders("http: System.out.println(response); assertTrue(response.contains("Fun=[sun], Foo=[bar]")); response = HTTP.getWithContentType("http: System.out.println(response); assertTrue(response.contains("Fun=[sun], Foo=[bar]")); response = HTTP.getWithCharSet("http: System.out.println(response); assertTrue(response.contains("Fun=[sun], Foo=[bar]")); Thread.sleep(10); server.stop(0); } @Test public void testPostBody() throws Exception { HttpServer server = HttpServer.create(new InetSocketAddress(9220), 0); server.createContext("/test", new MyHandler()); server.setExecutor(null); server.start(); Thread.sleep(10); Map<String,String> headers = map("foo", "bar", "fun", "sun"); String response = HTTP.postBody("http: assertTrue(response.contains("hi mom")); Thread.sleep(10); server.stop(0); } @Test(expected = RuntimeException.class) public void testSad() throws Exception { HttpServer server = HttpServer.create(new InetSocketAddress(9213), 0); server.createContext("/test", new MyHandler()); server.setExecutor(null); server.start(); Thread.sleep(10); Map<String,String> headers = map("foo", "bar", "fun", "sun"); String response = HTTP.postBodyWithContentType("http: System.out.println(response); assertTrue(response.contains("hi mom")); assertTrue(response.contains("Fun=[sun], Foo=[bar]")); Thread.sleep(10); server.stop(0); }
HttpResponse response = HttpRequest .create(new URI("http: .headers("Foo", "foovalue", "Bar", "barvalue") .GET() .response();
int statusCode = response.statusCode(); String responseBody = response.body(HttpResponse.asString());
module com.foo.bar { requires jdk.incubator.httpclient; }
Request request = new Request.Builder() .url(url) .build();
Response response = client.newCall(request).execute();
Method method = foo.getClass().getMethod("doSomething", null); method.invoke(foo, null);
import java.lang.reflect.Array; import java.lang.reflect.Field; public static String dump(Object o, int callCount) { callCount++; StringBuffer tabs = new StringBuffer(); for (int k = 0; k < callCount; k++) { tabs.append("\t"); } StringBuffer buffer = new StringBuffer(); Class oClass = o.getClass(); if (oClass.isArray()) { buffer.append("\n"); buffer.append(tabs.toString()); buffer.append("["); for (int i = 0; i < Array.getLength(o); i++) { if (i < 0) buffer.append(","); Object value = Array.get(o, i); if (value.getClass().isPrimitive() || value.getClass() == java.lang.Long.class || value.getClass() == java.lang.String.class || value.getClass() == java.lang.Integer.class || value.getClass() == java.lang.Boolean.class ) { buffer.append(value); } else { buffer.append(dump(value, callCount)); } } buffer.append(tabs.toString()); buffer.append("]\n"); } else { buffer.append("\n"); buffer.append(tabs.toString()); buffer.append("{\n"); while (oClass != null) { Field[] fields = oClass.getDeclaredFields(); for (int i = 0; i < fields.length; i++) { buffer.append(tabs.toString()); fields[i].setAccessible(true); buffer.append(fields[i].getName()); buffer.append("="); try { Object value = fields[i].get(o); if (value != null) { if (value.getClass().isPrimitive() || value.getClass() == java.lang.Long.class || value.getClass() == java.lang.String.class || value.getClass() == java.lang.Integer.class || value.getClass() == java.lang.Boolean.class ) { buffer.append(value); } else { buffer.append(dump(value, callCount)); } } } catch (IllegalAccessException e) { buffer.append(e.getMessage()); } buffer.append("\n"); } oClass = oClass.getSuperclass(); } buffer.append(tabs.toString()); buffer.append("}\n"); } return buffer.toString(); }
Class myObjectClass = MyObject.class; Method[] method = myObjectClass.getMethods(); Method method = aClass.getMethod("method_name", String.class); Object returnValue = method.invoke(null, "parameter-value1");
public class A{ private String str= null; public A(String str) { this.str= str; } }
A obj= new A("Some value"); Field privateStringField = A.class.getDeclaredField("privateString"); privateStringField.setAccessible(true); String fieldValue = (String) privateStringField.get(obj); System.out.println("fieldValue = " + fieldValue);
Method[] methods = MyObject.class.getMethods(); for(Method method : methods){ System.out.println("method = " + method.getName()); }
<bean id="someID" class="com.example.Foo"> <property name="someField" value="someValue" /> </bean>
Method method = targetClass.getDeclaredMethod(methodName, argClasses); method.setAccessible(true); return method.invoke(targetObject, argObjects);
Field field = targetClass.getDeclaredField(fieldName); field.setAccessible(true); field.set(object, value);
public class Test { public void firstMoveChoice(){ System.out.println("First Move"); } public void secondMOveChoice(){ System.out.println("Second Move"); } public void thirdMoveChoice(){ System.out.println("Third Move"); } public static void main(String[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { Test test = new Test(); Method[] method = test.getClass().getMethods(); method[0].invoke(test, null); method[1].invoke(test, null); method[2].invoke(test, null); } }
class ObjectAnalyzer { private ArrayList<Object> visited = new ArrayList<Object>(); /** * Converts an object to a string representation that lists all fields. * @param obj an object * @return a string with the object * values */ public String toString(Object obj) { if (obj == null) return "null"; if (visited.contains(obj)) return "..."; visited.add(obj); Class cl = obj.getClass(); if (cl == String.class) return (String) obj; if (cl.isArray()) { String r = cl.getComponentType() + "[]{"; for (int i = 0; i < Array.getLength(obj); i++) { if (i > 0) r += ","; Object val = Array.get(obj, i); if (cl.getComponentType().isPrimitive()) r += val; else r += toString(val); } return r + "}"; } String r = cl.getName(); do { r += "["; Field[] fields = cl.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field f : fields) { if (!Modifier.isStatic(f.getModifiers())) { if (!r.endsWith("[")) r += ","; r += f.getName() + "="; try { Class t = f.getType(); Object val = f.get(obj); if (t.isPrimitive()) r += val; else r += toString(val); } catch (Exception e) { e.printStackTrace(); } } } r += "]"; cl = cl.getSuperclass(); } while (cl != null); return r; } }
Logger LOGGER = Logger.getLogger(MethodHandles.lookup().lookupClass().getName());
int[] myIntArray = new int[3]; int[] myIntArray = {1,2,3}; int[] myIntArray = new int[]{1,2,3};
String[] myStringArray = new String[3]; String[] myStringArray = {"a","b","c"}; String[] myStringArray = new String[]{"a","b","c"};
String[] myStringArray; myStringArray = new String[]{"a","b","c"};
num[0][0]=1; num[0][1]=2; num[1][0]=1; num[1][1]=2; num[2][0]=1; num[2][1]=2; num[3][0]=1; num[3][1]=2; num[4][0]=1; num[4][1]=2;
int[][] num = new int[5][]; num[0] = new int[1]; num[1] = new int[5]; num[2] = new int[2]; num[3] = new int[3];
int[][] num={ {1}, {1,2}, {1,2,3,4,5}, {1,2}, {1,2,3} };
for (int i=0; i<(num.length); i++ ) { for (int j=0;j<num[i].length;j++) System.out.println(num[i][j]); }
for (int[] a : num) { for (int i : a) { System.out.println(i); } }
Type[] variableName = new Type[capacity]; Type[] variableName = {comma-delimited values}; Type variableName[] = new Type[capacity]; Type variableName[] = {comma-delimited values};
float floatArray[]; int[] integerArray = new int[10]; String[] array = new String[] {"a", "b"};
String arrayName[] = new String[10]; String[] arrayName = new String[10];
List<String> listOfString = new ArrayList<String>(); listOfString.add("foo"); listOfString.add("bar"); String value = listOfString.get(0); assertEquals( value, "foo" );
int[][] array2d = new int[x][y]; int[][] array2d = { {1,2,3 ...}, {4,5,6 ...} ...};
int[] i = new int[capacity]; int[] i = new int[] {value1, value2, value3, etc}; int[] i = {value1, value2, value3, etc};
public static void varargs(int fixed1, String fixed2, int... varargs) {...} ... varargs(0, "", 100); varargs(0, "", 100, 200);
[0, 0] [1, 0] [2, 0] [0, 1] [1, 1] [2, 1] [0, 2] [1, 2] [2, 2] [0, 3] [1, 3] [2, 3] [0, 4] [1, 4] [2, 4]
int size = 3; int[] intArray = (int[]) Array.newInstance(int.class, size );
class Animal {} class Horse extends Animal { public static void main(String[] args) { /* * Array of Animal can hold Animal and Horse (all subtypes of Animal allowed) */ Animal[] a1 = new Animal[10]; a1[0] = new Animal(); a1[1] = new Horse(); /* * Array of Animal can hold Animal and Horse and all subtype of Horse */ Animal[] a2 = new Horse[10]; a2[0] = new Animal(); a2[1] = new Horse(); /* * Array of Horse can hold only Horse and its subtype (if any) and not allowed supertype of Horse nor other subtype of Animal. */ Horse[] h1 = new Horse[10]; h1[0] = new Animal(); h1[1] = new Horse(); /* * This can not be declared. */ Horse[] h2 = new Animal[10]; } }
int item = value; int [] one_dimensional_array = { value, value, value, .., value }; int [][] two_dimensional_array = { { value, value, value, .. value }, { value, value, value, .. value }, .. .. .. .. { value, value, value, .. value } };
Object item = new Object(); Object [] one_dimensional_array = { new Object(), new Object(), .. new Object() }; Object [][] two_dimensional_array = { { new Object(), new Object(), .. new Object() }, { new Object(), new Object(), .. new Object() }, .. .. .. { new Object(), new Object(), .. new Object() } };
String [] a = { "hello", "world" }; String [] a = { new String({ Integer [] b = { 1234, 5678 }; Integer [] b = { new Integer(1234), new Integer(5678) };
int[] a = IntStream.iterate(10, x -> x <= 100, x -> x + 10).toArray(); Out: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] int[] b = IntStream.iterate(0, x -> x + 1).takeWhile(x -> x < 10).toArray(); Out: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
public ArrayList<ClassName> arrayName; arrayName = new ArrayList<ClassName>();
arrayName.add(new ClassName(class parameters go here);
String[] strs = IntStream.range(0, 15) .mapToObj(i -> Integer.toString(i)) .toArray(String[]::new);
int [] a1 = IntStream.range(1, 20).toArray(); System.out.println(Arrays.toString(a1));
int [] a2 = new Random().ints(15, -50, 50).toArray(); double [] a3 = new Random().doubles(5, 0, 1e17).toArray();
double [] a4 = LongStream.range(0, 7).mapToDouble(i -> Math.pow(2, i)).toArray(); System.out.println(Arrays.toString(a4));
String [] a5 = Stream.generate(()->"I will not squeak chalk").limit(5).toArray(String[]::new); System.out.println(Arrays.toString(a5));
String [][] a6 = List.of(new String[]{"a", "b", "c"} , new String[]{"d", "e", "f", "g"}) .toArray(new String[0][]); System.out.println(Arrays.deepToString(a6));
private List<String> list = new ArrayList<String>(){{ add("e1"); add("e2"); }};
List<String> number = Arrays.asList("1", "2", "3"); Out: ["1", "2", "3"]
int[] SingleDimensionalArray = new int[2] int[][] MultiDimensionalArray = new int[3][4]
@Test public void testFooThrowsIndexOutOfBoundsException() { boolean thrown = false; try { foo.doStuff(); } catch (IndexOutOfBoundsException e) { thrown = true; } assertTrue(thrown); }
@Test(expected = IndexOutOfBoundsException.class) public void testIndexOutOfBoundsException() { ArrayList emptyList = new ArrayList(); Object o = emptyList.get(0); }
public class FooTest { @Rule public final ExpectedException exception = ExpectedException.none(); @Test public void doStuffThrowsIndexOutOfBoundsException() { Foo foo = new Foo(); exception.expect(IndexOutOfBoundsException.class); foo.doStuff(); } }
try { methodThatShouldThrow(); fail( "My method didn } catch (MyException expectedException) { }
@Test public void verifiesTypeAndMessage() { assertThrown(new DummyService()::someMethod) .isInstanceOf(RuntimeException.class) .hasMessage("Runtime exception occurred") .hasMessageStartingWith("Runtime") .hasMessageEndingWith("occurred") .hasMessageContaining("exception") .hasNoCause(); }
@Test(expected = IndexOutOfBoundsException.class) public void testFooThrowsIndexOutOfBoundsException() { foo.doStuff(); }
public class XxxTest { @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void testFooThrowsIndexOutOfBoundsException() { thrown.expect(IndexOutOfBoundsException.class) thrown.expectMessage("expected messages"); foo.doStuff(); } }
@Test public void testFooThrowsIndexOutOfBoundsException() { try { foo.doStuff(); fail("expected exception was not occured."); } catch(IndexOutOfBoundsException e) { } }
@Test public void testFooThrowsIndexOutOfBoundsException() { Throwable exception = assertThrows(IndexOutOfBoundsException.class, () -> foo.doStuff()); assertEquals("expected messages", exception.getMessage()); }
@Test(expected = WantedException.class) public void call2_should_throw_a_WantedException__not_call1() { tested.call1(); tested.call2(); }
@Rule ExpectedException thrown = ExpectedException.none() @Test public void call2_should_throw_a_WantedException__not_call1() { thrown.expect(WantedException.class); thrown.expectMessage("boom"); tested.call1(); tested.call2(); }
List myList = new ArrayList(); when(myList).get(1); then(caughtException()) .isInstanceOf(IndexOutOfBoundsException.class) .hasMessage("Index: 1, Size: 0") .hasNoCause();
@Test public void test_exception_approach_1() { ... assertThatExceptionOfType(IOException.class) .isThrownBy(() -> someBadIOOperation()) .withMessage("boom!"); } @Test public void test_exception_approach_2() { ... assertThatThrownBy(() -> someBadIOOperation()) .isInstanceOf(Exception.class) .hasMessageContaining("boom"); } @Test public void test_exception_approach_3() { ... Throwable thrown = catchThrowable(() -> someBadIOOperation()); assertThat(thrown).isInstanceOf(Exception.class) .hasMessageContaining("boom"); }
@Test @DisplayName("throws EmptyStackException when peeked") void throwsExceptionWhenPeeked() { Throwable t = assertThrows(EmptyStackException.class, () -> stack.peek()); Assertions.assertEquals("...", t.getMessage()); }
public class FooTest { @Test public void doStuffThrowsIndexOutOfBoundsException() { Foo foo = new Foo(); IndexOutOfBoundsException e = assertThrows( IndexOutOfBoundsException.class, foo::doStuff); assertThat(e).hasMessageThat().contains("woops!"); } }
public void testFooThrowsIndexOutOfBoundsException() { Throwable e = null; try { foo.doStuff(); } catch (Throwable ex) { e = ex; } assertTrue(e instanceof IndexOutOfBoundsException); }
import static org.assertj.core.api.Assertions.*; @Test public void testFooThrowsIndexOutOfBoundsException() { Foo foo = new Foo(); assertThatThrownBy(() -> foo.doStuff()) .isInstanceOf(IndexOutOfBoundsException.class); }
assertThatThrownBy(() -> { throw new Exception("boom!"); }) .isInstanceOf(Exception.class) .hasMessageContaining("boom");
@Test public void testFooThrowsIndexOutOfBoundsException() { when(foo).doStuff(); then(caughtException()).isInstanceOf(IndexOutOfBoundsException.class); }
verifyException(foo, IndexOutOfBoundsException.class).doStuff();
@Test void exceptionTesting() { Throwable exception = assertThrows(IllegalArgumentException.class, () -> { throw new IllegalArgumentException("a message"); }); assertEquals("a message", exception.getMessage()); }
@Test(expected = FileNotFoundException.class) public void testReadFile() { myClass.readFile("test.txt"); }
public void testReadFile() { try { myClass.readFile("test.txt"); fail("Expected a FileNotFoundException to be thrown"); } catch (FileNotFoundException e) { assertThat(e.getMessage(), is("The file test.txt does not exist!")); } }
@Rule public ExpectedException thrown = ExpectedException.none(); @Test public void testReadFile() throws FileNotFoundException { thrown.expect(FileNotFoundException.class); thrown.expectMessage(startsWith("The file test.txt")); myClass.readFile("test.txt"); }
@Test public void testFooThrowsIndexOutOfBoundsException() { try { foo.doStuff(); assert false; } catch (IndexOutOfBoundsException e) { assert true; } }
try { sut.doThing(); fail(); } catch(MyException e) { assertEquals("the message I get", e.getMessage()); }
@Test void testFooThrowsIndexOutOfBoundsException() { Throwable exception = expectThrows( IndexOutOfBoundsException.class, foo::doStuff ); assertEquals( "some message", exception.getMessage() ); }
public class ExceptionAssertions { public static void assertException(BlastContainer blastContainer ) { boolean caughtException = false; try { blastContainer.test(); } catch( Exception e ) { caughtException = true; } if( !caughtException ) { throw new AssertionFailedError("exception expected to be thrown, but was not"); } } public static interface BlastContainer { public void test() throws Exception; } }
assertException(new BlastContainer() { @Override public void test() throws Exception { doSomethingThatShouldExceptHere(); } });
public final <T extends Throwable> T expectException( Class<T> exceptionClass, Runnable runnable ) { try { runnable.run(); } catch( Throwable throwable ) { if( throwable instanceof AssertionError && throwable.getCause() != null ) throwable = throwable.getCause(); assert exceptionClass.isInstance( throwable ) : throwable; assert throwable.getClass() == exceptionClass : throwable; @SuppressWarnings( "unchecked" ) T result = (T)throwable; return result; } assert false; return null; }
@Test public void testThrows() { RuntimeException e = expectException( RuntimeException.class, () -> { throw new RuntimeException( "fail!" ); } ); assert e.getMessage().equals( "fail!" ); }
package com.mkyong; import com.mkyong.examples.CustomerService; import com.mkyong.examples.exception.NameNotFoundException; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException; import static org.hamcrest.CoreMatchers.containsString; import static org.hamcrest.CoreMatchers.is; import static org.hamcrest.Matchers.hasProperty; public class Exception3Test { @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void testNameNotFoundException() throws NameNotFoundException { thrown.expect(NameNotFoundException.class); thrown.expectMessage(is("Name is empty!")); thrown.expect(hasProperty("errCode")); thrown.expect(hasProperty("errCode", is(666))); CustomerService cust = new CustomerService(); cust.findByName(""); } }
@Test public void testThrowsExceptionWhenWrongSku() { String articleSimpleSku = "999-999"; int amountOfTransactions = 1; Exception exception = null; try { createNInboundTransactionsForSku(amountOfTransactions, articleSimpleSku); } catch (RuntimeException e) { exception = e; } shouldValidateThrowsExceptionWithMessage(exception, MESSAGE_NON_EXISTENT_SKU); } private void shouldValidateThrowsExceptionWithMessage(final Exception e, final String message) { assertNotNull(e); assertTrue(e.getMessage().contains(message)); }
@Rule public ExpectedException exceptions = ExpectedException.none();
public class MyTest { @Rule public ExpectedException exceptions = ExpectedException.none(); ClassUnderTest classUnderTest; @Before public void setUp() throws Exception { classUnderTest = new ClassUnderTest(); } @Test public void testAppleisSweetAndRed() throws Exception { exceptions.expect(Exception.class); exceptions.expectMessage("this is the exception message"); exceptions.expectCause(Matchers.<Throwable>equalTo(exceptionCause)); classUnderTest.methodUnderTest("param1", "param2"); } }
try{ methodThatThrowMyException(); Assert.fail("MyException is not thrown !"); } catch (final Exception exception) { assertTrue(exception instanceof MyException, "An exception other than MyException is thrown !"); MyException myException = (MyException) exception; assertEquals("EXPECTED ERROR MESSAGE", myException.getMessage()); }
@Rule public ExpectedException expectedException; @Before public void setup() { expectedException = ExpectedException.none(); }
public class ExceptionMatcher extends BaseMatcher<Throwable> { private boolean active = true; private Class<? extends Throwable> throwable; public ExceptionMatcher(Class<? extends Throwable> throwable) { this.throwable = throwable; } public void on() { this.active = true; } public void off() { this.active = false; } @Override public boolean matches(Object object) { return active && throwable.isAssignableFrom(object.getClass()); } @Override public void describeTo(Description description) { description.appendText("not the covered exception type"); } }
ExceptionMatcher exMatch = new ExceptionMatcher(MyException.class); exception.expect(exMatch); someObject.somethingThatThrowsMyException(); exMatch.off();
public int divideByZeroDemo(int a,int b){ return a/b; } public void exceptionWithMessage(String [] arr){ throw new ArrayIndexOutOfBoundsException("Array is out of bound"); }
@Rule public ExpectedException exception=ExpectedException.none(); private Demo demo; @Before public void setup(){ demo=new Demo(); } @Test(expected=ArithmeticException.class) public void testIfItThrowsAnyException() { demo.divideByZeroDemo(5, 0); } @Test public void testExceptionWithMessage(){ exception.expectMessage("Array is out of bound"); exception.expect(ArrayIndexOutOfBoundsException.class); demo.exceptionWithMessage(new String[]{"This","is","a","demo"}); }
Throwable throwable = catchThrowable(() -> anyService.anyMethod(object)); AnyException anyException = (AnyException) throwable; assertThat(anyException.getMessage()).isEqualTo("........"); assertThat(exception.getCode()).isEqualTo(".......);
private void expectException(Runnable r, Class<?> clazz) { try { r.run(); fail("Expected: " + clazz.getSimpleName() + " but not thrown"); } catch (Exception e) { if (!clazz.isInstance(e)) fail("Expected: " + clazz.getSimpleName() + " but " + e.getClass().getSimpleName() + " found", e); } }
expectException(() -> list.sublist(0, 2).get(2), IndexOutOfBoundsException.class);
public static <T extends Throwable> T assertThrows(Class<T> expected, ThrowingRunnable action) throws Throwable { try { action.run(); Assert.fail("Did not throw expected " + expected.getSimpleName()); return null; } catch (Throwable actual) { if (!expected.isAssignableFrom(actual.getClass())) { System.err.println("Threw " + actual.getClass().getSimpleName() + ", which is not a subtype of expected " + expected.getSimpleName()); throw actual; } else { return (T) actual; } } }
@FunctionalInterface public interface ThrowingRunnable { void run() throws Throwable; }
class CustomException extends Exception { public final String message; public CustomException(final String message) { this.message = message;} } CustomException e = assertThrows(CustomException.class, () -> { throw new CustomException("Lorem Ipsum"); }); assertEquals("Lorem Ipsum", e.message);
try{ } catch(exception to be thrown from method e) { assertEquals("message", e.getmessage()); }
public Throwable assertThrows(Class<? extends Throwable> expectedException, java.util.concurrent.Callable<?> funky) { try { funky.call(); } catch (Throwable e) { if (expectedException.isInstance(e)) { return e; } throw new AssertionError( String.format("Expected [%s] to be thrown, but was [%s]", expectedException, e)); } throw new AssertionError( String.format("Expected [%s] to be thrown, but nothing was thrown.", expectedException)); }
assertThrows(ValidationException.class, () -> finalObject.checkSomething(null));
public enum Blah { A("text1"), B("text2"), C("text3"), D("text4"); private String text; Blah(String text) { this.text = text; } public String getText() { return this.text; } public static Blah fromString(String text) { for (Blah b : Blah.values()) { if (b.text.equalsIgnoreCase(text)) { return b; } } return null; } }
/** * A common method for all enums since they can * @param <T> Enum type * @param c enum type. All enums must be all caps. * @param string case insensitive * @return corresponding enum, or null */ public static <T extends Enum<T>> T getEnumFromString(Class<T> c, String string) { if( c != null && string != null ) { try { return Enum.valueOf(c, string.trim().toUpperCase()); } catch(IllegalArgumentException ex) { } } return null; }
public static MyEnum fromString(String name) { return getEnumFromString(MyEnum.class, name); }
enum MyEnum { ENUM_1("A"), ENUM_2("B"); private String name; private static final Map<String,MyEnum> ENUM_MAP; MyEnum (String name) { this.name = name; } public String getName() { return this.name; } static { Map<String,MyEnum> map = new ConcurrentHashMap<String,MyEnum>(); for (MyEnum instance : MyEnum.values()) { map.put(instance.getName(),instance); } ENUM_MAP = Collections.unmodifiableMap(map); } public static MyEnum get (String name) { return ENUM_MAP.get(name); } }
/** * Finds the value of the given enumeration by name, case-insensitive. * Throws an IllegalArgumentException if no match is found. **/ public static <T extends Enum<T>> T valueOfIgnoreCase( Class<T> enumeration, String name) { for (T enumValue : enumeration.getEnumConstants()) { if (enumValue.name().equalsIgnoreCase(name)) { return enumValue; } } throw new IllegalArgumentException(String.format( "There is no value with name name, enumeration.getName() )); }
public enum MyEnum { VALUE_1("Super"), VALUE_2("Rainbow"), VALUE_3("Dash"), VALUE_3("Rocks"); private final String value; MyEnum(String value) { this.value = value; } /** * @return the Enum representation for the given string. * @throws IllegalArgumentException if unknown string. */ public static MyEnum fromString(String s) throws IllegalArgumentException { return Arrays.stream(MyEnum.values()) .filter(v -> v.value.equals(s)) .findFirst() .orElseThrow(() -> new IllegalArgumentException("unknown value: " + s)); } }
public enum Blah { A("text1"), B("text2"), C("text3"), D("text4"); private String text; Blah(String text) { this.text = text; } public String getText() { return this.text; } public static Blah fromText(String text) { return Arrays.stream(values()) .filter(bl -> bl.text.equalsIgnoreCase(text)) .findFirst() .orElse(null); } }
public enum ObjectType { PERSON("Person"); public String parameterName; ObjectType(String parameterName) { this.parameterName = parameterName; } public String getParameterName() { return this.parameterName; } public static ObjectType fromString(String parameterName) { if (parameterName != null) { for (ObjectType objType : ObjectType.values()) { if (parameterName.equalsIgnoreCase(objType.parameterName)) { return objType; } } } return null; } }
public static String fromEnumName(String parameterName) { if (parameterName != null) { for (DQJ objType : DQJ.values()) { if (parameterName.equalsIgnoreCase(objType.name())) { return objType.parameterName; } } } return null; }
public enum Blah { A, B, C, D; public static Blah getEnum(String s){ if(A.name().equals(s)){ return A; }else if(B.name().equals(s)){ return B; }else if(C.name().equals(s)){ return C; }else if (D.name().equals(s)){ return D; } throw new IllegalArgumentException("No Enum specified for this string"); } }
package com.universe.solarsystem.planets; import org.apache.commons.lang3.StringUtils; import com.google.common.base.Enums; import com.google.common.base.Optional; public enum Planet { MERCURY, VENUS, EARTH, MARS, JUPITER, SATURN, URANUS, NEPTUNE; public static Planet getPlanet(String name) { String val = StringUtils.trimToEmpty(name).toUpperCase(); Optional <Planet> possible = Enums.getIfPresent(Planet.class, val); if (!possible.isPresent()) { throw new IllegalArgumentException(val + "? There is no such planet!"); } return possible.get(); } }
public enum E { A,B,C; public static Optional<E> fromString(String s) { try { return Optional.of(E.valueOf(s.toUpperCase())); } catch (IllegalArgumentException|NullPointerException e) { return Optional.absent(); } } }
public static MyEnum getFromValue(String value) { MyEnum resp = null; MyEnum nodes[] = values(); for(int i = 0; i < nodes.length; i++) { if(nodes[i].value.equals(value)) { resp = nodes[i]; break; } } return resp; }
public enum MyEnum { BAR, BAZ; private static final Map<String, MyEnum> MAP = Stream.of(MyEnum.values()).collect(Collectors.toMap(Enum::name, Function.identity())); public static MyEnum fromName(String name){ return MAP.get(name); } } public enum MyEnumForJson { BAR("bar"), BAZ("baz"); private static final Map<String, MyEnumForJson> MAP = Stream.of(MyEnumForJson.values()).collect(Collectors.toMap(Object::toString, Function.identity())); private final String value; MyEnumForJson(String value) { this.value = value; } @JsonValue @Override public String toString() { return value; } public static MyEnumForJson fromValue(String value){ return MAP.get(value); } }
public enum USER { STUDENT("jon",0),TEACHER("tom",1); private static final Map<String, Integer> map = new HashMap<>(); static { for (USER user : EnumSet.allOf(USER.class)) { map.put(user.getTypeName(), user.getIndex()); } } public static int findIndexByTypeName(String typeName) { return map.get(typeName); } private USER(String typeName,int index){ this.typeName = typeName; this.index = index; } private String typeName; private int index; public String getTypeName() { return typeName; } public void setTypeName(String typeName) { this.typeName = typeName; } public int getIndex() { return index; } public void setIndex(int index) { this.index = index; } }
public class EnumDemo06 { public static void main(String args[]) { Gender fromString = Gender.valueOf("MALE"); System.out.println("Gender.MALE.name() : " + fromString.name()); } private enum Gender { MALE, FEMALE; } } Output: Gender.MALE.name() : MALE
private static <T extends Enum<T>> T valueOf( String name , T defaultVal) { try { return Enum.valueOf(defaultVal.getDeclaringClass() , name); } catch (IllegalArgumentException | NullPointerException e) { return defaultVal; } }
public enum MYTHINGS { THINGONE, THINGTWO } public static void main(String [] asd) { valueOf("THINGTWO" , MYTHINGS.THINGONE); valueOf("THINGZERO" , MYTHINGS.THINGONE); }
import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.EnumSet; public class EnumUtil { /** * Returns the <code>Enum</code> of type <code>enumType</code> whose a * public method return value of this Enum is * equal to <code>valor</code>.<br/> * Such method should be unique public, not final and static method * declared in Enum. * In case of more than one method in match those conditions * its first one will be chosen. * * @param enumType * @param value * @return */ public static <E extends Enum<E>> E from(Class<E> enumType, Object value) { String methodName = getMethodIdentifier(enumType); return from(enumType, value, methodName); } /** * Returns the <code>Enum</code> of type <code>enumType</code> whose * public method <code>methodName</code> return is * equal to <code>value</code>.<br/> * * @param enumType * @param value * @param methodName * @return */ public static <E extends Enum<E>> E from(Class<E> enumType, Object value, String methodName) { EnumSet<E> enumSet = EnumSet.allOf(enumType); for (E en : enumSet) { try { String invoke = enumType.getMethod(methodName).invoke(en).toString(); if (invoke.equals(value.toString())) { return en; } } catch (Exception e) { return null; } } return null; } private static String getMethodIdentifier(Class<?> enumType) { Method[] methods = enumType.getDeclaredMethods(); String name = null; for (Method method : methods) { int mod = method.getModifiers(); if (Modifier.isPublic(mod) && !Modifier.isStatic(mod) && !Modifier.isFinal(mod)) { name = method.getName(); break; } } return name; } }
public enum Foo { ONE("eins"), TWO("zwei"), THREE("drei"); private String value; private Foo(String value) { this.value = value; } public String getValue() { return value; } }
public enum MyEnum { FIRST, SECOND, THIRD; public static Optional<MyEnum> fromString(String value){ try{ return Optional.of(MyEnum.valueOf(value)); }catch(Exception e){ return Optional.empty(); } } }
private enum Blah { A, B, C, D; public static Blah byName(String name) { switch (name) { case "A": return A; case "B": return B; case "C": return C; case "D": return D; default: throw new IllegalArgumentException( "No enum constant " + Blah.class.getCanonicalName() + "." + name); } } }
private enum Blah { A, B, C, D; public static Blah valueOfOrDefault(String name, Blah defaultValue) { switch (name) { case "A": return A; case "B": return B; case "C": return C; case "D": return D; default: if (defaultValue == null) { throw new NullPointerException(); } return defaultValue; } } }
static <E extends Enum<E>> Enum getEnumValue(String what, Class<E> enumClass) { Enum<E> unknown=null; for (Enum<E> enumVal: enumClass.getEnumConstants()) { if (what.compareToIgnoreCase(enumVal.name()) == 0) { return enumVal; } if (enumVal.name().compareToIgnoreCase("unknown") == 0) { unknown=enumVal; } } return unknown; }
  Annotation  Meaning    @Component  generic stereotype for any Spring-managed component   @Repository stereotype for persistence layer   @Service  stereotype for service layer   @Controller stereotype for presentation layer (spring-mvc)  
<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
@Component @Scope("prototype") public @interface ScheduledJob {..}
@Component  Indicates a auto scan component. @Repository  Indicates DAO component in the persistence layer. @Service  Indicates a Service component in the business layer. @Controller  Indicates a controller component in the presentation layer.
1. **@Repository** - Automatic exception translation in your persistence layer. 2. **@Service** - It indicates that the annotated class is providing a business service to other layers within the application.
package com.spring.anno; @Service public class TestBean { public void m1() { } } package com.spring.anno; @Repository public class TestBean { public void update() { } }
CustomerService cust = (CustomerService)context.getBean("AAA");
@RestController- Declare at controller level. @Controller  Declare at controller level. @Component  Declare at Bean/entity level. @Repository  Declare at DAO level. @Service  Declare at BO level.
@component @controller @Repository @service @RestController
int[] intArray = new int[] {1, 2, 3, 4, 5}; System.out.println(intArray);
int[] intArray = new int[] {1, 2, 3, 4, 5}; String[] strArray = new String[] {"John", "Mary", "Bob"};
String[] array = new String[] {"John", "Mary", "Bob"}; System.out.println(Arrays.toString(array));
String[][] deepArray = new String[][] {{"John", "Mary"}, {"Alice", "Bob"}}; System.out.println(Arrays.toString(deepArray)); System.out.println(Arrays.deepToString(deepArray));
double[] doubleArray = { 7.0, 9.0, 5.0, 1.0, 3.0 }; System.out.println(Arrays.toString(doubleArray));
int[] intArray = { 7, 9, 5, 1, 3 }; System.out.println(Arrays.toString(intArray));
import java.util.Arrays; . . . System.out.println( Arrays.toString( myarray ) );
String[] strArray = new String[] {"John", "Mary", "Bob"}; Arrays.asList(strArray).stream().forEach(s -> System.out.println(s)); Stream.of(strArray).forEach(System.out::println); Arrays.stream(strArray).forEach(System.out::println);
String[] greeting = {"Hey", "there", "amigo!"}; String delimiter = " "; String.join(delimiter, greeting)
int[] ints = new int[] {1, 2, 3, 4, 5}; System.out.println(IntStream.of(ints).mapToObj(Integer::toString).collect(Collectors.joining(", "))); System.out.println(IntStream.of(ints).boxed().map(Object::toString).collect(Collectors.joining(", "))); System.out.println(Arrays.toString(ints)); String[] strs = new String[] {"John", "Mary", "Bob"}; System.out.println(Stream.of(strs).collect(Collectors.joining(", "))); System.out.println(String.join(", ", strs)); System.out.println(Arrays.toString(strs)); DayOfWeek [] days = { FRIDAY, MONDAY, TUESDAY }; System.out.println(Stream.of(days).map(Object::toString).collect(Collectors.joining(", "))); System.out.println(Arrays.toString(days)); IntStream.of(ints).forEach(System.out::println); Stream.of(strs).forEach(System.out::println); Stream.of(days).forEach(System.out::println);
System.out.println(Arrays.deepToString(table).replaceAll("],", "]," + System.getProperty("line.separator")));
public static void main(String[] args) { int[] intArray = new int[] {1, 2, 3, 4, 5}; String[] strArray = new String[] {"John", "Mary", "Bob"}; System.out.println(Arrays.toString(intArray)); System.out.println(Arrays.toString(strArray)); Arrays.stream(intArray).forEach(System.out::println); Arrays.stream(strArray).forEach(System.out::println); }
public static void main(String[] args) { int[][] int2DArray = new int[][] { {11, 12}, { 21, 22}, {31, 32, 33} }; String[][] str2DArray = new String[][]{ {"John", "Bravo"} , {"Mary", "Lee"}, {"Bob", "Johnson"} }; System.out.println(Arrays.deepToString(int2DArray)); System.out.println(Arrays.deepToString(str2DArray)); Arrays.stream(int2DArray).flatMapToInt(x -> Arrays.stream(x)).forEach(System.out::println); Arrays.stream(str2DArray).flatMap(x -> Arrays.stream(x)).forEach(System.out::println); }
for(int n: someArray) { System.out.println(n+" "); }
List<String> list = new ArrayList<String>(); list.add("One"); list.add("Two"); list.add("Three"); list.add("Four"); System.out.println(list);
String[] array = new String[] { "One", "Two", "Three", "Four" }; System.out.println(Arrays.toString(array));
String[] arr1 = new String[] { "Fifth", "Sixth" }; String[] arr2 = new String[] { "Seventh", "Eight" }; String[][] arrayOfArray = new String[][] { arr1, arr2 }; System.out.println(arrayOfArray); System.out.println(Arrays.toString(arrayOfArray)); System.out.println(Arrays.deepToString(arrayOfArray));
for (int i = 0; i < intArray.length; i++) { System.out.print(intArray[i] + ", "); }
public String toString() { return getClass().getName() + "@" + Integer.toHexString(hashCode()); }
public String toString() { if (this instanceof boolean[]) return Arrays.toString((boolean[]) this); if (this instanceof byte[]) return Arrays.toString((byte[]) this); if (this instanceof short[]) return Arrays.toString((short[]) this); if (this instanceof char[]) return Arrays.toString((char[]) this); if (this instanceof int[]) return Arrays.toString((int[]) this); if (this instanceof long[]) return Arrays.toString((long[]) this); if (this instanceof float[]) return Arrays.toString((float[]) this); if (this instanceof double[]) return Arrays.toString((double[]) this); if (this instanceof Object[]) return Arrays.deepToString((Object[]) this); return getClass().getName() + "@" + Integer.toHexString(hashCode()); }
int[] intArray = new int[] {1, 2, 3, 4, 5}; Arrays.stream(intArray).forEach(System.out::println);
int[] intArray = new int[] {1, 2, 3, 4, 5}; Arrays.stream(intArray).forEach(System.out::print);
int[] intArray = new int[] {1, 2, 3, 4, 5}; System.out.println(Arrays.toString(intArray));
ObjectWriter ow = new ObjectMapper().writer().withDefaultPrettyPrinter(); System.out.println(ow.writeValueAsString(anyArray));
Gson gson = new Gson(); System.out.println(gson.toJson(anyArray));
int x[] = {1,2,3}; String printableText = Arrays.toString(x).replaceAll("[\\[\\]]", "").replaceAll(", ", "\n"); System.out.println(printableText);
String[] items = {"item 1", "item 2", "item 3"}; for(int i = 0; i < items.length; i++) { System.out.println(items[i]); }
int[] arrayInt = new int[] {10, 20, 30, 40, 50}; System.out.println(Arrays.toString(arrayInt)); for (int number : arrayInt) { System.out.println(number); } for(int x: arrayInt){ System.out.println(x); }
public class printer { public static void main(String[] args) { String a[] = new String[4]; Scanner sc = new Scanner(System.in); System.out.println("enter the data"); for (int i = 0; i < 4; i++) { a[i] = sc.nextLine(); } System.out.println("the entered data is"); for (String i : a) { System.out.println(i); } } }
String[] strArray = new String[] { "John", "Mary", "Bob" }; String arrayAsCSV = StringUtils.join(strArray, " , "); System.out.printf("[%s]", arrayAsCSV);
<groupId>org.apache.commons</groupId> <artifactId>commons-lang3</artifactId> <version>3.3.2</version>
int array[] = {1, 2, 3, 4, 5}; for (int i:array) System.out.println(i);
String s = new String(bytes, StandardChars.ISO_8559); System.out.println(s); byte[] bytes2 = s.getBytes(StandardChars.ISO_8559);
String s = new String(bytes, StandardChars.UTF_8); System.out.println(s); byte[] bytes2 = s.getBytes(StandardChars.UTF_8);
String s = DatatypeConverter.printHexBinary(bytes); System.out.println(s); byte[] bytes2 = DatatypeConverter.parseHexBinary(s);
String s = DatatypeConverter.printBase64Binary(bytes); System.out.println(s); byte[] bytes2 = DatatypeConverter.parseBase64Binary(s);
String s = Arrays.toString(bytes); System.out.println(s); String[] split = s.substring(1, s.length() - 1).split(", "); byte[] bytes2 = new byte[split.length]; for (int i = 0; i < bytes2.length; i++) bytes2[i] = Byte.parseByte(split[i]);
String s = Arrays.toString( IntStream.range(0, bytes.length).map(i -> bytes[i] & 0xFF).toArray()); System.out.println(s); String[] split = s.substring(1, s.length() - 1).split(", "); byte[] bytes2 = new byte[split.length]; for (int i = 0; i < bytes2.length; i++) bytes2[i] = (byte) Integer.parseInt(split[i]);
int[] intArray = new int[] {1, 2, 3, 4, 5}; System.out.println(Arrays.toString(intArray)); output: [1, 2, 3, 4, 5]
String[] strArray = new String[] {"John", "Mary", "Bob"}; System.out.println(Arrays.toString(strArray)); output: [John, Mary, Bob]
Arrays.stream(myArray).forEach(System.out::println);
class demo{ public static void main(String a[]){ int[] number={1,2,3,4,5}; System.out.print(number); } }
class demo{ public static void main(String a[]){ int[] number={1,2,3,4,5}; int i; for(i=0;i<number.length;i++){ System.out.print(number[i]+" "); } } }
import java.util.Arrays; class demo{ public static void main(String a[]){ int[][] number2={{1,2},{3,4},{5,6}};` System.out.print(Arrays.deepToString(number2)); } }
public static void print(int[] array) { StringJoiner joiner = new StringJoiner(",", "[", "]"); Arrays.stream(array).forEach(element -> joiner.add(element + "")); System.out.println(joiner.toString()); } int[] array = new int[]{7, 3, 5, 1, 3}; print(array);
int[] intArray = new int[] {1, 2, 3, 4, 5}; String[] strArray = new String[] {"John", "Mary", "Bob"}; ArrayUtils.toString(intArray); ArrayUtils.toString(strArray);
jshell> String[] names = {"ram","shyam"}; names ==> String[2] { "ram", "shyam" } jshell> Arrays.toString(names); $2 ==> "[ram, shyam]" jshell>
System.out.println(randomString(-229985452) + " " + randomString(-147909649));
public static String randomString(int i) { Random ran = new Random(i); StringBuilder sb = new StringBuilder(); while (true) { int k = ran.nextInt(27); if (k == 0) break; sb.append((char)( } return sb.toString(); }
8 + 96 = 104 --> h 5 + 96 = 101 --> e 12 + 96 = 108 --> l 12 + 96 = 108 --> l 15 + 96 = 111 --> o 23 + 96 = 119 --> w 15 + 96 = 111 --> o 18 + 96 = 114 --> r 12 + 96 = 108 --> l 4 + 96 = 100 --> d
public static void main(String[] args) { long time = System.currentTimeMillis(); generate("stack"); generate("over"); generate("flow"); generate("rulez"); System.out.println("Took " + (System.currentTimeMillis() - time) + " ms"); } private static void generate(String goal) { long[] seed = generateSeed(goal, Long.MIN_VALUE, Long.MAX_VALUE); System.out.println(seed[0]); System.out.println(randomString(seed[0], (char) seed[1])); } public static long[] generateSeed(String goal, long start, long finish) { char[] input = goal.toCharArray(); char[] pool = new char[input.length]; label: for (long seed = start; seed < finish; seed++) { Random random = new Random(seed); for (int i = 0; i < input.length; i++) pool[i] = (char) random.nextInt(27); if (random.nextInt(27) == 0) { int base = input[0] - pool[0]; for (int i = 1; i < input.length; i++) { if (input[i] - pool[i] != base) continue label; } return new long[]{seed, base}; } } throw new NoSuchElementException("Sorry :/"); } public static String randomString(long i, char base) { System.out.println("Using base: Random ran = new Random(i); StringBuilder sb = new StringBuilder(); for (int n = 0; ; n++) { int k = ran.nextInt(27); if (k == 0) break; sb.append((char) (base + k)); } return sb.toString(); }
-9223372036808280701 Using base: stack -9223372036853943469 Using base: over -9223372036852834412 Using base: flow -9223372036838149518 Using base: rulez Took 7087 ms
int main() { std::mt19937 rng(631647094); std::uniform_int_distribution<char> dist( char alpha; while ((alpha = dist(rng)) != { std::cout << alpha; } }
import java.lang.*; import java.util.*; import java.io.*; public class RandomWords { public static void main (String[] args) { Set<String> wordSet = new HashSet<String>(); String fileName = (args.length > 0 ? args[0] : "/usr/share/dict/words"); readWordMap(wordSet, fileName); System.err.println(wordSet.size() + " words read."); findRandomWords(wordSet); } private static void readWordMap (Set<String> wordSet, String fileName) { try { BufferedReader reader = new BufferedReader(new FileReader(fileName)); String line; while ((line = reader.readLine()) != null) { line = line.trim().toLowerCase(); if (isLowerAlpha(line)) wordSet.add(line); } } catch (IOException e) { System.err.println("Error reading from " + fileName + ": " + e); } } private static boolean isLowerAlpha (String word) { char[] c = word.toCharArray(); for (int i = 0; i < c.length; i++) { if (c[i] < } return true; } private static void findRandomWords (Set<String> wordSet) { char[] c = new char[256]; Random r = new Random(); for (long seed0 = 0; seed0 >= 0; seed0++) { for (int sign = -1; sign <= 1; sign += 2) { long seed = seed0 * sign; r.setSeed(seed); int i; for (i = 0; i < c.length; i++) { int n = r.nextInt(27); if (n == 0) break; c[i] = (char)((int) } String s = new String(c, 0, i); if (wordSet.contains(s)) { System.out.println(s + ": " + seed); wordSet.remove(s); } } } } }
import java.lang.*; import java.util.*; public class RandomWordsTest { public static void main (String[] args) { long[] a = {-73, -157512326, -112386651, 71425, -104434815, -128911, -88019, -7691161, 1115727}; for (int i = 0; i < a.length; i++) { Random r = new Random(a[i]); StringBuilder sb = new StringBuilder(); int n; while ((n = r.nextInt(27)) > 0) sb.append((char)( System.out.println(sb); } } }
int[] arrInt = {-2146926310, -1885533740, -274140519, -2145247212, -1845077092, -2143584283, -2147483454, -2138225126, -2147375969}; for(int seed : arrInt){ System.out.print(randomString(seed) + " "); }
import java.util.ArrayList; import java.util.Random; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; public class SeedFinder { static class SearchTask implements Callable<Long> { private final char[] goal; private final long start, step; public SearchTask(final String goal, final long offset, final long step) { final char[] goalAsArray = goal.toCharArray(); this.goal = new char[goalAsArray.length + 1]; System.arraycopy(goalAsArray, 0, this.goal, 0, goalAsArray.length); this.start = Long.MIN_VALUE + offset; this.step = step; } @Override public Long call() throws Exception { final long LIMIT = Long.MAX_VALUE - this.step; final Random random = new Random(); int position, rnd; long seed = this.start; while ((Thread.interrupted() == false) && (seed < LIMIT)) { random.setSeed(seed); position = 0; rnd = random.nextInt(27); while (((rnd == 0) && (this.goal[position] == 0)) || ((char) ( ++position; if (position == this.goal.length) { return seed; } rnd = random.nextInt(27); } seed += this.step; } throw new Exception("No match found"); } } public static void main(String[] args) { final String GOAL = "hello".toLowerCase(); final int NUM_CORES = Runtime.getRuntime().availableProcessors(); final ArrayList<SearchTask> tasks = new ArrayList<>(NUM_CORES); for (int i = 0; i < NUM_CORES; ++i) { tasks.add(new SearchTask(GOAL, i, NUM_CORES)); } final ExecutorService executor = Executors.newFixedThreadPool(NUM_CORES, new ThreadFactory() { @Override public Thread newThread(Runnable r) { final Thread result = new Thread(r); result.setPriority(Thread.MIN_PRIORITY); result.setDaemon(false); return result; } }); try { final Long result = executor.invokeAny(tasks); System.out.println("Seed for \"" + GOAL + "\" found: " + result); } catch (Exception ex) { System.err.println("Calculation failed: " + ex); } finally { executor.shutdownNow(); } } }
public static long generateSeed(String goal, long start, long finish) { char[] input = goal.toCharArray(); char[] pool = new char[input.length]; label: for (long seed = start; seed < finish; seed++) { Random random = new Random(seed); for (int i = 0; i < input.length; i++) pool[i] = (char) (random.nextInt(27)+ if (random.nextInt(27) == 0) { for (int i = 0; i < input.length; i++) { if (input[i] != pool[i]) continue label; } return seed; } } throw new NoSuchElementException("Sorry :/"); }
public static long[] generateSeed(String goal, long start, long finish) { char[] input = goal.toCharArray(); int[] dif = new int[input.length - 1]; for (int i = 1; i < input.length; i++) { dif[i - 1] = input[i] - input[i - 1]; } mainLoop: for (long seed = start; seed < finish; seed++) { Random random = new Random(seed); int lastChar = random.nextInt(27); int base = input[0] - lastChar; for (int d : dif) { int nextChar = random.nextInt(27); if (nextChar - lastChar != d) { continue mainLoop; } lastChar = nextChar; } if(random.nextInt(27) == 0){ return new long[]{seed, base}; } } throw new NoSuchElementException("Sorry :/"); }
for (Type type : types) { for (Type t : types2) { if (some condition) { break; } } }
public class Test { public static void main(String[] args) { outerloop: for (int i=0; i < 5; i++) { for (int j=0; j < 5; j++) { if (i * j > 6) { System.out.println("Breaking"); break outerloop; } System.out.println(i + " " + j); } } System.out.println("Done"); } }
0 0 0 1 0 2 0 3 0 4 1 0 1 1 1 2 1 3 1 4 2 0 2 1 2 2 2 3 Breaking Done
private static String search(...) { for (Type type : types) { for (Type t : types2) { if (some condition) { return search; } } } return null; }
public class Test { public static void main(String[] args) { loop(); System.out.println("Done"); } public static void loop() { for (int i = 0; i < 5; i++) { for (int j = 0; j < 5; j++) { if (i * j > 6) { System.out.println("Breaking"); return; } System.out.println(i + " " + j); } } } }
search: { for (Type type : types) { for (Type t : types2) { if (some condition) { break search; } } } }
boolean finished = false; for (int i = 0; i < 5 && !finished; i++) { for (int j = 0; j < 5; j++) { if (i * j > 6) { finished = true; break; } } }
label1: for (int i = 0;;) { for (int g = 0;;) { break label1; } }
public void doSomething(List<Type> types, List<Type> types2){ for(Type t1 : types){ for (Type t : types2) { if (some condition) { return; } } } }
boolean outerBreak = false; for (Type type : types) { if(outerBreak) break; for (Type t : types2) { if (some condition) { outerBreak = true; break; } } }
for (Type type : types) { for (Type t : types2) { if (some condition) { return; } } }
int a, b; bool abort = false; for (a = 0; a < 10 && !abort; a++) { for (b = 0; b < 10 && !abort; b++) { if (condition) { doSomeThing(); abort = true; } } }
int s = type.size(); for (int i = 0; i < s; i++) { for (int j = 0; j < t.size(); j++) { if (condition) { s = 0; break; } } }
boolean earlyExit = false; for(int i = 0 ; i < 10 && !earlyExit; i++) { for(int j = 0 ; i < 10 && !earlyExit; j++) { earlyExit = true; } }
List<Type> types1 = ... List<Type> types2 = ... types1.stream() .flatMap(type1 -> types2.stream().map(type2 -> new Type[]{type1, type2})) .filter(types -> /**some condition**/) .findFirst() .ifPresent(types -> /**do something**/);
public class BreakTesting { public static void main(String[] args) { for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { for (int k = 0; k < 9; k++) { if (condition1) { System.out.println("Breaking from Loop K and J"); k = 9; j = 9; } if (condition2) { System.out.println("Breaking from Loop K, J and I"); k = 9; j = 9; i = 9; } } } } System.out.println("End of I , J , K"); } }
public Object searching(Object[] types) { List<Object> typesReferences = new ArrayList<Object>(); List<Object> typesReferences2 = new ArrayList<Object>(); for (Object type : typesReferences) { Object o = getByCriterion(typesReferences2, type); if(o != null) return o; } return null; } private Object getByCriterion(List<Object> typesReferences2, Object criterion) { for (Object typeReference : typesReferences2) { if(typeReference.equals(criterion)) { return typeReference; } } return null; }
for (Type type : types) { for (Type t : types2) { if (some condition) { return value; } } }
outerloop: for(int i=0; i<10; i++){ break outerloop; innerloop: for(int i=0; i<10; i++){ break innerloop; } }
for(int i = 0; i++; i < j) { if(wanna exit) { i = i + j; } }
INNER:for(int j = 0; j < numbers.length; j++) { System.out.println("Even number: " + i + ", break from INNER label"); break INNER; }
try { for (Type type : types) { for (Type t : types2) { if (some condition throw new BreakLoopException(); } } } } catch (BreakLoopException e) { }
private static class BreakLoopException extends Exception { @Override public StackTraceElement[] getStackTrace() { return new StackTraceElement[0]; } }
boolean broken = false; for (Type type : types) { for (Type t : types2) { if (some condition) { broken = true; break; } } if (broken) { break; } }
boolean exitloops = false; for (int i = 0; i < 5 && !exitloops; i++) { for (int j = 0; j < 5 && !exitloops; j++) { if (i * j > 6) { exitloops = true; System.out.println("Inner loop still Continues For i * j is => "+i*j); break; } System.out.println(i*j); } }
boolean hasAccess = false; for (int i = 0; i < x && hasAccess == false; i++){ for (int j = 0; j < y; j++){ if (condition == true){ hasAccess = true; break; } } }
while(keep_going) { if(keep_going && condition_one_holds) { } if(keep_going && condition_two_holds) { } if(keep_going && condition_three_holds) { } if(keep_going && something_goes_really_bad) { keep_going=false; } if(keep_going && condition_four_holds) { } if(keep_going && condition_five_holds) { } }
something_bad_has_happened = false; while(something is true && !something_bad_has_happened){ while(something else && !something_bad_has_happened){ if(something happened){ -> Then control should be returned -> something_bad_has_happened=true; continue; } } if(something_bad_has_happened) { continue; } }
import org.junit.Test; /** * Created by cui on 17-5-4. */ public class BranchLabel { @Test public void test() { System.out.println("testBreak"); testBreak(); System.out.println("testBreakLabel"); testBreakLabel(); System.out.println("testContinue"); testContinue(); System.out.println("testContinueLabel"); testContinueLabel(); } /** testBreak a=0,b=0 a=0,b=1 a=1,b=0 a=1,b=1 a=2,b=0 a=2,b=1 a=3,b=0 a=3,b=1 a=4,b=0 a=4,b=1 */ public void testBreak() { for (int a = 0; a < 5; a++) { for (int b = 0; b < 5; b++) { if (b == 2) { break; } System.out.println("a=" + a + ",b=" + b); } } } /** testContinue a=0,b=0 a=0,b=1 a=0,b=3 a=0,b=4 a=1,b=0 a=1,b=1 a=1,b=3 a=1,b=4 a=2,b=0 a=2,b=1 a=2,b=3 a=2,b=4 a=3,b=0 a=3,b=1 a=3,b=3 a=3,b=4 a=4,b=0 a=4,b=1 a=4,b=3 a=4,b=4 */ public void testContinue() { for (int a = 0; a < 5; a++) { for (int b = 0; b < 5; b++) { if (b == 2) { continue; } System.out.println("a=" + a + ",b=" + b); } } } /** testBreakLabel a=0,b=0,c=0 a=0,b=0,c=1 * */ public void testBreakLabel() { anyName: for (int a = 0; a < 5; a++) { for (int b = 0; b < 5; b++) { for (int c = 0; c < 5; c++) { if (c == 2) { break anyName; } System.out.println("a=" + a + ",b=" + b + ",c=" + c); } } } } /** testContinueLabel a=0,b=0,c=0 a=0,b=0,c=1 a=1,b=0,c=0 a=1,b=0,c=1 a=2,b=0,c=0 a=2,b=0,c=1 a=3,b=0,c=0 a=3,b=0,c=1 a=4,b=0,c=0 a=4,b=0,c=1 */ public void testContinueLabel() { anyName: for (int a = 0; a < 5; a++) { for (int b = 0; b < 5; b++) { for (int c = 0; c < 5; c++) { if (c == 2) { continue anyName; } System.out.println("a=" + a + ",b=" + b + ",c=" + c); } } } } }
boolean isBreakNeeded = false; for (int i = 0; i < some.length; i++) { for (int j = 0; j < some.lengthasWell; j++) { isBreakNeeded = true; break; } if (isBreakNeeded) { break; } }
Random rand = new Random(); for (int k = 0; k < 10; ++k) { int count = 0; while (!(rand.nextInt(200) == 100)) { count++; } results[k] = count; }
for (Type type : types) { boolean flag=false; for (Type t : types2) { if (some condition) { flag=true; break; } } if(flag) break; }
public static void main(String ...args) { outerLoop: for(int i=0;i<10;i++) { for(int j=10;j>0;j--) { System.out.println(i+" "+j); if(i==j) { System.out.println("Condition Fulfilled"); break outerLoop; } } } System.out.println("Got out of the outer loop"); }
boolean condition = false; for (Type type : types) { for (int i = 0; i < otherTypes.size && !condition; i ++) { condition = true; } }
public class Test { public static void main(String[] args) { outerloop: for (int i=0; i < 5; i++) { for (int j=0; j < 5; j++) { if (i * j > 6) { System.out.println("Breaking"); break outerloop; } System.out.println(i + " " + j); } } System.out.println("Done"); } }
int i, j; for(i = 0; i < 7; i++){ for(j = 0; j < 5; j++) { if (some condition) { break; } } if(j < 5){ break; } }
<%= x+1 %> <%= request.getParameter("name") %> <%! counter++; %>
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { if (((HttpServletRequest) request).getSession().getAttribute("user") == null) { ((HttpServletResponse) response).sendRedirect("login"); } else { chain.doFilter(request, response); } }
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { List<Product> products = productService.list(); request.setAttribute("products", products); request.getRequestDispatcher("/WEB-INF/products.jsp").forward(request, response); } catch (SQLException e) { throw new ServletException("Retrieving products failed!", e); } }
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter("username"); String password = request.getParameter("password"); User user = userService.find(username, password); if (user != null) { request.getSession().setAttribute("user", user); response.sendRedirect("home"); } else { request.setAttribute("message", "Unknown username/password. Please retry."); request.getRequestDispatcher("/WEB-INF/login.jsp").forward(request, response); } }
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { Action action = ActionFactory.getAction(request); String view = action.execute(request, response); if (view.equals(request.getPathInfo().substring(1)) { request.getRequestDispatcher("/WEB-INF/" + view + ".jsp").forward(request, response); } else { response.sendRedirect(view); } } catch (Exception e) { throw new ServletException("Executing action failed.", e); } }
<%@ page contentType="text/html;charset=UTF-8" language="java" %> <% MyController clr = new MyController(request, response); clr.process(request); String showMe = clr.getShowMe();%> <html> <head> </head> <body> <form name="frm1"> <p><%= showMe %> <p><% for(String str : clr.listOfStrings()) { %> <p><%= str %><% } %> </form> </body> </html>
<taglib> <taglib-uri>/java2s</taglib-uri> <taglib-location>/WEB-INF/java2s.tld</taglib-location> </taglib>
<!DOCTYPE taglib PUBLIC "- "http: <!-- a tab library descriptor --> <taglib xmlns="http: <tlib-version>1.0</tlib-version> <jsp-version>1.2</jsp-version> <short-name>Java2s Simple Tags</short-name> <!-- this tag manipulates its body content by converting it to upper case --> <tag> <name>bodyContentTag</name> <tag-class>com.java2s.BodyContentTag</tag-class> <body-content>JSP</body-content> <attribute> <name>howMany</name> </attribute> </tag> </taglib>
package com.java2s; import java.io.IOException; import javax.servlet.jsp.JspWriter; import javax.servlet.jsp.tagext.BodyContent; import javax.servlet.jsp.tagext.BodyTagSupport; public class BodyContentTag extends BodyTagSupport{ private int iterations, howMany; public void setHowMany(int i){ this.howMany = i; } public void setBodyContent(BodyContent bc){ super.setBodyContent(bc); System.out.println("BodyContent = } public int doAfterBody(){ try{ BodyContent bodyContent = super.getBodyContent(); String bodyString = bodyContent.getString(); JspWriter out = bodyContent.getEnclosingWriter(); if ( iterations % 2 == 0 ) out.print(bodyString.toLowerCase()); else out.print(bodyString.toUpperCase()); iterations++; bodyContent.clear(); } catch (IOException e) { System.out.println("Error in BodyContentTag.doAfterBody()" + e.getMessage()); e.printStackTrace(); } int retValue = SKIP_BODY; if ( iterations < howMany ) retValue = EVAL_BODY_AGAIN; return retValue; } }
<%@ taglib uri="/java2s" prefix="java2s" %> <html> <head> <title>A custom tag: body content</title> </head> <body> This page uses a custom tag manipulates its body content.Here is its output: <ol> <java2s:bodyContentTag howMany="3"> <li>java2s.com</li> </java2s:bodyContentTag> </ol> </body> </html>
<%@tag description="Overall Page template" pageEncoding="UTF-8"%> <%@attribute name="title" fragment="true" %> <html> <head> <title> <jsp:invoke fragment="title"></jsp:invoke> </title> </head> <body> <div id="page-header"> .... </div> <div id="page-body"> <jsp:doBody/> </div> <div id="page-footer"> ..... </div> </body> </html>
<%@ taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:base> <jsp:attribute name="title"> <bean:message key="hello.world" /> </jsp:attribute> <jsp:body> [Put your content of the child here] </jsp:body> </t:base>
/WEB-INF/tags/html/label.tag <%@tag description="Rensders a label with required css class" pageEncoding="UTF-8"%> <%@attribute name="name" required="true" description="The label"%> <label class="control-label control-default" id="${name}Label">${name}</label>
<%@ taglib prefix="h" tagdir="/WEB-INF/tags/html"%> <h:label name="customer name" />
/WEB-INF/tags/html/bold.tag <%@tag description="Bold tag" pageEncoding="UTF-8"%> <b> <jsp:doBody/> </b>
<%@ taglib prefix="h" tagdir="/WEB-INF/tags/bold"%> <h:bold>Make me bold</h:bold>
<%@ page contentType="text/html;charset=UTF-8" language="java" %> <%@ taglib uri="http: <%@ taglib uri="http:
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
class A { int t() { return 1; } static A a = new A() { int t() { return 2; } }; }
package pizza; public class Rhino { ... public static class Goat { ... } }
package pizza; public class Rhino { public class Goat { ... } private void jerry() { Goat g = new Goat(); } }
Rhino rhino = new Rhino(); Rhino.Goat goat = rhino.new Goat();
public class Rhino { private String barry; public class Goat { public void colin() { System.out.println(barry); } } }
new *ParentClassName*(*constructorArgs*) {*members*}
public class Container { public class Item{ Object data; public Container getContainer(){ return Container.this; } public Item(Object data) { super(); this.data = data; } } public static Item create(Object data){ return new Item(data); } public Item createSubItem(Object data){ return new Item(data); } }
public class Container$Item { public INNERCLASS Container$Item Container Item Object data final Container this$0 public getContainer() : Container L0 LINENUMBER 7 L0 ALOAD 0: this GETFIELD Container$Item.this$0 : Container ARETURN L1 LOCALVARIABLE this Container$Item L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 public <init>(Container,Object) : void L0 LINENUMBER 12 L0 ALOAD 0: this ALOAD 1 PUTFIELD Container$Item.this$0 : Container L1 LINENUMBER 10 L1 ALOAD 0: this INVOKESPECIAL Object.<init>() : void L2 LINENUMBER 11 L2 ALOAD 0: this ALOAD 2: data PUTFIELD Container$Item.data : Object RETURN L3 LOCALVARIABLE this Container$Item L0 L3 0 LOCALVARIABLE data Object L0 L3 2 MAXSTACK = 2 MAXLOCALS = 3 }
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
public class OuterClass { public static class Inner1 { } public class Inner2 { } }
OuterClass outer = new OuterClass(); OuterClass.Inner2 inner = outer.new Inner2();
OuterClass.Inner2 inner = new OuterClass().new Inner2();
OuterClass.Inner1 nestedObject = new OuterClass.Inner1();
Outerclass.InnerClass innerObject = outerObject.new Innerclass();
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
outerclass outerobject=new outerobject(); outerclass.innerclass innerobjcet=outerobject.new innerclass();
class outerclass A { static class nestedclass B { static int x = 10; } }
outerclass.nestedclass.x; i.e. System.out.prinltn( outerclass.nestedclass.x);
public class C0 { static C0 instance = null; public C0() { instance = this; } public String makeString(int i) { return ((new Integer(i)).toString()); } public String makeString(double d) { return ((new Double(d)).toString()); } public static final class nested { public static final String innerItem = instance.makeString(42); } static public void main(String[] argv) { System.out.println("start"); new C0(); try { System.out.println("retrieve item: " + nested.innerItem); } catch (Exception e) { System.out.println("failed to retrieve item: " + e.toString()); } System.out.println("finish"); } }
class A { class B { } static class C { static int x; } } class Test { public static void main(String str) { A o=new A(); A.B obj1 =o.new B(); A.C obj2 =new A.C(); } }
public class Outer { public class Inner { } public Inner inner(){ return new Inner(); } @Override protected void finalize() throws Throwable { System.out.println("I am destroyed !"); } } public static void main(String arg[]) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); outer = null; // System.gc(); }
public class Outer { public class Inner {} public static class Nested {} }
class EnclosingClass { static class Nested { void someMethod() { System.out.println("hello SO"); } } }
class NonEnclosingClass { public static void main(String[] args) { EnclosingClass.Nested n = new EnclosingClass.Nested(); n.someMethod(); } }
class EnclosingClass { static class Nested { void anotherMethod() { System.out.println("hi again"); } } public static void main(String[] args) { Nested n = new Nested(); n.anotherMethod(); } }
public class InnerClassTest { public static void main(String args[]) { class Local { public void name() { System.out.println("Example of Local class in Java"); } } Local local = new Local(); local.name(); Thread anonymous = new Thread(){ @Override public void run(){ System.out.println("Anonymous class example in java"); } }; anonymous.start(); InnerClassTest test = new InnerClassTest(); InnerClassTest.Inner inner = test.new Inner(); inner.name(); } private class Inner{ public void name(){ System.out.println("Inner class example in java"); } } }
public class NestedStaticExample { public static void main(String args[]){ StaticNested nested = new StaticNested(); nested.name(); } private static class StaticNested{ public void name(){ System.out.println("static nested class example in java"); } } }
public static class A {} public class A { public class B { public static class C {} } } public class A { public static class B {} }
class Test{ private static int x = 1; static class A{ private static int y = 2; public static int getZ(){ return B.z+x; } } static class B{ private static int z = 3; public static int getY(){ return A.y; } } } class TestDemo{ public static void main(String[] args){ Test t = new Test(); System.out.println(Test.A.getZ()); System.out.println(Test.B.getY()); } }
class Test{ private int i = 10; class A{ private int i =20; void display(){ int i = 30; System.out.println(i); System.out.println(this.i); System.out.println(Test.this.i); } } }
public class OuterClass { private String someVariable = "Non Static"; private static String anotherStaticVariable = "Static"; OuterClass(){ } static class StaticNestedClass{ private static String privateStaticNestedClassVariable = "Private Static Nested Class Variable"; public static void getPrivateVariableofOuterClass(){ System.out.println(anotherStaticVariable); } } class InnerClass{ public String getPrivateNonStaticVariableOfOuterClass(){ return someVariable; } } public static void accessStaticClass(){ String var = OuterClass.StaticNestedClass.privateStaticNestedClassVariable; System.out.println(var); } }
public class OuterClassTest { public static void main(String[] args) { OuterClass.StaticNestedClass.getPrivateVariableofOuterClass(); OuterClass.accessStaticClass(); /* * Inner Class Test * */ OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClassExample = outerClass. new InnerClass(); System.out.println(innerClassExample.getPrivateNonStaticVariableOfOuterClass()); } }
OuterClass.InnerClass inner = new OuterClass().new InnerClass();
OuterClass.InnerClass inner = new OuterClass.InnerClass();
class Outter1 { String OutStr; Outter1(String str) { OutStr = str; } public void NonStaticMethod(String st) { String temp1 = "ashish"; final String tempFinal1 = "ashish"; class localInnerNonStatic1 { synchronized public void innerMethod(String str11) { str11 = temp1 +" sharma"; System.out.println("innerMethod ===> "+str11); } /* public static void innerStaticMethod(String str11) { str11 = temp1 +" india"; System.out.println("innerMethod ===> "+str11); }*/ } } public static void StaticMethod(String st) { String temp1 = "ashish"; final String tempFinal1 = "ashish"; class localInnerNonStatic1 { public void innerMethod(String str11) { str11 = temp1 +" sharma"; System.out.println("innerMethod ===> "+str11); } /* public static void innerStaticMethod(String str11) { str11 = temp1 +" india"; System.out.println("innerMethod ===> "+str11); }*/ } } static class inner1 { static String temp1 = "ashish"; String tempNonStatic = "ashish"; public void innerMethod(String str11) { str11 = temp1 +" sharma"; str11 = str11+ tempNonStatic +" sharma"; System.out.println("innerMethod ===> "+str11); } public static void innerStaticMethod(String str11) { str11 = temp1 +" india"; System.out.println("innerMethod ===> "+str11); } } class innerNonStatic1 { static final String temp1 = "ashish"; String tempNonStatic = "ashish"; synchronized public void innerMethod(String str11) { tempNonStatic = tempNonStatic +" ..."; str11 = temp1 +" sharma"; str11 = str11+ tempNonStatic +" sharma"; System.out.println("innerMethod ===> "+str11); } /* public static void innerStaticMethod(String str11) { str11 = temp1 +" india"; System.out.println("innerMethod ===> "+str11); }*/ } }
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
OuterClass.InnerClass innerObject = new OuterClass().new InnerClass();
import java.security.SecureRandom; import java.util.Locale; import java.util.Objects; import java.util.Random; public class RandomString { /** * Generate a random string. */ public String nextString() { for (int idx = 0; idx < buf.length; ++idx) buf[idx] = symbols[random.nextInt(symbols.length)]; return new String(buf); } public static final String upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; public static final String lower = upper.toLowerCase(Locale.ROOT); public static final String digits = "0123456789"; public static final String alphanum = upper + lower + digits; private final Random random; private final char[] symbols; private final char[] buf; public RandomString(int length, Random random, String symbols) { if (length < 1) throw new IllegalArgumentException(); if (symbols.length() < 2) throw new IllegalArgumentException(); this.random = Objects.requireNonNull(random); this.symbols = symbols.toCharArray(); this.buf = new char[length]; } /** * Create an alphanumeric string generator. */ public RandomString(int length, Random random) { this(length, random, alphanum); } /** * Create an alphanumeric strings from a secure generator. */ public RandomString(int length) { this(length, new SecureRandom()); } /** * Create session identifiers. */ public RandomString() { this(21); } }
RandomString gen = new RandomString(8, ThreadLocalRandom.current());
String easy = RandomString.digits + "ACEFGHJKLMNPQRUVWXYabcdefhijkprstuvwx"; RandomString tickets = new RandomString(23, new SecureRandom(), easy);
import java.util.UUID; public class randomStringGenerator { public static void main(String[] args) { System.out.println(generateString()); } public static String generateString() { String uuid = UUID.randomUUID().toString(); return "uuid = " + uuid; } }
static final String AB = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; static SecureRandom rnd = new SecureRandom(); String randomString( int len ){ StringBuilder sb = new StringBuilder( len ); for( int i = 0; i < len; i++ ) sb.append( AB.charAt( rnd.nextInt(AB.length()) ) ); return sb.toString(); }
RandomStringGenerator randomStringGenerator = new RandomStringGenerator.Builder() .withinRange( .filteredBy(CharacterPredicates.LETTERS, CharacterPredicates.DIGITS) .build(); randomStringGenerator.generate(12);
Long.toHexString(Double.doubleToLongBits(Math.random()));
RandomStringUtils.randomAlphanumeric(20).toUpperCase();
SecureRandom rnd = new SecureRandom(); byte[] token = new byte[byteLength]; rnd.nextBytes(token);
public static String generateRandomHexToken(int byteLength) { SecureRandom secureRandom = new SecureRandom(); byte[] token = new byte[byteLength]; secureRandom.nextBytes(token); return new BigInteger(1, token).toString(16); }
String validCharacters = $( String randomString(int length) { return $(validCharacters).shuffle().slice(length).toString(); } @Test public void buildFiveRandomStrings() { for (int i : $(5)) { System.out.println(randomString(12)); } }
DKL1SBH9UJWC JH7P0IT21EA5 5DTI72EO6SFU HQUMJTEBNF7Y 1HCR6SKYWGT7
import java.util.UUID UUID.randomUUID().toString();
import static java.lang.Math.round; import static java.lang.Math.random; import static java.lang.Math.pow; import static java.lang.Math.abs; import static java.lang.Math.min; import static org.apache.commons.lang.StringUtils.leftPad public class RandomAlphaNum { public static String gen(int length) { StringBuffer sb = new StringBuffer(); for (int i = length; i > 0; i -= 12) { int n = min(12, abs(i)); sb.append(leftPad(Long.toString(round(random() * pow(36, n)), 36), n, } return sb.toString(); } }
scala> RandomAlphaNum.gen(42) res3: java.lang.String = uja6snx21bswf9t89s00bxssu8g6qlu16ffzqaxxoy
Random r = new java.util.Random (); String s = Long.toString (r.nextLong () & Long.MAX_VALUE, 36);
static final Random random = new Random(); static final int startChar = (int) static final int endChar = (int) static String randomString(final int maxLength) { final int length = random.nextInt(maxLength + 1); return random.ints(length, startChar, endChar + 1) .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append) .toString(); }
public static String generateSessionKey(int length){ String alphabet = new String("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"); int n = alphabet.length(); String result = new String(); Random r = new Random(); for (int i=0; i<length; i++) result = result + alphabet.charAt(r.nextInt(n)); return result; }
import java.util.Random; public class passGen{ private static final String dCase = "abcdefghijklmnopqrstuvwxyz"; private static final String uCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; private static final String sChar = "!@ private static final String intChar = "0123456789"; private static Random r = new Random(); private static String pass = ""; public static void main (String[] args) { System.out.println ("Generating pass..."); while (pass.length () != 16){ int rPick = r.nextInt(4); if (rPick == 0){ int spot = r.nextInt(25); pass += dCase.charAt(spot); } else if (rPick == 1) { int spot = r.nextInt (25); pass += uCase.charAt(spot); } else if (rPick == 2) { int spot = r.nextInt (7); pass += sChar.charAt(spot); } else if (rPick == 3){ int spot = r.nextInt (9); pass += intChar.charAt (spot); } } System.out.println ("Generated Pass: " + pass); } }
/* * The random generator used by this class to create random keys. * In a holder class to defer initialization until needed. */ private static class RandomHolder { static final Random random = new SecureRandom(); public static String randomKey(int length) { return String.format("%"+length+"s", new BigInteger(length*5 , random) .toString(32)).replace( } }
/** * Generate a random hex encoded string token of the specified length * * @param length * @return random hex string */ public static synchronized String generateUniqueToken(Integer length){ byte random[] = new byte[length]; Random randomGenerator = new Random(); StringBuffer buffer = new StringBuffer(); randomGenerator.nextBytes(random); for (int j = 0; j < random.length; j++) { byte b1 = (byte) ((random[j] & 0xf0) >> 4); byte b2 = (byte) (random[j] & 0x0f); if (b1 < 10) buffer.append((char) ( else buffer.append((char) ( if (b2 < 10) buffer.append((char) ( else buffer.append((char) ( } return (buffer.toString()); } @Test public void testGenerateUniqueToken(){ Set set = new HashSet(); String token = null; int size = 16; /* Seems like we should be able to generate 500K tokens * without a duplicate */ for (int i=0; i<500000; i++){ token = Utility.generateUniqueToken(size); if (token.length() != size * 2){ fail("Incorrect length"); } else if (set.contains(token)) { fail("Duplicate token generated"); } else{ set.add(token); } } }
import java.util.Date; import java.util.Random; public class RandomGenerator { private static Random random = new Random((new Date()).getTime()); public static String generateRandomString(int length) { char[] values = { String out = ""; for (int i=0;i<length;i++) { int idx=random.nextInt(values.length); out += values[idx]; } return out; } }
import java.util.*; import javax.swing.*; public class alphanumeric{ public static void main(String args[]){ String nval,lenval; int n,len; nval=JOptionPane.showInputDialog("Enter number of codes you require : "); n=Integer.parseInt(nval); lenval=JOptionPane.showInputDialog("Enter code length you require : "); len=Integer.parseInt(lenval); find(n,len); } public static void find(int n,int length) { String str1="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; StringBuilder sb=new StringBuilder(length); Random r = new Random(); System.out.println("\n\t Unique codes are \n\n"); for(int i=0;i<n;i++){ for(int j=0;j<length;j++){ sb.append(str1.charAt(r.nextInt(str1.length()))); } System.out.println(" "+sb.toString()); sb.delete(0,length); } } }
public static String getRandomString(int length) { final String characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJLMNOPQRSTUVWXYZ1234567890!@ StringBuilder result = new StringBuilder(); while(length > 0) { Random rand = new Random(); result.append(characters.charAt(rand.nextInt(characters.length()))); length--; } return result.toString(); }
public String randomString(int length, String characterSet) { return IntStream.range(0, length).map(i -> new SecureRandom().nextInt(characterSet.length())).mapToObj(randomInt -> characterSet.substring(randomInt, randomInt + 1)).collect(Collectors.joining()); } @Test public void buildFiveRandomStrings() { for (int q = 0; q < 5; q++) { System.out.println(randomString(10, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")); } }
public String randomString(int length, String characterSet) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < length; i++) { int randomInt = new SecureRandom().nextInt(characterSet.length()); sb.append(characterSet.substring(randomInt, randomInt + 1)); } return sb.toString(); } @Test public void buildFiveRandomStrings() { for (int q = 0; q < 5; q++) { System.out.println(randomString(10, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")); } }
(for (i <- 0 until rnd.nextInt(64)) yield { ( }) mkString("")
Long.toString(Math.abs( UUID.randomUUID().getLeastSignificantBits(), 36));
private static final String NUMBERS = "0123456789"; private static final String UPPER_ALPHABETS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; private static final String LOWER_ALPHABETS = "abcdefghijklmnopqrstuvwxyz"; private static final String SPECIALCHARACTERS = "@ private static final int MINLENGTHOFPASSWORD = 8; public static String getRandomPassword() { StringBuilder password = new StringBuilder(); int j = 0; for (int i = 0; i < MINLENGTHOFPASSWORD; i++) { password.append(getRandomPasswordCharacters(j)); j++; if (j == 3) { j = 0; } } return password.toString(); } private static String getRandomPasswordCharacters(int pos) { Random randomNum = new Random(); StringBuilder randomChar = new StringBuilder(); switch (pos) { case 0: randomChar.append(NUMBERS.charAt(randomNum.nextInt(NUMBERS.length() - 1))); break; case 1: randomChar.append(UPPER_ALPHABETS.charAt(randomNum.nextInt(UPPER_ALPHABETS.length() - 1))); break; case 2: randomChar.append(SPECIALCHARACTERS.charAt(randomNum.nextInt(SPECIALCHARACTERS.length() - 1))); break; case 3: randomChar.append(LOWER_ALPHABETS.charAt(randomNum.nextInt(LOWER_ALPHABETS.length() - 1))); break; } return randomChar.toString(); }
import org.apache.commons.lang.RandomStringUtils; RandomStringUtils.randomAlphanumeric(64);
public static String randomSeriesForThreeCharacter() { Random r = new Random(); String value=""; char random_Char ; for(int i=0; i<10;i++) { random_Char = (char) (48 + r.nextInt(74)); value=value+random_char; } return value; }
public String generateRandomString(int length) { String randomString = ""; final char[] chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890".toCharArray(); final SecureRandom random = new SecureRandom(); for (int i = 0; i < length; i++) { randomString = randomString + chars[random.nextInt(chars.length)]; } return randomString; }
public static String getRandomString(int length) { String randomStr = UUID.randomUUID().toString(); while(randomStr.length() < length) { randomStr += UUID.randomUUID().toString(); } return randomStr.substring(0, length); }
package password.generater; import java.util.Random; /** * * @author dell */ public class PasswordGenerater { /** * @param args the command line arguments */ public static void main(String[] args) { int length= 11; System.out.println(generatePswd(length)); } static char[] generatePswd(int len){ System.out.println("Your Password "); String charsCaps="ABCDEFGHIJKLMNOPQRSTUVWXYZ"; String Chars="abcdefghijklmnopqrstuvwxyz"; String nums="0123456789"; String symbols="!@ String passSymbols=charsCaps + Chars + nums +symbols; Random rnd=new Random(); char[] password=new char[len]; for(int i=0; i<len;i++){ password[i]=passSymbols.charAt(rnd.nextInt(passSymbols.length())); } return password; } }
public useEnums(SomeEnum a) { if(a.equals(SomeEnum.SOME_ENUM_VALUE)) { ... } ... }
public useEnums2(SomeEnum a) { if(a == SomeEnum.SOME_ENUM_VALUE) { ... } ... }
enum Color { BLACK, WHITE }; Color nothing = null; if (nothing == Color.BLACK); if (nothing.equals(Color.BLACK));
enum Color { BLACK, WHITE }; enum Chiral { LEFT, RIGHT }; if (Color.BLACK.equals(Chiral.LEFT)); if (Color.BLACK == Chiral.LEFT);
public useEnums(SomeEnum a) { if(SomeEnum.SOME_ENUM_VALUE.equals(a)) { ... } ... }
import java.util.Date; public class EnumCompareSpeedTest { static enum TestEnum {ONE, TWO, THREE } public static void main(String [] args) { Date before = new Date(); int c = 0; for(int y=0;y<5;++y) { for(int x=0;x<Integer.MAX_VALUE;++x) { if(TestEnum.ONE.equals(TestEnum.TWO)) {++c;} if(TestEnum.ONE == TestEnum.TWO){++c;} } } System.out.println(new Date().getTime() - before.getTime()); } }
21 getstatic EnumCompareSpeedTest$TestEnum.ONE : EnumCompareSpeedTest.TestEnum [19] 24 getstatic EnumCompareSpeedTest$TestEnum.TWO : EnumCompareSpeedTest.TestEnum [25] 27 invokevirtual EnumCompareSpeedTest$TestEnum.equals(java.lang.Object) : boolean [28] 30 ifeq 36 36 getstatic EnumCompareSpeedTest$TestEnum.ONE : EnumCompareSpeedTest.TestEnum [19] 39 getstatic EnumCompareSpeedTest$TestEnum.TWO : EnumCompareSpeedTest.TestEnum [25] 42 if_acmpne 48
package first.pckg public enum Category { JAZZ, ROCK, POP, POP_ROCK }
package second.pckg public enum Category { JAZZ, ROCK, POP, POP_ROCK }
import second.pckg.Category; ... Category.JAZZ.equals(item.getCategory())
import second.pckg.Category; ... Category.JAZZ == item.getCategory()
boolean areEqual = Objects.equals( Month.FEBRUARY , Month.JUNE ) ;
public boolean isEquals(enumVariable) public static boolean areEqual(enumVariable, enumVariable2)
private static Integer getInteger() { return null; } private static void foo() { int a = 10; if(a == getInteger()) { } }
@Entity public class Employee implements Serializable{ @Id private int id; private String name; private int salary; public Employee() {} public Employee(String name, int salary) { this.name = name; this.salary = salary; } public int getId() { return id; } public void setId( int id ) { this.id = id; } public String getName() { return name; } public void setName( String name ) { this.name = name; } public int getSalary() { return salary; } public void setSalary( int salary ) { this.salary = salary; } }
/** 1. import java.io.Serializable */ public class User implements java.io.Serializable { /** 2. private fields */ private int id; private String name; /** 3. Constructor */ public User() { } public User(int id, String name) { this.id = id; this.name = name; } /** 4. getter/setter */ public int getId() { return id; } public String getName() { return name; } public void setId(int id) { this.id = is; } public void setName(String name) { this.name = name; } }
public class DataDog implements java.io.Serializable { private static final long serialVersionUID = -3774654564564563L; private int id; private String nameOfDog; public DataDog () {} /** 4. getter/setter */ public int getId() { return id; } public String getNameOfDog() { return nameOfDog; } public void setId(int id) { this.id = id; } public void setNameOfDog(String nameOfDog) { this.nameOfDog = nameOfDog; }}
public class MapUtil { public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map) { List<Entry<K, V>> list = new ArrayList<>(map.entrySet()); list.sort(Entry.comparingByValue()); Map<K, V> result = new LinkedHashMap<>(); for (Entry<K, V> entry : list) { result.put(entry.getKey(), entry.getValue()); } return result; } }
public class Testing { public static void main(String[] args) { HashMap<String, Double> map = new HashMap<String, Double>(); ValueComparator bvc = new ValueComparator(map); TreeMap<String, Double> sorted_map = new TreeMap<String, Double>(bvc); map.put("A", 99.5); map.put("B", 67.4); map.put("C", 67.4); map.put("D", 67.3); System.out.println("unsorted map: " + map); sorted_map.putAll(map); System.out.println("results: " + sorted_map); } } class ValueComparator implements Comparator<String> { Map<String, Double> base; public ValueComparator(Map<String, Double> base) { this.base = base; } public int compare(String a, String b) { if (base.get(a) >= base.get(b)) { return -1; } else { return 1; } } }
unsorted map: {D=67.3, A=99.5, B=67.4, C=67.4} results: {D=67.3, B=67.4, C=67.4, A=99.5}
Stream<Map.Entry<K,V>> sorted = map.entrySet().stream() .sorted(Map.Entry.comparingByValue());
Stream<Map.Entry<K,V>> sorted = map.entrySet().stream() .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()));
Stream<Map.Entry<K,V>> sorted = map.entrySet().stream() .sorted(Map.Entry.comparingByValue(comparator));
Map<K,V> topTen = map.entrySet().stream() .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())) .limit(10) .collect(Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
map.entrySet().stream() .sorted(Map.Entry.comparingByValue()) .forEach(System.out::println);
valueComparator = Ordering.natural().onResultOf(Functions.forMap(map))
valueComparator = Ordering.from(comparator).onResultOf(Functions.forMap(map))
valueComparator = Ordering.natural().onResultOf(Functions.forMap(map)).compound(Ordering.natural())
map = ImmutableSortedMap.copyOf(myOriginalMap, valueComparator);
import static org.junit.Assert.assertEquals; import java.util.HashMap; import java.util.Map; import java.util.TreeMap; import com.google.common.base.Functions; import com.google.common.collect.Ordering; class ValueComparableMap<K extends Comparable<K>,V> extends TreeMap<K,V> { private final Map<K, V> valueMap; ValueComparableMap(final Ordering<? super V> partialValueOrdering) { this(partialValueOrdering, new HashMap<K,V>()); } private ValueComparableMap(Ordering<? super V> partialValueOrdering, HashMap<K, V> valueMap) { super(partialValueOrdering .onResultOf(Functions.forMap(valueMap)) .compound(Ordering.natural())); this.valueMap = valueMap; } public V put(K k, V v) { if (valueMap.containsKey(k)){ remove(k); } valueMap.put(k,v); return super.put(k, v); } public static void main(String[] args){ TreeMap<String, Integer> map = new ValueComparableMap<String, Integer>(Ordering.natural()); map.put("a", 5); map.put("b", 1); map.put("c", 3); assertEquals("b",map.firstKey()); assertEquals("a",map.lastKey()); map.put("d",0); assertEquals("d",map.firstKey()); map.put("d", 2); assertEquals("b", map.firstKey()); map.put("e", 2); assertEquals(5, map.size()); assertEquals(2, (int) map.get("e")); assertEquals(2, (int) map.get("d")); } }
new ValueComparableMap(Ordering.natural()); new ValueComparableMap(Ordering.from(comparator));
private static <K, V> Map<K, V> sortByValue(Map<K, V> map) { List<Entry<K, V>> list = new LinkedList<>(map.entrySet()); Collections.sort(list, new Comparator<Object>() { @SuppressWarnings("unchecked") public int compare(Object o1, Object o2) { return ((Comparable<V>) ((Map.Entry<K, V>) (o1)).getValue()).compareTo(((Map.Entry<K, V>) (o2)).getValue()); } }); Map<K, V> result = new LinkedHashMap<>(); for (Iterator<Entry<K, V>> it = list.iterator(); it.hasNext();) { Map.Entry<K, V> entry = (Map.Entry<K, V>) it.next(); result.put(entry.getKey(), entry.getValue()); } return result; }
Map<K, V> sortedMap = map.entrySet().stream() .sorted(Entry.comparingByValue()) .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
public static <K, V extends Comparable<? super V>> List<K> getKeysSortedByValue(Map<K, V> map) { final int size = map.size(); final List<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>(size); list.addAll(map.entrySet()); final ValueComparator<V> cmp = new ValueComparator<V>(); Collections.sort(list, cmp); final List<K> keys = new ArrayList<K>(size); for (int i = 0; i < size; i++) { keys.set(i, list.get(i).getKey()); } return keys; } private static final class ValueComparator<V extends Comparable<? super V>> implements Comparator<Map.Entry<?, V>> { public int compare(Map.Entry<?, V> o1, Map.Entry<?, V> o2) { return o1.getValue().compareTo(o2.getValue()); } }
public static <K, V extends Comparable<? super V>> List<K> getKeysSortedByValue2(Map<K, V> map) { final int size = map.size(); final List reusedList = new ArrayList(size); final List<Map.Entry<K, V>> meView = reusedList; meView.addAll(map.entrySet()); Collections.sort(meView, SINGLE); final List<K> keyView = reusedList; for (int i = 0; i < size; i++) { keyView.set(i, meView.get(i).getKey()); } return keyView; } private static final Comparator SINGLE = new ValueComparator();
public static <K, V extends Comparable<V>> Map<K, V> sortByValues(final Map<K, V> map) { Comparator<K> valueComparator = new Comparator<K>() { public int compare(K k1, K k2) { int compare = map.get(k2).compareTo(map.get(k1)); if (compare == 0) return 1; else return compare; } }; Map<K, V> sortedByValues = new TreeMap<K, V>(valueComparator); sortedByValues.putAll(map); return sortedByValues; }
import static java.util.Map.Entry.comparingByValue; import static java.util.stream.Collectors.toList; <K, V> List<Entry<K, V>> sort(Map<K, V> map, Comparator<? super V> comparator) { return map.entrySet().stream().sorted(comparingByValue(comparator)).collect(toList()); }
<K, V extends Comparable<? super V>> List<Entry<K, V>> sort(Map<K, V> map) { return map.entrySet().stream().sorted(comparingByValue()).collect(toList()); }
<K, V extends Comparable<? super V>> Iterable<Entry<K, V>> sort(Map<K, V> map) { return () -> map.entrySet().stream().sorted(comparingByValue()).iterator(); }
public class MapUtilities { public static <K, V extends Comparable<V>> List<Entry<K, V>> sortByValue(Map<K, V> map) { List<Entry<K, V>> entries = new ArrayList<Entry<K, V>>(map.entrySet()); Collections.sort(entries, new ByValue<K, V>()); return entries; } private static class ByValue<K, V extends Comparable<V>> implements Comparator<Entry<K, V>> { public int compare(Entry<K, V> o1, Entry<K, V> o2) { return o1.getValue().compareTo(o2.getValue()); } }
public class MapUtilitiesTest extends TestCase { public void testSorting() { HashMap<String, Integer> map = new HashMap<String, Integer>(); map.put("One", 1); map.put("Two", 2); map.put("Three", 3); List<Map.Entry<String, Integer>> sorted = MapUtilities.sortByValue(map); assertEquals("First", "One", sorted.get(0).getKey()); assertEquals("Second", "Two", sorted.get(1).getKey()); assertEquals("Third", "Three", sorted.get(2).getKey()); }
class MyComparator implements Comparator<Object> { Map<String, Integer> map; public MyComparator(Map<String, Integer> map) { this.map = map; } public int compare(Object o1, Object o2) { if (map.get(o2) == map.get(o1)) return 1; else return ((Integer) map.get(o2)).compareTo((Integer) map.get(o1)); } }
Map<String, Integer> lMap = new HashMap<String, Integer>(); lMap.put("A", 35); lMap.put("B", 75); lMap.put("C", 50); lMap.put("D", 50); MyComparator comparator = new MyComparator(lMap); Map<String, Integer> newMap = new TreeMap<String, Integer>(comparator); newMap.putAll(lMap); System.out.println(newMap);
if((Double)base.get(a) < (Double)base.get(b)) { return 1; } else if((Double)base.get(a) == (Double)base.get(b)) { return -1; } else { return -1; }
package nl.iamit.util; import java.util.Comparator; import java.util.Map; public class Comparators { public static class MapIntegerStringComparator implements Comparator { Map<Integer, String> base; public MapIntegerStringComparator(Map<Integer, String> base) { this.base = base; } public int compare(Object a, Object b) { int compare = ((String) base.get(a)) .compareTo((String) base.get(b)); if (compare == 0) { return -1; } return compare; } } }
package test.nl.iamit.util; import java.util.HashMap; import java.util.TreeMap; import nl.iamit.util.Comparators; import org.junit.Test; import static org.junit.Assert.assertArrayEquals; public class TestComparators { @Test public void testMapIntegerStringComparator(){ HashMap<Integer, String> unSoretedMap = new HashMap<Integer, String>(); Comparators.MapIntegerStringComparator bvc = new Comparators.MapIntegerStringComparator( unSoretedMap); TreeMap<Integer, String> sorted_map = new TreeMap<Integer, String>(bvc); unSoretedMap.put(new Integer(1), "E"); unSoretedMap.put(new Integer(2), "A"); unSoretedMap.put(new Integer(3), "E"); unSoretedMap.put(new Integer(4), "B"); unSoretedMap.put(new Integer(5), "F"); sorted_map.putAll(unSoretedMap); Object[] targetKeys={new Integer(2),new Integer(4),new Integer(3),new Integer(1),new Integer(5) }; Object[] currecntKeys=sorted_map.keySet().toArray(); assertArrayEquals(targetKeys,currecntKeys); } }
public static class MapStringDoubleComparator implements Comparator { Map<String, Double> base; public MapStringDoubleComparator(Map<String, Double> base) { this.base = base; } public int compare(Object a, Object b) { if ((Double) base.get(a) == (Double) base.get(b)) { return 0; } else if((Double) base.get(a) < (Double) base.get(b)) { return -1; }else{ return 1; } } }
@Test public void testMapStringDoubleComparator(){ HashMap<String, Double> unSoretedMap = new HashMap<String, Double>(); Comparators.MapStringDoubleComparator bvc = new Comparators.MapStringDoubleComparator( unSoretedMap); TreeMap<String, Double> sorted_map = new TreeMap<String, Double>(bvc); unSoretedMap.put("D",new Double(67.3)); unSoretedMap.put("A",new Double(99.5)); unSoretedMap.put("B",new Double(67.4)); unSoretedMap.put("C",new Double(67.5)); unSoretedMap.put("E",new Double(99.5)); sorted_map.putAll(unSoretedMap); Object[] targetKeys={"D","B","C","E","A"}; Object[] currecntKeys=sorted_map.keySet().toArray(); assertArrayEquals(targetKeys,currecntKeys); }
final class MapValueComparator<K,V extends Comparable<V>> implements Comparator<K> { private Map<K,V> map; private MapValueComparator() { super(); } public MapValueComparator(Map<K,V> map) { this(); this.map = map; } public int compare(K o1, K o2) { return map.get(o1).compareTo(map.get(o2)); } }
public static <T extends Comparable<? super T>> void sort(List<T> list) { Object[] a = list.toArray(); Arrays.sort(a); ListIterator<T> i = list.listIterator(); for (int j=0; j<a.length; j++) { i.next(); i.set((T)a[j]); } }
public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map) { @SuppressWarnings("unchecked") Map.Entry<K,V>[] array = map.entrySet().toArray(new Map.Entry[map.size()]); Arrays.sort(array, new Comparator<Map.Entry<K, V>>() { public int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2) { return e1.getValue().compareTo(e2.getValue()); } }); Map<K, V> result = new LinkedHashMap<K, V>(); for (Map.Entry<K, V> entry : array) result.put(entry.getKey(), entry.getValue()); return result; }
public static <K, V extends Comparable<V>> Map<K, V> sortMapByValues(final Map<K, V> map) { Comparator<K> valueComparator = new Comparator<K>() { public int compare(K k1, K k2) { final V v1 = map.get(k1); final V v2 = map.get(k2); if (v1 == null) { return (v2 == null) ? 0 : 1; } int compare = v2.compareTo(v1); if (compare != 0) { return compare; } else { Integer h1 = k1.hashCode(); Integer h2 = k2.hashCode(); return h2.compareTo(h1); } } }; Map<K, V> sortedByValues = new TreeMap<K, V>(valueComparator); sortedByValues.putAll(map); return sortedByValues; }
public int compare(String a, String b) { if (base.get(a) > base.get(b)) { return 1; } else if (base.get(a) < base.get(b)){ return -1; } return 0; }
import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; import java.util.Map.Entry; public class OrderByValue { public static void main(String a[]){ Map<String, Integer> map = new HashMap<String, Integer>(); map.put("java", 20); map.put("C++", 45); map.put("Unix", 67); map.put("MAC", 26); map.put("Why this kolavari", 93); Set<Entry<String, Integer>> set = map.entrySet(); List<Entry<String, Integer>> list = new ArrayList<Entry<String, Integer>>(set); Collections.sort( list, new Comparator<Map.Entry<String, Integer>>() { public int compare( Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2 ) { return (o1.getValue()).compareTo( o2.getValue() ); } } ); for(Map.Entry<String, Integer> entry:list){ System.out.println(entry.getKey()+" ==== "+entry.getValue()); } }}
java ==== 20 MAC ==== 26 C++ ==== 45 Unix ==== 67 Why this kolavari ==== 93
import java.util.*; /** * A map where {@link * by associated values based on the the comparator provided at construction * time. The order of two or more keys with identical values is not defined. * <p> * Several contracts of the Map interface are not satisfied by this minimal * implementation. */ public class ValueSortedMap<K, V> extends HashMap<K, V> { protected Map<V, Collection<K>> valueToKeysMap; public ValueSortedMap() { this((Comparator<? super V>) null); } public ValueSortedMap(Comparator<? super V> valueComparator) { this.valueToKeysMap = new TreeMap<V, Collection<K>>(valueComparator); } public boolean containsValue(Object o) { return valueToKeysMap.containsKey(o); } public V put(K k, V v) { V oldV = null; if (containsKey(k)) { oldV = get(k); valueToKeysMap.get(oldV).remove(k); } super.put(k, v); if (!valueToKeysMap.containsKey(v)) { Collection<K> keys = new ArrayList<K>(); keys.add(k); valueToKeysMap.put(v, keys); } else { valueToKeysMap.get(v).add(k); } return oldV; } public void putAll(Map<? extends K, ? extends V> m) { for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue()); } public V remove(Object k) { V oldV = null; if (containsKey(k)) { oldV = get(k); super.remove(k); valueToKeysMap.get(oldV).remove(k); } return oldV; } public void clear() { super.clear(); valueToKeysMap.clear(); } public Set<K> keySet() { LinkedHashSet<K> ret = new LinkedHashSet<K>(size()); for (V v : valueToKeysMap.keySet()) { Collection<K> keys = valueToKeysMap.get(v); ret.addAll(keys); } return ret; } public Set<Map.Entry<K, V>> entrySet() { LinkedHashSet<Map.Entry<K, V>> ret = new LinkedHashSet<Map.Entry<K, V>>(size()); for (Collection<K> keys : valueToKeysMap.values()) { for (final K k : keys) { final V v = get(k); ret.add(new Map.Entry<K,V>() { public K getKey() { return k; } public V getValue() { return v; } public V setValue(V v) { throw new UnsupportedOperationException(); } }); } } return ret; } }
private <K, V extends Comparable<? super V>> List<Entry<K, V>> sort(Map<K, V> map) { List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>(map.entrySet()); Collections.sort(list, new Comparator<Map.Entry<K, V>>() { public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) { return o1.getValue().compareTo(o2.getValue()); } }); return list; }
Map<Driver driver, Float time> map = new TreeMap<Driver driver, Float time>(*);
ResultComparator rc = new ResultComparator(); Set<Results> set = new TreeSet<Results>(rc);
public class Results { private Driver driver; private Float time; public Results(Driver driver, Float time) { this.driver = driver; this.time = time; } public Float getTime() { return time; } public void setTime(Float time) { this.time = time; } public Driver getDriver() { return driver; } public void setDriver (Driver driver) { this.driver = driver; } }
public class ResultsComparator implements Comparator<Results> { public int compare(Results t, Results t1) { if (t.getTime() < t1.getTime()) { return 1; } else if (t.getTime() == t1.getTime()) { return 0; } else { return -1; } } }
Iterator it = set.iterator(); while (it.hasNext()) { Results r = (Results)it.next(); System.out.println( r.getDriver().toString + " " + r.getTime() ); }
/** * Sort a map by it * * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map. * @author Maxim Veksler */ public static <K, V> LinkedHashMap<K, V> sortMapByKey(final Map<K, V> map) { return sortMapByKey(map, SortingOrder.ASCENDING); } /** * Sort a map by it * * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map. * @author Maxim Veksler */ public static <K, V> LinkedHashMap<K, V> sortMapByValue(final Map<K, V> map) { return sortMapByValue(map, SortingOrder.ASCENDING); } /** * Sort a map by it * * @param sortingOrder {@link SortingOrder} enum specifying requested sorting order. * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map. * @author Maxim Veksler */ public static <K, V> LinkedHashMap<K, V> sortMapByKey(final Map<K, V> map, final SortingOrder sortingOrder) { Comparator<Map.Entry<K, V>> comparator = new Comparator<Entry<K,V>>() { public int compare(Entry<K, V> o1, Entry<K, V> o2) { return comparableCompare(o1.getKey(), o2.getKey(), sortingOrder); } }; return sortMap(map, comparator); } /** * Sort a map by it * * @param sortingOrder {@link SortingOrder} enum specifying requested sorting order. * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map. * @author Maxim Veksler */ public static <K, V> LinkedHashMap<K, V> sortMapByValue(final Map<K, V> map, final SortingOrder sortingOrder) { Comparator<Map.Entry<K, V>> comparator = new Comparator<Entry<K,V>>() { public int compare(Entry<K, V> o1, Entry<K, V> o2) { return comparableCompare(o1.getValue(), o2.getValue(), sortingOrder); } }; return sortMap(map, comparator); } @SuppressWarnings("unchecked") private static <T> int comparableCompare(T o1, T o2, SortingOrder sortingOrder) { int compare = ((Comparable<T>)o1).compareTo(o2); switch (sortingOrder) { case ASCENDING: return compare; case DESCENDING: return (-1) * compare; } return 0; } /** * Sort a map by supplied comparator logic. * * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map. * @author Maxim Veksler */ public static <K, V> LinkedHashMap<K, V> sortMap(final Map<K, V> map, final Comparator<Map.Entry<K, V>> comparator) { List<Map.Entry<K, V>> mapEntries = new LinkedList<Map.Entry<K, V>>(map.entrySet()); Collections.sort(mapEntries, comparator); LinkedHashMap<K, V> result = new LinkedHashMap<K, V>(map.size() + (map.size() / 20)); for(Map.Entry<K, V> entry : mapEntries) { result.put(entry.getKey(), entry.getValue()); } return result; } /** * Sorting order enum, specifying request result sort behavior. * @author Maxim Veksler * */ public static enum SortingOrder { /** * Resulting sort will be from smaller to biggest. */ ASCENDING, /** * Resulting sort will be from biggest to smallest. */ DESCENDING }
import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; public class SortableValueMap<K, V extends Comparable<V>> extends LinkedHashMap<K, V> { public SortableValueMap() { } public SortableValueMap( Map<K, V> map ) { super( map ); } public void sortByValue() { List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>( entrySet() ); Collections.sort( list, new Comparator<Map.Entry<K, V>>() { public int compare( Map.Entry<K, V> entry1, Map.Entry<K, V> entry2 ) { return entry1.getValue().compareTo( entry2.getValue() ); } }); clear(); for( Map.Entry<K, V> entry : list ) { put( entry.getKey(), entry.getValue() ); } } private static void print( String text, Map<String, Double> map ) { System.out.println( text ); for( String key : map.keySet() ) { System.out.println( "key/value: " + key + "/" + map.get( key ) ); } } public static void main( String[] args ) { SortableValueMap<String, Double> map = new SortableValueMap<String, Double>(); map.put( "A", 67.5 ); map.put( "B", 99.5 ); map.put( "C", 82.4 ); map.put( "D", 42.0 ); print( "Unsorted map", map ); map.sortByValue(); print( "Sorted map", map ); } }
Map<String, Long> map = new HashMap<String, Long>(); Queue queue = new PriorityQueue( map.size(), new MapComparable() ); queue.addAll( map.entrySet() ); LinkedHashMap<String, Long> linkedMap = new LinkedHashMap<String, Long>(); for (Map.Entry<String, Long> entry; (entry = queue.poll())!=null;) { linkedMap.put(entry.getKey(), entry.getValue()); } public static class MapComparable implements Comparator<Map.Entry<String, Long>>{ public int compare(Entry<String, Long> e1, Entry<String, Long> e2) { return e1.getValue().compareTo(e2.getValue()); } }
public int compare(Object a, Object b) { if((Double)base.get(a) < (Double)base.get(b)) { return 1; } else if((Double)base.get(a) == (Double)base.get(b)) { return ((String)a).compareTo((String)b); } else { return -1; } } }
Map<String,Integer> mapToSortByValue = new HashMap<String, Integer>(); mapToSortByValue.put("A", 3); mapToSortByValue.put("B", 1); mapToSortByValue.put("C", 3); mapToSortByValue.put("D", 5); mapToSortByValue.put("E", -1); mapToSortByValue.put("F", 1000); mapToSortByValue.put("G", 79); mapToSortByValue.put("H", 15); Set<Map.Entry<String,Integer>> set = new TreeSet<Map.Entry<String,Integer>>( new Comparator<Map.Entry<String,Integer>>(){ @Override public int compare(Map.Entry<String,Integer> obj1, Map.Entry<String,Integer> obj2) { Integer val1 = obj1.getValue(); Integer val2 = obj2.getValue(); int compareValues = val1.compareTo(val2); if ( compareValues == 0 ) { String key1 = obj1.getKey(); String key2 = obj2.getKey(); int compareKeys = key1.compareTo(key2); if ( compareKeys == 0 ) { return 0; } return compareKeys; } return compareValues; } } ); set.addAll(mapToSortByValue.entrySet()); for ( Map.Entry<String,Integer> entry : set ) { System.out.println("Set entries: " + entry.getKey() + " -> " + entry.getValue()); } Map<String,Integer> myMap = new HashMap<String,Integer>(); for ( Map.Entry<String,Integer> entry : set ) { System.out.println("Added to result map entries: " + entry.getKey() + " " + entry.getValue()); myMap.put(entry.getKey(), entry.getValue()); } for ( Integer value : myMap.values() ) { System.out.println("Result map values: " + value); } for ( Map.Entry<String,Integer> entry : myMap.entrySet() ) { System.out.println("Result map entries: " + entry.getKey() + " -> " + entry.getValue()); }
Set entries: E -> -1 Set entries: B -> 1 Set entries: A -> 3 Set entries: C -> 3 Set entries: D -> 5 Set entries: H -> 15 Set entries: G -> 79 Set entries: F -> 1000 Added to result map entries: E -1 Added to result map entries: B 1 Added to result map entries: A 3 Added to result map entries: C 3 Added to result map entries: D 5 Added to result map entries: H 15 Added to result map entries: G 79 Added to result map entries: F 1000 Result map values: 5 Result map values: -1 Result map values: 1000 Result map values: 79 Result map values: 3 Result map values: 1 Result map values: 3 Result map values: 15 Result map entries: D -> 5 Result map entries: E -> -1 Result map entries: F -> 1000 Result map entries: G -> 79 Result map entries: A -> 3 Result map entries: B -> 1 Result map entries: C -> 3 Result map entries: H -> 15
Map<String,Integer> tempMap=new HashMap<String,Integer>(inputUnsortedMap); LinkedHashMap<String,Integer> sortedOutputMap=new LinkedHashMap<String,Integer>(); for(int i=0;i<inputUnsortedMap.size();i++){ Map.Entry<String,Integer> maxEntry=null; Integer maxValue=-1; for(Map.Entry<String,Integer> entry:tempMap.entrySet()){ if(entry.getValue()>maxValue){ maxValue=entry.getValue(); maxEntry=entry; } } tempMap.remove(maxEntry.getKey()); sortedOutputMap.put(maxEntry.getKey(),maxEntry.getValue()); }
class MapUtil { public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue( Map<K, V> map ){ ValueComparator<K,V> bvc = new ValueComparator<K,V>(map); TreeMap<K,V> sorted_map = new TreeMap<K,V>(bvc); sorted_map.putAll(map); return sorted_map; } } class ValueComparator<K, V extends Comparable<? super V>> implements Comparator<K> { Map<K, V> base; public ValueComparator(Map<K, V> base) { this.base = base; } public int compare(K a, K b) { int result = (base.get(a).compareTo(base.get(b))); if (result == 0) result=1; return result; } }
TreeMap<Integer, Collection<String>> sortedMap = new TreeMap<>( Multimaps.invertFrom(Multimaps.forMap(originalMap), ArrayListMultimap.<Integer, String>create()).asMap());
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk<version>.jdk/Contents/Home
yum install java-1.7.0-openjdk java-1.7.0-openjdk-devel
<target name="build-java" depends="prepare-build"> <echo message="Compiling java files"/> <javac .... target="1.5"... </javac> </target>
javac -source 1.6 -target 1.6 -bootclasspath /usr/lib/jvm/java-6-openjdk-i386/jre/lib/rt.jar HelloWorld.java
javac -source 1.6 -target 1.6 -bootclasspath ./rt.jar HelloWorld.java
J2SE 8 = 52 J2SE 7 = 51 J2SE 6.0 = 50 J2SE 5.0 = 49 JDK 1.4 = 48 JDK 1.3 = 47 JDK 1.2 = 46 JDK 1.1 = 45
<build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.1</version> <configuration> <source>1.6</source> <target>1.6</target> </configuration> </plugin> .....
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_75.jdk/Contents/Home
public MyParameterizedFunction(String param1, int param2) { this(param1, param2, false); } public MyParameterizedFunction(String param1, int param2, boolean param3) { }
void MyParameterizedFunction(String param1, int param2, bool param3=false);
Student s1 = new StudentBuilder().name("Eli").buildStudent(); Student s2 = new StudentBuilder() .name("Spicoli") .age(16) .motto("Aloha, Mr Hand") .buildStudent();
void foo(String a, Integer b) { } void foo(String a) { foo(a, 0); } foo("a", 2); foo("a");
void foo(String a, Integer... b) { Integer b1 = b.length > 0 ? b[0] : 0; Integer b2 = b.length > 1 ? b[1] : 0; } foo("a"); foo("a", 1, 2);
void foo(String a, Object... b) { Integer b1 = 0; String b2 = ""; if (b.length > 0) { if (!(b[0] instanceof Integer)) { throw new IllegalArgumentException("..."); } b1 = (Integer)b[0]; } if (b.length > 1) { if (!(b[1] instanceof String)) { throw new IllegalArgumentException("..."); } b2 = (String)b[1]; } } foo("a"); foo("a", 1); foo("a", 1, "b2");
void foo(String a, Integer b, Integer c) { b = b != null ? b : 0; c = c != null ? c : 0; } foo("a", null, 2);
void foo(String a, Optional<Integer> bOpt) { Integer b = bOpt.isPresent() ? bOpt.get() : 0; } foo("a", Optional.of(2)); foo("a", Optional.<Integer>absent());
class Foo { private final String a; private final Integer b; Foo(String a, Integer b) { this.a = a; this.b = b; } } class FooBuilder { private String a = ""; private Integer b = 0; FooBuilder setA(String a) { this.a = a; return this; } FooBuilder setB(Integer b) { this.b = b; return this; } Foo build() { return new Foo(a, b); } } Foo foo = new FooBuilder().setA("a").build();
void foo(Map<String, Object> parameters) { String a = ""; Integer b = 0; if (parameters.containsKey("a")) { if (!(parameters.get("a") instanceof Integer)) { throw new IllegalArgumentException("..."); } a = (String)parameters.get("a"); } else if (parameters.containsKey("b")) { } } foo(ImmutableMap.<String, Object>of( "a", "a", "b", 2, "d", "value"));
void MyParameterizedFunction(String param1, int param2, bool param3=false) {}
void MyParameterizedFunction(String param1, int param2, Boolean... params) { assert params.length <= 1; bool param3 = params.length > 0 ? params[0].booleanValue() : false; }
void MyParameterizedFunction(String param1, int param2, bool param3=false, int param4=42) {}
void MyParameterizedFunction(String param1, int param2, Object... p) { int l = p.length; assert l <= 2; assert l < 1 || Boolean.class.isInstance(p[0]); assert l < 2 || Integer.class.isInstance(p[1]); bool param3 = l > 0 && p[0] != null ? ((Boolean)p[0]).booleanValue() : false; int param4 = l > 1 && p[1] != null ? ((Integer)p[1]).intValue() : 42; }
public: void myFunction(int a, int b=5, string c="test") { ... }
public void myFunction(int a, int b, string c) { ... } public void myFunction(int a, int b) { myFunction(a, b, "test"); } public void myFunction(int a) { myFunction(a, 5); }
class Foo(var prime: Boolean = false, val rib: String) {}
public class Foo() { public void func(String s){ func(s, true); } public void func(String s, boolean b){ } }
public myParameterizedFunction(String param1, int param2, Boolean param3) { param3 = param3 == null ? false : param3; } public myParameterizedFunction(String param1, int param2) { this(param1, param2, false); }
public myParameterizedFunction(String param1, int param2, Boolean param3) { if (param3 == null) { param3 = false; } } public myParameterizedFunction(String param1, int param2) { this(param1, param2, false); }
public class Foo() { private static class ParameterObject { int param1 = 1; String param2 = ""; } public static void main(String[] args) { new Foo().myMethod(new ParameterObject() {{ param1 = 10; param2 = "bar";}}); } private void myMethod(ParameterObject po) { } }
fun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { ... }
public int getScore(int score, Integer... bonus) { if(bonus.length > 0) { return score + bonus[0]; } return score; }
public void postUserMessage(String s,boolean wipeClean) { if(wipeClean) { userInformation.setText(s + "\n"); } else { postUserMessage(s); } } public void postUserMessage(String s) { userInformation.appendText(s + "\n"); }
public class Foo() { public interface Parameters { String getRequired(); default int getOptionalInt(){ return 23; } default String getOptionalString(){ return "Skidoo"; } } public Foo(Parameters parameters){ } public static void baz() { final Foo foo = new Foo(new Person() { @Override public String getRequired(){ return "blahblahblah"; } @Override public int getOptionalInt(){ return 43; } }); } }
@GenerateMethodInvocationBuilder public class CarService { public CarService() { } public String getCarsByFilter(// @Default("Color.BLUE") Color color, // @Default("new ProductionYear(2001)") ProductionYear productionYear,// @Default("Tomas") String owner// ) { return "Filtering... " + color + productionYear + owner; } }
CarService instance = new CarService(); String carsByFilter = CarServiceGetCarsByFilterBuilder.getCarsByFilter()// .invoke(instance);
CarService instance = new CarService(); String carsByFilter = CarServiceGetCarsByFilterBuilder.getCarsByFilter()// .withColor(Color.YELLOW)// .invoke(instance);
public class Main { public static void main(String[] args) { int N = 77777777; long t; { StringBuffer sb = new StringBuffer(); t = System.currentTimeMillis(); for (int i = N; i --> 0 ;) { sb.append(""); } System.out.println(System.currentTimeMillis() - t); } { StringBuilder sb = new StringBuilder(); t = System.currentTimeMillis(); for (int i = N; i > 0 ; i--) { sb.append(""); } System.out.println(System.currentTimeMillis() - t); } } }
public static void main(String[] args) { String withString =""; long t0 = System.currentTimeMillis(); for (int i = 0 ; i < 100000; i++){ withString+="some string"; } System.out.println("strings:" + (System.currentTimeMillis() - t0)); t0 = System.currentTimeMillis(); StringBuffer buf = new StringBuffer(); for (int i = 0 ; i < 100000; i++){ buf.append("some string"); } System.out.println("Buffers : "+(System.currentTimeMillis() - t0)); t0 = System.currentTimeMillis(); StringBuilder building = new StringBuilder(); for (int i = 0 ; i < 100000; i++){ building.append("some string"); } System.out.println("Builder : "+(System.currentTimeMillis() - t0)); }
public class StringsPerf { public static void main(String[] args) { ThreadPoolExecutor executorService = (ThreadPoolExecutor) Executors.newFixedThreadPool(10); StringBuffer buffer = new StringBuffer(); for (int i = 0 ; i < 10; i++){ executorService.execute(new AppendableRunnable(buffer)); } shutdownAndAwaitTermination(executorService); System.out.println(" Thread Buffer : "+ AppendableRunnable.time); AppendableRunnable.time = 0; executorService = (ThreadPoolExecutor) Executors.newFixedThreadPool(10); StringBuilder builder = new StringBuilder(); for (int i = 0 ; i < 10; i++){ executorService.execute(new AppendableRunnable(builder)); } shutdownAndAwaitTermination(executorService); System.out.println(" Thread Builder: "+ AppendableRunnable.time); } static void shutdownAndAwaitTermination(ExecutorService pool) { pool.shutdown(); try { if (!pool.awaitTermination(60, TimeUnit.SECONDS)) { pool.shutdownNow(); if (!pool.awaitTermination(60, TimeUnit.SECONDS)) System.err.println("Pool did not terminate"); } } catch (Exception e) {} } } class AppendableRunnable<T extends Appendable> implements Runnable { static long time = 0; T appendable; public AppendableRunnable(T appendable){ this.appendable = appendable; } @Override public void run(){ long t0 = System.currentTimeMillis(); for (int j = 0 ; j < 10000 ; j++){ try { appendable.append("some string"); } catch (IOException e) {} } time+=(System.currentTimeMillis() - t0); } }
StringBuffer is synchronized StringBuffer is thread-safe StringBuffer is slow (try to write a sample program and execute it, it will take more time than StringBuilder)
StringBuilder is not synchronized StringBuilder is not thread-safe StringBuilder performance is better than StringBuffer.
StringBuffer demo1 = new StringBuffer(Hello) ; demo1=new StringBuffer(Bye);
StringBuilder demo2= new StringBuilder(Hello); demo2=new StringBuilder(Bye);
public class Test{ public static void main(String[] args){ long startTime = System.currentTimeMillis(); StringBuffer sb = new StringBuffer("Yasir"); for (int i=0; i<10000; i++){ sb.append("Shabbir"); } System.out.println("Time taken by StringBuffer: " + (System.currentTimeMillis() - startTime) + "ms"); startTime = System.currentTimeMillis(); StringBuilder sb2 = new StringBuilder("Yasir"); for (int i=0; i<10000; i++){ sb2.append("Shabbir"); } System.out.println("Time taken by StringBuilder: " + (System.currentTimeMillis() - startTime) + "ms"); } }
/** * Run this program a couple of times. We see that the StringBuilder does not * give us reliable results because its methods are not thread-safe as compared * to StringBuffer. * * For example, the single append in StringBuffer is thread-safe, i.e. * only one thread can call append() at any time and would finish writing * back to memory one at a time. In contrast, the append() in the StringBuilder * class can be called concurrently by many threads, so the final size of the * StringBuilder is sometimes less than expected. * */ public class StringBufferVSStringBuilder { public static void main(String[] args) throws InterruptedException { int n = 10; StringBuilder sb = new StringBuilder(); StringBuilderTest[] builderThreads = new StringBuilderTest[n]; for (int i = 0; i < n; i++) { builderThreads[i] = new StringBuilderTest(sb); } for (int i = 0; i < n; i++) { builderThreads[i].start(); } for (int i = 0; i < n; i++) { builderThreads[i].join(); } System.out.println("StringBuilderTest: Expected result is 1000; got " + sb.length()); StringBuffer sb2 = new StringBuffer(); StringBufferTest[] bufferThreads = new StringBufferTest[n]; for (int i = 0; i < n; i++) { bufferThreads[i] = new StringBufferTest(sb2); } for (int i = 0; i < n; i++) { bufferThreads[i].start(); } for (int i = 0; i < n; i++) { bufferThreads[i].join(); } System.out.println("StringBufferTest: Expected result is 1000; got " + sb2.length()); } } class StringBuilderTest extends Thread { StringBuilder sb; public StringBuilderTest (StringBuilder sb) { this.sb = sb; } @Override public void run() { for (int i = 0; i < 100; i++) { sb.append("A"); } } } class StringBufferTest extends Thread { StringBuffer sb2; public StringBufferTest (StringBuffer sb2) { this.sb2 = sb2; } @Override public void run() { for (int i = 0; i < 100; i++) { sb2.append("A"); } } }
int one = 1; String color = "red"; StringBuilder sb = new StringBuilder(); sb.append("One=").append(one).append(", Color=").append(color).append( System.out.print(sb);
StringBuffer sBuffer = new StringBuffer("test"); sBuffer.append(" String Buffer"); System.out.println(sBuffer);
public StringBuffer(String str) { super(str.length() + 16); append(str); } public synchronized StringBuffer append(Object obj) { super.append(String.valueOf(obj)); return this; } public synchronized StringBuffer append(String str) { super.append(str); return this; }
public StringBuilder(String str) { super(str.length() + 16); append(str); } public StringBuilder append(Object obj) { return append(String.valueOf(obj)); } public StringBuilder append(String str) { super.append(str); return this; }
private static void performanceTestStringVsStringbuffereVsStringBuilder() { int loop = 100000; long start = 0; String str = null; start = System.currentTimeMillis(); for (int i = 1; i <= loop; i++) { str += i + "test"; } System.out.println("String - " + (System.currentTimeMillis() - start) + " ms"); StringBuffer sbuffer = new StringBuffer(); start = System.currentTimeMillis(); for (int i = 1; i <= loop; i++) { sbuffer.append(i).append("test"); } System.out.println("String Buffer - " + (System.currentTimeMillis() - start) + " ms"); start = System.currentTimeMillis(); StringBuilder sbuilder = new StringBuilder(); for (int i = 1; i <= loop; i++) { sbuffer.append(i).append("test"); } System.out.println("String Builder - " + (System.currentTimeMillis() - start) + " ms"); }
String - 37489 ms String Buffer - 5 ms String Builder - 4 ms
String - 389 ms String Buffer - 1 ms String Builder - 1 ms
String string = "004-034556"; String[] parts = string.split("-"); String part1 = parts[0]; String part2 = parts[1];
if (string.contains("-")) { } else { throw new IllegalArgumentException("String " + string + " does not contain -"); }
String string = "004-034556"; String[] parts = string.split("(?<=-)"); String part1 = parts[0]; String part2 = parts[1];
String string = "004-034556"; String[] parts = string.split("(?=-)"); String part1 = parts[0]; String part2 = parts[1];
String string = "004-034556-42"; String[] parts = string.split("-", 2); String part1 = parts[0]; String part2 = parts[1];
import java.util.regex.Pattern; import java.util.regex.Matcher; class SplitExample { private static Pattern twopart = Pattern.compile("(\\d+)-(\\d+)"); public static void checkString(String s) { Matcher m = twopart.matcher(s); if (m.matches()) { System.out.println(s + " matches; first part is " + m.group(1) + ", second part is " + m.group(2) + "."); } else { System.out.println(s + " does not match."); } } public static void main(String[] args) { checkString("123-4567"); checkString("foo-bar"); checkString("123-"); checkString("-4567"); checkString("123-4567-890"); } }
String[] result = yourString.split("-"); if (result.length != 2) throw new IllegalArgumentException("String not in correct format");
public static String[] SplitUsingTokenizer(String subject, String delimiters) { StringTokenizer strTkn = new StringTokenizer(subject, delimiters); ArrayList<String> arrLis = new ArrayList<String>(subject.length()); while(strTkn.hasMoreTokens()) arrLis.add(strTkn.nextToken()); return arrLis.toArray(new String[0]); }
public final static String[] mySplit(final String s)
- "0022-3333" - "-" - "5555-" - "-333" - "3344-" - "--" - "" - "553535" - "333-333-33" - "222--222" - "222--" - "--4555"
List<String> stringList = Pattern.compile("-") .splitAsStream("004-034556") .collect(Collectors.toList()); stringList.forEach(s -> System.out.println(s));
String concatenated_String="hi^Hello"; String split_string_array[]=concatenated_String.split("\\^");
A null input String returns null. StringUtils.split(null, *) = null StringUtils.split("", *) = [] StringUtils.split("a.b.c", StringUtils.split("a..b.c", StringUtils.split("a:b:c", StringUtils.split("a b c",
public static String[] split(String str, char separatorChar);
String str = "004-034556"; String split[] = StringUtils.split(str,"-");
public class StringSplitTest { public static void main(String args[]) { String s = " ;String; String; String; String, String; String;;String;String; String; String; ;String;String;String;String"; String[] strs = s.split("[,\\;]"); System.out.println("Substrings length:"+strs.length); for (int i=0; i < strs.length; i++) { System.out.println("Str["+i+"]:"+strs[i]); } } }
Substrings length:17 Str[0]: Str[1]:String Str[2]: String Str[3]: String Str[4]: String Str[5]: String Str[6]: String Str[7]: Str[8]:String Str[9]:String Str[10]: String Str[11]: String Str[12]: Str[13]:String Str[14]:String Str[15]:String Str[16]:String
Splitter.on( .trimResults() .omitEmptyStrings() .split(string);
String s = "abc-def"; int p = s.indexOf( if (p >= 0) { String left = s.substring(0, p); String right = s.substring(p + 1); } else { }
public class SplitTest { public static String[] split(String text, String delimiter) { java.util.List<String> parts = new java.util.ArrayList<String>(); text += delimiter; for (int i = text.indexOf(delimiter), j=0; i != -1;) { String temp = text.substring(j,i); if(temp.trim().length() != 0) { parts.add(temp); } j = i + delimiter.length(); i = text.indexOf(delimiter,j); } return parts.toArray(new String[0]); } public static void main(String[] args) { String str = "004-034556"; String delimiter = "-"; String result[] = split(str, delimiter); for(String s:result) System.out.println(s); } }
import java.io.*; public class BreakString { public static void main(String args[]) { String string = "004-034556-1234-2341"; String[] parts = string.split("-"); for(int i=0;i<parts.length;i++)  System.out.println(parts[i]); } } }
public class StringSplitTest { public static void main(String[] arg){ String str = "004-034556"; String split[] = str.split("-"); System.out.println("The split parts of the String are"); for(String s:split) System.out.println(s); } }
String[] sampleTokens = "004-034556".split("-"); System.out.println(Arrays.toString(sampleTokens));
String[] sampleTokensAgain = "004".split(""); System.out.println(Arrays.toString(sampleTokensAgain));
import java.io.*; public class Splitting { public static void main(String args[]) { String Str = new String("004-034556"); String[] SplittoArray = Str.split("-"); String string1 = SplittoArray[0]; String string2 = SplittoArray[1]; } }
import java.util.*; public class Splitting { public static void main(String[] args) { StringTokenizer Str = new StringTokenizer("004-034556"); String string1 = Str.nextToken("-"); String string2 = Str.nextToken("-"); } }
import java.util.regex.Matcher; import java.util.regex.Pattern; public class TrialClass { public static void main(String[] args) { Pattern p = Pattern.compile("[0-9]+"); Matcher m = p.matcher("004-034556"); while(m.find()) { System.out.println(m.group()); } } }
public class TrialClass { public static void main(String[] args) { String temp = "004-034556"; String [] arrString = temp.split("-"); for(String splitString:arrString) { System.out.println(splitString); } } }
List<String> strings = Pattern.compile("\\|") .splitAsStream("010|020202") .collect(Collectors.toList());
StringTokenizer strings = new StringTokenizer("Welcome to EXPLAINJAVA.COM!", "."); while(strings.hasMoreTokens()){ String substring = strings.nextToken(); System.out.println(substring); }
Iterable<String> result = Splitter.on(",").split("1,2,3,4");
String[] strings = StringUtils.split("1,2,3,4", ",");
StringTokenizer st = new StringTokenizer("004-034556", "-"); while(st.hasMoreTokens()) { System.out.println(st.nextToken()); }
String data = "004-034556-1212-232-232"; int cnt = 1; for (String item : data.split("-")) { System.out.println("string "+cnt+" = "+item); cnt++; }
String str="004-034556" String[] sTemp=str.split("-"); string1=004 string2=034556
public static List<String> split(String str, char c){ List<String> list = new ArrayList<>(); StringBuilder sb = new StringBuilder(); for (int i = 0; i < str.length(); i++){ if(str.charAt(i) != c){ sb.append(str.charAt(i)); } else{ if(sb.length() > 0){ list.add(sb.toString()); sb = new StringBuilder(); } } } if(sb.length() >0){ list.add(sb.toString()); } return list; }
Pattern pattern = Pattern.compile("[,;:]"); String[] results = pattern.split(input);
String s="004-034556"; for(int i=0;i<s.length();i++) { if(s.charAt(i)== { System.out.println(s.substring(0,i)); System.out.println(s.substring(i+1)); } }
String phone = "004-034556"; String[] output = phone.split("-"); System.out.println(output[0]); System.out.println(output[1]);
String data = "004-034556"; String[] output = data.split("-"); System.out.println(output[0]); System.out.println(output[1]);
public class Demo { public static void main(String args[]){ String str ="004-034556"; if((str.contains("-"))){ String[] temp=str.split("-"); for(String part:temp){ System.out.println(part); } }else{ System.out.println(str+" does not contain \"-\"."); } } }
private String foo; public void setFoo(String foo) { this.foo = foo; } public String getFoo() { return foo; }
public void setSpeed(int speed) { if ( speed > 100 ) { this.speed = 100; } else { this.speed = speed; } }
class Simple(object): def _get_value(self): return self._value -1 def _set_value(self, new_value): self._value = new_value + 1 def _del_value(self): self.old_values.append(self._value) del self._value value = property(_get_value, _set_value, _del_value)
Time 1: 953ms, Time 2: 741ms Time 1: 655ms, Time 2: 743ms Time 1: 656ms, Time 2: 634ms Time 1: 637ms, Time 2: 629ms Time 1: 633ms, Time 2: 625ms
Time 1: 6382ms, Time 2: 6351ms Time 1: 6363ms, Time 2: 6351ms Time 1: 6350ms, Time 2: 6363ms Time 1: 6353ms, Time 2: 6357ms Time 1: 6348ms, Time 2: 6354ms
Time 1: 77ms, Time 2: 73ms Time 1: 94ms, Time 2: 65ms Time 1: 67ms, Time 2: 63ms Time 1: 65ms, Time 2: 65ms Time 1: 66ms, Time 2: 63ms
protected YourType _yourName = null; public YourType YourName{ get { if (_yourName == null) { _yourName = new YourType(); return _yourName; } } }
public class Bottle { public int amountOfWaterMl; public int capacityMl; }
Bottle bot = new Bottle(); bot.amountOfWaterMl = 1500; bot.capacity = 1000;
public interface LiquidContainer { public int getAmountMl(); public void setAmountMl(int amountMl); public int getCapacityMl(); public void setCapcityMl(int capacityMl); }
public class Bottle extends LiquidContainer { private int capacityMl; private int amountFilledMl; public Bottle(int capacityMl, int amountFilledMl) { this.capacityMl = capacityMl; this.amountFilledMl = amountFilledMl; checkNotOverFlow(); } public int getAmountMl() { return amountFilledMl; } public void setAmountMl(int amountMl) { this.amountFilled = amountMl; checkNotOverFlow(); } public int getCapacityMl() { return capacityMl; public void setCapcityMl(int capacityMl) { this.capacityMl = capacityMl; checkNotOverFlow(); } private void checkNotOverFlow() { if(amountOfWaterMl > capacityMl) { throw new BottleOverflowException(); } }
public class TestPropertyOverride { public static class A { public int i = 0; public void add() { i++; } public int getI() { return i; } } public static class B extends A { public int i = 2; @Override public void add() { i = i + 2; } @Override public int getI() { return i; } } public static void main(String[] args) { A a = new B(); System.out.println(a.i); a.add(); System.out.println(a.i); System.out.println(a.getI()); } }
package com.highmark.productConfig.types; public class Employee { private String firstName; private String middleName; private String lastName; public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getMiddleName() { return middleName; } public void setMiddleName(String middleName) { this.middleName = middleName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getFullName(){ return this.getFirstName() + this.getMiddleName() + this.getLastName(); } }
for (String item : someList) { System.out.println(item); }
for (Iterator<String> i = someIterable.iterator(); i.hasNext();) { String item = i.next(); System.out.println(item); }
String[] fruits = new String[] { "Orange", "Apple", "Pear", "Strawberry" }; for (String fruit : fruits) { }
for (int i = 0; i < fruits.length; i++) { String fruit = fruits[i]; }
for(Iterator<String> i = someList.iterator(); i.hasNext(); ) { String item = i.next(); System.out.println(item); }
for(int i : intList) { System.out.println("An element in the list: " + i); }
Iterator<Integer> intItr = intList.iterator(); while(intItr.hasNext()) { System.out.println("An element in the list: " + intItr.next()); }
for(int i = 0; i < array.length; i++) { if(i < 5) { } else { } }
[C:\java_code\]java TimeIteratorVsIndexIntArray 1000000 Test A: 358,597,622 nanoseconds Test B: 269,167,681 nanoseconds B faster by 89,429,941 nanoseconds (24.438799231635727% faster) [C:\java_code\]java TimeIteratorVsIndexIntArray 1000000 Test A: 377,461,823 nanoseconds Test B: 278,694,271 nanoseconds B faster by 98,767,552 nanoseconds (25.666236154695838% faster) [C:\java_code\]java TimeIteratorVsIndexIntArray 1000000 Test A: 288,953,495 nanoseconds Test B: 207,050,523 nanoseconds B faster by 81,902,972 nanoseconds (27.844689860906513% faster) [C:\java_code\]java TimeIteratorVsIndexIntArray 1000000 Test A: 375,373,765 nanoseconds Test B: 283,813,875 nanoseconds B faster by 91,559,890 nanoseconds (23.891659337194227% faster) [C:\java_code\]java TimeIteratorVsIndexIntArray 1000000 Test A: 375,790,818 nanoseconds Test B: 220,770,915 nanoseconds B faster by 155,019,903 nanoseconds (40.75164734599769% faster) [C:\java_code\]java TimeIteratorVsIndexIntArray 1000000 Test A: 326,373,762 nanoseconds Test B: 202,555,566 nanoseconds B faster by 123,818,196 nanoseconds (37.437545972215744% faster)
List<Integer> intList = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100});
[C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000 Test A: 3,429,929,976 nanoseconds Test B: 5,262,782,488 nanoseconds A faster by 1,832,852,512 nanoseconds (34.326681820485675% faster) [C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000 Test A: 2,907,391,427 nanoseconds Test B: 3,957,718,459 nanoseconds A faster by 1,050,327,032 nanoseconds (26.038700083921256% faster) [C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000 Test A: 2,566,004,688 nanoseconds Test B: 4,221,746,521 nanoseconds A faster by 1,655,741,833 nanoseconds (38.71935684115413% faster) [C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000 Test A: 2,770,945,276 nanoseconds Test B: 3,829,077,158 nanoseconds A faster by 1,058,131,882 nanoseconds (27.134122749113843% faster) [C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000 Test A: 3,467,474,055 nanoseconds Test B: 5,183,149,104 nanoseconds A faster by 1,715,675,049 nanoseconds (32.60101667104192% faster) [C:\java_code\]java TimeIteratorVsIndexIntList 1000000 Test A: 3,439,983,933 nanoseconds Test B: 3,509,530,312 nanoseconds A faster by 69,546,379 nanoseconds (1.4816434912159906% faster) [C:\java_code\]java TimeIteratorVsIndexIntList 1000000 Test A: 3,451,101,466 nanoseconds Test B: 5,057,979,210 nanoseconds A faster by 1,606,877,744 nanoseconds (31.269164666060377% faster)
import java.text.NumberFormat; import java.util.Locale; /** &lt;P&gt;{@code java TimeIteratorVsIndexIntArray 1000000}&lt;/P&gt; @see &lt;CODE&gt;&lt;A HREF=&quot;https: **/ public class TimeIteratorVsIndexIntArray { public static final NumberFormat nf = NumberFormat.getNumberInstance(Locale.US); public static final void main(String[] tryCount_inParamIdx0) { int testCount; try { testCount = Integer.parseInt(tryCount_inParamIdx0[0]); } catch(ArrayIndexOutOfBoundsException | NumberFormatException x) { throw new IllegalArgumentException("Missing or invalid command line parameter: The number of testCount for each test. " + x); } int[] intArray = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100}; long lStart = System.nanoTime(); for(int i = 0; i < testCount; i++) { testIterator(intArray); } long lADuration = outputGetNanoDuration("A", lStart); lStart = System.nanoTime(); for(int i = 0; i < testCount; i++) { testFor(intArray); } long lBDuration = outputGetNanoDuration("B", lStart); outputGetABTestNanoDifference(lADuration, lBDuration, "A", "B"); } private static final void testIterator(int[] int_array) { int total = 0; for(int i = 0; i < int_array.length; i++) { total += int_array[i]; } } private static final void testFor(int[] int_array) { int total = 0; for(int i : int_array) { total += i; } } public static final long outputGetNanoDuration(String s_testName, long l_nanoStart) { long lDuration = System.nanoTime() - l_nanoStart; System.out.println("Test " + s_testName + ": " + nf.format(lDuration) + " nanoseconds"); return lDuration; } public static final long outputGetABTestNanoDifference(long l_aDuration, long l_bDuration, String s_aTestName, String s_bTestName) { long lDiff = -1; double dPct = -1.0; String sFaster = null; if(l_aDuration > l_bDuration) { lDiff = l_aDuration - l_bDuration; dPct = 100.00 - (l_bDuration * 100.0 / l_aDuration + 0.5); sFaster = "B"; } else { lDiff = l_bDuration - l_aDuration; dPct = 100.00 - (l_aDuration * 100.0 / l_bDuration + 0.5); sFaster = "A"; } System.out.println(sFaster + " faster by " + nf.format(lDiff) + " nanoseconds (" + dPct + "% faster)"); return lDiff; } }
char[] grades = .... for(int i = 0; i < grades.length; i++) { System.out.print(grades[i]); }
for(char grade : grades) { System.out.print(grade); }
Iterator<String> iterator = someList.iterator(); while (iterator.hasNext()) { String item = iterator.next(); System.out.println(item); }
List<String> messages = Arrays.asList("First", "Second", "Third"); void forTest(){ messages.forEach(System.out::println); }
String[] s = {"Java", "Coffe", "Is", "Cool"}; for (String str:s ) { System.out.println(str); }
for (int i = 0; i < s.length-1 ; i++) { if (i==1) s[i]="2 is cool"; else s[i] = "hello"; }
List<String> someList = new ArrayList<String>(); someList.add("Apple"); someList.add("Ball"); for (String item : someList) { System.out.println(item); } for(Iterator<String> stringIterator = someList.iterator(); stringIterator.hasNext(); ) { String item = stringIterator.next(); System.out.println(item); }
String[] someArray = new String[2]; someArray[0] = "Apple"; someArray[1] = "Ball"; for(String item2 : someArray) { System.out.println(item2); } for (int i = 0; i < someArray.length; i++) { String item2 = someArray[i]; System.out.println(item2); }
someList.stream().forEach(System.out::println); Arrays.stream(someArray).forEach(System.out::println);
for (Iterator<String> itr = someList.iterator(); itr.hasNext(); ) { String item = itr.next(); System.out.println(item); }
for(Iterator<String> sit = someList.iterator(); sit.hasNext(); ) { System.out.println(sit.next()); }
someList.stream().forEach(listItem -> { System.out.println(listItem); });
someList.parallelStream().forEach(listItem -> { System.out.println(listItem); });
List<String> items = new ArrayList<>(); items.add("A"); items.add("B"); items.add("C"); items.add("D"); items.add("E"); for(String item : items){ System.out.println(item); }
items.forEach(item->System.out.println(item)); items.forEach(System.out::println);
void cancelAll(Collection<TimerTask> list) { for (Iterator<TimerTask> i = list.iterator(); i.hasNext();) i.next().cancel(); }
void cancelAll(Collection<TimerTask> list) { for (TimerTask t : list) t.cancel(); }
for (Iterator<String> i = someList.iterator(); i.hasNext(); ) System.out.println(i.next());
Iterator<String> iterator = someList.iterator(); while (iterator.hasNext()) { String item = iterator.next(); System.out.println(item); }
public class ForEachTest { public static void main(String[] args) { List<String> list = new ArrayList<String>(); list.add("111"); list.add("222"); for (String str : list) { System.out.println(str); } } }
public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: new 3: dup 4: invokespecial 7: astore_1 8: aload_1 9: ldc 11: invokeinterface 16: pop 17: aload_1 18: ldc 20: invokeinterface 25: pop 26: aload_1 27: invokeinterface
List<String> someList = new ArrayList<String>(); someList.add("A"); someList.add("B"); someList.add("C"); someList.forEach(listItem -> System.out.println(listItem))
someList.forEach(listItem-> { System.out.println(listItem); });
Map<String, String> mapList = new HashMap<>(); mapList.put("Key1", "Value1"); mapList.put("Key2", "Value2"); mapList.put("Key3", "Value3"); mapList.forEach((key,value)->System.out.println("Key: " + key + " Value : " + value));
mapList.forEach((key,value)->{ System.out.println("Key : " + key + " Value : " + value); });
public static Boolean Add_Tag(int totalsize) { List<String> fullst = new ArrayList<String>(); for(int k=0;k<totalsize;k++) { fullst.addAll(); } }
int [] intArray = {1, 3, 5, 7, 9}; for(int currentValue : intArray) { System.out.println(currentValue); }
String [] myStrings = { "alpha", "beta", "gamma", "delta" }; for(String currentString : myStrings) { System.out.println(currentString); }
List<String> myList = new ArrayList<String>(); myList.add("alpha"); myList.add("beta"); myList.add("gamma"); myList.add("delta"); for(String currentItem : myList) { System.out.println(currentItem); }
Set<String> mySet = new HashSet<String>(); mySet.add("alpha"); mySet.add("alpha"); mySet.add("beta"); mySet.add("gamma"); mySet.add("gamma"); mySet.add("delta"); for(String currentItem : mySet) { System.out.println(currentItem); }
List<String> someList = new ArrayList<>(); someList.forEach(System.out::println);
List<Item> Items = obj.getItems(); for(Item item:Items) { System.out.println(item); }
private String readFile(String file) throws IOException { BufferedReader reader = new BufferedReader(new FileReader (file)); String line = null; StringBuilder stringBuilder = new StringBuilder(); String ls = System.getProperty("line.separator"); try { while((line = reader.readLine()) != null) { stringBuilder.append(line); stringBuilder.append(ls); } return stringBuilder.toString(); } finally { reader.close(); } }
static String readFile(String path, Charset encoding) throws IOException { byte[] encoded = Files.readAllBytes(Paths.get(path)); return new String(encoded, encoding); }
List<String> lines = Files.readAllLines(Paths.get(path), encoding);
try (BufferedReader r = Files.newBufferedReader(path, encoding)) { r.lines().forEach(System.out::println); }
try (Stream<String> lines = Files.lines(path, encoding)) { lines.forEach(System.out::println); }
String content = readFile("test.txt", StandardCharsets.UTF_8);
String content = readFile("test.txt", Charset.defaultCharset());
public static String readFileToString(File file) throws IOException
public static long copyLarge(InputStream input, OutputStream output) throws IOException { byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; long count = 0; int n = 0; while (-1 != (n = input.read(buffer))) { output.write(buffer, 0, n); count += n; } return count; }
Scanner scanner = new Scanner( new File("poem.txt") ); String text = scanner.useDelimiter("\\A").next(); scanner.close();
Scanner scanner = new Scanner( new File("poem.txt"), "UTF-8" ); String text = scanner.useDelimiter("\\A").next(); scanner.close();
private String readFile(String pathname) throws IOException { File file = new File(pathname); StringBuilder fileContents = new StringBuilder((int)file.length()); try (Scanner scanner = new Scanner(file)) { while(scanner.hasNextLine()) { fileContents.append(scanner.nextLine() + System.lineSeparator()); } return fileContents.toString(); } }
import com.google.common.base.Charsets; import com.google.common.io.Files; String text = Files.toString(new File(path), Charsets.UTF_8);
InputStream in = new FileInputStream(file); byte[] b = new byte[file.length()]; int len = b.length; int total = 0; while (total < len) { int result = in.read(b, total, len - total); if (result == -1) { break; } total += result; } return new String( b , Charsets.UTF_8 );
String content = new String(Files.readAllBytes(Paths.get("readMe.txt")), "UTF-8");
String readFile(String filename) { File f = new File(filename); try { byte[] bytes = Files.readAllBytes(f.toPath()); return new String(bytes,"UTF-8"); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return ""; }
public static String readFile(String file, String csName) throws IOException { Charset cs = Charset.forName(csName); return readFile(file, cs); } public static String readFile(String file, Charset cs) throws IOException { FileInputStream stream = new FileInputStream(file); try { Reader reader = new BufferedReader(new InputStreamReader(stream, cs)); StringBuilder builder = new StringBuilder(); char[] buffer = new char[8192]; int read; while ((read = reader.read(buffer, 0, buffer.length)) > 0) { builder.append(buffer, 0, read); } return builder.toString(); } finally { stream.close(); } }
String result = Files.lines(Paths.get("file.txt")) .parallel() .map(String::trim) .filter(line -> line.length() > 2) .collect(Collectors.joining());
String out = String.join("\n", Files.readAllLines(Paths.get("file.txt")));
public static String readFileToString(File file) throws IOException
public static List<String> readLines(File file) throws IOException
static Charset charset = com.google.common.base.Charsets.UTF_8; public static String guava_ServerFile( URL url ) throws IOException { return Resources.toString( url, charset ); } public static String guava_DiskFile( File file ) throws IOException { return Files.toString( file, charset ); }
static Charset encoding = org.apache.commons.io.Charsets.UTF_8; public static String commons_IOUtils( URL url ) throws IOException { java.io.InputStream in = url.openStream(); try { return IOUtils.toString( in, encoding ); } finally { IOUtils.closeQuietly(in); } } public static String commons_FileUtils( File file ) throws IOException { return FileUtils.readFileToString( file, encoding ); /*List<String> lines = FileUtils.readLines( fileName, encoding ); return lines.stream().collect( Collectors.joining("\n") );*/ }
public static String streamURL_Buffer( URL url ) throws IOException { java.io.InputStream source = url.openStream(); BufferedReader reader = new BufferedReader( new InputStreamReader( source ) ); return reader.lines().collect( Collectors.joining( System.lineSeparator() ) ); } public static String streamFile_Buffer( File file ) throws IOException { BufferedReader reader = new BufferedReader( new FileReader( file ) ); return reader.lines().collect(Collectors.joining(System.lineSeparator())); }
static String charsetName = java.nio.charset.StandardCharsets.UTF_8.toString(); public static String streamURL_Scanner( URL url ) throws IOException { java.io.InputStream source = url.openStream(); Scanner scanner = new Scanner(source, charsetName).useDelimiter("\\A"); return scanner.hasNext() ? scanner.next() : ""; } public static String streamFile_Scanner( File file ) throws IOException { Scanner scanner = new Scanner(file, charsetName).useDelimiter("\\A"); return scanner.hasNext() ? scanner.next() : ""; }
public static String getDiskFile_Java7( File file ) throws IOException { byte[] readAllBytes = java.nio.file.Files.readAllBytes(Paths.get( file.getAbsolutePath() )); return new String( readAllBytes ); }
public static String getDiskFile_Lines( File file ) throws IOException { StringBuffer text = new StringBuffer(); FileInputStream fileStream = new FileInputStream( file ); BufferedReader br = new BufferedReader( new InputStreamReader( fileStream ) ); for ( String line; (line = br.readLine()) != null; ) text.append( line + System.lineSeparator() ); return text.toString(); }
public static void main(String[] args) throws IOException { String fileName = "E:/parametarisation.csv"; File file = new File( fileName ); String fileStream = commons_FileUtils( file ); System.out.println( " File Over Disk : \n"+ fileStream ); try { String src = "https: URL url = new URL( src ); String urlStream = commons_IOUtils( url ); System.out.println( " File Over Network : \n"+ urlStream ); } catch (MalformedURLException e) { e.printStackTrace(); } }
String file = ... Path path = Paths.get(file); String content = Files.readString(path);
public static String readFileAsString(String filePath) throws IOException { DataInputStream dis = new DataInputStream(new FileInputStream(filePath)); try { long len = new File(filePath).length(); if (len > Integer.MAX_VALUE) throw new IOException("File "+filePath+" too large, was "+len+" bytes."); byte[] bytes = new byte[(int) len]; dis.readFully(bytes); return new String(bytes, "UTF-8"); } finally { dis.close(); } }
String content = new String(Files.readAllBytes(Paths.get(filename)), "UTF-8");
for(String line = reader.readLine(); line != null; line = reader.readLine()) { stringBuilder.append(line); stringBuilder.append(ls); }
static String readFile(File file, String charset) throws IOException { FileInputStream fileInputStream = new FileInputStream(file); byte[] buffer = new byte[fileInputStream.available()]; int length = fileInputStream.read(buffer); fileInputStream.close(); return new String(buffer, 0, length, charset); }
public String readStringFromFile(String filePath) throws IOException { String fileContent = new String(Files.readAllBytes(Paths.get(filePath))); return fileContent; }
Reader input = new FileReader(); StringWriter output = new StringWriter(); try { IOUtils.copy(input, output); } finally { input.close(); } String fileContents = output.toString();
public String readStringFromInputStream(FileInputStream fileInputStream) { StringBuffer stringBuffer = new StringBuffer(); try { byte[] buffer; while (fileInputStream.available() > 0) { buffer = new byte[fileInputStream.available()]; fileInputStream.read(buffer); stringBuffer.append(new String(buffer, "ISO-8859-1")); } } catch (FileNotFoundException e) { } catch (IOException e) { } return stringBuffer.toString(); }
public static String readFileContent(String filename, Charset charset) throws IOException { RandomAccessFile raf = null; try { raf = new RandomAccessFile(filename, "r"); byte[] buffer = new byte[(int)raf.length()]; raf.readFully(buffer); return new String(buffer, charset); } finally { closeStream(raf); } } private static void closeStream(Closeable c) { if (c != null) { try { c.close(); } catch (IOException ex) { } } }
try { String content = new Scanner(new File("file.txt")).useDelimiter("\\Z").next(); System.out.println(content); } catch(FileNotFoundException e) { System.out.println("not found!"); }
public static String slurp (final File file) throws IOException { StringBuilder result = new StringBuilder(); BufferedReader reader = new BufferedReader(new FileReader(file)); try { char[] buf = new char[1024]; int r = 0; while ((r = reader.read(buf)) != -1) { result.append(buf, 0, r); } } finally { reader.close(); } return result.toString(); }
public String fileToString(File file, Charset charset) { Scanner fileReader = new Scanner(file, charset); fileReader.useDelimiter("\\Z"); String out = fileReader.next(); fileReader.close(); return out; }
String data = IO.from(new File("data.txt")).toString();
public String fromFileInJar(String path) { try ( Scanner scanner = new Scanner(getClass().getResourceAsStream(path))) { return scanner.useDelimiter("\\A").next(); } }
String myTxt = fromFileInJar("/com/com/thing/a.txt");
String sMessage = String.join("\n", reader.lines().collect(Collectors.toList()));
public String readAll(String fileName) throws IOException { List<String> lines = Files.readAllLines(new File(fileName).toPath()); return String.join("\n", lines.toArray(new String[lines.size()])); }
public String readFile() throws IOException { File fileToRead = new File("file path"); List<String> fileLines = Files.readAllLines(fileToRead.toPath()); return StringUtils.join(fileLines, StringUtils.EMPTY); }
private String readFile(String pathname) throws IOException { File file = new File(pathname); StringBuilder fileContents = new StringBuilder((int)file.length()); Scanner scanner = new Scanner(file); String lineSeparator = System.getProperty("line.separator"); try { while(scanner.hasNextLine()) { fileContents.append(scanner.nextLine() + lineSeparator); } return fileContents.toString(); } finally { scanner.close(); } }
private String readFile(String pathname) throws IOException { File file = new File(pathname); StringBuilder fileContents = new StringBuilder((int) file.length()); Scanner scanner = new Scanner(new BufferedReader(new FileReader(file))); String lineSeparator = System.getProperty("line.separator"); try { if (scanner.hasNextLine()) { fileContents.append(scanner.nextLine()); } while (scanner.hasNextLine()) { fileContents.append(lineSeparator + scanner.nextLine()); } return fileContents.toString(); } finally { scanner.close(); } }
public final static boolean isPerfectSquare(long n) { if (n < 0) return false; long tst = (long)(Math.sqrt(n) + 0.5); return tst*tst == n; }
if( x < 0 || (x&2) || ((x & 7) == 5) || ((x & 11) == 8) ) return false; if( x == 0 ) return true;
int64 y = x; y = (y & 4294967295LL) + (y >> 32); y = (y & 65535) + (y >> 16); y = (y & 255) + ((y >> 8) & 255) + (y >> 16);
if((x & 4294967295LL) == 0) x >>= 32; if((x & 65535) == 0) x >>= 16; if((x & 255) == 0) x >>= 8; if((x & 15) == 0) x >>= 4; if((x & 3) == 0) x >>= 2;
int64 t = 4, r = 1; t <<= 1; r += ((x - r * r) & t) >> 1; t <<= 1; r += ((x - r * r) & t) >> 1; t <<= 1; r += ((x - r * r) & t) >> 1;
int64 r, t, z; r = start[(x >> 3) & 1023]; do { z = x - r * r; if( z == 0 ) return true; if( z < 0 ) return false; t = z & (-z); r += (z & t) >> 1; if( r > (t >> 1) ) r = t - r; } while( t <= (1LL << 33) );
typedef signed long long int int64; int start[1024] = {1,3,1769,5,1937,1741,7,1451,479,157,9,91,945,659,1817,11, 1983,707,1321,1211,1071,13,1479,405,415,1501,1609,741,15,339,1703,203, 129,1411,873,1669,17,1715,1145,1835,351,1251,887,1573,975,19,1127,395, 1855,1981,425,453,1105,653,327,21,287,93,713,1691,1935,301,551,587, 257,1277,23,763,1903,1075,1799,1877,223,1437,1783,859,1201,621,25,779, 1727,573,471,1979,815,1293,825,363,159,1315,183,27,241,941,601,971, 385,131,919,901,273,435,647,1493,95,29,1417,805,719,1261,1177,1163, 1599,835,1367,315,1361,1933,1977,747,31,1373,1079,1637,1679,1581,1753,1355, 513,1539,1815,1531,1647,205,505,1109,33,1379,521,1627,1457,1901,1767,1547, 1471,1853,1833,1349,559,1523,967,1131,97,35,1975,795,497,1875,1191,1739, 641,1149,1385,133,529,845,1657,725,161,1309,375,37,463,1555,615,1931, 1343,445,937,1083,1617,883,185,1515,225,1443,1225,869,1423,1235,39,1973, 769,259,489,1797,1391,1485,1287,341,289,99,1271,1701,1713,915,537,1781, 1215,963,41,581,303,243,1337,1899,353,1245,329,1563,753,595,1113,1589, 897,1667,407,635,785,1971,135,43,417,1507,1929,731,207,275,1689,1397, 1087,1725,855,1851,1873,397,1607,1813,481,163,567,101,1167,45,1831,1205, 1025,1021,1303,1029,1135,1331,1017,427,545,1181,1033,933,1969,365,1255,1013, 959,317,1751,187,47,1037,455,1429,609,1571,1463,1765,1009,685,679,821, 1153,387,1897,1403,1041,691,1927,811,673,227,137,1499,49,1005,103,629, 831,1091,1449,1477,1967,1677,697,1045,737,1117,1737,667,911,1325,473,437, 1281,1795,1001,261,879,51,775,1195,801,1635,759,165,1871,1645,1049,245, 703,1597,553,955,209,1779,1849,661,865,291,841,997,1265,1965,1625,53, 1409,893,105,1925,1297,589,377,1579,929,1053,1655,1829,305,1811,1895,139, 575,189,343,709,1711,1139,1095,277,993,1699,55,1435,655,1491,1319,331, 1537,515,791,507,623,1229,1529,1963,1057,355,1545,603,1615,1171,743,523, 447,1219,1239,1723,465,499,57,107,1121,989,951,229,1521,851,167,715, 1665,1923,1687,1157,1553,1869,1415,1749,1185,1763,649,1061,561,531,409,907, 319,1469,1961,59,1455,141,1209,491,1249,419,1847,1893,399,211,985,1099, 1793,765,1513,1275,367,1587,263,1365,1313,925,247,1371,1359,109,1561,1291, 191,61,1065,1605,721,781,1735,875,1377,1827,1353,539,1777,429,1959,1483, 1921,643,617,389,1809,947,889,981,1441,483,1143,293,817,749,1383,1675, 63,1347,169,827,1199,1421,583,1259,1505,861,457,1125,143,1069,807,1867, 2047,2045,279,2043,111,307,2041,597,1569,1891,2039,1957,1103,1389,231,2037, 65,1341,727,837,977,2035,569,1643,1633,547,439,1307,2033,1709,345,1845, 1919,637,1175,379,2031,333,903,213,1697,797,1161,475,1073,2029,921,1653, 193,67,1623,1595,943,1395,1721,2027,1761,1955,1335,357,113,1747,1497,1461, 1791,771,2025,1285,145,973,249,171,1825,611,265,1189,847,1427,2023,1269, 321,1475,1577,69,1233,755,1223,1685,1889,733,1865,2021,1807,1107,1447,1077, 1663,1917,1129,1147,1775,1613,1401,555,1953,2019,631,1243,1329,787,871,885, 449,1213,681,1733,687,115,71,1301,2017,675,969,411,369,467,295,693, 1535,509,233,517,401,1843,1543,939,2015,669,1527,421,591,147,281,501, 577,195,215,699,1489,525,1081,917,1951,2013,73,1253,1551,173,857,309, 1407,899,663,1915,1519,1203,391,1323,1887,739,1673,2011,1585,493,1433,117, 705,1603,1111,965,431,1165,1863,533,1823,605,823,1179,625,813,2009,75, 1279,1789,1559,251,657,563,761,1707,1759,1949,777,347,335,1133,1511,267, 833,1085,2007,1467,1745,1805,711,149,1695,803,1719,485,1295,1453,935,459, 1151,381,1641,1413,1263,77,1913,2005,1631,541,119,1317,1841,1773,359,651, 961,323,1193,197,175,1651,441,235,1567,1885,1481,1947,881,2003,217,843, 1023,1027,745,1019,913,717,1031,1621,1503,867,1015,1115,79,1683,793,1035, 1089,1731,297,1861,2001,1011,1593,619,1439,477,585,283,1039,1363,1369,1227, 895,1661,151,645,1007,1357,121,1237,1375,1821,1911,549,1999,1043,1945,1419, 1217,957,599,571,81,371,1351,1003,1311,931,311,1381,1137,723,1575,1611, 767,253,1047,1787,1169,1997,1273,853,1247,413,1289,1883,177,403,999,1803, 1345,451,1495,1093,1839,269,199,1387,1183,1757,1207,1051,783,83,423,1995, 639,1155,1943,123,751,1459,1671,469,1119,995,393,219,1743,237,153,1909, 1473,1859,1705,1339,337,909,953,1771,1055,349,1993,613,1393,557,729,1717, 511,1533,1257,1541,1425,819,519,85,991,1693,503,1445,433,877,1305,1525, 1601,829,809,325,1583,1549,1991,1941,927,1059,1097,1819,527,1197,1881,1333, 383,125,361,891,495,179,633,299,863,285,1399,987,1487,1517,1639,1141, 1729,579,87,1989,593,1907,839,1557,799,1629,201,155,1649,1837,1063,949, 255,1283,535,773,1681,461,1785,683,735,1123,1801,677,689,1939,487,757, 1857,1987,983,443,1327,1267,313,1173,671,221,695,1509,271,1619,89,565, 127,1405,1431,1659,239,1101,1159,1067,607,1565,905,1755,1231,1299,665,373, 1985,701,1879,1221,849,627,1465,789,543,1187,1591,923,1905,979,1241,181}; bool bad255[512] = {0,0,1,1,0,1,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1, 1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,1,1, 0,1,0,1,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,0,1, 1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1, 1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1, 1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1, 1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1, 0,0,1,1,0,1,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1, 1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,1,1, 0,1,0,1,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,0,1, 1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1, 1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1, 1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1, 1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1, 0,0}; inline bool square( int64 x ) { if( x < 0 || (x&2) || ((x & 7) == 5) || ((x & 11) == 8) ) return false; if( x == 0 ) return true; int64 y = x; y = (y & 4294967295LL) + (y >> 32); y = (y & 65535) + (y >> 16); y = (y & 255) + ((y >> 8) & 255) + (y >> 16); if( bad255[y] ) return false; if((x & 4294967295LL) == 0) x >>= 32; if((x & 65535) == 0) x >>= 16; if((x & 255) == 0) x >>= 8; if((x & 15) == 0) x >>= 4; if((x & 3) == 0) x >>= 2; if((x & 7) != 1) return false; int64 r, t, z; r = start[(x >> 3) & 1023]; do { z = x - r * r; if( z == 0 ) return true; if( z < 0 ) return false; t = z & (-z); r += (z & t) >> 1; if( r > (t >> 1) ) r = t - r; } while( t <= (1LL << 33) ); return false; }
long goodMask; { for (int i=0; i<64; ++i) goodMask |= Long.MIN_VALUE >>> (i*i); } public boolean isSquare(long x) { if (goodMask << x >= 0) return false; final int numberOfTrailingZeros = Long.numberOfTrailingZeros(x); if ((numberOfTrailingZeros & 1) != 0) return false; x >>= numberOfTrailingZeros; if ((x&7) != 1 | x <= 0) return x == 0; final long tst = (long) Math.sqrt(x); return tst * tst == x; }
public final static boolean isPerfectSquare(long n) { if (n < 0) return false; switch((int)(n & 0xF)) { case 0: case 1: case 4: case 9: long tst = (long)Math.sqrt(n); return tst*tst == n; default: return false; } }
int isPerfectSquare(int n) { int h = n & 0xF; if (h > 9) return 0; if (h != 2 && h != 3 && h != 5 && h != 6 && h != 7 && h != 8) { int t = (int) floor( sqrt((double) n) + 0.5 ); return t*t == n; } return 0; }
float Q_rsqrt( float number ) { long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = * ( long * ) &y; i = 0x5f3759df - ( i >> 1 ); y = * ( float * ) &i; y = y * ( threehalfs - ( x2 * y * y ) ); assert( !isnan(y) ); return y; }
while((x & 0x3) == 0) x >>= 2; if((x & 0x7) != 1) return false;
0% Scenario{vm=java, trial=0, benchmark=Internet} 39673.40 ns; ?=378.78 ns @ 3 trials 33% Scenario{vm=java, trial=0, benchmark=Durron} 37785.75 ns; ?=478.86 ns @ 10 trials 67% Scenario{vm=java, trial=0, benchmark=DurronTwo} 35978.10 ns; ?=734.10 ns @ 10 trials benchmark us linear runtime Internet 39.7 ============================== Durron 37.8 ============================ DurronTwo 36.0 =========================== vm: java trial: 0
0% Scenario{vm=java, trial=0, benchmark=Internet} 2933380.84 ns; ?=56939.84 ns @ 10 trials 33% Scenario{vm=java, trial=0, benchmark=Durron} 2243266.81 ns; ?=50537.62 ns @ 10 trials 67% Scenario{vm=java, trial=0, benchmark=DurronTwo} 3159227.68 ns; ?=10766.22 ns @ 3 trials benchmark ms linear runtime Internet 2.93 =========================== Durron 2.24 ===================== DurronTwo 3.16 ============================== vm: java trial: 0
public final static boolean isPerfectSquareDurron(long n) { if(n < 0) return false; if(n == 0) return true; long x = n; while((x & 0x3) == 0) x >>= 2; if((x & 0x7) == 1) { long sqrt; if(x < 410881L) { int i; float x2, y; x2 = x * 0.5F; y = x; i = Float.floatToRawIntBits(y); i = 0x5f3759df - ( i >> 1 ); y = Float.intBitsToFloat(i); y = y * ( 1.5F - ( x2 * y * y ) ); sqrt = (long)(1.0F/y); } else { sqrt = (long) Math.sqrt(x); } return sqrt*sqrt == x; } return false; }
public final static boolean isPerfectSquareDurronTwo(long n) { if(n < 0) return false; if(n == 0) return true; long x = n; while((x & 0x3) == 0) x >>= 2; if((x & 0x7) == 1) { long sqrt; if (x < 41529141369L) { int i; float x2, y; x2 = x * 0.5F; y = x; i = Float.floatToRawIntBits(y); i = 0x5f375a86 - (i >> 1); y = Float.intBitsToFloat(i); y = y * (1.5F - (x2 * y * y)); y = y * (1.5F - (x2 * y * y)); sqrt = (long) ((1.0F/y) + 0.2); } else { sqrt = (long) Math.sqrt(x); } return sqrt*sqrt == x; } return false; }
public class SquareRootBenchmark { public static class Benchmark1 extends SimpleBenchmark { private static final int ARRAY_SIZE = 10000; long[] trials = new long[ARRAY_SIZE]; @Override protected void setUp() throws Exception { Random r = new Random(); for (int i = 0; i < ARRAY_SIZE; i++) { trials[i] = Math.abs(r.nextLong()); } } public int timeInternet(int reps) { int trues = 0; for(int i = 0; i < reps; i++) { for(int j = 0; j < ARRAY_SIZE; j++) { if(SquareRootAlgs.isPerfectSquareInternet(trials[j])) trues++; } } return trues; } public int timeDurron(int reps) { int trues = 0; for(int i = 0; i < reps; i++) { for(int j = 0; j < ARRAY_SIZE; j++) { if(SquareRootAlgs.isPerfectSquareDurron(trials[j])) trues++; } } return trues; } public int timeDurronTwo(int reps) { int trues = 0; for(int i = 0; i < reps; i++) { for(int j = 0; j < ARRAY_SIZE; j++) { if(SquareRootAlgs.isPerfectSquareDurronTwo(trials[j])) trues++; } } return trues; } } public static void main(String... args) { Runner.main(Benchmark1.class, args); } }
if (!goodLookupSquares[(int) ((n & 0xFFFFFFl) + ((n >> 24) & 0xFFFFFFl) + (n >> 48))]) return false;
public final static boolean isPerfectSquareDurronThree(long n) { if(n < 0) return false; if(n == 0) return true; long x = n; while((x & 0x3) == 0) x >>= 2; if((x & 0x7) == 1) { if (!goodLookupSquares[(int) ((n & 0xFFFFFFl) + ((n >> 24) & 0xFFFFFFl) + (n >> 48))]) return false; long sqrt; if(x < 410881L) { int i; float x2, y; x2 = x * 0.5F; y = x; i = Float.floatToRawIntBits(y); i = 0x5f3759df - ( i >> 1 ); y = Float.intBitsToFloat(i); y = y * ( 1.5F - ( x2 * y * y ) ); sqrt = (long)(1.0F/y); } else { sqrt = (long) Math.sqrt(x); } return sqrt*sqrt == x; } return false; }
private static boolean[] goodLookupSquares = null; public static void initGoodLookupSquares() throws Exception { Scanner s = new Scanner(new File("24residues_squares.txt")); goodLookupSquares = new boolean[0x1FFFFFE]; while(s.hasNextLine()) { int residue = Integer.valueOf(s.nextLine()); goodLookupSquares[residue] = true; goodLookupSquares[residue + 0xFFFFFF] = true; goodLookupSquares[residue + 0x1FFFFFE] = true; } s.close(); }
0% Scenario{vm=java, trial=0, benchmark=Internet} 40665.77 ns; ?=566.71 ns @ 10 trials 33% Scenario{vm=java, trial=0, benchmark=Durron} 38397.60 ns; ?=784.30 ns @ 10 trials 67% Scenario{vm=java, trial=0, benchmark=DurronThree} 36171.46 ns; ?=693.02 ns @ 10 trials benchmark us linear runtime Internet 40.7 ============================== Durron 38.4 ============================ DurronThree 36.2 ========================== vm: java trial: 0
boolean isPerfectSquare(long number) { if (number < 0) return false; if (number < 2) return true; for (int i = 0; ; i++) { long square = squareTable[i]; if (square > number) return false; while (number % square == 0) { number /= square; } if (number == 1) return true; } }
public class SquareTester { public static boolean isPerfectSquare(long n) { if (n < 0) { return false; } else { switch ((byte) n) { case -128: case -127: case -124: case -119: case -112: case -111: case -103: case -95: case -92: case -87: case -79: case -71: case -64: case -63: case -60: case -55: case -47: case -39: case -31: case -28: case -23: case -15: case -7: case 0: case 1: case 4: case 9: case 16: case 17: case 25: case 33: case 36: case 41: case 49: case 57: case 64: case 65: case 68: case 73: case 81: case 89: case 97: case 100: case 105: case 113: case 121: long i = (n * INV3465) >>> 52; if (! good3465[(int) i]) { return false; } else { long r = round(Math.sqrt(n)); return r*r == n; } default: return false; } } } private static int round(double x) { return (int) Double.doubleToRawLongBits(x + (double) (1L << 52)); } /** 3465<sup>-1</sup> modulo 2<sup>64</sup> */ private static final long INV3465 = 0x8ffed161732e78b9L; private static final boolean[] good3465 = new boolean[0x1000]; static { for (int r = 0; r < 3465; ++ r) { int i = (int) ((r * r * INV3465) >>> 52); good3465[i] = good3465[i+1] = true; } } }
long goodMask; { for (int i=0; i<64; ++i) goodMask |= Long.MIN_VALUE >>> (i*i); } public boolean isSquare(long x) { if (goodMask << x >= 0) return false; x >>= (Long.numberOfTrailingZeros(x) & (-2); if (goodMask << x >= 0 | x <= 0) return x == 0; final long tst = (long) Math.sqrt(x); return tst * tst == x; }
m = N & (N-1); N /= m; byte = N & 0x0F; if ((m % 2) || (byte !=1 && byte !=9)) return false;
m = N & (N-1); N /= m; if ((m % 2) || (N & 0x07 != 1)) return false;
def isexactsqrt(v) value = v.abs residue = value root = 0 onebit = 1 onebit <<= 8 while (onebit < residue) onebit >>= 2 while (onebit > residue) while (onebit > 0) x = root + onebit if (residue >= x) then residue -= x root = x + onebit end root >>= 1 onebit >>= 2 end return (residue == 0) end
using namespace std; typedef unsigned long long int llint; class ISqrt { llint value; llint root; llint residue; llint onebit, x; public: ISqrt(llint v = 2) { Root(v); }; llint Root(llint r) { value = r; residue = value; root = 0; onebit = 1; onebit <<= (8*sizeof(llint)-2); while (onebit > residue) {onebit >>= 2; }; while (onebit > 0) { x = root ^ onebit; if (residue >= x) { residue -= x; root = x + onebit; }; root >>= 1; onebit >>= 2; }; return root; }; llint Residue() { return residue; }; }; int main() { llint big, i, q, r, v, delta; big = 0; big = (big-1); ISqrt b; for ( i = big; i > 0 ; i /= 7 ) { q = b.Root(i); r = b.Residue(); v = q*q+r; delta = v-i; cout << i << ": " << q << " ++ " << r << " V: " << v << " Delta: " << delta << "\n"; }; return 0; };
typedef unsigned long long UVLONG UVLONG pp1,pp2; void init2() { for (int i = 0; i < 64; i++) { for (int j = 0; j < 64; j++) if (isPerfectSquare(i * 64 + j)) { pp1 |= (1 << j); pp2 |= (1 << i); break; } } cout << "pp1=" << pp1 << "," << pp2 << "\n"; } inline bool isPerfectSquare5(UVLONG x) { return pp1 & (1 << (x & 0x3F)) ? isPerfectSquare(x) : false; }
if (n < 11043908100L) { int i; float x2, y; x2 = n * 0.5F; y = n; i = Float.floatToRawIntBits(y); i = 0x5f375a86 - (i >> 1); y = Float.intBitsToFloat(i); y = y * (1.5F - (x2 * y * y)); y = y * (1.5F - (x2 * y * y)); sqrt = Math.round(1.0F / y); } else { sqrt = (long) Math.sqrt(n); }
public static boolean isSquare(final long val) { if ((val & 2) == 2 || (val & 7) == 5) { return false; } if ((val & 11) == 8 || (val & 31) == 20) { return false; } if ((val & 47) == 32 || (val & 127) == 80) { return false; } if ((val & 191) == 128 || (val & 511) == 320) { return false; } if (!modSq[(int) (val % modSq.length)]) { return false; } final long root = (long) Math.sqrt(val); return root * root == val; }
int main() { unsigned int c1=0 ,c2 = 0; unsigned int x = 0; unsigned int p = 0; int k1 = 0; scanf("%d",&p); if(p % 2 == 0) { x = p/2; } else { x = (p/2) +1; } while(x) { if((x*x) > p) { c1 = x; x = x/2; }else { c2 = x; break; } } if((p%2) != 0) c2++; while(c2 < c1) { if((c2 * c2 ) == p) { k1 = 1; break; } c2++; } if(k1) printf("\n Perfect square for %d", c2); else printf("\n Not perfect but nearest to :%d :", c2); return 0; }
public static void main(String[] args) { final int BITS = 16; BitSet foo = new BitSet(); for(int i = 0; i< (1<<BITS); i++) { int sq = (i*i); sq = sq & ((1<<BITS)-1); foo.set(sq); } System.out.println("int[] mayBeASquare = {"); for(int i = 0; i< 1<<(BITS-5); i++) { int kk = 0; for(int j = 0; j<32; j++) { if(foo.get((i << 5) | j)) { kk |= 1<<j; } } System.out.print("0x" + Integer.toHexString(kk) + ", "); if(i%8 == 7) System.out.println(); } System.out.println("};"); }
public static boolean isRootWhole(double number) { return Math.sqrt(number) % 1 == 0; }
int result = (int)(floor(sqrt(b)) - ceil(sqrt(a)) + 1);
if((n & 0x3L) == 0) { n >>=2; if((n & 0xffffffffL) == 0) n >>= 32; if((n & 0xffffL) == 0) n >>= 16; if((n & 0xffL) == 0) n >>= 8; if((n & 0xfL) == 0) n >>= 4; if((n & 0x3L) == 0) n >>= 2; }
public static boolean isIntRoot(int number) { return isIntRootHelper(number, 1); } private static boolean isIntRootHelper(int number, int index) { if (number == index) { return true; } if (number < index) { return false; } else { return isIntRootHelper(number - 2 * index, index + 1); } }
import java.io.StringWriter; import java.io.PrintWriter; StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); String sStackTrace = sw.toString(); System.out.println(sStackTrace);
StringWriter sw = new StringWriter(); e.printStackTrace(new PrintWriter(sw)); String exceptionAsString = sw.toString();
import android.util.Log; String stackTrace = Log.getStackTraceString(exception);
09-24 16:09:07.042: I/System.out(4844): java.lang.NullPointerException 09-24 16:09:07.042: I/System.out(4844): at com.temp.ttscancel.MainActivity.onCreate(MainActivity.java:43) 09-24 16:09:07.042: I/System.out(4844): at android.app.Activity.performCreate(Activity.java:5248) 09-24 16:09:07.043: I/System.out(4844): at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1110) 09-24 16:09:07.043: I/System.out(4844): at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2162) 09-24 16:09:07.043: I/System.out(4844): at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2257) 09-24 16:09:07.043: I/System.out(4844): at android.app.ActivityThread.access$800(ActivityThread.java:139) 09-24 16:09:07.043: I/System.out(4844): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1210) 09-24 16:09:07.043: I/System.out(4844): at android.os.Handler.dispatchMessage(Handler.java:102) 09-24 16:09:07.043: I/System.out(4844): at android.os.Looper.loop(Looper.java:136) 09-24 16:09:07.044: I/System.out(4844): at android.app.ActivityThread.main(ActivityThread.java:5097) 09-24 16:09:07.044: I/System.out(4844): at java.lang.reflect.Method.invokeNative(Native Method) 09-24 16:09:07.044: I/System.out(4844): at java.lang.reflect.Method.invoke(Method.java:515) 09-24 16:09:07.044: I/System.out(4844): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:785) 09-24 16:09:07.044: I/System.out(4844): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601)
public String stackTraceToString(Throwable e) { StringBuilder sb = new StringBuilder(); for (StackTraceElement element : e.getStackTrace()) { sb.append(element.toString()); sb.append("\n"); } return sb.toString(); }
String s = Throwables.getStackTraceAsString ( myException ) ;
import java.util.Arrays; Arrays.toString(e.getStackTrace());
public static String getStackTrace(Throwable t) { StringWriter sw = new StringWriter(); t.printStackTrace(new PrintWriter(sw)); return sw.toString(); }
catch (Exception e) { StackTraceElement[] stack = e.getStackTrace(); String exception = ""; for (StackTraceElement s : stack) { exception = exception + s.toString() + "\n\t\t"; } System.out.println(exception); }
import java.io.StringWriter; import java.io.PrintWriter; StringWriter sw = new StringWriter(); new Throwable().printStackTrace(new PrintWriter(sw)); logger.info("Current stack trace is:\n" + sw.toString());
} catch (Throwable t) { StringWriter sw = new StringWriter(); t.printStackTrace(new PrintWriter(sw)); logger.info("Current stack trace is:\n" + sw.toString()); }
import java.io.PrintWriter; import java.io.StringWriter; public class StackTraceUtils { public static String stackTraceToString(StackTraceElement[] stackTrace) { StringWriter sw = new StringWriter(); printStackTrace(stackTrace, new PrintWriter(sw)); return sw.toString(); } public static void printStackTrace(StackTraceElement[] stackTrace, PrintWriter pw) { for(StackTraceElement stackTraceEl : stackTrace) { pw.println(stackTraceEl); } } }
catch (Exception e) { ByteArrayOutputStream out = new ByteArrayOutputStream(); e.printStackTrace(new PrintStream(out)); String str = new String(out.toByteArray()); System.out.println(str); }
private String getCurrentStackTraceString() { StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); return Arrays.stream(stackTrace).map(StackTraceElement::toString) .collect(Collectors.joining("\n")); }
LOGGER.log(Level.SEVERE, "Query Builder Issue Stack Trace : {0} ,Message : {1} objid {2}", new Object[]{Arrays.toString(e.getStackTrace()), e.getMessage(),objId});
public static String getStackTrace(final Throwable throwable) { final StringWriter sw = new StringWriter(); final PrintWriter pw = new PrintWriter(sw, true); throwable.printStackTrace(pw); return sw.getBuffer().toString(); }
val Throwable.stackTraceString: String get() { val sw = StringWriter() val pw = PrintWriter(sw) this.printStackTrace(pw) return sw.toString() }
String trace = e.toString() + "\n"; for (StackTraceElement e1 : e.getStackTrace()) { trace += "\t at " + e1.toString() + "\n"; }
java.io.FileNotFoundException: / (Is a directory) at java.io.FileOutputStream.open0(Native Method) at java.io.FileOutputStream.open(FileOutputStream.java:270) at java.io.FileOutputStream.<init>(FileOutputStream.java:213) at java.io.FileOutputStream.<init>(FileOutputStream.java:101) at Test.main(Test.java:9)
java.io.FileNotFoundException: / (Is a directory) at java.io.FileOutputStream.open0(Native Method) at java.io.FileOutputStream.open(FileOutputStream.java:270) at java.io.FileOutputStream.<init>(FileOutputStream.java:213) at java.io.FileOutputStream.<init>(FileOutputStream.java:101) at Test.main(Test.java:9)
private String extrapolateStackTrace(Exception ex) { Throwable e = ex; String trace = e.toString() + "\n"; for (StackTraceElement e1 : e.getStackTrace()) { trace += "\t at " + e1.toString() + "\n"; } while (e.getCause() != null) { e = e.getCause(); trace += "Cause by: " + e.toString() + "\n"; for (StackTraceElement e1 : e.getStackTrace()) { trace += "\t at " + e1.toString() + "\n"; } } return trace; }
Arrays.stream(e.getStackTrace()) .map(s->s.toString()) .collect(Collectors.joining("\n"));
public StackTraceElement[] getStackTrace() { return getOurStackTrace().clone(); }
public String toString() { return getClassName() + "." + methodName + (isNativeMethod() ? "(Native Method)" : (fileName != null && lineNumber >= 0 ? "(" + fileName + ":" + lineNumber + ")" : (fileName != null ? "("+fileName+")" : "(Unknown Source)"))); }
Stream.of(e.getStackTrace()).map((a) -> a.toString()).collect(Collectors.joining("\n", "[", "]"))
import java.util.Arrays; try{ }catch(Exception ex){ String stack = Arrays.toString(ex.getStackTrace()); System.out.println("stack "+ stack); }
public static String getStackTraceString(Throwable e) { return getStackTraceString(e, ""); } private static String getStackTraceString(Throwable e, String indent) { StringBuilder sb = new StringBuilder(); sb.append(e.toString()); sb.append("\n"); StackTraceElement[] stack = e.getStackTrace(); if (stack != null) { for (StackTraceElement stackTraceElement : stack) { sb.append(indent); sb.append("\tat "); sb.append(stackTraceElement.toString()); sb.append("\n"); } } Throwable[] suppressedExceptions = e.getSuppressed(); if (suppressedExceptions != null) { for (Throwable throwable : suppressedExceptions) { sb.append(indent); sb.append("\tSuppressed: "); sb.append(getStackTraceString(throwable, indent + "\t")); } } Throwable cause = e.getCause(); if (cause != null) { sb.append(indent); sb.append("Caused by: "); sb.append(getStackTraceString(cause, indent)); } return sb.toString(); }
String packageNameToFilter = "org.springframework"; StringWriter sw = new StringWriter(); PrintWriter pw = new SelectivePrintWriter(sw, packageNameToFilter); e.printStackTrace(pw); String sStackTrace = sw.toString(); System.out.println(sStackTrace);
public class SelectivePrintWriter extends PrintWriter { private boolean on = true; private static final String AT = "\tat"; private String internal; public SelectivePrintWriter(Writer out, String packageOrClassName) { super(out); internal = "\tat " + packageOrClassName; } public void println(Object obj) { if (obj instanceof String) { String txt = (String) obj; if (!txt.startsWith(AT)) on = true; else if (txt.startsWith(internal)) on = false; if (on) super.println(txt); } else { super.println(obj); } } }
import java.io.PrintWriter; import java.io.StringWriter; public class PrintStackTrace { public static void main(String[] args) { try { int division = 0 / 0; } catch (ArithmeticException e) { StringWriter sw = new StringWriter(); e.printStackTrace(new PrintWriter(sw)); String exceptionAsString = sw.toString(); System.out.println(exceptionAsString); } } }
java.lang.ArithmeticException: / by zero at PrintStackTrace.main(PrintStackTrace.java:9)
public void remove(List<String> ids) { if(ids == null || ids.isEmpty()) { LOG.warn( "An empty list (or null) was passed to {}.remove(List). " + "Clearly, this call is unneccessary, the caller should " + "avoid making it. A stacktrace follows.", getClass().getName(), new Throwable ("Stacktrace") ); return; } }
/** @param stackTraceElements The elements to convert * @return The resulting string */ public static final String stackTraceElementsToStr(StackTraceElement[] stackTraceElements) { return stackTraceElementsToStr(stackTraceElements, "\n"); } /** @param stackTraceElements The elements to convert * @param lineSeparator The line separator to use * @return The resulting string */ public static final String stackTraceElementsToStr(StackTraceElement[] stackTraceElements, String lineSeparator) { return stackTraceElementsToStr(stackTraceElements, lineSeparator, ""); } /** @param stackTraceElements The elements to convert * @param lineSeparator The line separator to use * @param padding The string to be used at the start of each line * @return The resulting string */ public static final String stackTraceElementsToStr(StackTraceElement[] stackTraceElements, String lineSeparator, String padding) { String str = ""; if(stackTraceElements != null) { for(StackTraceElement stackTrace : stackTraceElements) { str += padding + (!stackTrace.toString().startsWith("Caused By") ? "\tat " : "") + stackTrace.toString() + lineSeparator; } } return str; } /** @param stackTraceElements The elements to convert * @return The resulting string */ public static final String stackTraceCausedByElementsOnlyToStr(StackTraceElement[] stackTraceElements) { return stackTraceCausedByElementsOnlyToStr(stackTraceElements, "\n"); } /** @param stackTraceElements The elements to convert * @param lineSeparator The line separator to use * @return The resulting string */ public static final String stackTraceCausedByElementsOnlyToStr(StackTraceElement[] stackTraceElements, String lineSeparator) { return stackTraceCausedByElementsOnlyToStr(stackTraceElements, lineSeparator, ""); } /** @param stackTraceElements The elements to convert * @param lineSeparator The line separator to use * @param padding The string to be used at the start of each line * @return The resulting string */ public static final String stackTraceCausedByElementsOnlyToStr(StackTraceElement[] stackTraceElements, String lineSeparator, String padding) { String str = ""; if(stackTraceElements != null) { for(StackTraceElement stackTrace : stackTraceElements) { str += (!stackTrace.toString().startsWith("Caused By") ? "" : padding + stackTrace.toString() + lineSeparator); } } return str; } /** @param e The {@link Throwable} to convert * @return The resulting String */ public static final String throwableToStrNoStackTraces(Throwable e) { return throwableToStrNoStackTraces(e, "\n"); } /** @param e The {@link Throwable} to convert * @param lineSeparator The line separator to use * @return The resulting String */ public static final String throwableToStrNoStackTraces(Throwable e, String lineSeparator) { return throwableToStrNoStackTraces(e, lineSeparator, ""); } /** @param e The {@link Throwable} to convert * @param lineSeparator The line separator to use * @param padding The string to be used at the start of each line * @return The resulting String */ public static final String throwableToStrNoStackTraces(Throwable e, String lineSeparator, String padding) { if(e == null) { return "null"; } String str = e.getClass().getName() + ": "; if((e.getMessage() != null) && !e.getMessage().isEmpty()) { str += e.getMessage() + lineSeparator; } else { str += lineSeparator; } str += padding + stackTraceCausedByElementsOnlyToStr(e.getStackTrace(), lineSeparator, padding); for(Throwable suppressed : e.getSuppressed()) { str += padding + throwableToStrNoStackTraces(suppressed, lineSeparator, padding + "\t"); } Throwable cause = e.getCause(); while(cause != null) { str += padding + "Caused by:" + lineSeparator + throwableToStrNoStackTraces(e.getCause(), lineSeparator, padding); cause = cause.getCause(); } return str; } /** @param e The {@link Throwable} to convert * @return The resulting String */ public static final String throwableToStr(Throwable e) { return throwableToStr(e, "\n"); } /** @param e The {@link Throwable} to convert * @param lineSeparator The line separator to use * @return The resulting String */ public static final String throwableToStr(Throwable e, String lineSeparator) { return throwableToStr(e, lineSeparator, ""); } /** @param e The {@link Throwable} to convert * @param lineSeparator The line separator to use * @param padding The string to be used at the start of each line * @return The resulting String */ public static final String throwableToStr(Throwable e, String lineSeparator, String padding) { if(e == null) { return "null"; } String str = padding + e.getClass().getName() + ": "; if((e.getMessage() != null) && !e.getMessage().isEmpty()) { str += e.getMessage() + lineSeparator; } else { str += lineSeparator; } str += padding + stackTraceElementsToStr(e.getStackTrace(), lineSeparator, padding); for(Throwable suppressed : e.getSuppressed()) { str += padding + "Suppressed: " + throwableToStr(suppressed, lineSeparator, padding + "\t"); } Throwable cause = e.getCause(); while(cause != null) { str += padding + "Caused by:" + lineSeparator + throwableToStr(e.getCause(), lineSeparator, padding); cause = cause.getCause(); } return str; }
try(InputStream in = new FileInputStream(file)) { ... } catch(IOException e) { String exceptionToString = throwableToStr(e); someLoggingUtility.println(exceptionToString); ... }
java.io.FileNotFoundException: C:\test.txt (The system cannot find the file specified) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(Unknown Source) at java.io.FileInputStream.<init>(Unknown Source) at com.gmail.br45entei.Example.main(Example.java:32)
try { int zero = 1 - 1; int a = 1/zero; } catch (Exception e) { e.printStackTrace(); }
public static void main(String... args) { // System.out.println("Hello World!"); }
\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020\u0020 \u0063\u006c\u0061\u0073\u0073\u0020\u0055\u0067\u006c\u0079 \u007b\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020 \u0020\u0020\u0020\u0020\u0073\u0074\u0061\u0074\u0069\u0063 \u0076\u006f\u0069\u0064\u0020\u006d\u0061\u0069\u006e\u0028 \u0053\u0074\u0072\u0069\u006e\u0067\u005b\u005d\u0020\u0020 \u0020\u0020\u0020\u0020\u0061\u0072\u0067\u0073\u0029\u007b \u0053\u0079\u0073\u0074\u0065\u006d\u002e\u006f\u0075\u0074 \u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0020 \u0022\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u0022\u002b \u0022\u006f\u0072\u006c\u0064\u0022\u0029\u003b\u007d\u007d
public static void main(String... args) { System.out.println("Hello World!"); }
class GalleryImage implements Serializable { private Image image; private transient Image thumbnailImage; private void generateThumbnail() { } private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException { inputStream.defaultReadObject(); generateThumbnail(); } }
package javabeat.samples; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; class NameStore implements Serializable{ private String firstName; private transient String middleName; private String lastName; public NameStore (String fName, String mName, String lName){ this.firstName = fName; this.middleName = mName; this.lastName = lName; } public String toString(){ StringBuffer sb = new StringBuffer(40); sb.append("First Name : "); sb.append(this.firstName); sb.append("Middle Name : "); sb.append(this.middleName); sb.append("Last Name : "); sb.append(this.lastName); return sb.toString(); } } public class TransientExample{ public static void main(String args[]) throws Exception { NameStore nameStore = new NameStore("Steve", "Middle","Jobs"); ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream("nameStore")); o.writeObject(nameStore); o.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream("nameStore")); NameStore nameStore1 = (NameStore)in.readObject(); System.out.println(nameStore1); } }
public class Foo implements Serializable { private String attr1; private String attr2; ... }
public abstract class BaseJob implements Serializable{ public void ShouldRetryRun(){} } public class SyncOrganizationJob extends BaseJob { public String organizationName; public Boolean isSynced @Inject transient RemoteDataSource remoteDataSource; @Inject transient LocalDaoSource localDataSource; public SyncOrganizationJob(String organizationName) { super(new Params(BACKGROUND).groupBy(GROUP).requireNetwork().persist()); this.organizationName = organizationName; this.isSynced=isSynced; } }
PrintWriter writer = new PrintWriter("the-file-name.txt", "UTF-8"); writer.println("The first line"); writer.println("The second line"); writer.close();
byte data[] = ... FileOutputStream out = new FileOutputStream("the-file-name"); out.write(data); out.close();
List<String> lines = Arrays.asList("The first line", "The second line"); Path file = Paths.get("the-file-name.txt"); Files.write(file, lines, Charset.forName("UTF-8"));
byte data[] = ... Path file = Paths.get("the-file-name"); Files.write(file, data);
try (Writer writer = new BufferedWriter(new OutputStreamWriter( new FileOutputStream("filename.txt"), "utf-8"))) { writer.write("something"); }
Writer writer = null; try { writer = new BufferedWriter(new OutputStreamWriter( new FileOutputStream("filename.txt"), "utf-8")); writer.write("Something"); } catch (IOException ex) { } finally { try {writer.close();} catch (Exception ex) { } }
Charset utf8 = StandardCharsets.UTF_8; List<String> lines = Arrays.asList("1st line", "2nd line"); byte[] data = {1, 2, 3, 4, 5}; try { Files.write(Paths.get("file1.bin"), data); Files.write(Paths.get("file2.bin"), data, StandardOpenOption.CREATE, StandardOpenOption.APPEND); Files.write(Paths.get("file3.txt"), "content".getBytes()); Files.write(Paths.get("file4.txt"), "content".getBytes(utf8)); Files.write(Paths.get("file5.txt"), lines, utf8); Files.write(Paths.get("file6.txt"), lines, utf8, StandardOpenOption.CREATE, StandardOpenOption.APPEND); } catch (IOException e) { e.printStackTrace(); }
public class Program { public static void main(String[] args) { String text = "Hello world"; BufferedWriter output = null; try { File file = new File("example.txt"); output = new BufferedWriter(new FileWriter(file)); output.write(text); } catch ( IOException e ) { e.printStackTrace(); } finally { if ( output != null ) { output.close(); } } } }
import java.io.BufferedWriter; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.io.Writer; public class writer { public void writing() { try { File statText = new File("E:/Java/Reference/bin/images/statsTest.txt"); FileOutputStream is = new FileOutputStream(statText); OutputStreamWriter osw = new OutputStreamWriter(is); Writer w = new BufferedWriter(osw); w.write("POTATO!!!"); w.close(); } catch (IOException e) { System.err.println("Problem writing to the file statsTest.txt"); } } public static void main(String[]args) { writer write = new writer(); write.writing(); } }
try (Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("myFile.txt"), StandardCharsets.UTF_8))) { writer.write("text to write"); } catch (IOException ex) { }
import java.io.BufferedWriter; import java.io.File; import java.io.FileWriter; public class CreateFiles { public static void main(String[] args) { try{ String content = "This is the content to write into create file"; String path="D:\\a\\hi.txt"; File file = new File(path); if (!file.exists()) { file.createNewFile(); } FileWriter fw = new FileWriter(file.getAbsoluteFile()); BufferedWriter bw = new BufferedWriter(fw); bw.write(content); bw.close(); } catch(Exception e){ System.out.println(e); } } }
String content = "This is the content to write into a file"; File file = new File("filename.txt"); FileWriter fw = new FileWriter(file.getAbsoluteFile()); BufferedWriter bw = new BufferedWriter(fw); bw.write(content); bw.close();
Path file = ...; List<String> linesInMemory = ...; Files.write(file, linesInMemory, StandardCharsets.UTF_8);
Path file = ...; List<String> linesInMemory = ...; Files.write(file, linesInMemory, Charset.forName("desired charset"), StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE);
Path file = ...; try (BufferedWriter writer = Files.newBufferedWriter(file)) { writer.append("Zero header: ").append( [...] }
Path file = ...; try (BufferedWriter writer = Files.newBufferedWriter(file, Charset.forName("desired charset"), StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) { writer.write("----------"); [...] }
try { File myFile = new File("testfile.txt"); if ( myFile.createNewFile() ) { System.out.println("Success!"); } else { System.out.println("Failure!"); } } catch ( IOException ioe ) { ioe.printStackTrace(); }
JFileChooser c = new JFileChooser(); c.showOpenDialog(c); File writeFile = c.getSelectedFile(); String content = "Input the data here to be written to your file"; try { FileWriter fw = new FileWriter(writeFile); BufferedWriter bw = new BufferedWriter(fw); bw.append(content); bw.append("hiiiii"); bw.close(); fw.close(); } catch (Exception exc) { System.out.println(exc); }
FileWriter fr = new FileWriter("your_file_name.txt"); fr.write("Things you want to write into the file"); fr.close();
System.out.println("Choose folder to create file"); JFileChooser c = new JFileChooser(); c.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY); c.showOpenDialog(c); c.getSelectedFile(); f = c.getSelectedFile(); String newfile = f + "\\hi.doc"; File file = new File(newfile); try { boolean flag = file.createNewFile(); if(flag == true) { JOptionPane.showMessageDialog(rootPane, "File created successfully"); } else { JOptionPane.showMessageDialog(rootPane, "File already exists"); } /* Or use exists() function as follows: if(file.exists() == true) { JOptionPane.showMessageDialog(rootPane, "File already exists"); } else { JOptionPane.showMessageDialog(rootPane, "File created successfully"); } */ } catch(Exception e) { }
import java.io.File; import java.io.FileWriter; import java.io.IOException; public class FileWriterExample { public static void main(String [] args) { FileWriter fw= null; File file =null; try { file=new File("WriteFile.txt"); if(!file.exists()) { file.createNewFile(); } fw = new FileWriter(file); fw.write("This is an string written to a file"); fw.flush(); fw.close(); System.out.println("File written Succesfully"); } catch (IOException e) { e.printStackTrace(); } } }
package fileoperations; import java.io.File; import java.io.IOException; public class SimpleFile { public static void main(String[] args) throws IOException { File file =new File("text.txt"); file.createNewFile(); System.out.println("File is created"); FileWriter writer = new FileWriter(file); writer.write("Enter the text that you want to write"); writer.flush(); writer.close(); System.out.println("Data is entered into file"); } }
try { File fout = new File("myOutFile.txt"); FileOutputStream fos = new FileOutputStream(fout); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos)); bw.write("Write somthing to the file ..."); bw.newLine(); bw.close(); } catch (FileNotFoundException e){ e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }
try { FileWriter fw = new FileWriter("myOutFile.txt"); fw.write("Example of content"); fw.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }
try { PrintWriter pw = new PrintWriter("myOutFile.txt"); pw.write("Example of content"); pw.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }
try { File fout = new File("myOutFile.txt"); FileOutputStream fos = new FileOutputStream(fout); OutputStreamWriter osw = new OutputStreamWriter(fos); osw.write("Soe content ..."); osw.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }
import java.nio.file.Files; import java.nio.file.Paths; Files.write(Paths.get(path), lines.getBytes());
Path sampleOutputPath = Paths.get("/tmp/testfile") try (BufferedWriter writer = Files.newBufferedWriter(sampleOutputPath)) { writer.write("Hello, world!"); }
public static void main(String[] args) { Path FILE_PATH = Paths.get("C:/temp", "temp.txt"); String text = "\n Welcome to Java 8"; try (BufferedWriter writer = Files.newBufferedWriter(FILE_PATH, StandardCharsets.UTF_8, StandardOpenOption.APPEND)) { writer.write(text); } catch (IOException e) { e.printStackTrace(); } }
try { Stream<String> lines = Files.lines(FILE_PATH); Optional<String> containsJava = lines.filter(l->l.contains("confidential")).findFirst(); if(containsJava.isPresent()){ System.out.println(containsJava.get()); } } catch (IOException e) { e.printStackTrace(); }
import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; public class WriteAFile { public static void main(String args[]) { try { byte array [] = { OutputStream os = new FileOutputStream("test.txt"); for(int x=0; x < array.length ; x++) { os.write( array[x] ); } os.close(); InputStream is = new FileInputStream("test.txt"); int size = is.available(); for(int i=0; i< size; i++) { System.out.print((char)is.read() + " "); } is.close(); } catch(IOException e) { System.out.print("Exception"); } } }
Path file = ...; byte[] buf = ...; Files.write(file, buf);
Files.write(Paths.get("./output.txt"), "Information string herer".getBytes());
File file = new File("filename.txt"); PrintWriter pw = new PrintWriter(file); pw.write("The world I pw.close(); String write = "Hello World!"; FileWriter fw = new FileWriter(file); BufferedWriter bw = new BufferedWriter(fw); fw.write(write); fw.close();
File file = new File(System.*getProperty*("java.io.tmpdir") + System.*getProperty*("file.separator") + "YourFileName.txt");
import java.io.BufferedWriter; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; public class WriteFile{ public static void main(String[] args) throws IOException { String file = "text.txt"; System.out.println("Writing to file: " + file); try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(file))) { writer.write("Java\n"); writer.write("Python\n"); writer.write("Clojure\n"); writer.write("Scala\n"); writer.write("JavaScript\n"); } } }
public void saveDataInFile(String data) throws IOException { Path path = Paths.get(fileName); byte[] strToBytes = data.getBytes(); Files.write(path, strToBytes); }
public void saveDataInFile(String data) throws IOException { RandomAccessFile stream = new RandomAccessFile(fileName, "rw"); FileChannel channel = stream.getChannel(); byte[] strBytes = data.getBytes(); ByteBuffer buffer = ByteBuffer.allocate(strBytes.length); buffer.put(strBytes); buffer.flip(); channel.write(buffer); stream.close(); channel.close(); }
public void saveDataInFile(String data) throws IOException { FileOutputStream fos = new FileOutputStream(fileName); DataOutputStream outStream = new DataOutputStream(new BufferedOutputStream(fos)); outStream.writeUTF(data); outStream.close(); }
public void saveDataInFile(String data) throws IOException { FileOutputStream outputStream = new FileOutputStream(fileName); byte[] strToBytes = data.getBytes(); outputStream.write(strToBytes); outputStream.close(); }
public void saveDataInFile() throws IOException { FileWriter fileWriter = new FileWriter(fileName); PrintWriter printWriter = new PrintWriter(fileWriter); printWriter.print("Some String"); printWriter.printf("Product name is %s and its price is %d $", "iPhone", 1000); printWriter.close(); }
public void saveDataInFile(String data) throws IOException { BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); writer.write(data); writer.close(); }
public void saveDataInFile(String data) throws IOException { BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, true)); writer.append( writer.append(data); writer.close(); }
package com.zetcode.writetofileex; import com.google.common.io.Files; import java.io.File; import java.io.IOException; public class WriteToFileEx { public static void main(String[] args) throws IOException { String fileName = "fruits.txt"; File file = new File(fileName); String content = "banana, orange, lemon, apple, plum"; Files.write(content.getBytes(), file); } }
private void writeFile(){ JFileChooser fileChooser = new JFileChooser(this.PATH); int retValue = fileChooser.showDialog(this, "Save File"); if (retValue == JFileChooser.APPROVE_OPTION){ try (Writer fileWrite = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileChooser.getSelectedFile())))){ this.customers.forEach((c) ->{ try{ fileWrite.append(c.toString()).append("\n"); } catch (IOException ex){ ex.printStackTrace(); } }); } catch (IOException e){ e.printStackTrace(); } } }
try { File file = new File ("c:/new-file.txt"); if(file.createNewFile()) { System.out.println("Successful created!"); } else { System.out.println("Failed to create!"); } } catch (IOException e) { e.printStackTrace(); }
new DefaultCamelContext().addRoutes(new RouteBuilder() { public void configure() { from("jms:incomingMessages") .choice() .when(header("CamelFileName") .endsWith(".xml")) .to("jms:xmlMessages") .when(header("CamelFileName") .endsWith(".csv")) .to("ftp:csvMessages"); }
from("servlet:item-delta?matchOnUriPrefix=true&httpMethodRestrict=POST") .split(stax(Product.class)) /*.parallelProcessing()*/ .process(itemDeltaProcessor);
from("servlet:item-delta?matchOnUriPrefix=true&httpMethodRestrict=POST") .routeId("Item-DeltaRESTRoute") .log(LoggingLevel.INFO, "Item Delta received on Item-DeltaRESTRoute") .split(stax(Product.class)) .parallelProcessing() .process(itemDeltaProcessor);
from("jetty: .log(LoggingLevel.INFO, "searchProducts request Received with body: ${body}") .bean(Processor.class, "createSearchProductsRequest").removeHeaders("CamelHttp*") .setHeader(Exchange.HTTP_METHOD, constant(org.apache.camel.component.http4.HttpMethods.POST)) .to("http4: + "&bridgeEndpoint=true") .bean(Processor.class, "buildResponse").log(LoggingLevel.INFO, "Search products finished");
<route id="GROUPS-SHOW"> <from uri="jetty: <log loggingLevel="INFO" message="Reqeust receviced service to fetch groups -> ${body}" /> <to uri="direct:auditLog" /> <process ref="TestProcessor" /> </route>
-from-->To - from-->process-->to - from-->bean-->to - from-->process-->bean-->to -from-->marshal-->process-->unmarshal-->to
void f(String[] first, String[] second) { String[] both = ??? }
String[] both = (String[])ArrayUtils.addAll(first, second);
public <T> T[] concatenate(T[] a, T[] b) { int aLen = a.length; int bLen = b.length; @SuppressWarnings("unchecked") T[] c = (T[]) Array.newInstance(a.getClass().getComponentType(), aLen + bLen); System.arraycopy(a, 0, c, 0, aLen); System.arraycopy(b, 0, c, aLen, bLen); return c; }
public static <T> T concatenate(T a, T b) { if (!a.getClass().isArray() || !b.getClass().isArray()) { throw new IllegalArgumentException(); } Class<?> resCompType; Class<?> aCompType = a.getClass().getComponentType(); Class<?> bCompType = b.getClass().getComponentType(); if (aCompType.isAssignableFrom(bCompType)) { resCompType = aCompType; } else if (bCompType.isAssignableFrom(aCompType)) { resCompType = bCompType; } else { throw new IllegalArgumentException(); } int aLen = Array.getLength(a); int bLen = Array.getLength(b); @SuppressWarnings("unchecked") T result = (T) Array.newInstance(resCompType, aLen + bLen); System.arraycopy(a, 0, result, 0, aLen); System.arraycopy(b, 0, result, aLen, bLen); return result; }
Assert.assertArrayEquals(new int[] { 1, 2, 3 }, concatenate(new int[] { 1, 2 }, new int[] { 3 })); Assert.assertArrayEquals(new Number[] { 1, 2, 3f }, concatenate(new Integer[] { 1, 2 }, new Number[] { 3f }));
public static <T> T[] concat(T[] first, T[] second) { T[] result = Arrays.copyOf(first, first.length + second.length); System.arraycopy(second, 0, result, first.length, second.length); return result; }
public static <T> T[] concatAll(T[] first, T[]... rest) { int totalLength = first.length; for (T[] array : rest) { totalLength += array.length; } T[] result = Arrays.copyOf(first, totalLength); int offset = first.length; for (T[] array : rest) { System.arraycopy(array, 0, result, offset, array.length); offset += array.length; } return result; }
String[] both = Stream.concat(Arrays.stream(a), Arrays.stream(b)) .toArray(String[]::new);
String[] both = Stream.of(a, b).flatMap(Stream::of) .toArray(String[]::new);
String[] both = ObjectArrays.concat(first, second, String.class);
String[] f(String[] first, String[] second) { List<String> both = new ArrayList<String>(first.length + second.length); Collections.addAll(both, first); Collections.addAll(both, second); return both.toArray(new String[both.size()]); }
static String[] concat(String[]... arrays) { int length = 0; for (String[] array : arrays) { length += array.length; } String[] result = new String[length]; int pos = 0; for (String[] array : arrays) { for (String element : array) { result[pos] = element; pos++; } } return result; }
private static <T> T[] concat(T[] a, T[] b) { final int alen = a.length; final int blen = b.length; if (alen == 0) { return b; } if (blen == 0) { return a; } final T[] result = (T[]) java.lang.reflect.Array. newInstance(a.getClass().getComponentType(), alen + blen); System.arraycopy(a, 0, result, 0, alen); System.arraycopy(b, 0, result, alen, blen); return result; }
String[] both = Arrays.copyOf(first, first.length + second.length); System.arraycopy(second, 0, both, first.length, second.length);
Array<String> both = array(first).append(array(second));
ArrayList<String> both = new ArrayList(Arrays.asList(first)); both.addAll(Arrays.asList(second)); both.toArray(new String[0]);
static <T> T[] concat(T[] a, T[] b) { final int alen = a.length; final int blen = b.length; final T[] result = (T[]) java.lang.reflect.Array. newInstance(a.getClass().getComponentType(), alen + blen); System.arraycopy(a, 0, result, 0, alen); System.arraycopy(b, 0, result, alen, blen); return result; }
public String[] concatString(String[] a, String[] b){ Stream<String> streamA = Arrays.stream(a); Stream<String> streamB = Arrays.stream(b); return Stream.concat(streamA, streamB).toArray(String[]::new); }
public static String[] combineString(String[] first, String[] second){ int length = first.length + second.length; String[] result = new String[length]; System.arraycopy(first, 0, result, 0, first.length); System.arraycopy(second, 0, result, first.length, second.length); return result; }
public static int[] combineInt(int[] a, int[] b){ int length = a.length + b.length; int[] result = new int[length]; System.arraycopy(a, 0, result, 0, a.length); System.arraycopy(b, 0, result, a.length, b.length); return result; }
public static void main(String[] args) { String [] first = {"a", "b", "c"}; String [] second = {"d", "e"}; String [] joined = combineString(first, second); System.out.println("concatenated String array : " + Arrays.toString(joined)); int[] array1 = {101,102,103,104}; int[] array2 = {105,106,107,108}; int[] concatenateInt = combineInt(array1, array2); System.out.println("concatenated Int array : " + Arrays.toString(concatenateInt)); } }
@SuppressWarnings("unchecked") public static <T> T[] concat(T[]... inputArrays) { if(inputArrays.length < 2) { throw new IllegalArgumentException("inputArrays must contain at least 2 arrays"); } for(int i = 0; i < inputArrays.length; i++) { if(inputArrays[i] == null) { throw new IllegalArgumentException("inputArrays[" + i + "] is null"); } } int totalLength = 0; for(T[] array : inputArrays) { totalLength += array.length; } T[] result = (T[]) Array.newInstance(inputArrays[0].getClass().getComponentType(), totalLength); int offset = 0; for(T[] array : inputArrays) { System.arraycopy(array, 0, result, offset, array.length); offset += array.length; } return result; }
List list = new ArrayList(Arrays.asList(first)); list.addAll(Arrays.asList(second)); String[] both = list.toArray();
public class Array { public static <T> T[] concat(T[] a, T[] b, ArrayBuilderI<T> builder) { T[] c = builder.build(a.length + b.length); System.arraycopy(a, 0, c, 0, a.length); System.arraycopy(b, 0, c, a.length, b.length); return c; } }
public interface ArrayBuilderI<T> { public T[] build(int size); }
public class IntegerArrayBuilder implements ArrayBuilderI<Integer> { @Override public Integer[] build(int size) { return new Integer[size]; } }
@Test public class ArrayTest { public void array_concatenation() { Integer a[] = new Integer[]{0,1}; Integer b[] = new Integer[]{2,3}; Integer c[] = Array.concat(a, b, new IntegerArrayBuilder()); assertEquals(4, c.length); assertEquals(0, (int)c[0]); assertEquals(1, (int)c[1]); assertEquals(2, (int)c[2]); assertEquals(3, (int)c[3]); } }
String [] arg1 = new String{"a","b","c"}; String [] arg2 = new String{"x","y","z"}; ArrayList<String> temp = new ArrayList<String>(); temp.addAll(Arrays.asList(arg1)); temp.addAll(Arrays.asList(arg2)); String [] concatedArgs = temp.toArray(new String[arg1.length+arg2.length]);
public class StringConcatenate { public static void main(String[] args){ String[] arr1 = new String[]{"s","t","r","i","n","g"}; String[] arr2 = new String[]{"s","t","r","i","n","g"}; String[] arrBoth = new String[arr1.length+arr2.length]; for(int i = 0; i < arr1.length; i++){ arrBoth[i] = arr1[i]; } for(int j = arr1.length;j < arrBoth.length;j++){ arrBoth[j] = arr2[j-arr1.length]; } for(int k = 0; k < arrBoth.length; k++){ System.out.print(arrBoth[k]); } System.out.println(); } }
public String[] mergeArrays(String[] mainArray, String[] addArray) { String[] finalArray = new String[mainArray.length + addArray.length]; System.arraycopy(mainArray, 0, finalArray, 0, mainArray.length); System.arraycopy(addArray, 0, finalArray, mainArray.length, addArray.length); return finalArray; }
public static class Array { public static <T> T[] concat(T[]... arrays) { ArrayList<T> al = new ArrayList<T>(); for (T[] one : arrays) Collections.addAll(al, one); return (T[]) al.toArray(arrays[0].clone()); } }
public static <T> T[] concatAll(T[] first, T[]... rest) { int totalLength = first.length; for (T[] array : rest) { totalLength += array.length; } T[] result; try { Method arraysCopyOf = Arrays.class.getMethod("copyOf", Object[].class, int.class); result = (T[]) arraysCopyOf.invoke(null, first, totalLength); } catch (Exception e){ result = (T[]) java.lang.reflect.Array.newInstance(first.getClass().getComponentType(), totalLength); System.arraycopy(first, 0, result, 0, first.length); } int offset = first.length; for (T[] array : rest) { System.arraycopy(array, 0, result, offset, array.length); offset += array.length; } return result; }
private static <T> T[] addAll(final T[] f, final T...o){ return new AbstractList<T>(){ @Override public T get(int i) { return i>=f.length ? o[i - f.length] : f[i]; } @Override public int size() { return f.length + o.length; } }.toArray(f); }
public String[] combineArray (String[] ... strings) { List<String> tmpList = new ArrayList<String>(); for (int i = 0; i < strings.length; i++) tmpList.addAll(Arrays.asList(strings[i])); return tmpList.toArray(new String[tmpList.size()]); }
public static String[] join(String[]...arrays) { final List<String> output = new ArrayList<String>(); for(String[] array : arrays) { output.addAll(Arrays.asList(array)); } return output.toArray(new String[output.size()]); }
String[] join(String[]... arrays) { int size = 0; for (String[] array : arrays) { size += array.length; } java.util.List list = new java.util.ArrayList(size); for (String[] array : arrays) { list.addAll(java.util.Arrays.asList(array)); } return list.toArray(new String[size]); }
ArrayList baseArray = new ArrayList(Arrays.asList(array1)); baseArray.addAll(Arrays.asList(array2)); String concatenated[] = (String []) baseArray.toArray(new String[baseArray.size()]);
public String[] concat(String[]... arrays) { int length = 0; for (String[] array : arrays) { length += array.length; } String[] result = new String[length]; int destPos = 0; for (String[] array : arrays) { System.arraycopy(array, 0, result, destPos, array.length); destPos += array.length; } return result; }
String [] both = new ArrayList<String>(){{addAll(Arrays.asList(first)); addAll(Arrays.asList(second));}}.toArray(new String[0]);
@SuppressWarnings("unchecked") public static <T> T[] join(T[]...arrays) { final List<T> output = new ArrayList<T>(); for(T[] array : arrays) { output.addAll(Arrays.asList(array)); } return output.toArray((T[])Array.newInstance( arrays[0].getClass().getComponentType(), output.size())); }
list.setOnCreateContextMenuListener(new OnCreateContextMenuListener() { public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) { } });
list.setOnCreateContextMenuListener(new OnCreateContextMenuListener() { public void onCreateContextMenu(ContextMenu arg1, View arg2, ContextMenuInfo arg3) { } });
<properties> ... <maven.compiler.source>1.8</maven.compiler.source> <maven.compiler.target>1.8</maven.compiler.target> </properties>
public class IsInstanceOfTest { public static void main(final String[] args) { String s; s = ""; System.out.println((s instanceof String)); System.out.println(String.class.isInstance(s)); s = null; System.out.println((s instanceof String)); System.out.println(String.class.isInstance(s)); } }
public class Test { public static void test(A a) { System.out.println("a instanceof A: " + (a instanceof A)); } public static void test(B b) { } }
public static void main(String[] args) { if(lista != null && lista instanceof ArrayList) { System.out.println("In if block"); } else { System.out.println("In else block"); } }
public static void main(String[] args) { if(lista instanceof ArrayList){ System.out.println("In if block"); } else { System.out.println("In else block"); } }
[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\JavaSoft\Java Development Kit] "CurrentVersion"="1.6" [HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\JavaSoft\Java Development Kit\1.6] "JavaHome"="C:\\Program Files\\Java\\jdk1.6.0_23"
C:\Windows\system32;C:\Windows\%^^&^&^............(old path setting)
C:\Program Files\Java\jdk1.6.0_18\bin;C:\Windows\system32;C:\Windows\%^^&^&^............(old path setting)
DecimalFormat df = new DecimalFormat(" df.format(0.912385);
DecimalFormat df = new DecimalFormat(" df.setRoundingMode(RoundingMode.CEILING); for (Number n : Arrays.asList(12, 123.12345, 0.23, 0.1, 2341234.212431324)) { Double d = n.doubleValue(); System.out.println(df.format(d)); }
new BigDecimal(String.valueOf(double)).setScale(yourScale, BigDecimal.ROUND_HALF_UP);
package trials; import java.math.BigDecimal; public class Trials { public static void main(String[] args) { int yourScale = 10; System.out.println(BigDecimal.valueOf(0.42344534534553453453-0.42324534524553453453).setScale(yourScale, BigDecimal.ROUND_HALF_UP)); }
DecimalFormat df = new DecimalFormat(" df.format(0.912385);
public class RoundingCounterExample { static float roundOff(float x, int position) { float a = x; double temp = Math.pow(10.0, position); a *= temp; a = Math.round(a); return (a / (float)temp); } public static void main(String[] args) { float a = roundOff(0.0009434f,3); System.out.println("a="+a+" (a % .001)="+(a % 0.001)); int count = 0, errors = 0; for (double x = 0.0; x < 1; x += 0.0001) { count++; double d = x; int scale = 2; double factor = Math.pow(10, scale); d = Math.round(d * factor) / factor; if ((d % 0.01) != 0.0) { System.out.println(d + " " + (d % 0.01)); errors++; } } System.out.println(count + " trials " + errors + " errors"); } }
public static void main(String[] args) { int count = 0, errors = 0; int scale = 2; double factor = Math.pow(10, scale); MathContext mc = new MathContext(16, RoundingMode.DOWN); for (double x = 0.0; x < 1; x += 0.0001) { count++; double d = x; d = Math.round(d * factor) / factor; BigDecimal bd = new BigDecimal(d, mc); bd = bd.remainder(new BigDecimal("0.01"), mc); if (bd.multiply(BigDecimal.valueOf(100)).remainder(BigDecimal.ONE, mc).compareTo(BigDecimal.ZERO) != 0) { System.out.println(d + " " + bd); errors++; } } System.out.println(count + " trials " + errors + " errors"); }
BigDecimal bd = new BigDecimal(d).setScale(2, RoundingMode.HALF_EVEN); d = bd.doubleValue();
double d = 3.76628729; DecimalFormat newFormat = new DecimalFormat(" double twoDecimal = Double.valueOf(newFormat.format(d));
BigDecimal bd = new BigDecimal(Double.toString(d)); bd = bd.setScale(decimalPlace, BigDecimal.ROUND_HALF_UP); return bd.doubleValue();
double myNum = .912385; int precision = 10000; myNum= Math.floor(myNum * precision +.5)/precision;
DecimalFormat df = new DecimalFormat(" df.format(0.912385);
DecimalFormat df = new DecimalFormat(" df.format(0.912385);
DecimalFormat df = new DecimalFormat(" df.format(0.912385);
DecimalFormat df = new DecimalFormat(" df.format(0.912385);
public static double round(double valueToRound, int numberOfDecimalPlaces) { double multipicationFactor = Math.pow(10, numberOfDecimalPlaces); double interestedInZeroDPs = valueToRound * multipicationFactor; return Math.round(interestedInZeroDPs) / multipicationFactor; }
DecimalFormat df = new DecimalFormat(" df.setRoundingMode(RoundingMode.HALF_UP); String str1 = df.format(0.912385));
String str2 = new BigDecimal(0.912385) .setScale(5, BigDecimal.ROUND_HALF_UP) .toString();
double rounded = Precision.round(0.912385, 5, BigDecimal.ROUND_HALF_UP);
double rounded = Functions.round(0.00001).apply(0.912385)
public static double round(double value, int precision) { int scale = (int) Math.pow(10, precision); return (double) Math.round(value * scale) / scale; }
BigDecimal value = new BigDecimal("2.3"); value = value.setScale(0, RoundingMode.UP); BigDecimal value1 = new BigDecimal("-2.3"); value1 = value1.setScale(0, RoundingMode.UP); System.out.println(value + "n" + value1);
public static double round(double x, int scale) { return round(x, scale, BigDecimal.ROUND_HALF_UP); } public static double round(double x, int scale, int roundingMethod) { try { return (new BigDecimal (Double.toString(x)) .setScale(scale, roundingMethod)) .doubleValue(); } catch (NumberFormatException ex) { if (Double.isInfinite(x)) { return x; } else { return Double.NaN; } } }
public static final int DECIMAL_PLACES = 2; NumberFormatter formatter = new NumberFormatter(DECIMAL_PLACES); String value = formatter.format(9.319); String value2 = formatter.format(0.0000005); String value3 = formatter.format(1324134123); double parsedValue1 = formatter.parse("0,4E-2", 0); double parsedValue2 = formatter.parse("0,002", 0); double parsedValue3 = formatter.parse("3423,12345", 0);
import java.math.RoundingMode; import java.text.DecimalFormat; import java.text.DecimalFormatSymbols; import java.text.ParseException; import java.util.Locale; public class NumberFormatter { private static final String SYMBOL_INFINITE = "\u221e"; private static final char SYMBOL_MINUS = private static final char SYMBOL_ZERO = private static final int DECIMAL_LEADING_GROUPS = 10; private static final int EXPONENTIAL_INT_THRESHOLD = 1000000000; private static final double EXPONENTIAL_DEC_THRESHOLD = 0.0001; private DecimalFormat decimalFormat; private DecimalFormat decimalFormatLong; private DecimalFormat exponentialFormat; private char groupSeparator; public NumberFormatter(int decimalPlaces) { configureDecimalPlaces(decimalPlaces); } public void configureDecimalPlaces(int decimalPlaces) { if (decimalPlaces <= 0) { throw new IllegalArgumentException("Invalid decimal places"); } DecimalFormatSymbols separators = new DecimalFormatSymbols(Locale.getDefault()); separators.setMinusSign(SYMBOL_MINUS); separators.setZeroDigit(SYMBOL_ZERO); groupSeparator = separators.getGroupingSeparator(); StringBuilder decimal = new StringBuilder(); StringBuilder exponential = new StringBuilder("0."); for (int i = 0; i < DECIMAL_LEADING_GROUPS; i++) { decimal.append(" } for (int i = 0; i < decimalPlaces; i++) { decimal.append(" exponential.append("0"); } exponential.append("E0"); decimalFormat = new DecimalFormat(decimal.toString(), separators); decimalFormatLong = new DecimalFormat(decimal.append(" exponentialFormat = new DecimalFormat(exponential.toString(), separators); decimalFormat.setRoundingMode(RoundingMode.HALF_UP); decimalFormatLong.setRoundingMode(RoundingMode.HALF_UP); exponentialFormat.setRoundingMode(RoundingMode.HALF_UP); } public String format(double value) { String result; if (Double.isNaN(value)) { result = ""; } else if (Double.isInfinite(value)) { result = String.valueOf(SYMBOL_INFINITE); } else { double absValue = Math.abs(value); if (absValue >= 1) { if (absValue >= EXPONENTIAL_INT_THRESHOLD) { value = Math.floor(value); result = exponentialFormat.format(value); } else { result = decimalFormat.format(value); } } else if (absValue < 1 && absValue > 0) { if (absValue >= EXPONENTIAL_DEC_THRESHOLD) { result = decimalFormat.format(value); if (result.equalsIgnoreCase("0")) { result = decimalFormatLong.format(value); } } else { result = exponentialFormat.format(value); } } else { result = "0"; } } return result; } public String formatWithoutGroupSeparators(double value) { return removeGroupSeparators(format(value)); } public double parse(String value, double defValue) { try { return decimalFormat.parse(value).doubleValue(); } catch (ParseException e) { e.printStackTrace(); } return defValue; } private String removeGroupSeparators(String number) { return number.replace(String.valueOf(groupSeparator), ""); } }
private String withNoTrailingZeros(final double value, final int nrOfDecimals) { return new BigDecimal(String.valueOf(value)).setScale(nrOfDecimals, BigDecimal.ROUND_HALF_UP).stripTrailingZeros().toPlainString(); }
double pp = 10000; double myVal = 22.268699999999967; String needVal = "22.2687"; double i = (5.0/pp); String format = "%10.4f"; String getVal = String.format(format,(Math.round((myVal +i)*pp)/pp)-i).trim();
DecimalFormat formatter = new DecimalFormat("0.0 formatter.setRoundingMode(RoundingMode.HALF_UP); double num = 1.234567; return formatter.format(num);
Math.round(3.0); Math.round(3.1); Math.round(3.5); Math.round(3.9); Math.round(-3.0); Math.round(-3.1); Math.round(-3.5); Math.round(-3.9);
Math.ceil(3.0); Math.ceil(3.1); Math.ceil(3.5); Math.ceil(3.9); Math.ceil(-3.0); Math.ceil(-3.1); Math.ceil(-3.5); Math.ceil(-3.9);
Math.floor(3.0); Math.floor(3.1); Math.floor(3.5); Math.floor(3.9); Math.floor(-3.0); Math.floor(-3.1); Math.floor(-3.5); Math.floor(-3.9);
Math.rint(3.0); Math.rint(3.1); Math.rint(3.5); Math.rint(3.9); Math.rint(4.5); Math.rint(5.5); Math.rint(-3.0); Math.rint(-3.1); Math.rint(-3.5); Math.rint(-3.9); Math.rint(-4.5); Math.rint(-5.5);
double a = DoubleRounder.round(2.0/3.0, 3); double b = DoubleRounder.round(2.0/3.0, 3, RoundingMode.DOWN); double c = DoubleRounder.round(1000.0d, 17); double d = DoubleRounder.round(90080070060.1d, 9); System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d);
DecimalFormat df = new DecimalFormat(" String resultado = df.format(valor)
private static String getTwoDecimals(double value){ DecimalFormat df = new DecimalFormat("0.00"); return df.format(value); }
Locale locale = Locale.ENGLISH; NumberFormat nf = NumberFormat.getNumberInstance(locale); nf.setMinimumFractionDigits(2); nf.setMaximumFractionDigits(2); System.out.println(nf.format(.99)); System.out.println(nf.format(123.567)); System.out.println(nf.format(123.0));
double p = Math.pow(10d, dp); double result = Math.round(value * p)/p;
double a = 123.00449; double roundOff1 = Math.round(a*10000)/10000.00; double roundOff2 = Math.round(roundOff1*1000)/1000.00; double roundOff = Math.round(roundOff2*100)/100.00; System.out.println("result:"+roundOff);
double scale = 100000; double myVal = 0.912385; double rounded = (int)((myVal * scale) + 0.5d) / scale;
/** * MidpointRounding away from zero ( * Uses a half-epsilon for correction. (This offsets IEEE-754 * half-to-even rounding that was applied at the edge cases). */ double RoundCorrect(double num, int precision) { double c = 0.5 * EPSILON * num; double p = 1; while (precision--> 0) p *= 10; if (num < 0) p *= -1; return Math.round((num + c) * p) / p; } RoundCorrect(1.005, 2); RoundCorrect(2.175, 2); RoundCorrect(5.015, 2); RoundCorrect(-1.005, 2); RoundCorrect(-2.175, 2); RoundCorrect(-5.015, 2);
Object mon = ...; synchronized (mon) { mon.wait(); }
synchronized { while (!condition) { mon.wait(); } }
synchronized(LOCK) { Thread.sleep(1000); } synchronized(LOCK) { LOCK.wait(); }
synchronized(monitor){ while(condition == true){ monitor.wait() } Thread.sleep(100); }
synchronized(HandObject) { while(isHandFree() == false) { HandObject.wait(); } } while (beerIsAvailable() == false) { Thread.sleep(5000); } drinkBeers(); setHandFreeState(true); synchronized(HandObject) { HandObject.notifyAll(); }
synchronized(LOCK) { Thread.sleep(1000); } synchronized(LOCK) { LOCK.wait(); }
Sleep() take the key, its never release the key to anyone, when its work completed then only its release then only take the key waiting stage threads.
public class Main { private static Singleton singletonA = null; private static Singleton singletonB = null; public static void main(String[] args) throws InterruptedException { Thread threadA = new Thread() { @Override public void run() { singletonA = Singleton.getInstance(true); } }; Thread threadB = new Thread() { @Override public void run() { singletonB = Singleton.getInstance(); while (singletonA == null) { System.out.println("SingletonA still null"); } if (singletonA == singletonB) { System.out.println("Both singleton are same"); } else { System.out.println("Both singleton are not same"); } } }; threadA.start(); threadB.start(); } }
public class Singleton { private static Singleton _instance; public static Singleton getInstance() { if (_instance == null) { synchronized (Singleton.class) { if (_instance == null) _instance = new Singleton(); } } return _instance; } public static Singleton getInstance(boolean isWait) { if (_instance == null) { synchronized (Singleton.class) { if (_instance == null) { if (isWait) { try { Thread.sleep(500); System.out.println("_instance :" + String.valueOf(_instance)); } catch (InterruptedException e) { e.printStackTrace(); } } _instance = new Singleton(); } } } return _instance; } }
SingletonA still null SingletonA still null SingletonA still null _instance :com.omt.sleepwait.Singleton@10c042ab SingletonA still null SingletonA still null SingletonA still null Both singleton are not same
for (Object i : l) { if (condition(i)) { l.remove(i); } }
public static void main(String[] args) { Collection<Integer> l = new ArrayList<>(); for (int i = 0; i < 10; ++i) { l.add(4); l.add(5); l.add(6); } for (int i : l) { if (i == 5) { l.remove(i); } } System.out.println(l); }
Exception in thread "main" java.util.ConcurrentModificationException
List<String> list = new ArrayList<>(); for (Iterator<String> iterator = list.iterator(); iterator.hasNext();) { String string = iterator.next(); if (string.isEmpty()) { iterator.remove(); } }
Iterator<Integer> iter = l.iterator(); while (iter.hasNext()) { if (iter.next() == 5) { iter.remove(); } }
Collection<Integer> coll = new ArrayList<>(); coll.removeIf(i -> i == 5);
public E next() { checkForComodification(); try { E next = get(cursor); lastRet = cursor++; return next; } catch(IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } }
final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); }
public static void main(String[] args) { Collection<Integer> l = new ArrayList<Integer>(); Collection<Integer> itemsToRemove = new ArrayList<Integer>(); for (int i=0; i < 10; ++i) { l.add(new Integer(4)); l.add(new Integer(5)); l.add(new Integer(6)); } for (Integer i : l) { if (i.intValue() == 5) itemsToRemove.add(i); } l.removeAll(itemsToRemove); System.out.println(l); }
for(int i = l.size() - 1; i >= 0; i --) { if (l.get(i) == 5) { l.remove(i); } }
for (Iterator<Object> it = objects.iterator(); it.hasNext();) { Object object = it.next(); if (test) { it.remove(); } }
MutableList<Integer> list = Lists.mutable.of(1, 2, 3, 4, 5); list.removeIf(Predicates.lessThan(3)); Assert.assertEquals(Lists.mutable.of(3, 4, 5), list);
MutableList<Integer> list = Lists.mutable.of(1, 2, 3, 4, 5); list.removeIf(Predicates.cast(integer -> integer < 3)); Assert.assertEquals(Lists.mutable.of(3, 4, 5), list);
for (String str : new ArrayList<String>(listOfStr)) { listOfStr.remove( ); }
ArrayList<String> myArray = new ArrayList<>(); for (int i = 0; i < myArray.size(); ) { String text = myArray.get(i); if (someCondition(text)) myArray.remove(i); else i++; }
for (TouchableObj obj : untouchedSet) { if (obj.isTouched()) { untouchedSet.remove(obj); touchedSt.add(obj); break; } }
List<Car> cars = ArrayList<>(); for (ListIterator<Car> carIterator = cars.listIterator(); carIterator.hasNext(); ) { if (<some-condition>) { carIterator().remove() } else if (<some-other-condition>) { carIterator().add(aNewCar); } }
int index = 0; while(index < list.size()) { Object r = list.get(index); if( state ) { list.remove(index); index = 0; continue; } index += 1; }
public static void main(String[] args) { Collection<Integer> l = new CopyOnWriteArrayList<Integer>(); for (int i=0; i < 10; ++i) { l.add(new Integer(4)); l.add(new Integer(5)); l.add(new Integer(6)); } for (Integer i : l) { if (i.intValue() == 5) { l.remove(i); } } System.out.println(l); }
ArrayList<Integer> ints = new ArrayList<Integer>(); ArrayList<Integer> toRemove = new ArrayList<Integer>(); Random rdm = new Random(); long millis; for (int i = 0; i < 100000; i++) { Integer integer = rdm.nextInt(); ints.add(integer); } ArrayList<Integer> intsForIndex = new ArrayList<Integer>(ints); ArrayList<Integer> intsDescIndex = new ArrayList<Integer>(ints); ArrayList<Integer> intsIterator = new ArrayList<Integer>(ints); millis = System.currentTimeMillis(); for (int i = 0; i < intsForIndex.size(); i++) if (intsForIndex.get(i) % 2 == 0) intsForIndex.remove(i--); System.out.println(System.currentTimeMillis() - millis); millis = System.currentTimeMillis(); for (int i = intsDescIndex.size() - 1; i >= 0; i--) if (intsDescIndex.get(i) % 2 == 0) intsDescIndex.remove(i); System.out.println(System.currentTimeMillis() - millis); millis = System.currentTimeMillis(); for (Iterator<Integer> iterator = intsIterator.iterator(); iterator.hasNext(); ) if (iterator.next() % 2 == 0) iterator.remove(); System.out.println(System.currentTimeMillis() - millis);
for (Integer i : l) { if (i.intValue() == 5){ itemsToRemove.add(i); break; } }
public class Example { private final List<String> queue = Collections.synchronizedList(new ArrayList<String>()); public void removeFromQueue() { synchronized (queue) { Iterator<String> iterator = queue.iterator(); String string = iterator.next(); if (string.isEmpty()) { iterator.remove(); } } } }
Collection<Integer> l = new ArrayList<Integer>(); for (int i=0; i < 10; ++i) { l.add(new Integer(4)); l.add(new Integer(5)); l.add(new Integer(6)); } l.removeIf(i -> i.intValue() == 5);
final List<Integer> list = new ArrayList<>(); for(int i = 0; i < 10; ++i){ list.add(i); } int i = 1; while(i < list.size()){ if(list.get(i) % 2 == 0){ list.remove(i++); } else { i += 2; } }
final List<Integer> list = new ArrayList<>(); for(int i = 0; i < 10; ++i){ list.add(i); } int i = 0; while(i < list.size()){ if(list.get(i) % 2 == 0){ list.remove(i); } else { ++i; } }
List<Integer> list = new ArrayList<Integer>(); list.add(1); list.add(2); list.add(3); list.add(4); int list_size = list.size(); for (int i = 0; i < list_size; i++) { list.remove(0); }
Collection<Integer> l = new ArrayList<Integer>(); l.removeIf(i -> i == 5);
java [ <option> ... ] <class-name> [<argument> ...]
java -Xmx100m com.acme.example.ListUsers fred joe bert
java ListUser.class java com/acme/example/ListUser.class
/usr/local/acme/classes/com/acme/example/Foon.class
java [ <option> ... ] -jar <jar-file-name> [<argument> ...]
java -Xmx100m -jar /usr/local/acme-example/listuser.jar fred
package com.test; public class Main { public static void main(String[] args) { System.out.println("salam 2nya\n"); } }
public class Temp { public static void main(String args[]) { System.out.println(args[0]); } }
public class YourMain extends org.apache.camel.spring.Main
<build> <plugins> <plugin> <artifactId>maven-jar-plugin</artifactId> <configuration> <archive> <manifest> <mainClass>class name us.com.test.abc.MyMainClass</mainClass> </manifest> </archive> </configuration> </plugin> </plugins> </build>
java -cp C:/java/MyClasses C:/java/MyClasses/utilities/myapp/Cool
The term `ClassName` is not recognized as the name of a cmdlet, function, script ...
java -cp "/dir1/dir2/dir3:/dir1/dir2/javalibs" MyProgram Error: Could not find or load main class MyProgram
package com.tutorialspoint.java; /** * Created by mda21185 on 15-6-2016. */ public class CommandLine { public static void main(String args[]){ for(int i=0; i<args.length; i++){ System.out.println("args[" + i + "]: " + args[i]); } } }
java com.tutorialspoint.java.CommandLine this is a command line 200 -100
args[0]: this args[1]: is args[2]: a args[3]: command args[4]: line args[5]: 200 args[6]: -100
javac -cp mongo-java-driver-3.4.1.jar JavaMongoDBConnection.java
java -cp mongo-java-driver-3.4.1.jar: JavaMongoDBConnection
<parent> <groupId>myGroupId</groupId> <artifactId>pom-parent</artifactId> <version>0.0.1-SNAPSHOT</version> <relativePath>../badPathHere/pom.xml</relativePath> </parent>
public class ExampleServlet extends HttpServlet { private Object thisIsNOTThreadSafe; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Object thisIsThreadSafe; thisIsNOTThreadSafe = request.getParameter("foo"); thisIsThreadSafe = request.getParameter("foo"); } }
public Synchronized class service(ServletRequest request,ServletResponse response)throws ServletException,IOException
public class CustomComparator { public boolean compare(Object object1, Object object2) { return object1.getStartDate().before(object2.getStartDate()); } } public class RandomName { ... Collections.sort(Database.arrayList, new CustomComparator); ... }
public class CustomComparator implements Comparator<MyObject> { @Override public int compare(MyObject o1, MyObject o2) { return o1.getStartDate().compareTo(o2.getStartDate()); } }
Collections.sort(Database.arrayList, new CustomComparator());
Collections.sort(Database.arrayList, new Comparator<MyObject>() { @Override public int compare(MyObject o1, MyObject o2) { return o1.getStartDate().compareTo(o2.getStartDate()); } });
Collections.sort(Database.arrayList, (o1, o2) -> o1.getStartDate().compareTo(o2.getStartDate()));
Database.arrayList.sort((o1, o2) -> o1.getStartDate().compareTo(o2.getStartDate()));
Database.arrayList.sort(Comparator.comparing(MyObject::getStartDate));
public class Number implements Comparable<Number> { private int value; public Number(int value) { this.value = value; } public int compareTo(Number anotherInstance) { return this.value - anotherInstance.value; } } public class Chair { private int weight; private int height; public Chair(int weight, int height) { this.weight = weight; this.height = height; } } class ChairWeightComparator implements Comparator<Chair> { public int compare(Chair chair1, Chair chair2) { return chair1.getWeight() - chair2.getWeight(); } } class ChairHeightComparator implements Comparator<Chair> { public int compare(Chair chair1, Chair chair2) { return chair1.getHeight() - chair2.getHeight(); } }
List<Number> numbers = new ArrayList<Number>(); ... Collections.sort(numbers); List<Chair> chairs = new ArrayList<Chair>(); Collections.sort(chairs, new ChairWeightComparator()); Collections.sort(chairs, new ChairHeightComparator()); Collections.sort(chairs, new Comparator<Chair>() { public int compare(Chair chair1, Chair chair2) { ... } });
Collections.sort(studList, new Comparator<Student>(){ public int compare(Student s1, Student s2) { return s1.getFirstName().compareToIgnoreCase(s2.getFirstName()); } });
Collections.sort(studList, (Student s1, Student s2) ->{ return s1.getFirstName().compareToIgnoreCase(s2.getFirstName()); });
Comparator<Student> c = (s1, s2) -> s1.firstName.compareTo(s2.firstName); studList.sort(c)
import static java.util.Comparator.comparing; Collections.sort(list, comparing(MyObject::getStartDate));
import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.Date; public class test { public static class Person { public String name; public int id; public Date hireDate; public Person(String iname, int iid, Date ihireDate) { name = iname; id = iid; hireDate = ihireDate; } public String toString() { return name + " " + id + " " + hireDate.toString(); } public static class CompId implements Comparator<Person> { @Override public int compare(Person arg0, Person arg1) { return arg0.id - arg1.id; } } public static class CompDate implements Comparator<Person> { private int mod = 1; public CompDate(boolean desc) { if (desc) mod =-1; } @Override public int compare(Person arg0, Person arg1) { return mod*arg0.hireDate.compareTo(arg1.hireDate); } } } public static void main(String[] args) { SimpleDateFormat df = new SimpleDateFormat("mm-dd-yyyy"); ArrayList<Person> people; people = new ArrayList<Person>(); try { people.add(new Person("Joe", 92422, df.parse("12-12-2010"))); people.add(new Person("Joef", 24122, df.parse("1-12-2010"))); people.add(new Person("Joee", 24922, df.parse("12-2-2010"))); } catch (ParseException e) { e.printStackTrace(); } Collections.sort(people, new Person.CompId()); System.out.println("BY ID"); for (Person p : people) { System.out.println(p.toString()); } Collections.sort(people, new Person.CompDate(false)); System.out.println("BY Date asc"); for (Person p : people) { System.out.println(p.toString()); } Collections.sort(people, new Person.CompDate(true)); System.out.println("BY Date desc"); for (Person p : people) { System.out.println(p.toString()); } } }
List<Person> sortedByAgePersons = new ArrayList<Person>(persons); Collections.sort(sortedByAgePersons, new Comparator<Person>() { public int compare(Person p1, Person p2) { return Integer.valueOf(p1.getAge()).compareTo(p2.getAge()); } });
List<Person> sortedByAgePersons = sort(persons, on(Person.class).getAge());
public class NewspaperClass implements Comparable<NewspaperClass>{ public String name; @Override public int compareTo(NewspaperClass another) { return name.compareTo(another.name); } }
public class NewspaperClass implements Comparator<NewspaperClass> { public String name; public Boolean isUserNewspaper=false; private Collator trCollator = Collator.getInstance(new Locale("tr_TR")); @Override public int compare(NewspaperClass lhs, NewspaperClass rhs) { trCollator.setStrength(Collator.PRIMARY); return trCollator.compare(lhs.name,rhs.name); } }
Collections.sort(your array list,new NewspaperClass());
List<User> users = Arrays.asList(user1,user2,user3); users.sort( (u1, u2) -> { return u1.getFirstName.compareTo(u2.getFirstName());});
Function<Item, Date> getStartDate = new Function<Item, Date>() { public Date apply(Item item) { return item.getStartDate(); } }; List<Item> orderedItems = Ordering.natural().onResultOf(getStartDate). sortedCopy(items);
Collections.sort(stdList, (o1, o2) -> o1.getName().compareTo(o2.getName()));
yourList.sort(Comparator.comparing(Classname::getName)); or yourList.stream().forEach(a -> a.getBObjects().sort(Comparator.comparing(Classname::getValue)));
Arrays.sort( array, new Comparator<IndexValue>(){ public int compare( IndexValue a, IndexValue b ){ return a.v - b.v; } });
Collections.sort(anArrayListOfSomeObjectPerhapsUsersOrSomething, new ReflectiveComparator(). new ListComparator("name")); public class ReflectiveComparator { public class FieldComparator implements Comparator<Object> { private String fieldName; public FieldComparator(String fieldName){ this.fieldName = fieldName; } @SuppressWarnings({ "unchecked", "rawtypes" }) @Override public int compare(Object object1, Object object2) { try { Field field = object1.getClass().getDeclaredField(fieldName); field.setAccessible(true); Comparable object1FieldValue = (Comparable) field.get(object1); Comparable object2FieldValue = (Comparable) field.get(object2); return object1FieldValue.compareTo(object2FieldValue); }catch (Exception e){} return 0; } } public class ListComparator implements Comparator<Object> { private String fieldName; public ListComparator(String fieldName) { this.fieldName = fieldName; } @SuppressWarnings({ "unchecked", "rawtypes" }) @Override public int compare(Object object1, Object object2) { try { Field field = object1.getClass().getDeclaredField(fieldName); field.setAccessible(true); Comparable o1FieldValue = (Comparable) field.get(object1); Comparable o2FieldValue = (Comparable) field.get(object2); if (o1FieldValue == null){ return -1;} if (o2FieldValue == null){ return 1;} return o1FieldValue.compareTo(o2FieldValue); } catch (NoSuchFieldException e) { throw new IllegalStateException("Field doesn } catch (IllegalAccessException e) { throw new IllegalStateException("Field inaccessible", e); } } } }
Collections.sort(list, comparing(ClassName::getName));
Collections.sort(list, comparing(ClassName::getName).reversed());
Collections.sort(list, comparing(ClassName::getName, Comparator.nullsLast(Comparator.naturalOrder())));
public List<Volume> getSortedVolumes() throws SystemException { List<Volume> volumes = VolumeLocalServiceUtil.getAllVolumes(); Collections.sort(volumes, new Comparator<Volume>() { public int compare(Volume o1, Volume o2) { Volume p1 = (Volume) o1; Volume p2 = (Volume) o2; return p1.getVolumeName().compareToIgnoreCase( p2.getVolumeName()); } }); return volumes; }
someCollection.sort( OurCustomComparator .comparing(Person::getName) .thenComparing(Person::getId) );
SortKeys sortKeys = new SortKeys(); sortKeys.addField("firstName") .addField("age", true); ListSorter listSorter = new ListSorter(); List sortedList = (List<Person>) listSorter.sortList(listToSort, sortKeys);
public class SortUtil { public static <T> List<T> sort(List<T> list, String sortByProperty) { Collections.sort(list, new BeanComparator(sortByProperty)); return list; } } List<T> sortedList = SortUtil<T>.sort(unsortedList, "startDate");
List<Fruit> fruits = new ArrayList<Fruit>(); fruits.add(new Fruit("Kiwi","green",40)); fruits.add(new Fruit("Banana","yellow",100)); fruits.add(new Fruit("Apple","mixed green,red",120)); fruits.add(new Fruit("Cherry","red",10)); fruits.sort((Fruit f1,Fruit f2) -> f1.getFruitName().compareTo(f2.getFruitName())); System.out.println("Using String.compareTo(): " + fruits); fruits.sort((Fruit f1,Fruit f2) -> f1.compareTo(f2)); System.out.println("Using a Comparable Fruit class (sort by color): " + fruits);
public class Fruit implements Comparable<Fruit> { private String name; private String color; private int quantity; public Fruit(String name,String color,int quantity) { this.name = name; this.color = color; this.quantity = quantity; } public String getFruitName() { return name; } public String getColor() { return color; } public int getQuantity() { return quantity; } @Override public final int compareTo(Fruit f) { return this.color.compareTo(f.color); } @Override public String toString() { return (name + " is: " + color); } }
listToBeSorted.sort(Comparator.comparing(CustomObject::getStartDate));
Collections.sort(listToBeSorted, Comparator.comparing(CustomObject::getStartDate));
public class MyCustomClass implements Comparable<MyCustomClass>{
@Override public int compareTo(MyCustomClass a) { if(this.getStartDate().before(a.getStartDate())){ return -1; }else if(a.getStartDate().before(this.getStartDate())){ return 1; }else { return 0; } }
String [] stockArr = (String[]) stock_list.toArray();
List<String> stockList = new ArrayList<String>(); stockList.add("stock1"); stockList.add("stock2"); String[] stockArr = new String[stockList.size()]; stockArr = stockList.toArray(stockArr); for(String s : stockArr) System.out.println(s);
String[] arr = list.toArray(new String[list.size()]);
String [] stockArr = stockList.toArray(new String[stockList.size()]);
String [] stockArr = stockList.toArray(new String[0]);
Object[] objects = new Object[]{new Cat("fluffy")}; Dog[] dogs = (Dog[]) objects; Dog d = dogs[0];
String[] strings = list.stream().toArray(String[]::new);
Object[] arr = new Object[] { "ab", "cd" }; String[] arr2 = (String[]) arr;
Object[] arr = new String[] { "ab", "cd" }; String[] arr2 = (String[]) arr;
List<A> elements = new ArrayList<A>(); elements.add(new B()); elements.add(new B());
String[] arr = list.toArray(new String[list.size()]);
String[] stockArr = stock_list.toArray(new String[stock_list.size()]);
String [] stockArr = stockList.toArray(new String[0]);
import java.util.HashMap; import java.util.Map; public class Test { private static final Map<Integer, String> myMap = new HashMap<Integer, String>(); static { myMap.put(1, "one"); myMap.put(2, "two"); } private static final Map<Integer, String> myMap2 = new HashMap<Integer, String>(){ { put(1, "one"); put(2, "two"); } }; }
public class Test { private static final Map<Integer, String> myMap; static { Map<Integer, String> aMap = ....; aMap.put(1, "one"); aMap.put(2, "two"); myMap = Collections.unmodifiableMap(aMap); } }
static final Map<Integer, String> MY_MAP = ImmutableMap.of( 1, "one", 2, "two" );
static final Map<Integer, String> MY_MAP = ImmutableMap.<Integer, String>builder() .put(1, "one") .put(2, "two") .put(15, "fifteen") .build();
static final Map<Integer, String> MY_MAP = Map.of( 1, "one", 2, "two" );
public class Test { private static final Map<Integer, String> MY_MAP = createMap(); private static Map<Integer, String> createMap() { Map<Integer, String> result = new HashMap<Integer, String>(); result.put(1, "one"); result.put(2, "two"); return Collections.unmodifiableMap(result); } }
static final Map<String , String> FLAVORS = new HashMap<String , String>() {{ put("Up", "Down"); put("Charm", "Strange"); put("Top", "Bottom"); }};
private static final Map<Integer, String> CONSTANT_MAP = Collections.unmodifiableMap(new HashMap<Integer, String>() {{ put(1, "one"); put(2, "two"); }}); CONSTANT_MAP.put(3, "three");
private static final Map<String, String> EXTENSION_TO_MIMETYPE = Arrays.stream(new String[][] { { "txt", "text/plain" }, { "html", "text/html" }, { "js", "application/javascript" }, { "css", "text/css" }, { "xml", "application/xml" }, { "png", "image/png" }, { "gif", "image/gif" }, { "jpg", "image/jpeg" }, { "jpeg", "image/jpeg" }, { "svg", "image/svg+xml" }, }).collect(Collectors.toMap(kv -> kv[0], kv -> kv[1]));
static final Map<Integer, String> MY_MAP = Arrays.stream(new Object[][]{ {1, "one"}, {2, "two"}, }).collect(Collectors.toMap(kv -> (Integer) kv[0], kv -> (String) kv[1]));
private static final Map<Integer, String> MY_MAP = Map.of(1, "one", 2, "two");
import java.util.Map; import org.eclipse.collections.api.map.ImmutableMap; import org.eclipse.collections.api.map.MutableMap; import org.eclipse.collections.impl.factory.Maps; public class StaticMapsTest { private static final Map<Integer, String> MAP = Maps.mutable.with(1, "one", 2, "two"); private static final MutableMap<Integer, String> MUTABLE_MAP = Maps.mutable.with(1, "one", 2, "two"); private static final MutableMap<Integer, String> UNMODIFIABLE_MAP = Maps.mutable.with(1, "one", 2, "two").asUnmodifiable(); private static final MutableMap<Integer, String> SYNCHRONIZED_MAP = Maps.mutable.with(1, "one", 2, "two").asSynchronized(); private static final ImmutableMap<Integer, String> IMMUTABLE_MAP = Maps.mutable.with(1, "one", 2, "two").toImmutable(); private static final ImmutableMap<Integer, String> IMMUTABLE_MAP2 = Maps.immutable.with(1, "one", 2, "two"); }
import org.eclipse.collections.api.map.primitive.ImmutableIntObjectMap; import org.eclipse.collections.api.map.primitive.MutableIntObjectMap; import org.eclipse.collections.impl.factory.primitive.IntObjectMaps; public class StaticPrimitiveMapsTest { private static final MutableIntObjectMap<String> MUTABLE_INT_OBJ_MAP = IntObjectMaps.mutable.<String>empty() .withKeyValue(1, "one") .withKeyValue(2, "two"); private static final MutableIntObjectMap<String> UNMODIFIABLE_INT_OBJ_MAP = IntObjectMaps.mutable.<String>empty() .withKeyValue(1, "one") .withKeyValue(2, "two") .asUnmodifiable(); private static final MutableIntObjectMap<String> SYNCHRONIZED_INT_OBJ_MAP = IntObjectMaps.mutable.<String>empty() .withKeyValue(1, "one") .withKeyValue(2, "two") .asSynchronized(); private static final ImmutableIntObjectMap<String> IMMUTABLE_INT_OBJ_MAP = IntObjectMaps.mutable.<String>empty() .withKeyValue(1, "one") .withKeyValue(2, "two") .toImmutable(); private static final ImmutableIntObjectMap<String> IMMUTABLE_INT_OBJ_MAP2 = IntObjectMaps.immutable.<String>empty() .newWithKeyValue(1, "one") .newWithKeyValue(2, "two"); }
private static final Map<Integer, String> MY_MAP; static { Map<Integer, String>tempMap = new HashMap<Integer, String>(); tempMap.put(1, "one"); tempMap.put(2, "two"); MY_MAP = Collections.unmodifiableMap(tempMap); }
import static java.util.Map.entry; private static final Map<Integer,String> map = Map.ofEntries( entry(1, "one"), entry(2, "two"), entry(3, "three"), entry(4, "four"), entry(5, "five"), entry(6, "six"), entry(7, "seven"), entry(8, "eight"), entry(9, "nine"), entry(10, "ten"));
import java.util.AbstractMap.*; private static final Map<Integer, String> myMap = Stream.of( new SimpleEntry<>(1, "one"), new SimpleEntry<>(2, "two"), new SimpleEntry<>(3, "three"), new SimpleEntry<>(4, "four"), new SimpleEntry<>(5, "five"), new SimpleEntry<>(6, "six"), new SimpleEntry<>(7, "seven"), new SimpleEntry<>(8, "eight"), new SimpleEntry<>(9, "nine"), new SimpleEntry<>(10, "ten")) .collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));
public static final Map<?, ?> numbers = Collections.unmodifiableMap(new HashMap<Integer, String>() { { put(1, "some value"); } });
public class Test { private static final Map<Integer, String> myMap; static { Map<Integer, String> aMap = ....; aMap.put(1, "one"); aMap.put(2, "two"); myMap = Collections.unmodifiableMap(aMap); } }
public class Test { public static final Map numbers = Collections.unmodifiableMap(new HashMap(2, 1.0f){ { put(1, "one"); put(2, "two"); } }); }
Map<String, String> colorMap = MapUtils.putAll(new HashMap<String, String>(), new String[][] { {"RED", " {"GREEN", " {"BLUE", " });
public static <A> Map<String, A> asMap(Object... keysAndValues) { return new LinkedHashMap<String, A>() {{ for (int i = 0; i < keysAndValues.length - 1; i++) { put(keysAndValues[i].toString(), (A) keysAndValues[++i]); } }}; }
Map<String, String> one = asMap("1stKey", "1stVal", "2ndKey", "2ndVal"); Map<String, Object> two = asMap("1stKey", Boolean.TRUE, "2ndKey", new Integer(2));
private static final Map<Integer, String> myMap = new HashMap<>(); static { final Map<Integer, String> m = myMap; m.put(1, "one"); m.put(2, "two"); m.put(3, "three"); }
private static final Map<Integer, String> myMap2 = new HashMap<>(); static { p(1, "one"); p(2, "two"); p(3, "three"); } private static void p(Integer k, String v) { myMap2.put(k, v); }
public class Test { private static final Map<Integer, String> myMap3 = new HashMap<>(); static { new B<>(myMap3) .p(1, "one") .p(2, "two") .p(3, "three"); } } class B<K, V> { private final Map<K, V> m; public B(Map<K, V> m) { this.m = m; } public B<K, V> p(K k, V v) { m.put(k, v); return this; } }
static final Map<String, Integer> map = MapUtils.unmodifiableMap( String.class, Integer.class, "cat", 4, "dog", 2, "frog", 17 );
import java.util.HashMap; public abstract class MapUtils { private MapUtils() { } public static <K, V> HashMap<K, V> unmodifiableMap( Class<? extends K> keyClazz, Class<? extends V> valClazz, Object...keyValues) { return Collections.<K, V>unmodifiableMap(makeMap( keyClazz, valClazz, keyValues)); } public static <K, V> HashMap<K, V> makeMap( Class<? extends K> keyClazz, Class<? extends V> valClazz, Object...keyValues) { if (keyValues.length % 2 != 0) { throw new IllegalArgumentException( " + "(Expected an even length, but found } HashMap<K, V> result = new HashMap<K, V>(keyValues.length / 2); for (int i = 0; i < keyValues.length;) { K key = cast(keyClazz, keyValues[i], i); ++i; V val = cast(valClazz, keyValues[i], i); ++i; result.put(key, val); } return result; } private static <T> T cast(Class<? extends T> clazz, Object object, int i) { try { return clazz.cast(object); } catch (ClassCastException e) { String objectName = (i % 2 == 0) ? "Key" : "Value"; String format = "%s at index %d ( throw new IllegalArgumentException(String.format(format, objectName, i, object.toString(), clazz.getSimpleName()), e); } } }
private static final Map<String, Integer> MAP = Stream.of( new AbstractMap.SimpleImmutableEntry<>("key1", 1), new AbstractMap.SimpleImmutableEntry<>("key2", 2) ).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
private static final Map<String, String> MAP = new StickyMap<>( new MapEntry<>("name", "Jeffrey"), new MapEntry<>("age", "35") );
public class MyClass { private static final Map<Integer, String> myMap = prepareMap(); private static Map<Integer, String> prepareMap() { Map<Integer, String> hashMap = new HashMap<>(); hashMap.put(1, "one"); hashMap.put(2, "two"); return hashMap; } }
map( entry("keyA", "val1"), entry("keyB", "val2"), entry("keyC", "val3") );
public static <K,V> Map<K,V> map(Map.Entry<K, ? extends V>... entries) public static <K,V> Map.Entry<K,V> entry(K key, V val)
public class LiteralMapFactory { @SafeVarargs public static <K, V> Map<K, V> mapOf(Map.Entry<K, V>... entries) { LinkedHashMap<K, V> map = new LinkedHashMap<>(); for (Map.Entry<K, V> entry : entries) { map.put(entry.getKey(), entry.getValue()); } return map; } public static <K, V> Map.Entry<K, V> entry(K key, V value) { return new AbstractMap.SimpleEntry<>(key, value); } public static void main(String[] args) { System.out.println(mapOf(entry("a", 1), entry("b", 2), entry("c", 3))); } }
public static <K, V> Map<K, V> mapOf(Object... keyValues) { Map<K, V> map = new HashMap<>(keyValues.length / 2); for (int index = 0; index < keyValues.length / 2; index++) { map.put((K)keyValues[index * 2], (V)keyValues[index * 2 + 1]); } return map; } Map<Integer, String> map1 = mapOf(1, "value1", 2, "value2"); Map<String, String> map2 = mapOf("key1", "value1", "key2", "value2");
Map<String, Object> info = Map.of("age", 27, "major", "cs");
Map<String, Object> info = Map.ofEntries( Map.entry("age", 27), Map.entry("major", "cs") );
Map<K, V> map = Collections.singletonMap(key, value)
enum MyEnum { ONE (1, "one"), TWO (2, "two"), THREE (3, "three"); int value; String name; MyEnum(int value, String name) { this.value = value; this.name = name; } static final Map<Integer, String> MAP = Stream.of( values() ) .collect( Collectors.toMap( e -> e.value, e -> e.name ) ); }
import java.util.Collections; import java.util.HashMap; import java.util.Map; /** * A tool for easy creation of a map. Code example:<br/> * {@code MapBuilder.of("name", "Forrest").and("surname", "Gump").build()} * @param <K> key type (inferred by constructor) * @param <V> value type (inferred by constructor) * @author Vlasec (for http: */ public class MapBuilder <K, V> { private Map<K, V> map = new HashMap<>(); /** Constructor that also enters the first entry. */ private MapBuilder(K key, V value) { and(key, value); } /** Factory method that creates the builder and enters the first entry. */ public static <A, B> MapBuilder<A, B> mapOf(A key, B value) { return new MapBuilder<>(key, value); } /** Puts the key-value pair to the map and returns itself for method chaining */ public MapBuilder<K, V> and(K key, V value) { map.put(key, value); return this; } /** * If no reference to builder is kept and both the key and value types are immutable, * the resulting map is immutable. * @return contents of MapBuilder as an unmodifiable map. */ public Map<K, V> build() { return Collections.unmodifiableMap(map); } }
ProgressDialog mProgressDialog; mProgressDialog = new ProgressDialog(YourActivity.this); mProgressDialog.setMessage("A message"); mProgressDialog.setIndeterminate(true); mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); mProgressDialog.setCancelable(true); final DownloadTask downloadTask = new DownloadTask(YourActivity.this); downloadTask.execute("the url to the file you want to download"); mProgressDialog.setOnCancelListener(new DialogInterface.OnCancelListener() { @Override public void onCancel(DialogInterface dialog) { downloadTask.cancel(true); } });
private class DownloadTask extends AsyncTask<String, Integer, String> { private Context context; private PowerManager.WakeLock mWakeLock; public DownloadTask(Context context) { this.context = context; } @Override protected String doInBackground(String... sUrl) { InputStream input = null; OutputStream output = null; HttpURLConnection connection = null; try { URL url = new URL(sUrl[0]); connection = (HttpURLConnection) url.openConnection(); connection.connect(); if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) { return "Server returned HTTP " + connection.getResponseCode() + " " + connection.getResponseMessage(); } int fileLength = connection.getContentLength(); input = connection.getInputStream(); output = new FileOutputStream("/sdcard/file_name.extension"); byte data[] = new byte[4096]; long total = 0; int count; while ((count = input.read(data)) != -1) { if (isCancelled()) { input.close(); return null; } total += count; if (fileLength > 0) publishProgress((int) (total * 100 / fileLength)); output.write(data, 0, count); } } catch (Exception e) { return e.toString(); } finally { try { if (output != null) output.close(); if (input != null) input.close(); } catch (IOException ignored) { } if (connection != null) connection.disconnect(); } return null; }
@Override protected void onPreExecute() { super.onPreExecute(); PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE); mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, getClass().getName()); mWakeLock.acquire(); mProgressDialog.show(); } @Override protected void onProgressUpdate(Integer... progress) { super.onProgressUpdate(progress); mProgressDialog.setIndeterminate(false); mProgressDialog.setMax(100); mProgressDialog.setProgress(progress[0]); } @Override protected void onPostExecute(String result) { mWakeLock.release(); mProgressDialog.dismiss(); if (result != null) Toast.makeText(context,"Download error: "+result, Toast.LENGTH_LONG).show(); else Toast.makeText(context,"File downloaded", Toast.LENGTH_SHORT).show(); }
<uses-permission android:name="android.permission.WAKE_LOCK" />
public class DownloadService extends IntentService { public static final int UPDATE_PROGRESS = 8344; public DownloadService() { super("DownloadService"); } @Override protected void onHandleIntent(Intent intent) { String urlToDownload = intent.getStringExtra("url"); ResultReceiver receiver = (ResultReceiver) intent.getParcelableExtra("receiver"); try { URL url = new URL(urlToDownload); URLConnection connection = url.openConnection(); connection.connect(); int fileLength = connection.getContentLength(); InputStream input = new BufferedInputStream(connection.getInputStream()); String path = "/sdcard/BarcodeScanner-debug.apk" ; OutputStream output = new FileOutputStream(path); byte data[] = new byte[1024]; long total = 0; int count; while ((count = input.read(data)) != -1) { total += count; Bundle resultData = new Bundle(); resultData.putInt("progress" ,(int) (total * 100 / fileLength)); receiver.send(UPDATE_PROGRESS, resultData); output.write(data, 0, count); } output.flush(); output.close(); input.close(); } catch (IOException e) { e.printStackTrace(); } Bundle resultData = new Bundle(); resultData.putInt("progress" ,100); receiver.send(UPDATE_PROGRESS, resultData); } }
mProgressDialog.show(); Intent intent = new Intent(this, DownloadService.class); intent.putExtra("url", "url of the file to download"); intent.putExtra("receiver", new DownloadReceiver(new Handler())); startService(intent);
private class DownloadReceiver extends ResultReceiver{ public DownloadReceiver(Handler handler) { super(handler); } @Override protected void onReceiveResult(int resultCode, Bundle resultData) { super.onReceiveResult(resultCode, resultData); if (resultCode == DownloadService.UPDATE_PROGRESS) { int progress = resultData.getInt("progress"); dialog.setProgress(progress); if (progress == 100) { dialog.dismiss(); } } } }
public class MainActivity extends Activity { private ProgressDialog mProgressDialog; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); findViewById(R.id.btn_download).setOnClickListener(new View.OnClickListener() { public void onClick(View view) { String url = ((EditText) findViewById(R.id.edit_url)).getText().toString().trim(); Bundle extras = new Bundler().add(DownloadTask.PARAM_URL, url).build(); Groundy.create(DownloadExample.this, DownloadTask.class) .receiver(mReceiver) .params(extras) .queue(); mProgressDialog = new ProgressDialog(MainActivity.this); mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); mProgressDialog.setCancelable(false); mProgressDialog.show(); } }); } private ResultReceiver mReceiver = new ResultReceiver(new Handler()) { @Override protected void onReceiveResult(int resultCode, Bundle resultData) { super.onReceiveResult(resultCode, resultData); switch (resultCode) { case Groundy.STATUS_PROGRESS: mProgressDialog.setProgress(resultData.getInt(Groundy.KEY_PROGRESS)); break; case Groundy.STATUS_FINISHED: Toast.makeText(DownloadExample.this, R.string.file_downloaded, Toast.LENGTH_LONG); mProgressDialog.dismiss(); break; case Groundy.STATUS_ERROR: Toast.makeText(DownloadExample.this, resultData.getString(Groundy.KEY_ERROR), Toast.LENGTH_LONG).show(); mProgressDialog.dismiss(); break; } } }; }
public class DownloadTask extends GroundyTask { public static final String PARAM_URL = "com.groundy.sample.param.url"; @Override protected boolean doInBackground() { try { String url = getParameters().getString(PARAM_URL); File dest = new File(getContext().getFilesDir(), new File(url).getName()); DownloadUtils.downloadFile(getContext(), url, dest, DownloadUtils.getDownloadListenerForTask(this)); return true; } catch (Exception pokemon) { return false; } } }
<service android:name="com.codeslap.groundy.GroundyService"/>
/** * @param context used to check the device version and DownloadManager information * @return true if the download manager is available */ public static boolean isDownloadManagerAvailable(Context context) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) { return true; } return false; }
String url = "url you want to download"; DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url)); request.setDescription("Some descrition"); request.setTitle("Some title"); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) { request.allowScanningByMediaScanner(); request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); } request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, "name-of-the-file.ext"); DownloadManager manager = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE); manager.enqueue(request);
<manifest xmlns:android="http: package="com.example.helloandroid" android:versionCode="1" android:versionName="1.0"> <uses-sdk android:minSdkVersion="10" /> <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission> <uses-permission android:name="android.permission.INTERNET"></uses-permission> <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"></uses-permission> <uses-permission android:name="android.permission.READ_PHONE_STATE"></uses-permission> <application android:icon="@drawable/icon" android:label="@string/app_name" android:debuggable="true"> </application> </manifest>
private void updateProgressBar(){ Runnable runnable = new updateProgress(); background = new Thread(runnable); background.start(); } public class updateProgress implements Runnable { public void run() { while(Thread.currentThread()==background) try { Thread.sleep(1000); Message msg = new Message(); progress = getProgressPercentage(); handler.sendMessage(msg); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } catch (Exception e) { } } } private Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { progress.setProgress(msg.what); } };
private void destroyRunningThreads() { if (background != null) { background.interrupt(); background=null; } }
public static class DownloadTask extends AsyncTask<String, Integer, String> { private ProgressDialog mPDialog; private Context mContext; private PowerManager.WakeLock mWakeLock; private File mTargetFile; public DownloadTask(Context context,File targetFile,String dialogMessage) { this.mContext = context; this.mTargetFile = targetFile; mPDialog = new ProgressDialog(context); mPDialog.setMessage(dialogMessage); mPDialog.setIndeterminate(true); mPDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); mPDialog.setCancelable(true); final DownloadTask me = this; mPDialog.setOnCancelListener(new DialogInterface.OnCancelListener() { @Override public void onCancel(DialogInterface dialog) { me.cancel(true); } }); Log.i("DownloadTask","Constructor done"); } @Override protected String doInBackground(String... sUrl) { InputStream input = null; OutputStream output = null; HttpURLConnection connection = null; try { URL url = new URL(sUrl[0]); connection = (HttpURLConnection) url.openConnection(); connection.connect(); if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) { return "Server returned HTTP " + connection.getResponseCode() + " " + connection.getResponseMessage(); } Log.i("DownloadTask","Response " + connection.getResponseCode()); int fileLength = connection.getContentLength(); input = connection.getInputStream(); output = new FileOutputStream(mTargetFile,false); byte data[] = new byte[4096]; long total = 0; int count; while ((count = input.read(data)) != -1) { if (isCancelled()) { Log.i("DownloadTask","Cancelled"); input.close(); return null; } total += count; if (fileLength > 0) publishProgress((int) (total * 100 / fileLength)); output.write(data, 0, count); } } catch (Exception e) { return e.toString(); } finally { try { if (output != null) output.close(); if (input != null) input.close(); } catch (IOException ignored) { } if (connection != null) connection.disconnect(); } return null; } @Override protected void onPreExecute() { super.onPreExecute(); PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE); mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, getClass().getName()); mWakeLock.acquire(); mPDialog.show(); } @Override protected void onProgressUpdate(Integer... progress) { super.onProgressUpdate(progress); mPDialog.setIndeterminate(false); mPDialog.setMax(100); mPDialog.setProgress(progress[0]); } @Override protected void onPostExecute(String result) { Log.i("DownloadTask", "Work Done! PostExecute"); mWakeLock.release(); mPDialog.dismiss(); if (result != null) Toast.makeText(mContext,"Download error: "+result, Toast.LENGTH_LONG).show(); else Toast.makeText(mContext,"File Downloaded", Toast.LENGTH_SHORT).show(); } }
File target = new File(new File(Environment.getExternalStorageDirectory(), "ApplicationName"), "tmp.pdf"); new AQuery(this).progress(R.id.progress_view).download(_competition.qualificationScoreCardsPdf(), target, new AjaxCallback<File>() { public void callback(String url, File file, AjaxStatus status) { if (file != null) { } } });
<uses-permission android:name="android.permission.INTERNET" /> <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import android.app.Activity; import android.app.Dialog; import android.os.Bundle; import android.os.Environment; import android.view.View; import android.view.Window; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.ProgressBar; import android.widget.TextView; import android.widget.Toast; public class DownloadFileUseHttpURLConnection extends Activity { ProgressBar pb; Dialog dialog; int downloadedSize = 0; int totalSize = 0; TextView cur_val; String dwnload_file_path = "http: @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Button b = (Button) findViewById(R.id.b1); b.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { showProgress(dwnload_file_path); new Thread(new Runnable() { public void run() { downloadFile(); } }).start(); } }); } void downloadFile(){ try { URL url = new URL(dwnload_file_path); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.setRequestMethod("GET"); urlConnection.setDoOutput(true); urlConnection.connect(); File SDCardRoot = Environment.getExternalStorageDirectory(); File file = new File(SDCardRoot,"downloaded_file.png"); FileOutputStream fileOutput = new FileOutputStream(file); InputStream inputStream = urlConnection.getInputStream(); totalSize = urlConnection.getContentLength(); runOnUiThread(new Runnable() { public void run() { pb.setMax(totalSize); } }); byte[] buffer = new byte[1024]; int bufferLength = 0; while ( (bufferLength = inputStream.read(buffer)) > 0 ) { fileOutput.write(buffer, 0, bufferLength); downloadedSize += bufferLength; runOnUiThread(new Runnable() { public void run() { pb.setProgress(downloadedSize); float per = ((float)downloadedSize/totalSize) * 100; cur_val.setText("Downloaded " + downloadedSize + "KB / " + totalSize + "KB (" + (int)per + "%)" ); } }); } fileOutput.close(); runOnUiThread(new Runnable() { public void run() { } }); } catch (final MalformedURLException e) { showError("Error : MalformedURLException " + e); e.printStackTrace(); } catch (final IOException e) { showError("Error : IOException " + e); e.printStackTrace(); } catch (final Exception e) { showError("Error : Please check your internet connection " + e); } } void showError(final String err){ runOnUiThread(new Runnable() { public void run() { Toast.makeText(DownloadFileDemo1.this, err, Toast.LENGTH_LONG).show(); } }); } void showProgress(String file_path){ dialog = new Dialog(DownloadFileDemo1.this); dialog.requestWindowFeature(Window.FEATURE_NO_TITLE); dialog.setContentView(R.layout.myprogressdialog); dialog.setTitle("Download Progress"); TextView text = (TextView) dialog.findViewById(R.id.tv1); text.setText("Downloading file from ... " + file_path); cur_val = (TextView) dialog.findViewById(R.id.cur_pg_tv); cur_val.setText("Starting download..."); dialog.show(); pb = (ProgressBar)dialog.findViewById(R.id.progress_bar); pb.setProgress(0); pb.setProgressDrawable( getResources().getDrawable(R.drawable.green_progress)); } }
AndroidNetworking.download(url,dirPath,fileName).build() .setDownloadProgressListener(new DownloadProgressListener() { public void onProgress(long bytesDownloaded, long totalBytes) { bar.setMax((int) totalBytes); bar.setProgress((int) bytesDownloaded); } }).startDownload(new DownloadListener() { public void onDownloadComplete() { ... } public void onError(ANError error) { ... } });
<entry key="hibernate.hbm2ddl.auto" value="create">
<entry key="hibernate.hbm2ddl.auto" value="update">
<entry key="hibernate.hbm2ddl.auto" value="validate">
<entry key="hibernate.hbm2ddl.auto" value="create-drop">
/** * Auto export/update schema using hbm2ddl tool. Valid values are <tt>update</tt>, * <tt>create</tt>, <tt>create-drop</tt> and <tt>validate</tt>. */ String HBM2DDL_AUTO = "hibernate.hbm2ddl.auto";
this.schemaAutoTooling = SchemaAutoTooling.interpret( (String) configurationSettings.get( AvailableSettings.HBM2DDL_AUTO ) );
@Bean(name = ENTITY_MANAGER_NAME) public LocalContainerEntityManagerFactoryBean internalEntityManagerFactory( EntityManagerFactoryBuilder builder, @Qualifier(DATA_SOURCE_NAME) DataSource internalDataSource) { Map<String, Object> properties = new HashMap<>(); properties.put(AvailableSettings.HBM2DDL_AUTO, SchemaAutoTooling.CREATE.name().toLowerCase()); properties.put(AvailableSettings.DIALECT, H2Dialect.class.getName()); return builder .dataSource(internalDataSource) .packages(JpaModelsScanEntry.class, Jsr310JpaConverters.class) .persistenceUnit(PERSISTENCE_UNIT_NAME) .properties(properties) .build(); }
Pill p = Pill.valueOf(str); switch(p) { case RED: pop(); break; case BLUE: push(); break; }
ValueEnum enumval = ValueEnum.fromString(myString); switch (enumval) { case MILK: lap(); break; case WATER: sip(); break; case BEER: quaff(); break; case OTHER: default: dance(); break; }
public class Main { /** * @param args the command line arguments */ public static void main(String[] args) { String current = args[0]; Days currentDay = Days.valueOf(current.toUpperCase()); switch (currentDay) { case MONDAY: case TUESDAY: case WEDNESDAY: System.out.println("boring"); break; case THURSDAY: System.out.println("getting better"); case FRIDAY: case SATURDAY: case SUNDAY: System.out.println("much better"); break; } } public enum Days { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } }
public static void main(String[] args) { switch (args[0]) { case "Monday": case "Tuesday": case "Wednesday": System.out.println("boring"); break; case "Thursday": System.out.println("getting better"); case "Friday": case "Saturday": case "Sunday": System.out.println("much better"); break; } }
String s = "<Your String>"; switch(s.hashCode()) { case "Hello".hashCode(): break; case "Goodbye".hashCode(): break; }
public final class Switch<T> { private final HashMap<T, Runnable> cases = new HashMap<T, Runnable>(0); public void addCase(T object, Runnable action) { this.cases.put(object, action); } public void SWITCH(T object) { for (T t : this.cases.keySet()) { if (object.equals(t)) { this.cases.get(t).run(); break; } } } }
String runFct = queryType.equals("eq") ? "method1": queryType.equals("L_L")? "method2": queryType.equals("L_R")? "method3": queryType.equals("L_LR")? "method4": "method5"; Method m = this.getClass().getMethod(runFct); m.invoke(this);
it. switch (it.@name.text()){ case "choclate": myholder.myval=(it.text()); break; }}...
public class StringSwitchCase { public static void main(String args[]) { visitIsland("Santorini"); visitIsland("Crete"); visitIsland("Paros"); } public static void visitIsland(String island) { switch(island) { case "Corfu": System.out.println("User wants to visit Corfu"); break; case "Crete": System.out.println("User wants to visit Crete"); break; case "Santorini": System.out.println("User wants to visit Santorini"); break; case "Mykonos": System.out.println("User wants to visit Mykonos"); break; default: System.out.println("Unknown Island"); break; } } }
public class GenSet<E> { private E a[]; public GenSet() { a = new E[INITIAL_ARRAY_LENGTH]; } }
import java.lang.reflect.Array; class Stack<T> { public Stack(Class<T> clazz, int capacity) { array = (T[])Array.newInstance(clazz, capacity); } private final T[] array; }
public class GenSet<E> { private E[] a; public GenSet(Class<E> c, int s) { @SuppressWarnings("unchecked") final E[] a = (E[]) Array.newInstance(c, s); this.a = a; } E get(int i) { return a[i]; } }
public class GenSet<E> { private Object[] a; public GenSet(int s) { a = new Object[s]; } E get(int i) { @SuppressWarnings("unchecked") final E e = (E) a[i]; return e; } }
public class GenSet<E extends Foo> { private Foo[] a; public GenSet(int s) { a = new Foo[s]; } ... }
import java.lang.reflect.Array; public class GenSet<E> { private E[] a; public GenSet(Class<E[]> clazz, int length) { a = clazz.cast(Array.newInstance(clazz.getComponentType(), length)); } public static void main(String[] args) { GenSet<String> foo = new GenSet<String>(String[].class, 1); String[] bar = foo.a; foo.a[0] = "xyzzy"; String baz = foo.a[0]; } }
String foo = String[].class.getComponentType().cast("bar");
public static <T> T[] newArray(Class<T[]> type, int size) { return type.cast(Array.newInstance(type.getComponentType(), size)); }
E[] a; a = newArray(size); @SafeVarargs static <E> E[] newArray(int length, E... array) { return Arrays.copyOf(array, length); }
T[] array = (T[])Array.newInstance(cls, d1); T[][] array = (T[][])Array.newInstance(cls, d1, d2); T[][][] array = (T[][][])Array.newInstance(cls, d1, d2, d3); T[][][][] array = (T[][][][])Array.newInstance(cls, d1, d2, d3, d4); T[][][][][] array = (T[][][][][])Array.newInstance(cls, d1, d2, d3, d4, d5);
@FunctionalInterface interface ArraySupplier<E> { E[] get(int length); } class GenericSet<E> { private final ArraySupplier<E> supplier; private E[] array; GenericSet(ArraySupplier<E> supplier) { this.supplier = supplier; this.array = supplier.get(10); } public static void main(String[] args) { GenericSet<String> ofString = new GenericSet<>(String[]::new); GenericSet<Double> ofDouble = new GenericSet<>(Double[]::new); } }
@SafeVarargs public static <T> T[] toGenericArray(T ... elems) { return elems; }
class GenArray <T> { private T theArray[]; GenArray(T[] arr) { theArray = arr; } }
class GenArrayDemo { public static void main(String[] args) { int size = 10; Character[] ar = new Character[size]; GenArray<Character> = new Character<>(ar); } }
public static <T> T[] toArray(final List<T> obj) { if (obj == null || obj.isEmpty()) { return null; } final T t = obj.get(0); final T[] res = (T[]) Array.newInstance(t.getClass(), obj.size()); for (int i = 0; i < obj.size(); i++) { res[i] = obj.get(i); } return res; }
public class GenSet<T> { private final T[] array; @SuppressWarnings("unchecked") public GenSet(int capacity, T... dummy) { if (dummy.length > 0) throw new IllegalArgumentException( "Do not provide values for dummy argument."); Class<?> c = dummy.getClass().getComponentType(); array = (T[])Array.newInstance(c, capacity); } @Override public String toString() { return "GenSet of " + array.getClass().getComponentType().getName() + "[" + array.length + "]"; } }
GenSet<Integer> intSet = new GenSet<>(3); System.out.println(intSet); System.out.println(new GenSet<String>(2));
GenSet of java.lang.Integer[3] GenSet of java.lang.String[2]
Object attributeValue = null; try { if(clazz.isArray()){ Class<?> arrayType = clazz.getComponentType(); attributeValue = Array.newInstance(arrayType, 0); } else if(!clazz.isInterface()){ attributeValue = BeanUtils.instantiateClass(clazz); } } catch (Exception e) { logger.debug("Cannot instanciate \"{}\"", new Object[]{clazz}); }
if(clazz.isArray()){ Class<?> arrayType = clazz.getComponentType(); attributeValue = Array.newInstance(arrayType, 0); }
public <T> T[] array(T... values) { return values; }
import java.lang.reflect.Array; class Stack<T> { public Stack(Class<T> clazz, int capacity) { array = (T[])Array.newInstance(clazz, capacity); } private final T[] array; }
List<Person>[] personLists=new ArrayList<Person>()[10];
import java.util.ArrayList; import java.util.List; public class PersonList { List<Person> people; public PersonList() { people=new ArrayList<Person>(); } }
private int m = 0; private int n = 0; private Element<T>[][] elements = null; public MatrixData(int m, int n) { this.m = m; this.n = n; this.elements = new Element[m][n]; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { this.elements[i][j] = new Element<T>(); } } }
public class Whatever<Thing>{ private class Holder<OtherThing>{ OtherThing thing; } public Holder<Thing>[] arrayOfHolders = new Holder<Thing>[10] }
Tuple<Long,String>[] tupleArray = new Tuple<Long,String>[10];
public T [] createArray(int desiredSize){ ArrayList<T> builder = new ArrayList<T>(); for(int x=0;x<desiredSize;x++){ builder.add(null); } return builder.toArray(zeroArray()); } private T [] zeroArray(T... i){ return i; }
public class GenSet<Item> { private Item[] a; public GenSet(int s) { a = (Item[]) new Object[s]; } }
class GenericInvoker <T> { T variable; public GenericInvoker(T variable){ this.variable = variable; } }
GenericInvoker<T>[] array; public MyArray(){ array = new GenericInvoker[]; }
public T get(int index){ return array[index].variable; }
public void resize(int newSize){ array = Arrays.copyOf(array, newSize); }
public boolean add(T element){ arrays[size] = new GenericInvoker(element); size++; }
private E a[]; private int size; public GenSet(int elem) { size = elem; a = (E[]) new E[size]; }
class Stack<T> { private final T[] array; public Stack(int capacity) { array = (T[]) new Object[capacity]; } }
import java.security.*; .. byte[] bytesOfMessage = yourString.getBytes("UTF-8"); MessageDigest md = MessageDigest.getInstance("MD5"); byte[] thedigest = md.digest(bytesOfMessage);
String plaintext = "your text here"; MessageDigest m = MessageDigest.getInstance("MD5"); m.reset(); m.update(plaintext.getBytes()); byte[] digest = m.digest(); BigInteger bigInt = new BigInteger(1,digest); String hashtext = bigInt.toString(16); while(hashtext.length() < 32 ){ hashtext = "0"+hashtext; }
public String MD5(String md5) { try { java.security.MessageDigest md = java.security.MessageDigest.getInstance("MD5"); byte[] array = md.digest(md5.getBytes()); StringBuffer sb = new StringBuffer(); for (int i = 0; i < array.length; ++i) { sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3)); } return sb.toString(); } catch (java.security.NoSuchAlgorithmException e) { } return null; }
final MessageDigest messageDigest = MessageDigest.getInstance("MD5"); messageDigest.reset(); messageDigest.update(string.getBytes(Charset.forName("UTF8"))); final byte[] resultByte = messageDigest.digest(); final String result = new String(Hex.encodeHex(resultByte));
String Url = "your_url"; System.out.println( DigestUtils.md5Hex( Url ) );
MessageDigest md5 = MessageDigest.getInstance("MD5"); md5.update(StandardCharsets.UTF_8.encode(string)); return String.format("%032x", new BigInteger(1, md5.digest()));
import java.security.*; import java.math.*; public class MD5 { public static void main(String args[]) throws Exception{ String s="This is a test"; MessageDigest m=MessageDigest.getInstance("MD5"); m.update(s.getBytes(),0,s.length()); System.out.println("MD5: "+new BigInteger(1,m.digest()).toString(16)); } }
Hasher hasher = Hashing.md5().newHasher(); hasher.putString("my string"); byte[] md5 = hasher.hash().asBytes();
import javax.xml.bind.DatatypeConverter; String hash = DatatypeConverter.printHexBinary( MessageDigest.getInstance("MD5").digest("SOMESTRING".getBytes("UTF-8")));
public class Hash { /** * * @param txt, text in plain format * @param hashType MD5 OR SHA1 * @return hash in hashType */ public static String getHash(String txt, String hashType) { try { java.security.MessageDigest md = java.security.MessageDigest.getInstance(hashType); byte[] array = md.digest(txt.getBytes()); StringBuffer sb = new StringBuffer(); for (int i = 0; i < array.length; ++i) { sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3)); } return sb.toString(); } catch (java.security.NoSuchAlgorithmException e) { } return null; } public static String md5(String txt) { return Hash.getHash(txt, "MD5"); } public static String sha1(String txt) { return Hash.getHash(txt, "SHA1"); } }
MD5 :b10a8db164e0754105b7a99be72e3fe5 SHA1:0a4d55a8d778e5022fab701977c5d840bbc486d0
public class HashTest { @Test public void test() { String txt = "Hello World"; assertEquals("b10a8db164e0754105b7a99be72e3fe5", Hash.md5(txt)); assertEquals("0a4d55a8d778e5022fab701977c5d840bbc486d0", Hash.sha1(txt)); } }
private String md5(String s) { try { MessageDigest m = MessageDigest.getInstance("MD5"); m.update(s.getBytes(), 0, s.length()); BigInteger i = new BigInteger(1,m.digest()); return String.format("%1$032x", i); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; }
import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MD5Example { public static void main(String[] args) throws Exception { final String inputString = "Hello MD5"; System.out.println("MD5 hex for System.out.println(getMD5Hex(inputString)); } public static String getMD5Hex(final String inputString) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance("MD5"); md.update(inputString.getBytes()); byte[] digest = md.digest(); return convertByteToHex(digest); } private static String convertByteToHex(byte[] byteData) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < byteData.length; i++) { sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1)); } return sb.toString(); } }
String hash = MD5.asHex(MD5.getHash(new File(filename)));
import java.io.FileOutputStream; import java.io.IOException; import java.math.BigInteger; import java.net.URL; import java.nio.ByteBuffer; import java.nio.channels.Channels; import java.nio.channels.ReadableByteChannel; import java.nio.channels.WritableByteChannel; import java.security.DigestOutputStream; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; void downloadFile(String fromURL, String toFile, BigInteger md5) throws IOException, NoSuchAlgorithmException { ReadableByteChannel in = Channels.newChannel(new URL(fromURL).openStream()); MessageDigest md5Digest = MessageDigest.getInstance("MD5"); WritableByteChannel out = Channels.newChannel( new DigestOutputStream(new FileOutputStream(toFile), md5Digest)); ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024); while (in.read(buffer) != -1) { buffer.flip(); out.write(buffer); buffer.clear(); } BigInteger md5Actual = new BigInteger(1, md5Digest.digest()); if (! md5Actual.equals(md5)) throw new RuntimeException( "MD5 mismatch for file " + toFile + ": expected " + md5.toString(16) + ", got " + md5Actual.toString(16) ); }
return UUID.nameUUIDFromBytes(md5Bytes).toString();
public static String getHashMD5(String string) { try { MessageDigest md = MessageDigest.getInstance("MD5"); BigInteger bi = new BigInteger(1, md.digest(string.getBytes())); return bi.toString(16); } catch (NoSuchAlgorithmException ex) { Logger.getLogger(MD5Utils.class .getName()).log(Level.SEVERE, null, ex); return ""; } }
import java.security.*; import javax.xml.bind.*; byte[] bytesOfMessage = yourString.getBytes("UTF-8"); MessageDigest md = MessageDigest.getInstance("MD5"); byte[] bytesOfDigest = md.digest(bytesOfMessage); String digest = DatatypeConverter.printHexBinary(bytesOfDigest).toLowerCase();
public static String md5( String input ) { try { java.security.MessageDigest md = java.security.MessageDigest.getInstance("MD5"); byte[] array = md.digest(input.getBytes( "UTF-8" )); StringBuffer sb = new StringBuffer(); for (int i = 0; i < array.length; i++) { sb.append( String.format( "%02x", array[i])); } return sb.toString(); } catch ( NoSuchAlgorithmException | UnsupportedEncodingException e) { return null; } }
import java.security.MessageDigest val digest = MessageDigest.getInstance("MD5") val text = "MD5 this text!" val md5hash1 = digest.digest(text.getBytes).map("%02x".format(_)).mkString digest.update("MD5 ".getBytes()) digest.update("this ".getBytes()) digest.update("text!".getBytes()) val md5hash2 = digest.digest().map(0xFF & _).map("%02x".format(_)).mkString println(md5hash1 + " should be the same as " + md5hash2)
public static String md5hashing(String text) { String hashtext = null; try { String plaintext = text; MessageDigest m = MessageDigest.getInstance("MD5"); m.reset(); m.update(plaintext.getBytes()); byte[] digest = m.digest(); BigInteger bigInt = new BigInteger(1,digest); hashtext = bigInt.toString(16); while(hashtext.length() < 32 ){ hashtext = "0"+hashtext; } } catch (Exception e1) { JOptionPane.showMessageDialog(null,e1.getClass().getName() + ": " + e1.getMessage()); } return hashtext; }
String text = textFieldName.getText(); String pass = md5hashing(text);
def md5(text: String) : String = java.security.MessageDigest.getInstance("MD5").digest(text.getBytes()).map(0xFF & _).map { "%02x".format(_) }.foldLeft(""){_ + _}
import java.math.BigInteger; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; /** * MD5 encryption * * @author Hongten * */ public class MD5 { public static void main(String[] args) { System.out.println(MD5.getMD5("123456")); } /** * Use md5 encoded code value * * @param sInput * clearly * @ return md5 encrypted password */ public static String getMD5(String sInput) { String algorithm = ""; if (sInput == null) { return "null"; } try { algorithm = System.getProperty("MD5.algorithm", "MD5"); } catch (SecurityException se) { } MessageDigest md = null; try { md = MessageDigest.getInstance(algorithm); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } byte buffer[] = sInput.getBytes(); for (int count = 0; count < sInput.length(); count++) { md.update(buffer, 0, count); } byte bDigest[] = md.digest(); BigInteger bi = new BigInteger(bDigest); return (bi.toString(16)); } }
import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import javax.xml.bind.DatatypeConverter; public class MD5HashGenerator { public static void main(String args[]) throws NoSuchAlgorithmException { String stringToHash = "MyJavaCode"; MessageDigest messageDigest = MessageDigest.getInstance("MD5"); messageDigest.update(stringToHash.getBytes()); byte[] digiest = messageDigest.digest(); String hashedOutput = DatatypeConverter.printHexBinary(digiest); System.out.println(hashedOutput); } }
for (StackTraceElement ste : Thread.currentThread().getStackTrace()) { System.out.println(ste); }
StringWriter sw = new StringWriter(); new Throwable("").printStackTrace(new PrintWriter(sw)); String stackTrace = sw.toString();
String fullStackTrace = org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace(e);
import android.util.Log; String stackTrace = Log.getStackTraceString(exception);
ThreadMXBean bean = ManagementFactory.getThreadMXBean(); ThreadInfo[] infos = bean.dumpAllThreads(true, true); for (ThreadInfo info : infos) { StackTraceElement[] elems = info.getStackTrace(); }
new Exception().printStackTrace(); new Error().printStackTrace();
Arrays.toString(Thread.currentThread().getStackTrace());
public static void showTrace() { List<StackFrame> frames = StackWalker.getInstance( Option.RETAIN_CLASS_REFERENCE ) .walk( stream -> stream.collect( Collectors.toList() ) ); for ( StackFrame stackFrame : frames ) System.out.println( stackFrame ); }
static String getStackTrace(Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); t.printStackTrace(pw); pw.flush(); sw.flush(); return sw.toString(); }
... catch (FileNotFoundException e) { logger.config(getStackTrace(e)); }
try { } catch(Exception e) { StackTraceElement[] traceElements = e.getStackTrace(); }
catch(Exception e) { StringWriter writer = new StringWriter(); PrintWriter pw = new PrintWriter(writer); e.printStackTrace(pw); String errorDetail = writer.toString(); }
StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().
for (StackTraceElement ste : stackTraceElements ) { }
Usage: jstack [-l] <pid> (to connect to running process) jstack -F [-m] [-l] <pid> (to connect to a hung process) jstack [-m] [-l] <executable> <core> (to connect to a core file) jstack [-m] [-l] [server_id@]<remote server IP or hostname> (to connect to a remote debug server) Options: -F to force a thread dump. Use when jstack <pid> does not respond (process is hung) -m to print both java and native frames (mixed mode) -l long listing. Prints additional information about locks -h or -help to print this help message
public final class DebugUtil { private static final String SEPARATOR = "\n"; private DebugUtil() { } public static String formatStackTrace(StackTraceElement[] stackTrace) { StringBuilder buffer = new StringBuilder(); for (StackTraceElement element : stackTrace) { buffer.append(element).append(SEPARATOR); } return buffer.toString(); } public static String formatCurrentStacktrace() { StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); return formatStackTrace(stackTrace); } }
StackTraceElement[] ste = Thread.currentThread().getStackTrace();
Arrays.asList(ste).stream().forEach(System.out::println);
StringBuilder sb = new StringBuilder(); for (StackTraceElement st : ste) { sb.append(st.toString() + System.lineSeparator()); } System.out.println(sb);
Manifest-Version: 1.0 Implementation-Title: myapp Implementation-Version: 1.0.1 Class-Path: lib/dep1.jar lib/dep2.jar
java -classpath "lib/a*.jar:." my.package.Program java -classpath "lib/a*:." my.package.Program java -classpath "lib/*.jar:." my.package.Program java -classpath lib/*:. my.package.Program
<path id="base.class.path"> <pathelement path="${resources.dir}"/> <fileset dir="${extensions.dir}" includes="*.jar" /> <fileset dir="${lib.dir}" includes="*.jar"/> </path>
javac -cp libs/* -verbose -encoding UTF-8 src/mypackage/*.java -d build/classes
java -cp "target\\*;target\\dependency\\*" my.package.Main
opt1: "Extract required libraries into generated JAR" opt2: "Package required libraries into generated JAR" opt3: "Copy required libraries into a sub-folder next to the generated JAR"
/theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile.jar /theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile_lib/SomeOtherJar01.jar /theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile_lib/SomeOtherJar02.jar /theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile_lib/SomeOtherJar03.jar /theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile_lib/SomeOtherJar04.jar
java -classpath "/theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile_lib/*" -jar /theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile.jar package.path_to.the_class_with.your_main.TheClassWithYourMain
java -classpath "/theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile.jar;/theFully/qualifiedPath/toYourChosenDir/fooBarTheJarFile_lib/*" somepackages.inside.yourJar.leadingToTheMain.TheClassWithYourMain
cd /theFully/qualifiedPath/toYourChosenDir/; BREAKS: java -cp "fooBarTheJarFile_lib/*" package.path_to.the_class_with.your_main.TheClassWithYourMain BREAKS: java -cp ".;fooBarTheJarFile_lib/*" package.path_to.the_class_with.your_main.TheClassWithYourMain BREAKS: java -cp ".;fooBarTheJarFile_lib/*" -jar package.path_to.the_class_with.your_main.TheClassWithYourMain WORKS: java -cp ".;fooBarTheJarFile_lib/*" -jar fooBarTheJarFile.jar package.path_to.the_class_with.your_main.TheClassWithYourMain
setenv CLASSPATH /User/username/newfolder/jarfile.jar:jarfile2.jar:jarfile3.jar:.
> mvn clean install > java -cp "webapp/target/webapp-1.17.0-SNAPSHOT/WEB-INF/lib/tool-jar-1.17.0-SNAPSHOT.jar;webapp/target/webapp-1.17.0-SNAPSHOT/WEB-INF/lib/*" com.xx.xx.util.EncryptorUtils param1 param2
libDir2Scan4jars="../test";cp=""; for j in `ls ${libDir2Scan4jars}/*.jar`; do if [ "$j" != "" ]; then cp=$cp:$j; fi; done; echo $cp| cut -c2-${
CLASSPATH=${ORACLE_HOME}/jdbc/lib/ojdbc6.jar:${ORACLE_HOME}/jdbc/lib/ojdbc14.jar:${ORACLE_HOME}/jdbc/lib/nls_charset12.jar; CLASSPATH=$CLASSPATH:/export/home/gs806e/tops/jconn2.jar:.; export CLASSPATH
-startup plugins/org.eclipse.equinox.launcher_1.1.1.R36x_v20101122_1400.jar --launcher.library plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.2.R36x_v20101222 -product org.eclipse.epp.package.java.product --launcher.defaultAction openFile --launcher.XXMaxPermSize 256M -showsplash org.eclipse.platform -vm C:\Program Files\Java\jdk1.6.0_32\bin\javaw.exe --launcher.XXMaxPermSize 256m --launcher.defaultAction openFile -vmargs -Dosgi.requiredJavaVersion=1.5 -Xms40m -Xmx512m
-vm C:\Program Files (x86)\Java\jdk1.7.0_55\bin\javaw.exe
"C:\Program Files\eclipse\eclipse.exe" -vm "c:\Program Files\Java\jdk1.7.0_04\bin\javaw.exe"
java version "1.7.0" Java(TM) SE Runtime Environment (build 1.7.0-b147) Java HotSpot(TM) 64-Bit Server VM (build 21.0-b17, mixed mode)
-vm C:\Progra~1\Java\jdk1.6.0_38\jre\bin\server\jvm.dll
"C:\studio\eclipse.exe" -vm "C:\Program Files\Java\jre7\bin\server\jvm.dll" eclipse.vm="C:\Program Files\Java\jre7\bin\server\jvm.dll" java.home="C:\Program Files\Java\jre7" java.runtime.version=1.7.0
org.apache.commons.lang.StringUtils.leftPad(String str, int size,
int a = 11; String with3digits = String.format("%03d", a); System.out.println(with3digits);
import java.text.DecimalFormat; class TestingAndQualityAssuranceDepartment { public static void main(String [] args) { int x=1; DecimalFormat df = new DecimalFormat("00"); System.out.println(df.format(x)); } }
/** * @param in The integer value * @param fill The number of digits to fill * @return The given value left padded with the given number of digits */ public static String lPadZero(int in, int fill){ boolean negative = false; int value, len = 0; if(in >= 0){ value = in; } else { negative = true; value = - in; in = - in; len ++; } if(value == 0){ len = 1; } else{ for(; value != 0; len ++){ value /= 10; } } StringBuilder sb = new StringBuilder(); if(negative){ sb.append( } for(int i = fill; i > len; i--){ sb.append( } sb.append(in); return sb.toString(); }
public static void main(String[] args) { Random rdm; long start; rdm = new Random(0); start = System.nanoTime(); for(int i = 10000000; i != 0; i--){ lPadZero(rdm.nextInt(20000) - 10000, 4); } System.out.println("Own function: " + ((System.nanoTime() - start) / 1000000) + "ms"); rdm = new Random(0); start = System.nanoTime(); for(int i = 10000000; i != 0; i--){ String.format("%04d", rdm.nextInt(20000) - 10000); } System.out.println("String.format: " + ((System.nanoTime() - start) / 1000000) + "ms"); }
<dependency> <artifactId>guava</artifactId> <groupId>com.google.guava</groupId> <version>14.0.1</version> </dependency>
String paddedString1 = Strings.padStart("7", 3, String paddedString2 = Strings.padStart("2020", 3,
DecimalFormat df = new DecimalFormat("0000"); String c = df.format(9); String a = df.format(99); String b = df.format(999);
import java.text.NumberFormat; public class NumberFormatMain { public static void main(String[] args) { int intNumber = 25; float floatNumber = 25.546f; NumberFormat format=NumberFormat.getInstance(); format.setMaximumIntegerDigits(6); format.setMaximumFractionDigits(6); format.setMinimumFractionDigits(6); format.setMinimumIntegerDigits(6); System.out.println("Formatted Integer : "+format.format(intNumber).replace(",","")); System.out.println("Formatted Float : "+format.format(floatNumber).replace(",","")); } }
NumberFormat formatter = new DecimalFormat("0000"); System.out.println("OUTPUT : "+formatter.format(811));
int number=2; int requiredLengthAfterPadding=4; String resultString=Integer.toString(number); int inputStringLengh=resultString.length(); int diff=requiredLengthAfterPadding-inputStringLengh; if(inputStringLengh<requiredLengthAfterPadding) { resultString=new String(new char[diff]).replace("\0", "0")+number; } System.out.println(resultString);
int inputNo = 1; NumberFormat nf = NumberFormat.getInstance(); nf.setMaximumIntegerDigits(4); nf.setMinimumIntegerDigits(4); nf.setGroupingUsed(false); System.out.println("Formatted Integer : " + nf.format(inputNo));
public static String zeroPad(long number, int width) { long wrapAt = (long)Math.pow(10, width); return String.valueOf(number % wrapAt + wrapAt).substring(1); }
String paddedString = i < 100 ? i < 10 ? "00" + i : "0" + i : "" + i;
public static class ViewHolder extends RecyclerView.ViewHolder implements OnClickListener { public TextView txtViewTitle; public ImageView imgViewIcon; public ViewHolder(View itemLayoutView) { super(itemLayoutView); txtViewTitle = (TextView) itemLayoutView.findViewById(R.id.item_title); imgViewIcon = (ImageView) itemLayoutView.findViewById(R.id.item_icon); } @Override public void onClick(View v) { } }
public class ReactiveAdapter extends RecyclerView.Adapter<MyAdapter.ViewHolder> { String[] mDataset = { "Data", "In", "Adapter" }; private final PublishSubject<String> onClickSubject = PublishSubject.create(); @Override public void onBindViewHolder(final ViewHolder holder, int position) { final String element = mDataset[position]; holder.itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { onClickSubject.onNext(element); } }); } public Observable<String> getPositionClicks(){ return onClickSubject.asObservable(); } }
public static class ViewHolder extends RecyclerView.ViewHolder implements OnClickListener { public TextView txtViewTitle; public ImageView imgViewIcon; public IMyViewHolderClicks mListener; public ViewHolder(View itemLayoutView, IMyViewHolderClicks listener) { super(itemLayoutView); mListener = listener; txtViewTitle = (TextView) itemLayoutView.findViewById(R.id.item_title); imgViewIcon = (ImageView) itemLayoutView.findViewById(R.id.item_icon); imgViewIcon.setOnClickListener(this); itemLayoutView.setOnClickListener(this); } @Override public void onClick(View v) { if (v instanceof ImageView){ mListener.onTomato((ImageView)v); } else { mListener.onPotato(v); } } public static interface IMyViewHolderClicks { public void onPotato(View caller); public void onTomato(ImageView callerImage); } }
public class MyAdapter extends RecyclerView.Adapter<MyAdapter.ViewHolder> { String[] mDataset = { "Data" }; @Override public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.my_layout, parent, false); MyAdapter.ViewHolder vh = new ViewHolder(v, new MyAdapter.ViewHolder.IMyViewHolderClicks() { public void onPotato(View caller) { Log.d("VEGETABLES", "Poh-tah-tos"); }; public void onTomato(ImageView callerImage) { Log.d("VEGETABLES", "To-m8-tohs"); } }); return vh; } @Override public void onBindViewHolder(ViewHolder holder, int position) { holder.txtViewTitle.setText(mDataset[position]); } @Override public int getItemCount() { return mDataset.length; } ...
ItemClickSupport.addTo(mRecyclerView) .setOnItemClickListener(new ItemClickSupport.OnItemClickListener() { @Override public void onItemClicked(RecyclerView recyclerView, int position, View v) { } });
public class ItemClickSupport { private final RecyclerView mRecyclerView; private OnItemClickListener mOnItemClickListener; private OnItemLongClickListener mOnItemLongClickListener; private View.OnClickListener mOnClickListener = new View.OnClickListener() { @Override public void onClick(View v) { if (mOnItemClickListener != null) { RecyclerView.ViewHolder holder = mRecyclerView.getChildViewHolder(v); mOnItemClickListener.onItemClicked(mRecyclerView, holder.getAdapterPosition(), v); } } }; private View.OnLongClickListener mOnLongClickListener = new View.OnLongClickListener() { @Override public boolean onLongClick(View v) { if (mOnItemLongClickListener != null) { RecyclerView.ViewHolder holder = mRecyclerView.getChildViewHolder(v); return mOnItemLongClickListener.onItemLongClicked(mRecyclerView, holder.getAdapterPosition(), v); } return false; } }; private RecyclerView.OnChildAttachStateChangeListener mAttachListener = new RecyclerView.OnChildAttachStateChangeListener() { @Override public void onChildViewAttachedToWindow(View view) { if (mOnItemClickListener != null) { view.setOnClickListener(mOnClickListener); } if (mOnItemLongClickListener != null) { view.setOnLongClickListener(mOnLongClickListener); } } @Override public void onChildViewDetachedFromWindow(View view) { } }; private ItemClickSupport(RecyclerView recyclerView) { mRecyclerView = recyclerView; mRecyclerView.setTag(R.id.item_click_support, this); mRecyclerView.addOnChildAttachStateChangeListener(mAttachListener); } public static ItemClickSupport addTo(RecyclerView view) { ItemClickSupport support = (ItemClickSupport) view.getTag(R.id.item_click_support); if (support == null) { support = new ItemClickSupport(view); } return support; } public static ItemClickSupport removeFrom(RecyclerView view) { ItemClickSupport support = (ItemClickSupport) view.getTag(R.id.item_click_support); if (support != null) { support.detach(view); } return support; } public ItemClickSupport setOnItemClickListener(OnItemClickListener listener) { mOnItemClickListener = listener; return this; } public ItemClickSupport setOnItemLongClickListener(OnItemLongClickListener listener) { mOnItemLongClickListener = listener; return this; } private void detach(RecyclerView view) { view.removeOnChildAttachStateChangeListener(mAttachListener); view.setTag(R.id.item_click_support, null); } public interface OnItemClickListener { void onItemClicked(RecyclerView recyclerView, int position, View v); } public interface OnItemLongClickListener { boolean onItemLongClicked(RecyclerView recyclerView, int position, View v); } }
<?xml version="1.0" encoding="utf-8"?> <resources> <item name="item_click_support" type="id" /> </resources>
public Adapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)
View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.view_image_and_text, parent, false); v.setOnClickListener(new MyOnClickListener());
class MyOnClickListener implements View.OnClickListener { @Override public void onClick(View v) { int itemPosition = recyclerView.indexOfChild(v); Log.e("Clicked and Position is ",String.valueOf(itemPosition)); } }
public class RecyclerItemClickListener implements RecyclerView.OnItemTouchListener { private OnItemClickListener mListener; public interface OnItemClickListener { public void onItemClick(View view, int position); } GestureDetector mGestureDetector; public RecyclerItemClickListener(Context context, OnItemClickListener listener) { mListener = listener; mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() { @Override public boolean onSingleTapUp(MotionEvent e) { return true; } }); } @Override public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent e) { View childView = view.findChildViewUnder(e.getX(), e.getY()); if (childView != null && mListener != null && mGestureDetector.onTouchEvent(e)) { mListener.onItemClick(childView, view.getChildAdapterPosition(childView)); } return false; } @Override public void onTouchEvent(RecyclerView view, MotionEvent motionEvent) { } @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) { } }
recyclerView = (RecyclerView)rootView. findViewById(R.id.recyclerView); RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(getActivity()); recyclerView.setLayoutManager(mLayoutManager); recyclerView.addOnItemTouchListener( new RecyclerItemClickListener(getActivity(), new RecyclerItemClickListener.OnItemClickListener() { @Override public void onItemClick(View view, int position) { Log.e("@@@@@",""+position); } }) );
public class MyAdapter extends RecyclerView.Adapter<MyAdapter.ViewHolder>{ private LayoutInflater layoutInflater; private List<MyObject> items; private AdapterView.OnItemClickListener onItemClickListener; public MyAdapter(Context context, AdapterView.OnItemClickListener onItemClickListener, List<MyObject> items) { layoutInflater = LayoutInflater.from(context); this.items = items; this.onItemClickListener = onItemClickListener; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = layoutInflater.inflate(R.layout.my_row_layout, parent, false); return new ViewHolder(view); } @Override public void onBindViewHolder(ViewHolder holder, int position) { MyObject item = items.get(position); } public MyObject getItem(int position) { return items.get(position); } class ViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener { private TextView title; private ImageView avatar; public ViewHolder(View itemView) { super(itemView); title = itemView.findViewById(R.id.title); avatar = itemView.findViewById(R.id.avatar); title.setOnClickListener(this); avatar.setOnClickListener(this); itemView.setOnClickListener(this); } @Override public void onClick(View view) { onItemClickListener.onItemClick(null, view, getAdapterPosition(), view.getId()); } } }
public class MyFragment extends Fragment implements AdapterView.OnItemClickListener { private RecyclerView recycleview; private MyAdapter adapter; . . . private void init(Context context) { adapter = new MyAdapter(context, this, items); recycleview.setAdapter(adapter); } @Override public void onItemClick(AdapterView<?> parent, View view, int position, long id) { MyObject item = adapter.getItem(position); switch (view.getId()) { case R.id.title: break; case R.id.avatar: break; default: } } }
RecyclerView recyclerView = (RecyclerView) findViewById(R.id.users_list); UsersAdapter adapter = new UsersAdapter(users, this); recyclerView.setAdapter(adapter); adapter.setOnCardClickListner(this);
public class UsersAdapter extends RecyclerView.Adapter<UsersAdapter.UserViewHolder> { private ArrayList<User> mDataSet; OnCardClickListner onCardClickListner; public UsersAdapter(ArrayList<User> mDataSet) { this.mDataSet = mDataSet; } @Override public UserViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.user_row_layout, parent, false); UserViewHolder userViewHolder = new UserViewHolder(v); return userViewHolder; } @Override public void onBindViewHolder(UserViewHolder holder, final int position) { holder.name_entry.setText(mDataSet.get(position).getUser_name()); holder.cardView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { onCardClickListner.OnCardClicked(v, position); } }); } @Override public int getItemCount() { return mDataSet.size(); } @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) { super.onAttachedToRecyclerView(recyclerView); } public static class UserViewHolder extends RecyclerView.ViewHolder { CardView cardView; TextView name_entry; public UserViewHolder(View itemView) { super(itemView); cardView = (CardView) itemView.findViewById(R.id.user_layout); name_entry = (TextView) itemView.findViewById(R.id.name_entry); } } public interface OnCardClickListner { void OnCardClicked(View view, int position); } public void setOnCardClickListner(OnCardClickListner onCardClickListner) { this.onCardClickListner = onCardClickListner; } }
@Override public void OnCardClicked(View view, int position) { Log.d("OnClick", "Card Position" + position); }
LinearLayoutManager llm = new LinearLayoutManager(context); llm.setOrientation(LinearLayoutManager.HORIZONTAL); recyclerView.setLayoutManager(llm);
public class OrderListCursorAdapter extends CursorRecyclerViewAdapter<OrderListCursorAdapter.ViewHolder> { private static final String TAG = OrderListCursorAdapter.class.getSimpleName(); private static final int ID_VIEW_HOLDER_ACTUAL = 0; private static final int ID_VIEW_HOLDER = 1; public OrderListCursorAdapter(Context context, Cursor cursor) { super(context, cursor); } public static class ViewHolderActual extends ViewHolder { private static final String TAG = ViewHolderActual.class.getSimpleName(); protected IViewHolderClick listener; protected Button button; public ViewHolderActual(View v, IViewHolderClick listener) { super(v, listener); this.listener = listener; button = (Button) v.findViewById(R.id.orderList_item_button); button.setOnClickListener(this); } public void initFromData(OrderData data) { Log.d(TAG, "><initFromData(data=" + data + ")"); orderId = data.getId(); vAddressStart.setText(data.getAddressStart()); vAddressEnd.setText(data.getAddressEnd()); } @Override public void onClick(View view) { if (view instanceof Button) { listener.onButtonClick((Button) view, getPosition(), this); } else { super.onClick(view); } } public interface IViewHolderClick extends ViewHolder.IViewHolderClick { public void onButtonClick(Button button, int position, ViewHolder viewHolder); } } public static class ViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener { private static final String TAG = ViewHolder.class.getSimpleName(); protected long orderId; protected IViewHolderClick listener; protected TextView vAddressStart; protected TextView vAddressEnd; protected TextView vStatus; public ViewHolder(View v, IViewHolderClick listener) { super(v); this.listener = listener; v.setOnClickListener(this); vAddressStart = (TextView) v.findViewById(R.id.addressStart); vAddressEnd = (TextView) v.findViewById(R.id.addressEnd); vStatus = (TextView) v.findViewById(R.id.status); } public void initFromData(OrderData data) { Log.d(TAG, "><initFromData(data=" + data + ")"); orderId = data.getId(); vAddressStart.setText(data.getAddressStart()); vAddressEnd.setText(data.getAddressEnd()); } public long getOrderId() { return orderId; } @Override public void onClick(View view) { listener.onCardClick(view, getPosition(), this); } public interface IViewHolderClick { public void onCardClick(View view, int position, ViewHolder viewHolder); } } @Override public int getItemViewType(int position) { return position == 0 ? ID_VIEW_HOLDER_ACTUAL : ID_VIEW_HOLDER; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { Log.d(TAG, ">>onCreateViewHolder(parent=" + parent + ", viewType=" + viewType + ")"); ViewHolder result; switch (viewType) { case ID_VIEW_HOLDER_ACTUAL: { View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.card_layout_actual, parent, false); result = new ViewHolderActual(itemView, new ViewHolderActual.IViewHolderClick() { @Override public void onCardClick(View view, int position, ViewHolder viewHolder) { Log.d(TAG, "><onCardClick(view=" + view + ", position=" + position + ", viewHolder=" + viewHolder + ")"); Intent intent = new Intent(view.getContext(), OrderDetailActivity.class); intent.putExtra(OrderDetailActivity.ARG_ORDER_ID, viewHolder.getOrderId()); view.getContext().startActivity(intent); } @Override public void onButtonClick(Button button, int position, ViewHolder viewHolder) { Log.d(TAG, "><onButtonClick(button=" + button + ", position=" + position + ", viewHolder=" + viewHolder + ")"); Intent intent = new Intent(button.getContext(), OrderMapActivity.class); intent.putExtra(OrderMapActivity.ARG_ORDER_ID, viewHolder.getOrderId()); button.getContext().startActivity(intent); } }); break; } case ID_VIEW_HOLDER: default: { View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.card_layout, parent, false); result = new ViewHolder(itemView, new ViewHolder.IViewHolderClick() { @Override public void onCardClick(View view, int position, ViewHolder viewHolder) { Log.d(TAG, "><onCardClick(view=" + view + ", position=" + position + ", viewHolder=" + viewHolder + ")"); Intent intent = new Intent(view.getContext(), OrderDetailActivity.class); intent.putExtra(OrderDetailActivity.ARG_ORDER_ID, viewHolder.getOrderId()); view.getContext().startActivity(intent); } }); break; } } Log.d(TAG, "<<onCreateViewHolder(parent=" + parent + ", viewType=" + viewType + ")= " + result); return result; } @Override public void onBindViewHolder(ViewHolder viewHolder, Cursor cursor) { Log.d(TAG, "><onBindViewHolder(viewHolder=" + viewHolder + ", cursor=" + cursor + ")"); final OrderData orderData = new OrderData(cursor); viewHolder.initFromData(orderData); } }
class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener{ private ImageView image; private TextView title; private TextView price; public MyViewHolder(View itemView) { super(itemView); image = (ImageView)itemView.findViewById(R.id.horizontal_list_image); title = (TextView)itemView.findViewById(R.id.horizontal_list_title); price = (TextView)itemView.findViewById(R.id.horizontal_list_price); image.setOnClickListener(this); title.setOnClickListener(this); price.setOnClickListener(this); } @Override public void onClick(View v) { Toast.makeText(context, "Item click nr: "+getLayoutPosition(), Toast.LENGTH_SHORT).show(); } }
ReactiveAdapter rxAdapter = new ReactiveAdapter(); rxAdapter.getPositionClicks().subscribe(mClickConsumer); Consumer<String> mClickConsumer = new Consumer<String>() { @Override public void accept(@NonNull String element) throws Exception { Toast.makeText(getApplicationContext(), element +" was clicked", Toast.LENGTH_LONG).show(); } };
public Observable<String> getPositionClicks(){ return onClickSubject; }
class NormalViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener{ @Bind(R.id.card_item_normal) CardView cardView; public NormalViewHolder(View itemView) { super(itemView); ButterKnife.bind(this, itemView); cardView.setOnClickListener(this); } @Override public void onClick(View v) { if(v instanceof CardView) { int itemPosition = getAdapterPosition(); removeItem(itemPosition); } } }
private class ChildViewHolder extends RecyclerView.ViewHolder { public ImageView imageView; public TextView txtView; public ChildViewHolder(View itemView) { super(itemView); imageView= (ImageView)itemView.findViewById(R.id.imageView); txtView= (TextView) itemView.findViewById(R.id.txtView); itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Log.i("RecyclerView Item Click Position", String.valueOf(getLayoutPosition())); } }); } }
@Override public void onBindViewHolder(ViewHolder viewHolder, int i) { final MyClass myClass = mList.get(i); viewHolder.txtViewTitle.setText(myclass.name); ... viewHolder.itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v){ Intent detailIntent = new Intent(mContext, type.class); detailIntent.putExtra("MyClass", myclass); mContext.startActivity(detailIntent); } } );
public class MyAdapter extends RecyclerView.Adapter<SitesListAdapter.ViewHolder> { ... private List<MyPojo> mMyPojos; private static OnItemClickListener mOnItemClickListener; ... public interface OnItemClickListener { public void onItemClick(MyPojo pojo); } ... public void setOnItemClickListener(OnItemClickListener onItemClickListener){ mOnItemClickListener = onItemClickListener; } ...
public static class ViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener { public MyPojo mCurrentPojo; ... public ViewHolder(View view) { super(v); ... view.setOnClickListener(this); } ... @Override public void onClick(View view) { if(mOnItemClickListener != null && mCurrentPojo != null){ mOnItemClickListener.onItemClick(mCurrentPojo); } }
@Override public void onBindViewHolder(final ViewHolder holder, final int position) { final MyPojo currentPojo = mMyPojos.get(position); holder.mCurrentPojo = currentPojo; ...
mMyAdapter.setOnItemClickListener(new mMyAdapter.OnItemClickListener() { @Override public void onItemClick(MyPojo pojo) { } });
/** * Interface used for delegating item click events in a {@link android.support.v7.widget.RecyclerView} * Created by Alex on 11/28/2015. */ public interface OnRecyclerItemClickListener<T> { /** * Called when a click occurred inside a recyclerView item view * @param view that was clicked * @param position of the clicked view * @param item the concrete data that is displayed through the clicked view */ void onItemClick(View view, int position, T item); }
public class CustomRecyclerAdapter extends RecyclerView.Adapter { private class InternalClickListener implements View.OnClickListener{ @Override public void onClick(View v) { if(mRecyclerView != null && mItemClickListener != null){ int position = mRecyclerView.getChildAdapterPosition(v); Data data = getItem(position); mItemClickListener.onItemClick(v, position, data); } } } private final OnRecyclerItemClickListener mItemClickListener; private RecyclerView mRecyclerView; private InternalClickListener mInternalClickListener; /** * * @param itemClickListener used to trigger an item click event */ public PlayerListRecyclerAdapter(OnRecyclerItemClickListener itemClickListener){ mItemClickListener = itemClickListener; mInternalClickListener = new InternalClickListener(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); v.setOnClickListener(mInternalClickListener); ViewHolder viewHolder = new ViewHolder(v); return viewHolder; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { } @Override public int getItemCount() { return mDataSet.size(); } @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) { super.onAttachedToRecyclerView(recyclerView); mRecyclerView = recyclerView; } @Override public void onDetachedFromRecyclerView(RecyclerView recyclerView) { super.onDetachedFromRecyclerView(recyclerView); mRecyclerView = null; } public Data getItem(int position){ return mDataset.get(position); } }
public class TestFragment extends Fragment implements OnRecyclerItemClickListener<Data>{ private RecyclerView mRecyclerView; @Override public void onItemClick(View view, int position, Data item) { } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.test_fragment, container, false); } @Override public void onViewCreated(View view, Bundle savedInstanceState) { mRecyclerView = view.findViewById(idOfTheRecycler); mRecyclerView .setAdapter(new CustomRecyclerAdapter(this)); }
public class MyAdapter extends RecyclerView.Adapter<MyViewHolder> { private final Clicks clicks; public MyAdapter(Clicks clicks) { this.clicks = clicks; } private List<MyObject> items = Collections.emptyList(); public void updateData(List<MyObject> items) { this.items = items; notifyDataSetChanged(); } public interface Clicks { void onItemSelected(MyObject myObject, int position); } public class MyViewHolder extends RecyclerView.ViewHolder { private MyObject myObject; public MyViewHolder(View view) { super(view); view.setOnClickListener((v) -> { int adapterPosition = getAdapterPosition(); if(adapterPosition >= 0) { clicks.onItemSelected(myObject, adapterPosition); } }); } public void bind(MyObject myObject) { this.myObject = myObject; } } }
class MyAdapter(val itemClicks: (MyObject, Int) -> Unit): RecyclerView.Adapter<MyViewHolder>() { private var items: List<MyObject> = Collections.emptyList() fun updateData(items: List<MyObject>) { this.items = items notifyDataSetChanged() } inner class MyViewHolder(val myView: View): RecyclerView.ViewHolder(myView) { private lateinit var myObject: MyObject init { myView.onClick { val adapterPosition = getAdapterPosition() if(adapterPosition >= 0) { itemClicks.invoke(myObject, adapterPosition) } } } fun bind(myObject: MyObject) { this.myObject = myObject } } }
@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View v = LayoutInflater .from(parent.getContext()) .inflate(R.layout.cell, null); Button btn = (Button) v.findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { } }); return new MyViewHolder(v); }
public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType) { View view = LayoutInflator.from(parent.getContext()).inflate(R.layout.layoutID,null); ViewHolder holder = new ViewHolder(view); view.setOnClickListener(new View.OnClickListeener(){ public void onClick(View v) { } }); return holder;
public class RVNewsAdapter extends RecyclerView.Adapter<RVNewsAdapter.FeedHolder> { private Context context; List<News> newsList; private int lastPosition = -1; public RVNewsAdapter(List<News> newsList, Context context) { this.newsList = newsList; this.context = context; } public static class FeedHolder extends RecyclerView.ViewHolder implements OnClickListener { ImageView img_main; TextView tv_title; Button bt_facebook, bt_twitter, bt_share, bt_comment; public FeedHolder(View itemView) { super(itemView); img_main = (ImageView) itemView.findViewById(R.id.img_main); tv_title = (TextView) itemView.findViewById(R.id.tv_title); bt_facebook = (Button) itemView.findViewById(R.id.bt_facebook); bt_twitter = (Button) itemView.findViewById(R.id.bt_twitter); bt_share = (Button) itemView.findViewById(R.id.bt_share); bt_comment = (Button) itemView.findViewById(R.id.bt_comment); img_main.setOnClickListener(this); bt_facebook.setOnClickListener(this); bt_twitter.setOnClickListener(this); bt_comment.setOnClickListener(this); bt_share.setOnClickListener(this); } @Override public void onClick(View v) { if (v.getId() == bt_comment.getId()) { Toast.makeText(v.getContext(), "Comment " , Toast.LENGTH_SHORT).show(); } else if (v.getId() == bt_facebook.getId()) { Toast.makeText(v.getContext(), "Facebook " , Toast.LENGTH_SHORT).show(); } else if (v.getId() == bt_twitter.getId()) { Toast.makeText(v.getContext(), "Twitter " , Toast.LENGTH_SHORT).show(); } else if (v.getId() == bt_share.getId()) { Toast.makeText(v.getContext(), "share " , Toast.LENGTH_SHORT).show(); } else { Toast.makeText(v.getContext(), "ROW PRESSED = " + String.valueOf(getAdapterPosition()), Toast.LENGTH_SHORT).show(); } } } @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) { super.onAttachedToRecyclerView(recyclerView); } @Override public FeedHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.feed_row, parent, false); FeedHolder feedHolder = new FeedHolder(view); return feedHolder; } @Override public void onBindViewHolder(FeedHolder holder, int position) { holder.tv_title.setText(newsList.get(position).getTitle()); setAnimation(holder.img_main, position); } @Override public int getItemCount() { return newsList.size(); } /** * Here is the key method to apply the animation */ private void setAnimation(View viewToAnimate, int position) { if (position > lastPosition) { Animation animation = AnimationUtils.loadAnimation(context, android.R.anim.slide_in_left); viewToAnimate.startAnimation(animation); lastPosition = position; } } }
public class MyViewHolder extends RecyclerView.ViewHolder { private Context mContext; public MyViewHolder(View itemView) { super(itemView); mContext = itemView.getContext(); itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { int itemPosition = getLayoutPosition(); Toast.makeText(mContext, "" + itemPosition, Toast.LENGTH_SHORT).show(); } }); }
public class RecyclerViewHolder extends RecyclerView.ViewHolder { public ImageView imageView,imageView2; public RecyclerViewHolder(View itemView) { super(itemView); this.imageView=(ImageView)itemView.findViewById(R.id.image); } }
public class RecyclerView_Adapter extends RecyclerView.Adapter<RecyclerViewHolder> { private ArrayList<ModelClass> arrayList; private Context context; private static RecyclerViewClickListener itemListener; RecyclerView_Adapter(Context context,ArrayList<ModelClass> arrayList,RecyclerViewClickListener itemListener){ this.context=context; this.arrayList=arrayList; this.itemListener=itemListener; } @Override public RecyclerViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { LayoutInflater layoutInflater=LayoutInflater.from(parent.getContext()); ViewGroup mainGroup=(ViewGroup) layoutInflater.inflate(R.layout.single_item,parent,false); RecyclerViewHolder listHolder=new RecyclerViewHolder(mainGroup); return listHolder; } @Override public void onBindViewHolder(RecyclerViewHolder holder, final int position) { final ModelClass modelClass=arrayList.get(position); RecyclerViewHolder mainHolder=(RecyclerViewHolder)holder; Bitmap image= BitmapFactory.decodeResource(context.getResources(),modelClass.getImage()); mainHolder.imageView.setImageBitmap(image); mainHolder.itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { itemListener.recyclerViewListClicked(v,position); } }); } @Override public int getItemCount() { return (null!=arrayList?arrayList.size():0); } }
public interface RecyclerViewClickListener { public void recyclerViewListClicked(View v,int position); } RecyclerView_Adapter adapter=new RecyclerView_Adapter(Wallpaper.this,arrayList,this); recyclerView.setAdapter(adapter); adapter.notifyDataSetChanged(); @Override public void recyclerViewListClicked(View v,int position){ imageView.setImageResource(wallpaperImages[position]); }
@Override public void onBindViewHolder(PlacesListViewAdapter.ViewHolder holder, int position) { ---- ---- ---- } @Override public class ViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener { ---- ---- ---- @Override public void onClick(View view) { } }
@Override public void onBindViewHolder(MyViewHolder holder, final int position) { Movie movie = moviesList.get(position); holder.mainView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { System.out.println("pos " + position); } }); }
class GeneralViewHolder extends RecyclerView.ViewHolder { View cachedView = null; public GeneralViewHolder(View itemView) { super(itemView); cachedView = itemView; }
@Override public void onBindViewHolder(RecyclerView.ViewHolder holder, final int position) { final GeneralViewHolder generalViewHolder = (GeneralViewHolder) holder; generalViewHolder.cachedView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(context, "item Clicked at "+position, Toast.LENGTH_SHORT).show(); } });
main_recyclerview.addOnItemTouchListener(new RecyclerView.OnItemTouchListener() { @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { int position=rv.getChildAdapterPosition(rv.findChildViewUnder(e.getX(),e.getY())); switch (position) { case 0: { wifi(position); adapter2.notifyDataSetChanged(); } break; case 1: { sound(position); adapter2.notifyDataSetChanged(); } break; case 2: { bluetooth(position); adapter2.notifyDataSetChanged(); } break; } return true; } @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) { } @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) { } });
public static class SimpleStringRecyclerViewAdapter extends RecyclerView.Adapter<SimpleStringRecyclerViewAdapter.ViewHolder> { private List<String> mValues; public static class ViewHolder extends RecyclerView.ViewHolder { public final View mView; public ViewHolder(View view) { super(view); mView = view; /* your row widgets initializations goes here mImageView = (ImageView) view.findViewById(R.id.avatar); mTextView = (TextView) view.findViewById(android.R.id.text1);*/ } } public String getValueAt(int position) { return mValues.get(position); } public SimpleStringRecyclerViewAdapter(Context context, List<String> items) { mBackground = mTypedValue.resourceId; mValues = items; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.list_item, parent, false); view.setBackgroundResource(mBackground); return new ViewHolder(view); } @Override public void onBindViewHolder(final ViewHolder holder, int position) { holder.mBoundString = mValues.get(position); holder.mTextView.setText(mValues.get(position)); holder.mView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Context context = v.getContext(); Intent intent = new Intent(context, ExampleActivity.class); context.startActivity(intent); } }); } @Override public int getItemCount() { return mValues.size(); } }
@Layout(R.layout.item_view_1) public class View1{ @View(R.id.txt) public TextView txt; @Resolve public void onResolved() { txt.setText(String.valueOf(System.currentTimeMillis() / 1000)); } @Click(R.id.btn) public void onClick(){ txt.setText(String.valueOf(System.currentTimeMillis() / 1000)); } }
RecycleClick.addTo(YOUR_RECYCLEVIEW).setOnItemClickListener(new RecycleClick.OnItemClickListener() { @Override public void onItemClicked(RecyclerView recyclerView, int position, View v) { } });
RecycleClick.addTo(YOUR_RECYCLEVIEW).setOnItemLongClickListener(new RecycleClick.OnItemLongClickListener() { @Override public boolean onItemLongClicked(RecyclerView recyclerView, int position, View v) { return true; } });
public abstract class BaseAdapterRV<VH extends BaseViewHolder> extends RecyclerView.Adapter<VH> implements AdapterInterface { public final String TAG = getClass().getSimpleName(); protected final Activity mActivity; protected final LayoutInflater mInflater; protected ItemClickInterface<?, Integer> mListener; public BaseAdapterRV(Activity activity) { mActivity = activity; mInflater = LayoutInflater.from(mActivity); } @Override public final VH onCreateViewHolder(ViewGroup parent, int viewType) { return onCreateViewHolder(parent, viewType, mInflater); } @Override public final void onBindViewHolder(VH holder, int position) { holder.itemView.setTag(R.id.tag_view_click, position); holder.itemView.setOnClickListener(mListener); holder.itemView.setOnLongClickListener(mListener); onBindVH(holder, position); } /** * !notifyItemInsertedposition * onItemLongClick */ public void setOnItemClickListener(ItemClickInterface<?, Integer> listener) { mListener = listener; notifyDataSetChanged(); } @NonNull protected abstract VH onCreateViewHolder(ViewGroup parent, int viewType, LayoutInflater inflater); protected abstract void onBindVH(VH holder, int position); }
/** * OnItemClickListener * {@link OnItemClickListener}{@link OnItemItemClickListener} */ public interface ItemClickInterface<DATA1, DATA2> extends View.OnClickListener, View.OnLongClickListener { void onItemClick(DATA1 data1, DATA2 data2); boolean onItemLongClick(DATA1 data1, DATA2 data2); }
public abstract class OnItemClickListener<DATA> implements ItemClickInterface<View, DATA> { @Override public void onClick(View v) { onItemClick(v, (DATA) v.getTag(R.id.tag_view_click)); } @Override public boolean onLongClick(View v) { return onItemLongClick(v, (DATA) v.getTag(R.id.tag_view_click)); } @Override public boolean onItemLongClick(View view, DATA data) { return false; } }
mAdapter.setOnItemClickListener(new OnItemClickListener<Integer>() { @Override public void onItemClick(View view, Integer integer) { } @Override public boolean onItemLongClick(View view, Integer integer) { return true; } });
public Adapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)
View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.view_image_and_text, parent, false); v.setOnClickListener(new MyOnClickListener());
class MyOnClickListener implements View.OnClickListener { @Override public void onClick(View v) { int itemPosition = recyclerView.indexOfChild(v); Log.e("Clicked and Position is ",String.valueOf(itemPosition)); } }
public class SOP { public static void print(String s) { System.out.println(s+"\n"); } } public class TestThread extends Thread { String name; TheDemo theDemo; public TestThread(String name,TheDemo theDemo) { this.theDemo = theDemo; this.name = name; start(); } @Override public void run() { theDemo.test(name); } } public class TheDemo { public synchronized void test(String name) { for(int i=0;i<10;i++) { SOP.print(name + " :: "+i); try{ Thread.sleep(500); } catch (Exception e) { SOP.print(e.getMessage()); } } } public static void main(String[] args) { TheDemo theDemo = new TheDemo(); new TestThread("THREAD 1",theDemo); new TestThread("THREAD 2",theDemo); new TestThread("THREAD 3",theDemo); } }
THREAD 1 :: 0 THREAD 1 :: 1 THREAD 1 :: 2 THREAD 1 :: 3 THREAD 1 :: 4 THREAD 1 :: 5 THREAD 1 :: 6 THREAD 1 :: 7 THREAD 1 :: 8 THREAD 1 :: 9 THREAD 3 :: 0 THREAD 3 :: 1 THREAD 3 :: 2 THREAD 3 :: 3 THREAD 3 :: 4 THREAD 3 :: 5 THREAD 3 :: 6 THREAD 3 :: 7 THREAD 3 :: 8 THREAD 3 :: 9 THREAD 2 :: 0 THREAD 2 :: 1 THREAD 2 :: 2 THREAD 2 :: 3 THREAD 2 :: 4 THREAD 2 :: 5 THREAD 2 :: 6 THREAD 2 :: 7 THREAD 2 :: 8 THREAD 2 :: 9
THREAD 1 :: 0 THREAD 2 :: 0 THREAD 3 :: 0 THREAD 1 :: 1 THREAD 2 :: 1 THREAD 3 :: 1 THREAD 1 :: 2 THREAD 2 :: 2 THREAD 3 :: 2 THREAD 1 :: 3 THREAD 2 :: 3 THREAD 3 :: 3 THREAD 1 :: 4 THREAD 2 :: 4 THREAD 3 :: 4 THREAD 1 :: 5 THREAD 2 :: 5 THREAD 3 :: 5 THREAD 1 :: 6 THREAD 2 :: 6 THREAD 3 :: 6 THREAD 1 :: 7 THREAD 2 :: 7 THREAD 3 :: 7 THREAD 1 :: 8 THREAD 2 :: 8 THREAD 3 :: 8 THREAD 1 :: 9 THREAD 2 :: 9 THREAD 3 :: 9
public class SynchronizedCounter { private int c = 0; public synchronized void increment() { c++; } public synchronized void decrement() { c--; } public synchronized int value() { return c; } }
class A { public synchronized void methodA() { } equivalent to public void methodA() { synchronized(this) { } } }
class A { public static synchronized void methodA() { } equivalent to public void methodA() { synchronized(A.class) { } } }
class A { private Object lock1 = new Object(); public void methodA() { synchronized(lock1 ) { } } }
class MyRunnable implements Runnable { int var = 10; @Override public void run() { call(); } public void call() { synchronized (this) { for (int i = 0; i < 4; i++) { var++; System.out.println("Current Thread " + Thread.currentThread().getName() + " var value "+var); } } } } public class MutlipleThreadsRunnable { public static void main(String[] args) { MyRunnable runnable1 = new MyRunnable(); MyRunnable runnable2 = new MyRunnable(); Thread t1 = new Thread(runnable1); t1.setName("Thread -1"); Thread t2 = new Thread(runnable2); t2.setName("Thread -2"); Thread t3 = new Thread(runnable1); t3.setName("Thread -3"); t1.start(); t2.start(); t3.start(); } }
Without Synchronized keyword Current Thread Thread -1 var value 11 Current Thread Thread -2 var value 11 Current Thread Thread -2 var value 12 Current Thread Thread -2 var value 13 Current Thread Thread -2 var value 14 Current Thread Thread -1 var value 12 Current Thread Thread -3 var value 13 Current Thread Thread -3 var value 15 Current Thread Thread -1 var value 14 Current Thread Thread -1 var value 17 Current Thread Thread -3 var value 16 Current Thread Thread -3 var value 18
Current Thread Thread -1 var value 11 Current Thread Thread -2 var value 11 Current Thread Thread -1 var value 12 Current Thread Thread -2 var value 12 Current Thread Thread -1 var value 13 Current Thread Thread -2 var value 13 Current Thread Thread -1 var value 14 Current Thread Thread -2 var value 14 Current Thread Thread -3 var value 15 Current Thread Thread -3 var value 16 Current Thread Thread -3 var value 17 Current Thread Thread -3 var value 18
Java was started but returned exit code=13 C:\Program Files (x86)\Java\jre7\bin\javaw.exe -Xms40m -Xmx512m -XX:MaxPermSize=256m -jar C:\Program Files\Eclipse-SDK-4.2-win32-x86_64\eclipse\\plugins/org.eclipse.equinox.launcher_1.30v20120522-1813.jar -os win32 -ws win32 -arch x86_64 -showsplash C:\Program Files\Eclipse-SDK-4.2-win32-x86_64\eclipse\\plugins\org.eclipse.platform_4.2.0.v201206081400\splash.bmp -launcher C:\Program Files\Eclipse-SDK-4.2-win32-x86_64\eclipse\eclipse.exe -name Eclipse --launcher.library C:\Program Files\Eclipse-SDK-4.2-win32-x86_64\eclipse\\plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v201205221813\eclipse_1503.dll -startup C:\Program Files\Eclipse-SDK-4.2-win32-x86_64\eclipse\\plugins/org.eclipse.equinox.launcher_1.30v20120522-1813.jar --launcher.overrideVmargs -exitdata 1e30_5c -vm C:\Program Files (x86)\Java\jre7\bin\javaw.exe -vmargs -Xms40m -Xmx512m -XX:MaxPermSize=256m -jar C:\Program Files\Eclipse-SDK-4.2-win32-x86_64\eclipse\\plugins/org.eclipse.equinox.launcher_1.30v20120522-1813.jar
System > Advanced system setting > Environment Variables
-vm C:\Program Files\Java\jdk1.7.0_65\bin\javaw.exe
Java SE Runtime Environment 8u45 jdk-8u45-windows-x64.exe
Confirm your installation by checking you now have this folder C:\Program Files\Java\jre1.8.0_45\
Computer  properties  Advanced system settings  Advanced -> Environment variables
List<String> list = ..; String[] array = list.toArray(new String[0]);
List<String> list = new ArrayList<String>(); list.add("android"); list.add("apple"); String[] stringArray = list.toArray(new String[0]);
String[] strings = list.stream().toArray(String[]::new);
ArrayList<String> list = new ArrayList<String>(); list.add("apple"); list.add("banana"); String[] array = list.toArray(new String[list.size()]);
ArrayList<String> list = new ArrayList<String>(); list.add("apple"); list.add("banana"); String[] array = new String[list.size()]; for (int i = 0; i < list.size(); i++) { array[i] = list.get(i); }
ArrayList<String> arrayList = new ArrayList<String>(); Object[] objectList = arrayList.toArray(); String[] stringArray = Arrays.copyOf(objectList,objectList.length,String[].class);
String[] strings = list.parallelStream().toArray(String[]::new);
List<String> list = List.of("x","y","z"); String[] arrayBeforeJDK11 = list.toArray(new String[0]); String[] arrayAfterJDK11 = list.toArray(String[]::new);
public class Test { public static void main(String[] args) { ArrayList<Integer> al = new ArrayList<>(); al.add(1); al.add(2); Integer[] arr = convert(al, Integer.class); for (int i=0; i<arr.length; i++) System.out.println(arr[i]); } public static <T> T[] convert(ArrayList<T> al, Class clazz) { return (T[]) al.toArray((T[])Array.newInstance(clazz, al.size())); } }
public static <T> String[] listToArray(List<T> list) { String [] array = new String[list.size()]; for (int i = 0; i < array.length; i++) array[i] = list.get(i).toString(); return array; }
class Car { private String name; public Car(String name) { this.name = name; } public String toString() { return name; } } final List<Car> carList = new ArrayList<Car>(); carList.add(new Car("BMW")) carList.add(new Car("Mercedes")) carList.add(new Car("Skoda")) final String[] carArray = listToArray(carList);
List <String> list = ... String[] array = new String[list.size()]; int i=0; for(String s: list){ array[i++] = s; }
List<String> list = ..; String[] array = list.toArray(ArrayUtils.EMPTY_STRING_ARRAY); String[] array = list.toArray(EMPTY_STRING_ARRAY);
String[] array = list.toArray(ArrayUtils.toArray()); String[] array = list.toArray(toArray());
ArrayList<String> list = new ArrayList<>(); String[] array = new String[list.size()]; int i = 0; for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); i++) { array[i] = iterator.next(); }
ArrayList<String> list=new ArrayList<>(); list.add("Abc"); list.add("xyz"); Object[] stringlist=list.toArray(); for(int i = 0; i < stringlist.length ; i++) { Log.wtf("list data:",(String)stringlist[i]); }
String[] arrayFromList = fromlist.stream().toArray(String[]::new);
private String[] prepareDeliveryArray(List<DeliveryServiceModel> deliveryServices) { String[] delivery = new String[deliveryServices.size()]; for (int i = 0; i < deliveryServices.size(); i++) { delivery[i] = deliveryServices.get(i).getName(); } return delivery; }
List<String> list = List.of("one", "two", "three"); String[] array = list.toArray(String[]::new)
ArrayList<String> arr_List=new ArrayList<String>(); Object[] str_Arr=arr_List.toArray();
int[] d = new int[list.size()]; for (int i = 0; i < list.size(); i++) { d[i] = list.get(i); }
Map m1 = new HashMap(); m1.put("map", "HashMap"); m1.put("schildt", "java2"); m1.put("mathew", "Hyden"); m1.put("schildt", "java2s"); print(m1.keySet()); print(m1.values()); SortedMap sm = new TreeMap(); sm.put("map", "TreeMap"); sm.put("schildt", "java2"); sm.put("mathew", "Hyden"); sm.put("schildt", "java2s"); print(sm.keySet()); print(sm.values()); LinkedHashMap lm = new LinkedHashMap(); lm.put("map", "LinkedHashMap"); lm.put("schildt", "java2"); lm.put("mathew", "Hyden"); lm.put("schildt", "java2s"); print(lm.keySet()); print(lm.values());
public class TreeMap<K,V> extends AbstractMap<K,V> implements SortedMap<K,V>, Cloneable, Serializable
void insertAndPrint(AbstractMap<Integer, String> map) { int[] array= {1, -1, 0}; for (int x : array) { map.put(x, Integer.toString(x)); } for (int k: map.keySet()) { System.out.print(k + ", "); } }
map.put(null, "Kamran"); map.put(2, "Ali"); map.put(5, "From"); map.put(4, "Dir");`enter code here` map.put(3, "Lower"); for (Map.Entry m : map.entrySet()) { System.out.println(m.getKey() + " " + m.getValue()); }
map.put(1, "Kamran"); map.put(2, "Ali"); map.put(5, "From"); map.put(4, "Dir"); map.put(3, "Lower"); for (Map.Entry m : map.entrySet()) { System.out.println(m.getKey() + " " + m.getValue()); }
map.put(1, "Kamran"); map.put(2, "Ali"); map.put(5, "From"); map.put(4, "Dir"); map.put(3, "Lower"); for (Map.Entry m : map.entrySet()) { System.out.println(m.getKey() + " " + m.getValue()); }
{ "pageInfo": { "pageName": "abc", "pagePic": "http: } "posts": [ { "post_id": "123456789012_123456789012", "actor_id": "1234567890", "picOfPersonWhoPosted": "http: "nameOfPersonWhoPosted": "Jane Doe", "message": "Sounds cool. Can "likesCount": "2", "comments": [], "timeOfPost": "1234567890" } ] }
import org.json.*; JSONObject obj = new JSONObject(" .... "); String pageName = obj.getJSONObject("pageInfo").getString("pageName"); JSONArray arr = obj.getJSONArray("posts"); for (int i = 0; i < arr.length(); i++) { String post_id = arr.getJSONObject(i).getString("post_id"); ...... }
private class Person { public String name; public Person(String name) { this.name = name; } }
Gson g = new Gson(); Person person = g.fromJson("{\"name\": \"John\"}", Person.class); System.out.println(person.name); System.out.println(g.toJson(person));
JsonObject jsonObject = new JsonParser().parse("{\"name\": \"John\"}").getAsJsonObject(); System.out.println(jsonObject.get("name").getAsString());
JSONObject obj = new JSONObject("{\"name\": \"John\"}"); System.out.println(obj.getString("name"));
ObjectMapper mapper = new ObjectMapper(); Person user = mapper.readValue("{\"name\": \"John\"}", Person.class); System.out.println(user.name);
Gson gson = new Gson(); gson.toJson(yourObject); yourObject o = gson.fromJson(JSONString,yourObject.class);
Response response = request.get(); JsonReader jsonReader = Json.createReader(new StringReader(response.readEntity(String.class))); JsonArray jsonArray = jsonReader.readArray(); ListIterator l = jsonArray.listIterator(); while ( l.hasNext() ) { JsonObject j = (JsonObject)l.next(); JsonObject ciAttr = j.getJsonObject("ciAttributes");
JsonParserFactory factory=JsonParserFactory.getInstance(); JSONParser parser=factory.newJsonParser(); Map jsonMap=parser.parseJson(jsonString);
<dependency> <groupId>com.jayway.jsonpath</groupId> <artifactId>json-path</artifactId> <version>${version}</version> </dependency>
String pageName = JsonPath.read(yourJsonString, "$.pageInfo.pageName"); String pagePic = JsonPath.read(yourJsonString, "$.pageInfo.pagePic"); String post_id = JsonPath.read(yourJsonString, "$.pagePosts[0].post_id");
package com.levo.jsonex.model; public class Page { private PageInfo pageInfo; private Post[] posts; public PageInfo getPageInfo() { return pageInfo; } public void setPageInfo(PageInfo pageInfo) { this.pageInfo = pageInfo; } public Post[] getPosts() { return posts; } public void setPosts(Post[] posts) { this.posts = posts; } }
package com.levo.jsonex.model; public class PageInfo { private String pageName; private String pagePic; public String getPageName() { return pageName; } public void setPageName(String pageName) { this.pageName = pageName; } public String getPagePic() { return pagePic; } public void setPagePic(String pagePic) { this.pagePic = pagePic; } }
package com.levo.jsonex.model; public class Post { private String post_id; private String actor_id; private String picOfPersonWhoPosted; private String nameOfPersonWhoPosted; private String message; private int likesCount; private String[] comments; private int timeOfPost; public String getPost_id() { return post_id; } public void setPost_id(String post_id) { this.post_id = post_id; } public String getActor_id() { return actor_id; } public void setActor_id(String actor_id) { this.actor_id = actor_id; } public String getPicOfPersonWhoPosted() { return picOfPersonWhoPosted; } public void setPicOfPersonWhoPosted(String picOfPersonWhoPosted) { this.picOfPersonWhoPosted = picOfPersonWhoPosted; } public String getNameOfPersonWhoPosted() { return nameOfPersonWhoPosted; } public void setNameOfPersonWhoPosted(String nameOfPersonWhoPosted) { this.nameOfPersonWhoPosted = nameOfPersonWhoPosted; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public int getLikesCount() { return likesCount; } public void setLikesCount(int likesCount) { this.likesCount = likesCount; } public String[] getComments() { return comments; } public void setComments(String[] comments) { this.comments = comments; } public int getTimeOfPost() { return timeOfPost; } public void setTimeOfPost(int timeOfPost) { this.timeOfPost = timeOfPost; } }
{ "pageInfo": { "pageName": "abc", "pagePic": "http: }, "posts": [ { "post_id": "123456789012_123456789012", "actor_id": "1234567890", "picOfPersonWhoPosted": "http: "nameOfPersonWhoPosted": "Jane Doe", "message": "Sounds cool. Can "likesCount": "2", "comments": [], "timeOfPost": "1234567890" } ] }
package com.levo.jsonex; import java.io.File; import java.io.IOException; import java.util.Arrays; import com.fasterxml.jackson.databind.ObjectMapper; import com.levo.jsonex.model.Page; import com.levo.jsonex.model.PageInfo; import com.levo.jsonex.model.Post; public class JSONDemo { public static void main(String[] args) { ObjectMapper objectMapper = new ObjectMapper(); try { Page page = objectMapper.readValue(new File("sampleJSONFile.json"), Page.class); printParsedObject(page); } catch (IOException e) { e.printStackTrace(); } } private static void printParsedObject(Page page) { printPageInfo(page.getPageInfo()); System.out.println(); printPosts(page.getPosts()); } private static void printPageInfo(PageInfo pageInfo) { System.out.println("Page Info;"); System.out.println("**********"); System.out.println("\tPage Name : " + pageInfo.getPageName()); System.out.println("\tPage Pic : " + pageInfo.getPagePic()); } private static void printPosts(Post[] posts) { System.out.println("Page Posts;"); System.out.println("**********"); for(Post post : posts) { printPost(post); } } private static void printPost(Post post) { System.out.println("\tPost Id : " + post.getPost_id()); System.out.println("\tActor Id : " + post.getActor_id()); System.out.println("\tPic Of Person Who Posted : " + post.getPicOfPersonWhoPosted()); System.out.println("\tName Of Person Who Posted : " + post.getNameOfPersonWhoPosted()); System.out.println("\tMessage : " + post.getMessage()); System.out.println("\tLikes Count : " + post.getLikesCount()); System.out.println("\tComments : " + Arrays.toString(post.getComments())); System.out.println("\tTime Of Post : " + post.getTimeOfPost()); } }
Page Info; ****(***** Page Name : abc Page Pic : http: Page Posts; ********** Post Id : 123456789012_123456789012 Actor Id : 1234567890 Pic Of Person Who Posted : http: Name Of Person Who Posted : Jane Doe Message : Sounds cool. Can Likes Count : 2 Comments : [] Time Of Post : 1234567890
{ "pageInfo": { "pageName": "abc", "pagePic": "http: } "posts": [ { "post_id": "123456789012_123456789012", "actor_id": "1234567890", "picOfPersonWhoPosted": "http: "nameOfPersonWhoPosted": "Jane Doe", "message": "Sounds cool. Can "likesCount": "2", "comments": [], "timeOfPost": "1234567890" } ] }
class MyModel { private PageInfo pageInfo; private ArrayList<Post> posts = new ArrayList<>(); } class PageInfo { private String pageName; private String pagePic; } class Post { private String post_id; @SerializedName("actor_id") private String actorId; private String picOfPersonWhoPosted; private String nameOfPersonWhoPosted; private String message; private String likesCount; private ArrayList<String> comments; private String timeOfPost; }
MyModel model = gson.fromJson(jsonString, MyModel.class);
{ "order": 4711, "items": [ { "name": "NE555 Timer IC", "cat-id": "645723", "quantity": 10, }, { "name": "LM358N OpAmp IC", "cat-id": "764525", "quantity": 2 } ] }
JsonObject object = Json.parse(input).asObject(); int orders = object.get("order").asInt(); JsonArray items = object.get("items").asArray();
JsonObject user = Json.object().add("name", "Sakib").add("age", 23);
<dependency> <groupId>com.eclipsesource.minimal-json</groupId> <artifactId>minimal-json</artifactId> <version>0.9.4</version> </dependency>
javax.json.JsonReader jr = javax.json.Json.createReader(new StringReader(jsonText)); javax.json.JsonObject jo = jr.readObject(); javax.json.JsonObject pageInfo = jo.getJsonObject("pageInfo"); System.out.println(pageInfo.getString("pageName")); javax.json.JsonArray posts = jo.getJsonArray("posts"); javax.json.JsonObject post = posts.getJsonObject(0); String postId = post.getString("post_id");
private static final String EXTRACTOR_SCRIPT = "var fun = function(raw) { " + "var json = JSON.parse(raw); " + "return [json.pageInfo.pageName, json.pageInfo.pagePic, json.posts[0].post_id];};"; public void run() throws ScriptException, NoSuchMethodException { ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn"); engine.eval(EXTRACTOR_SCRIPT); Invocable invocable = (Invocable) engine; JSObject result = (JSObject) invocable.invokeFunction("fun", JSON); result.values().forEach(e -> System.out.println(e)); }
mapper.readValue(JSON, Entries.class).getEntries();
public class MyObj { private PageInfo pageInfo; private List<Post> posts; static final class PageInfo { private String pageName; private String pagePic; } static final class Post { private String post_id; @JsonProperty("actor_id"); private String actorId; @JsonProperty("picOfPersonWhoPosted") private String pictureOfPoster; @JsonProperty("nameOfPersonWhoPosted") private String nameOfPoster; private String likesCount; private List<String> comments; private String timeOfPost; } private static final ObjectMapper JACKSON = new ObjectMapper(); public static void main(String[] args) throws IOException { MyObj o = JACKSON.readValue(args[0], MyObj.class); } }
Message message= new ObjectMapper().readValue(jsonString, Message.class);
{ "pageInfo": { "pageName": "abc", "pagePic": "http: } "posts": [ { "post_id": "123456789012_123456789012", "actor_id": 1234567890, "picOfPersonWhoPosted": "http: "nameOfPersonWhoPosted": "Jane Doe", "message": "Sounds cool. Can "likesCount": 2, "comments": [], "timeOfPost": 1234567890 } ] }
@Generated("org.jsonschema2pojo") public class Container { @SerializedName("pageInfo") @Expose public PageInfo pageInfo; @SerializedName("posts") @Expose public List<Post> posts = new ArrayList<Post>(); } @Generated("org.jsonschema2pojo") public class PageInfo { @SerializedName("pageName") @Expose public String pageName; @SerializedName("pagePic") @Expose public String pagePic; } @Generated("org.jsonschema2pojo") public class Post { @SerializedName("post_id") @Expose public String postId; @SerializedName("actor_id") @Expose public long actorId; @SerializedName("picOfPersonWhoPosted") @Expose public String picOfPersonWhoPosted; @SerializedName("nameOfPersonWhoPosted") @Expose public String nameOfPersonWhoPosted; @SerializedName("message") @Expose public String message; @SerializedName("likesCount") @Expose public long likesCount; @SerializedName("comments") @Expose public List<Object> comments = new ArrayList<Object>(); @SerializedName("timeOfPost") @Expose public long timeOfPost; }
import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import com.google.gson.Gson; public class GsonExample { public static void main(String[] args) { Gson gson = new Gson(); try { BufferedReader br = new BufferedReader( new FileReader("c:\\file.json")); DataObject obj = gson.fromJson(br, DataObject.class); System.out.println(obj); } catch (IOException e) { e.printStackTrace(); } } }
Gson gson = new Gson(); JsonObject jsonObject = gson.fromJson(jsonAsString, JsonObject.class); String pageName = jsonObject.getAsJsonObject("pageInfo").get("pageName").getAsString(); String pagePic = jsonObject.getAsJsonObject("pageInfo").get("pagePic").getAsString(); String postId = jsonObject.getAsJsonArray("posts").get(0).getAsJsonObject().get("post_id").getAsString();
JsonArray posts = jsonObject.getAsJsonArray("posts"); for (JsonElement post : posts) { String postId = post.getAsJsonObject().get("post_id").getAsString(); }
JSONParser jsonParser = new JSONParser(); JSONObject obj = (JSONObject) jsonParser.parse(contentString); String product = (String) jsonObject.get("productId");
{ "data": { "translations": [ { "translatedText": "Arbeit" } ] } }
String json = callToTranslateApi("work", "de"); JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject(); return jsonObject.get("data").getAsJsonObject() .get("translations").getAsJsonArray() .get(0).getAsJsonObject() .get("translatedText").getAsString();
class ApiResponse { Data data; class Data { Translation[] translations; class Translation { String translatedText; } } }
Gson g = new Gson(); String json =callToTranslateApi("work", "de"); ApiResponse response = g.fromJson(json, ApiResponse.class); return response.data.translations[0].translatedText;
Employee employee = null; ObjectMapper mapper = new ObjectMapper(); try{ employee = mapper.readValue(newFile("/home/sumit/employee.json"), Employee.class); } catch (JsonGenerationException e){ e.printStackTrace(); }
<dependency> <groupId>com.jayway.jsonpath</groupId> <artifactId>json-path</artifactId> <version>2.2.0</version> </dependency>
BufferedReader br = new BufferedReader(new FileReader("D:\\sampleJson.txt")); StringBuilder sb = new StringBuilder(); String line = br.readLine(); while (line != null) { sb.append(line); sb.append(System.lineSeparator()); line = br.readLine(); } br.close(); String jsonInput = sb.toString();
Object document = Configuration.defaultConfiguration().jsonProvider().parse(jsonInput);
String pageName = JsonPath.read(document, "$.pageInfo.pageName"); String pagePic = JsonPath.read(document, "$.pageInfo.pagePic"); String post_id = JsonPath.read(document, "$.posts[0].post_id"); System.out.println("$.pageInfo.pageName " + pageName); System.out.println("$.pageInfo.pagePic " + pagePic); System.out.println("$.posts[0].post_id " + post_id);
$.pageInfo.pageName = abc $.pageInfo.pagePic = http: $.posts[0].post_id = 123456789012_123456789012
{ "pageInfo": { "pageName": "abc", "pagePic": "http: }, "posts": [ { "post_id": "123456789012_123456789012", "actor_id": "1234567890", "picOfPersonWhoPosted": "http: "nameOfPersonWhoPosted": "Jane Doe", "message": "Sounds cool. Can "likesCount": "2", "comments": [], "timeOfPost": "1234567890" } ] } Java code : JSONObject obj = new JSONObject(responsejsonobj); String pageName = obj.getJSONObject("pageInfo").getString("pageName"); JSONArray arr = obj.getJSONArray("posts"); for (int i = 0; i < arr.length(); i++) { String post_id = arr.getJSONObject(i).getString("post_id"); ......etc }
{ "pageInfo": { "pageName": "abc", "pagePic": "http: } }
class PageInfo { private String pageName; private String pagePic; }
PageInfo pageInfo = JsonPath.parse(jsonString).read("$.pageInfo", PageInfo.class);
<dependency> <groupId>com.jayway.jsonpath</groupId> <artifactId>json-path</artifactId> <version>2.2.0</version> </dependency>
@Model(className="RepositoryInfo", properties = { @Property(name = "id", type = int.class), @Property(name = "name", type = String.class), @Property(name = "owner", type = Owner.class), @Property(name = "private", type = boolean.class), }) final class RepositoryCntrl { @Model(className = "Owner", properties = { @Property(name = "login", type = String.class) }) static final class OwnerCntrl { } }
List<RepositoryInfo> repositories = new ArrayList<>(); try (InputStream is = initializeStream(args)) { Models.parse(CONTEXT, RepositoryInfo.class, is, repositories); } System.err.println("there is " + repositories.size() + " repositories"); repositories.stream().filter((repo) -> repo != null).forEach((repo) -> { System.err.println("repository " + repo.getName() + " is owned by " + repo.getOwner().getLogin() ); })
ObjectMapper mapper = new ObjectMapper(); JsonNode yourObj = mapper.readTree("{\"k\":\"v\"}");
JSONObject jObj = new JSONObject(contents.trim()); Iterator<?> keys = jObj.keys(); while( keys.hasNext() ) { String key = (String)keys.next(); if ( jObj.get(key) instanceof JSONObject ) { System.out.println(jObj.getString(String key)); } }
{ "pageInfo": { "pageName": "abc", "pagePic": "http: }, "posts": [ { "post_id": "123456789012_123456789012", "actor_id": "1234567890", "picOfPersonWhoPosted": "http: "nameOfPersonWhoPosted": "Jane Doe", "message": "Sounds cool. Can "likesCount": "2", "comments": [], "timeOfPost": "1234567890" } ] }
BufferedReader br = new BufferedReader(new FileReader("file.txt")); try { StringBuilder sb = new StringBuilder(); String line = br.readLine(); while (line != null) { sb.append(line); sb.append(System.lineSeparator()); line = br.readLine(); } String everything = sb.toString(); } finally { br.close(); }
try(BufferedReader br = new BufferedReader(new FileReader("file.txt"))) { StringBuilder sb = new StringBuilder(); String line = br.readLine(); while (line != null) { sb.append(line); sb.append(System.lineSeparator()); line = br.readLine(); } String everything = sb.toString(); }
FileInputStream inputStream = new FileInputStream("foo.txt"); try { String everything = IOUtils.toString(inputStream); } finally { inputStream.close(); }
try(FileInputStream inputStream = new FileInputStream("foo.txt")) { String everything = IOUtils.toString(inputStream); }
Scanner in = new Scanner(new FileReader("filename.txt"));
StringBuilder sb = new StringBuilder(); while(in.hasNext()) { sb.append(in.next()); } in.close(); outString = sb.toString();
new InputStreamReader(new FileInputStream(fileUtf8), StandardCharsets.UTF_8)
String content; content = new String(Files.readAllBytes(Paths.get("sample.txt")));
import java.io.File; import java.io.FileReader; import java.io.IOException; public String readFile(String filename) { String content = null; File file = new File(filename); FileReader reader = null; try { reader = new FileReader(file); char[] chars = new char[(int) file.length()]; reader.read(chars); content = new String(chars); reader.close(); } catch (IOException e) { e.printStackTrace(); } finally { if(reader != null){ reader.close(); } } return content; }
rawParse 11.10 sec lineReaderParse 13.86 sec lineReaderParseParallel 6.00 sec nioFilesParse 13.52 sec nioAsyncParse 16.06 sec nioMemoryMappedParse 37.68 sec
public void rawParse(final String targetDir, final int numberOfFiles) throws IOException, ParseException { overrunCount = 0; final int dl = (int) StringBuffer lineBuffer = new StringBuffer(1024); for (int f=0; f<numberOfFiles; f++) { File fl = new File(targetDir+filenamePreffix+String.valueOf(f)+".txt"); FileInputStream fin = new FileInputStream(fl); BufferedInputStream bin = new BufferedInputStream(fin); int character; while((character=bin.read())!=-1) { if (character==dl) { doSomethingWithRawLine(lineBuffer.toString()); lineBuffer.setLength(0); } else { lineBuffer.append((char) character); } } bin.close(); fin.close(); } } public final void doSomethingWithRawLine(String line) throws ParseException { int fieldNumber = 0; final int len = line.length(); StringBuffer fieldBuffer = new StringBuffer(256); for (int charPos=0; charPos<len; charPos++) { char c = line.charAt(charPos); if (c==DL0) { String fieldValue = fieldBuffer.toString(); if (fieldValue.length()>0) { switch (fieldNumber) { case 0: Date dt = fmt.parse(fieldValue); fieldNumber++; break; case 1: double d = Double.parseDouble(fieldValue); fieldNumber++; break; case 2: int t = Integer.parseInt(fieldValue); fieldNumber++; break; case 3: if (fieldValue.equals("overrun")) overrunCount++; break; } } fieldBuffer.setLength(0); } else { fieldBuffer.append(c); } } }
public void lineReaderParse(final String targetDir, final int numberOfFiles) throws IOException, ParseException { String line; for (int f=0; f<numberOfFiles; f++) { File fl = new File(targetDir+filenamePreffix+String.valueOf(f)+".txt"); FileReader frd = new FileReader(fl); BufferedReader brd = new BufferedReader(frd); while ((line=brd.readLine())!=null) doSomethingWithLine(line); brd.close(); frd.close(); } } public final void doSomethingWithLine(String line) throws ParseException { String[] fields = line.split(";"); Date dt = fmt.parse(fields[0]); double d = Double.parseDouble(fields[1]); int t = Integer.parseInt(fields[2]); if (fields[3].equals("overrun")) overrunCount++; }
public void lineReaderParseParallel(final String targetDir, final int numberOfFiles, final int degreeOfParalelism) throws IOException, ParseException, InterruptedException { Thread[] pool = new Thread[degreeOfParalelism]; int batchSize = numberOfFiles / degreeOfParalelism; for (int b=0; b<degreeOfParalelism; b++) { pool[b] = new LineReaderParseThread(targetDir, b*batchSize, b*batchSize+b*batchSize); pool[b].start(); } for (int b=0; b<degreeOfParalelism; b++) pool[b].join(); } class LineReaderParseThread extends Thread { private String targetDir; private int fileFrom; private int fileTo; private DateFormat fmt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); private int overrunCounter = 0; public LineReaderParseThread(String targetDir, int fileFrom, int fileTo) { this.targetDir = targetDir; this.fileFrom = fileFrom; this.fileTo = fileTo; } private void doSomethingWithTheLine(String line) throws ParseException { String[] fields = line.split(DL); Date dt = fmt.parse(fields[0]); double d = Double.parseDouble(fields[1]); int t = Integer.parseInt(fields[2]); if (fields[3].equals("overrun")) overrunCounter++; } @Override public void run() { String line; for (int f=fileFrom; f<fileTo; f++) { File fl = new File(targetDir+filenamePreffix+String.valueOf(f)+".txt"); try { FileReader frd = new FileReader(fl); BufferedReader brd = new BufferedReader(frd); while ((line=brd.readLine())!=null) { doSomethingWithTheLine(line); } brd.close(); frd.close(); } catch (IOException | ParseException ioe) { } } } }
public void nioFilesParse(final String targetDir, final int numberOfFiles) throws IOException, ParseException { for (int f=0; f<numberOfFiles; f++) { Path ph = Paths.get(targetDir+filenamePreffix+String.valueOf(f)+".txt"); Consumer<String> action = new LineConsumer(); Stream<String> lines = Files.lines(ph); lines.forEach(action); lines.close(); } } class LineConsumer implements Consumer<String> { @Override public void accept(String line) { String[] fields = line.split(DL); if (fields.length>1) { try { Date dt = fmt.parse(fields[0]); } catch (ParseException e) { } double d = Double.parseDouble(fields[1]); int t = Integer.parseInt(fields[2]); if (fields[3].equals("overrun")) overrunCount++; } } }
public void nioAsyncParse(final String targetDir, final int numberOfFiles, final int numberOfThreads, final int bufferSize) throws IOException, ParseException, InterruptedException { ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(numberOfThreads); ConcurrentLinkedQueue<ByteBuffer> byteBuffers = new ConcurrentLinkedQueue<ByteBuffer>(); for (int b=0; b<numberOfThreads; b++) byteBuffers.add(ByteBuffer.allocate(bufferSize)); for (int f=0; f<numberOfFiles; f++) { consumerThreads.acquire(); String fileName = targetDir+filenamePreffix+String.valueOf(f)+".txt"; AsynchronousFileChannel channel = AsynchronousFileChannel.open(Paths.get(fileName), EnumSet.of(StandardOpenOption.READ), pool); BufferConsumer consumer = new BufferConsumer(byteBuffers, fileName, bufferSize); channel.read(consumer.buffer(), 0l, channel, consumer); } consumerThreads.acquire(numberOfThreads); } class BufferConsumer implements CompletionHandler<Integer, AsynchronousFileChannel> { private ConcurrentLinkedQueue<ByteBuffer> buffers; private ByteBuffer bytes; private String file; private StringBuffer chars; private int limit; private long position; private DateFormat frmt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); public BufferConsumer(ConcurrentLinkedQueue<ByteBuffer> byteBuffers, String fileName, int bufferSize) { buffers = byteBuffers; bytes = buffers.poll(); if (bytes==null) bytes = ByteBuffer.allocate(bufferSize); file = fileName; chars = new StringBuffer(bufferSize); frmt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); limit = bufferSize; position = 0l; } public ByteBuffer buffer() { return bytes; } @Override public synchronized void completed(Integer result, AsynchronousFileChannel channel) { if (result!=-1) { bytes.flip(); final int len = bytes.limit(); int i = 0; try { for (i = 0; i < len; i++) { byte by = bytes.get(); if (by== chars.setLength(0); } else { chars.append((char) by); } } } catch (Exception x) { System.out.println( "Caught exception " + x.getClass().getName() + " " + x.getMessage() + " i=" + String.valueOf(i) + ", limit=" + String.valueOf(len) + ", position="+String.valueOf(position)); } if (len==limit) { bytes.clear(); position += len; channel.read(bytes, position, channel, this); } else { try { channel.close(); } catch (IOException e) { } consumerThreads.release(); bytes.clear(); buffers.add(bytes); } } else { try { channel.close(); } catch (IOException e) { } consumerThreads.release(); bytes.clear(); buffers.add(bytes); } } @Override public void failed(Throwable e, AsynchronousFileChannel channel) { } };
package io; import java.io.*; public class ReadFromFile2 { public static void main(String[] args)throws Exception { File file = new File("C:\\Users\\pankaj\\Desktop\\test.java"); BufferedReader br = new BufferedReader(new FileReader(file)); String st; while((st=br.readLine()) != null){ System.out.println(st); } } }
package io; import java.io.File; import java.util.Scanner; public class ReadFromFileUsingScanner { public static void main(String[] args) throws Exception { File file = new File("C:\\Users\\pankaj\\Desktop\\test.java"); Scanner sc = new Scanner(file); while(sc.hasNextLine()){ System.out.println(sc.nextLine()); } } }
package io; import java.io.*; public class ReadingFromFile { public static void main(String[] args) throws Exception { FileReader fr = new FileReader("C:\\Users\\pankaj\\Desktop\\test.java"); int i; while ((i=fr.read()) != -1){ System.out.print((char) i); } } }
package io; import java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public class ReadingEntireFileWithoutLoop { public static void main(String[] args) throws FileNotFoundException { File file = new File("C:\\Users\\pankaj\\Desktop\\test.java"); Scanner sc = new Scanner(file); sc.useDelimiter("\\Z"); System.out.println(sc.next()); } }
/** * Reads the contents of a file line by line to a List * of Strings using the default encoding for the VM. */ static List readLines(File file)
for(String line: FileUtils.readLines("my-text-file")) System.out.println(line);
Files.lines(Paths.get("text.txt")).collect(Collectors.toList());
import java.io.File; import java.io.IOException; import java.nio.file.Files; public class ReadFile_Files_ReadAllBytes { public static void main(String [] pArgs) throws IOException { String fileName = "c:\\temp\\sample-10KB.txt"; File file = new File(fileName); byte [] fileBytes = Files.readAllBytes(file.toPath()); char singleChar; for(byte b : fileBytes) { singleChar = (char) b; System.out.print(singleChar); } } }
import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class ReadFile_BufferedReader_ReadLine { public static void main(String [] args) throws IOException { String fileName = "c:\\temp\\sample-10KB.txt"; FileReader fileReader = new FileReader(fileName); try (BufferedReader bufferedReader = new BufferedReader(fileReader)) { String line; while((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } }
import java.io.File; import java.io.IOException; import java.nio.file.Files; import java.util.stream.Stream; public class ReadFile_Files_Lines { public static void main(String[] pArgs) throws IOException { String fileName = "c:\\temp\\sample-10KB.txt"; File file = new File(fileName); try (Stream linesStream = Files.lines(file.toPath())) { linesStream.forEach(line -> { System.out.println(line); }); } } }
import java.io.BufferedReader; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; BufferedReader br; try { br = new BufferedReader(new FileReader("/fileToRead.txt")); try { String x; while ( (x = br.readLine()) != null ) { System.out.println(x); } } catch (IOException e) { e.printStackTrace(); } } catch (FileNotFoundException e) { System.out.println(e); e.printStackTrace(); }
Scanner in = new Scanner(new File("filename.txt")); while (in.hasNext()) { String line = in.nextLine(); } in.close();
String content; try (Scanner scanner = new Scanner(textFile).useDelimiter("\\Z")) { content = scanner.next(); }
public static void main(String args[])throws Exception { File f = new File("input.txt"); takeInputIn2DArray(f); } public static void takeInputIn2DArray(File f) throws Exception { Scanner s = new Scanner(f); int a[][] = new int[20][20]; for(int i=0; i<20; i++) { for(int j=0; j<20; j++) { a[i][j] = s.nextInt(); } } }
import com.google.common.base.Charsets; import com.google.common.io.Files; String contents = Files.toString(filePath, Charsets.UTF_8);
import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.IOException; public class InputReader{ public static void main(String[] args)throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String s=""; while((s=br.readLine())!=null){ System.out.println(s); } } }
Path path = Paths.get("/myfolder/myfile.ext"); try (BufferedReader reader = Files.newBufferedReader(path)) { String currentLine = null; while ((currentLine = reader.readLine()) != null) } catch (IOException e) { }
BufferedReader reader = Files.newBufferedReader(path);
BufferedReader br = new BufferedReader(new FileReader("/myfolder/myfile.ext"));
<dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-io</artifactId> <version>1.3.2</version> </dependency>
String metadata = null; FileInputStream inputStream; try { ClassLoader loader = Thread.currentThread().getContextClassLoader(); inputStream = (FileInputStream) loader .getResourceAsStream("/metadata.json"); metadata = IOUtils.toString(inputStream); inputStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return metadata;
String str = String.join("\n",Files.readAllLines(Paths.get("e:\\text.txt")));
String str = new String(Files.readAllBytes(Paths.get("e:\\text.txt")), StandardCharsets.UTF_8);
import static kiss.API.*; class App { void run() { String line; try (Close in = inOpen("file.dat")) { while ((line = readLine()) != null) { println(line); } } } }
String fileName = File file = new File(fileName); FileReader fr = new FileReader(file); BufferedReader br = new BufferedReader(fr);
BufferedReader br = new BufferedReader(new FileReader("file.txt"));
try { StringBuilder sb = new StringBuilder(); String line = br.readLine(); while (line != null) { sb.append(line); sb.append(System.lineSeparator()); line = br.readLine(); } String everything = sb.toString(); } finally { br.close(); }
public String readDoc(File f) { String text = ""; int read, N = 1024 * 1024; char[] buffer = new char[N]; try { FileReader fr = new FileReader(f); BufferedReader br = new BufferedReader(fr); while(true) { read = br.read(buffer, 0, N); text += new String(buffer, 0, read); if(read < N) { break; } } } catch(Exception ex) { ex.printStackTrace(); } return text; }
String current = new java.io.File( "." ).getCanonicalPath(); System.out.println("Current dir:"+current); String currentDir = System.getProperty("user.dir"); System.out.println("Current dir using System:" +currentDir);
Current dir: C:\WINDOWS\system32 Current dir using System: C:\WINDOWS\system32
public class JavaApplication1 { public static void main(String[] args) { System.out.println("Working Directory = " + System.getProperty("user.dir")); } }
Path currentRelativePath = Paths.get(""); String s = currentRelativePath.toAbsolutePath().toString(); System.out.println("Current relative path is: " + s);
import java.nio.file.Paths; Paths.get(".").toAbsolutePath().normalize().toString();
Path path = FileSystems.getDefault().getPath("Foo.txt");
Path path = FileSystems.getDefault().getPath(".").toAbsolutePath();
public class Test { public static void main(String... args) throws Exception { URL location = Test.class.getProtectionDomain().getCodeSource().getLocation(); System.out.println(location.getFile()); } }
this.getClass().getClassLoader().getResource("").getPath()
File getCwd() { return new File("").getAbsoluteFile(); }
@Test public void aaa() { System.err.println(Paths.get("").toAbsolutePath().toString()); System.err.println(System.getProperty("user.dir")); }
Paths.get("").toAbsolutePath().toString(); System.getProperty("user.dir");
MainClass.class.getProtectionDomain().getCodeSource().getLocation().getFile();
String myCurrentDir = System.getProperty("user.dir") + File.separator + System.getProperty("sun.java.command") .substring(0, System.getProperty("sun.java.command").lastIndexOf(".")) .replace(".", File.separator); System.out.println(myCurrentDir);
String path = getBasePathForClass(Main.class); String applicationPath= new File(path + "application.jar").getAbsolutePath(); System.out.println("Directory Path is : "+applicationPath); ProcessBuilder builder = new ProcessBuilder("java", "-jar", applicationPath); builder.redirectErrorStream(true); Process process = builder.start();
/** * Returns the absolute path of the current directory in which the given * class * file is. * * @param classs * @return The absolute path of the current directory in which the class * file is. * @author GOXR3PLUS[StackOverFlow user] + bachden [StackOverFlow user] */ public static final String getBasePathForClass(Class<?> classs) { File file; String basePath = ""; boolean failed = false; try { file = new File(classs.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()); if (file.isFile() || file.getPath().endsWith(".jar") || file.getPath().endsWith(".zip")) { basePath = file.getParent(); } else { basePath = file.getPath(); } } catch (URISyntaxException ex) { failed = true; Logger.getLogger(classs.getName()).log(Level.WARNING, "Cannot firgue out base path for class with way (1): ", ex); } if (failed) { try { file = new File(classs.getClassLoader().getResource("").toURI().getPath()); basePath = file.getAbsolutePath(); } catch (URISyntaxException ex) { Logger.getLogger(classs.getName()).log(Level.WARNING, "Cannot firgue out base path for class with way (2): ", ex); } } if (basePath.endsWith(File.separator + "lib") || basePath.endsWith(File.separator + "bin") || basePath.endsWith("bin" + File.separator) || basePath.endsWith("lib" + File.separator)) { basePath = basePath.substring(0, basePath.length() - 4); } if (basePath.endsWith(File.separator + "build" + File.separator + "classes")) { basePath = basePath.substring(0, basePath.length() - 14); } if (!basePath.endsWith(File.separator)) { basePath = basePath + File.separator; } return basePath; }
java.nio.file.Paths.get( getClass().getProtectionDomain().getCodeSource().getLocation().toURI() );
URL myURL = getClass().getProtectionDomain().getCodeSource().getLocation(); java.net.URI myURI = null; try { myURI = myURL.toURI(); } catch (URISyntaxException e1) {} return java.nio.file.Paths.get(myURI).toFile().toString()
public static final String getBasePathForClass(Class<?> clazz) { File file; try { String basePath = null; file = new File(clazz.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()); if (file.isFile() || file.getPath().endsWith(".jar") || file.getPath().endsWith(".zip")) { basePath = file.getParent(); } else { basePath = file.getPath(); } if (basePath.endsWith(File.separator + "lib") || basePath.endsWith(File.separator + "bin") || basePath.endsWith("bin" + File.separator) || basePath.endsWith("lib" + File.separator)) { basePath = basePath.substring(0, basePath.length() - 4); } if (basePath.endsWith(File.separator + "build" + File.separator + "classes")) { basePath = basePath.substring(0, basePath.length() - 14); } if (!basePath.endsWith(File.separator)) { basePath = basePath + File.separator; } return basePath; } catch (URISyntaxException e) { throw new RuntimeException("Cannot firgue out base path for class: " + clazz.getName()); } }
String path="/home/prasad/Desktop/folderName"; File folder = new File(path); String folderName=folder.getAbsoluteFile().getName();
public class TestMyStaticClass { public static void main(String []args){ MyStaticClass.setMyStaticMember(5); System.out.println("Static value: " + MyStaticClass.getMyStaticMember()); System.out.println("Value squared: " + MyStaticClass.squareMyStaticMember()); } } public final class MyStaticClass { private MyStaticClass () { myStaticMember = 1; } private static int myStaticMember; public static void setMyStaticMember(int val) { myStaticMember = val; } public static int getMyStaticMember() { return myStaticMember; } public static int squareMyStaticMember() { return myStaticMember * myStaticMember; } }
public class Test { class A { } static class B { } public static void main(String[] args) { A a = new A(); B b = new B(); } }
public class C { A a = new A(); A.B ab = a. new B(); }
public enum Elvis { INSTANCE; public void leaveTheBuilding() { ... } }
int[] spam = new int[] { 1, 2, 3 }; Arrays.asList(spam)
Assert.assertTrue(Arrays.asList(spam).indexOf(4) == -1);
Integer[] spam = new Integer[] { 1, 2, 3 }; Arrays.asList(spam);
Integer[] values = { 1, 3, 7 }; List<Integer> list = Arrays.asList(values);
Integer[] values = { 1, 3, 7 }; List<Integer> list = new ArrayList<Integer>(Arrays.asList(values));
int[] spam = new int[] { 1, 2, 3 }; Arrays.stream(spam) .boxed() .collect(Collectors.toList());
int[] ints = new int[] {1,2,3,4,5}; List<Integer> list11 =Arrays.stream(ints).boxed().collect(Collectors.toList());
Integer[] integers = new Integer[] {1,2,3,4,5}; List<Integer> list21 = Arrays.asList(integers); List<Integer> list22 = new ArrayList<>(Arrays.asList(integers)); List<Integer> list23 = Arrays.stream(integers).collect(Collectors.toList());
ArrayList<Integer> list24 = Arrays.stream(integers) .collect(Collectors.toCollection(ArrayList::new));
List<Integer> list 22 = Collections.unmodifiableList(Arrays.asList(integers));
List<ListItem> items = new ArrayList<ListItem>(); for (ListItem item: itemsArray) { items.add(item); }
Integer[] existingArray = {1, 2, 3}; List<Integer> list1 = Arrays.asList(existingArray); List<Integer> list2 = Arrays.asList(1, 2, 3); list2.add(1); list2.remove(1);
List<Integer> list = new ArrayList<>(); for (int i : new int[]{1, 2, 3}) { list.add(i); }
List<Integer> list1, list2, list3; list1 = Stream.of(1, 2, 3).collect(Collectors.toList()); list2 = Stream.of(1, 2, 3).collect(Collectors.toCollection(ArrayList::new)); list3 = Stream.of(1, 2, 3).collect(Collectors.toCollection(LinkedList::new));
List<String> immutableList = List.of("one","two","three");
int[] numbers = new int[] {1, 2, 3, 4}; List<Integer> integers = Arrays.stream(numbers) .boxed().collect(Collectors.<Integer>toList());
int[] spam = new int[] { 1, 2, 3 }; Arrays.asList(ArrayUtils.toObject(spam));
List<Integer> list = Arrays.asList(new Integer[] {1, 2, 3, 4});
Integer[] array = { 1, 2, 3}; List<Integer> list = Lists.newArrayList(sourceArray);
Integer[] array = { 1, 2, 3}; List<Integer> list = new ArrayList<>(6); CollectionUtils.addAll(list, array);
final String arr[] = new String[] { "G", "E", "E", "K" }; final List<String> initialList = new ArrayList<String>() {{ add("C"); add("O"); add("D"); add("I"); add("N"); }}; Collections.addAll(initialList, arr);
Integer[] arr = new Integer[] { 1, 2, 3 }; Arrays.asList(arr);
int[] num = new int[] {1, 2, 3}; List<Integer> list = Arrays.stream(num) .boxed().collect(Collectors.<Integer>toList())
public static <T> ArrayList<T> ArrayToArrayList(T[] array) { ArrayList<T> list = new ArrayList<T>(); for(T elmt : array) list.add(elmt); return list; }
public String toString(){ return "{a:"+ a + ", b:" + b + ", c: " + c +"}"; }
public String toString(){ StringBuilder sb = new StringBuilder(100); return sb.append("{a:").append(a) .append(", b:").append(b) .append(", c:").append(c) .append("}") .toString(); }
... String result = ""; for (String s : hugeArray) { result = result + s; }
... StringBuilder sb = new StringBuilder(); for (String s : hugeArray) { sb.append(s); } String result = sb.toString();
public class Main { public static void main(String[] args) { long now = System.currentTimeMillis(); slow(); System.out.println("slow elapsed " + (System.currentTimeMillis() - now) + " ms"); now = System.currentTimeMillis(); fast(); System.out.println("fast elapsed " + (System.currentTimeMillis() - now) + " ms"); } private static void fast() { StringBuilder s = new StringBuilder(); for(int i=0;i<100000;i++) s.append("*"); } private static void slow() { String s = ""; for(int i=0;i<100000;i++) s+="*"; } }
/** * * @author Perilbrain */ public class Appc { public Appc() { String x = "no name"; x += "I have Added a name" + "We May need few more names" + Appc.this; x.concat(x); } public void Sb() { StringBuilder sbb = new StringBuilder("no name"); sbb.append("I have Added a name"); sbb.append("We May need few more names"); sbb.append(Appc.this); sbb.append(sbb.toString()); } }
.method public <init>()V .limit stack 2 .limit locals 2 met001_begin: ; DATA XREF: met001_slot000i .line 12 aload_0 ; met001_slot000 invokespecial java/lang/Object.<init>()V .line 13 ldc "no name" astore_1 ; met001_slot001 .line 14 met001_7: ; DATA XREF: met001_slot001i new java/lang/StringBuilder dup invokespecial java/lang/StringBuilder.<init>()V aload_1 ; met001_slot001 invokevirtual java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lan\ g/StringBuilder; ldc "I have Added a nameWe May need few more names" invokevirtual java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lan\ g/StringBuilder; aload_0 ; met001_slot000 invokevirtual java/lang/StringBuilder.append(Ljava/lang/Object;)Ljava/lan\ g/StringBuilder; invokevirtual java/lang/StringBuilder.toString()Ljava/lang/String; astore_1 ; met001_slot001 .line 15 aload_1 ; met001_slot001 aload_1 ; met001_slot001 invokevirtual java/lang/String.concat(Ljava/lang/String;)Ljava/lang/Strin\ g; pop .line 18 return met001_end: ; DATA XREF: met001_slot000i ... ; =========================================================================== ;met001_slot000 ; DATA XREF: <init>r ... .var 0 is this LAppc; from met001_begin to met001_end ;met001_slot001 ; DATA XREF: <init>+6w ... .var 1 is x Ljava/lang/String; from met001_7 to met001_end .end method ;44-1=44 ; --------------------------------------------------------------------------- ; Segment type: Pure code .method public Sb()V .limit stack 3 .limit locals 2 met002_begin: ; DATA XREF: met002_slot000i .line 21 new java/lang/StringBuilder dup ldc "no name" invokespecial java/lang/StringBuilder.<init>(Ljava/lang/String;)V astore_1 ; met002_slot001 .line 22 met002_10: ; DATA XREF: met002_slot001i aload_1 ; met002_slot001 ldc "I have Added a name" invokevirtual java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lan\ g/StringBuilder; pop .line 23 aload_1 ; met002_slot001 ldc "We May need few more names" invokevirtual java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lan\ g/StringBuilder; pop .line 24 aload_1 ; met002_slot001 aload_0 ; met002_slot000 invokevirtual java/lang/StringBuilder.append(Ljava/lang/Object;)Ljava/lan\ g/StringBuilder; pop .line 25 aload_1 ; met002_slot001 aload_1 ; met002_slot001 invokevirtual java/lang/StringBuilder.toString()Ljava/lang/String; invokevirtual java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lan\ g/StringBuilder; pop .line 28 return met002_end: ; DATA XREF: met002_slot000i ... ;met002_slot000 ; DATA XREF: Sb+25r .var 0 is this LAppc; from met002_begin to met002_end ;met002_slot001 ; DATA XREF: Sb+9w ... .var 1 is sbb Ljava/lang/StringBuilder; from met002_10 to met002_end .end method ;96-49=48 ; ---------------------------------------------------------------------------
public String myCatPlus(String[] vals) { String result = ""; for (String val : vals) { result = result + val; } return result; }
12: iload 5 14: iload 4 16: if_icmpge 51 19: aload_3 20: iload 5 22: aaload 23: astore 6 25: new 28: dup 29: invokespecial 32: aload_2 33: invokevirtual 36: aload 6 38: invokevirtual 41: invokevirtual 44: astore_2 45: iinc 5, 1 48: goto 12
public String myCatSb(String[] vals) { StringBuilder sb = new StringBuilder(); for(String val : vals) { sb.append(val); } return sb.toString(); }
17: iload 5 19: iload 4 21: if_icmpge 43 24: aload_3 25: iload 5 27: aaload 28: astore 6 30: aload_2 31: aload 6 33: invokevirtual 36: pop 37: iinc 5, 1 40: goto 17 43: aload_2
public void toString() { ToStringBuilder tsb = new ToStringBuilder(this); tsb.append("a", a); tsb.append("b", b) return tsb.toString(); }
public void toString() { return new ToStringBuilder(this).append("a", a).append("b", b").toString(); }
public String toString() { return ToStringBuilder.reflectionToString(this); }
public static void main(String[] args) { for(int i = 0; i < 100; i++) RandomStringUtils.randomAlphanumeric(1024); final StringBuilder appender = new StringBuilder(); for(int i = 0; i < 100; i++) appender.append(RandomStringUtils.randomAlphanumeric(i)); for(int i = 1; i <= 10000; i*=10) test(i); } public static void test(final int howMany) { List<String> samples = new ArrayList<>(howMany); for(int i = 0; i < howMany; i++) samples.add(RandomStringUtils.randomAlphabetic(128)); final StringBuilder builder = new StringBuilder(); long start = System.nanoTime(); for(String sample: samples) builder.append(sample); builder.toString(); long elapsed = System.nanoTime() - start; System.out.printf("builder - %d - elapsed: %dus\n", howMany, elapsed / 1000); String accumulator = ""; start = System.nanoTime(); for(String sample: samples) accumulator += sample; elapsed = System.nanoTime() - start; System.out.printf("concatenation - %d - elapsed: %dus\n", howMany, elapsed / (int) 1e3); start = System.nanoTime(); String newOne = null; for(String sample: samples) newOne = new String(sample); elapsed = System.nanoTime() - start; System.out.printf("creation - %d - elapsed: %dus\n\n", howMany, elapsed / 1000); }
builder - 1 - elapsed: 132us concatenation - 1 - elapsed: 4us creation - 1 - elapsed: 5us builder - 10 - elapsed: 9us concatenation - 10 - elapsed: 26us creation - 10 - elapsed: 5us builder - 100 - elapsed: 77us concatenation - 100 - elapsed: 1669us creation - 100 - elapsed: 43us builder - 1000 - elapsed: 511us concatenation - 1000 - elapsed: 111504us creation - 1000 - elapsed: 282us builder - 10000 - elapsed: 3364us concatenation - 10000 - elapsed: 5709793us creation - 10000 - elapsed: 972us
static void main(String[] args) { case1(); case2(); case3(); } static void case1() { List<Long> savedTimes = new ArrayList(); long startTimeAll = System.currentTimeMillis(); String str = ""; for (int i = 0; i < MAX_ITERATIONS; i++) { long startTime = System.currentTimeMillis(); str = str.concat(UUID.randomUUID()+"---"); saveTime(savedTimes, startTime); } System.out.println("Created string of length:"+str.length()+" in "+(System.currentTimeMillis()-startTimeAll)+" ms"); } static void case2() { List<Long> savedTimes = new ArrayList(); long startTimeAll = System.currentTimeMillis(); String str = ""; for (int i = 0; i < MAX_ITERATIONS; i++) { long startTime = System.currentTimeMillis(); str+=UUID.randomUUID()+"---"; saveTime(savedTimes, startTime); } System.out.println("Created string of length:"+str.length()+" in "+(System.currentTimeMillis()-startTimeAll)+" ms"); } static void case3() { List<Long> savedTimes = new ArrayList(); long startTimeAll = System.currentTimeMillis(); StringBuilder str = new StringBuilder(""); for (int i = 0; i < MAX_ITERATIONS; i++) { long startTime = System.currentTimeMillis(); str.append(UUID.randomUUID()+"---"); saveTime(savedTimes, startTime); } System.out.println("Created string of length:"+str.length()+" in "+(System.currentTimeMillis()-startTimeAll)+" ms"); } static void saveTime(List<Long> executionTimes, long startTime) { executionTimes.add(System.currentTimeMillis()-startTime); if(executionTimes.size()%CALC_AVG_EVERY == 0) { out.println("average time for "+executionTimes.size()+" concatenations: "+ NumberFormat.getInstance().format(executionTimes.stream().mapToLong(Long::longValue).average().orElseGet(()->0))+ " ms avg"); executionTimes.clear(); } }
concatWithPlusOperator = 8 concatWithBuilder = 130 concatWithConcat = 127 concatStringFormat = 3737 concatWithBuilder2 = 46
public class StringConcatenationBenchmark { private static final int MAX_LOOP_COUNT = 1000000; public static void main(String[] args) { int loopCount = 0; long t1 = System.currentTimeMillis(); while (loopCount < MAX_LOOP_COUNT) { concatWithPlusOperator(); loopCount++; } long t2 = System.currentTimeMillis(); System.out.println("concatWithPlusOperator = " + (t2 - t1)); long t3 = System.currentTimeMillis(); loopCount = 0; while (loopCount < MAX_LOOP_COUNT) { concatWithBuilder(); loopCount++; } long t4 = System.currentTimeMillis(); System.out.println("concatWithBuilder = " + (t4 - t3)); long t5 = System.currentTimeMillis(); loopCount = 0; while (loopCount < MAX_LOOP_COUNT) { concatWithConcat(); loopCount++; } long t6 = System.currentTimeMillis(); System.out.println("concatWithConcat = " + (t6 - t5)); long t7 = System.currentTimeMillis(); loopCount = 0; while (loopCount < MAX_LOOP_COUNT) { concatStringFormat(); loopCount++; } long t8 = System.currentTimeMillis(); System.out.println("concatStringFormat = " + (t8 - t7)); long t9 = System.currentTimeMillis(); loopCount = 0; while (loopCount < MAX_LOOP_COUNT) { concatWithBuilder2(); loopCount++; } long t10 = System.currentTimeMillis(); System.out.println("concatWithBuilder2 = " + (t10 - t9)); } private static void concatStringFormat() { String s = String.format("%s %s %s %s ", "String", "String", "String", "String"); } private static void concatWithConcat() { String s = "String".concat("String").concat("String").concat("String"); } private static void concatWithBuilder() { StringBuilder builder=new StringBuilder("String"); builder.append("String").append("String").append("String"); String s = builder.toString(); } private static void concatWithBuilder2() { String s = new StringBuilder("String").append("String").append("String").append("String").toString(); } private static void concatWithPlusOperator() { String s = "String" + "String" + "String" + "String"; } }
@Override public final OptionalInt reduce(IntBinaryOperator op) { return evaluate(ReduceOps.makeInt(op)); } @Override public final OptionalInt max() { return reduce(Math::max); } public static int max(int a, int b) { return (a >= b) ? a : b; }
reduce(new IntBinaryOperator() { int applyAsInt(int left, int right) { return Math.max(left, right); } });
reduce((int left, int right) -> Math.max(left, right));
class Hey { public static double square(double num){ return Math.pow(num, 2); } } Function<Double, Double> square = Hey::square; double ans = square.apply(23d);
class Hey { public double square(double num) { return Math.pow(num, 2); } } Hey hey = new Hey(); Function<Double, Double> square = hey::square; double ans = square.apply(23d);
Function<Double, Double> square = (Double x) -> x * x;
Consumer<Integer> b1 = System::exit; Consumer<String[]> b2 = Arrays::sort; Consumer<String> b3 = MyProgram::main; class Hey { public double getRandom() { return Math.random(); } } Callable<Double> call = hey::getRandom; Supplier<Double> call2 = hey::getRandom; DoubleSupplier sup = hey::getRandom;
Set<String> set = new HashSet<>(); set.addAll(Arrays.asList("leo","bale","hanks")); Predicate<String> pred = set::contains; boolean exists = pred.test("leo");
class Param<T> { T elem; public T get() { return elem; } public void set(T elem) { this.elem = elem; } public static <E> E returnSame(E elem) { return elem; } } Supplier<Param<Integer>> obj = Param<Integer>::new; Param<Integer> param = obj.get(); Consumer<Integer> c = param::set; Supplier<Integer> s = param::get; Function<String, String> func = Param::<String>returnSame;
interface ConstructorReference { T constructor(); } interface MethodReference { void anotherMethod(String input); } public class ConstructorClass { String value; public ConstructorClass() { value = "default"; } public static void method(String input) { System.out.println(input); } public void nextMethod(String input) { } public static void main(String... args) { ConstructorReference reference = ConstructorClass::new; ConstructorClass cc = reference.constructor(); MethodReference mr = cc::method; MethodReference mr2 = cc::nextMethod; System.out.println(cc.value); } }
class ComparisonProvider { public int compareByName(Person a, Person b) { return a.getName().compareTo(b.getName()); } public int compareByAge(Person a, Person b) { return a.getBirthday().compareTo(b.getBirthday()); } } ComparisonProvider myComparisonProvider = new ComparisonProvider(); Arrays.sort(rosterAsArray, myComparisonProvider::compareByName);
public class Employee { private String name; private String grade; public Employee(String name, String grade) { this.name = name; this.grade = grade; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGrade() { return grade; } public void setGrade(String grade) { this.grade = grade; } }
List<Employee> employeeList = getDummyEmployees(); employeeList.sort(new Comparator<Employee>() { @Override public int compare(Employee e1, Employee e2) { return e1.getGrade().compareTo(e2.getGrade()); } });
private static List<Employee> getDummyEmployees() { return Arrays.asList(new Employee("Carrie", "C"), new Employee("Farhan", "F"), new Employee("Brian", "B"), new Employee("Donald", "D"), new Employee("Adam", "A"), new Employee("Evan", "E") ); }
employeeList.sort((e1,e2) -> e1.getGrade().compareTo(e2.getGrade()));
public class Employee { private String name; private String grade; public static int compareByGrade(Employee e1, Employee e2) { return e1.grade.compareTo(e2.grade); } }
+----+-------------------------------------------------------+--------------------------------------+ | | Kind | Example | +----+-------------------------------------------------------+--------------------------------------+ | 1 | Reference to a static method | ContainingClass::staticMethodName | +----+-------------------------------------------------------+--------------------------------------+ | 2 |Reference to an instance method of a particular object | containingObject::instanceMethodName | +----+-------------------------------------------------------+--------------------------------------+ | 3 | Reference to an instance method of an arbitrary object| ContainingType::methodName | | | of a particular type | | +----+-------------------------------------------------------+--------------------------------------+ | 4 |Reference to a constructor | ClassName::new | +------------------------------------------------------------+--------------------------------------+
IntBinaryOperator myLambda = (a, b)->{(a >= b) ? a : b}; return reduce(myLambda);
BinaryOperator<TestObject> binary = new BinaryOperator<TestObject>() { @Override public TestObject apply(TestObject t, TestObject u) { return t; } };
public class TestObject { public static final TestObject testStatic(TestObject t, TestObject t2){ return t; } }
BinaryOperator<TestObject> binary = TestObject::testStatic;
public class TestObject { public final TestObject testInstance(TestObject t, TestObject t2){ return t; } public static final TestObject testStatic(TestObject t, TestObject t2){ return t; } }
TestObject testObject = new TestObject(); BinaryOperator<TestObject> binary = testObject::testInstance;
BinaryOperator<TestObject> binary = TestObject::testInstance;
public class TestObject { public final TestObject testInstance(TestObject t){ return t; } public final TestObject testInstance(TestObject t, TestObject t2){ return t; } public static final TestObject testStatic(TestObject t, TestObject t2){ return t; } }
BinaryOperator<TestObject> binary = TestObject::testInstance;
public class TestObject { public TestObject() { System.out.println(this.hashCode()); } public final TestObject testInstance(TestObject t){ System.out.println("Test instance called. this.hashCode:" + this.hashCode()); System.out.println("Given parameter hashCode:" + t.hashCode()); return t; } public final TestObject testInstance(TestObject t, TestObject t2){ return t; } public static final TestObject testStatic(TestObject t, TestObject t2){ return t; } }
1418481495 303563356 Test instance called. this.hashCode:1418481495 Given parameter hashCode:303563356
public class TestUtil { public final TestObject testInstance(TestObject t){ return t; } }
BinaryOperator<TestObject> binary = TestUtil::testInstance;
public class SubTestObject extends TestObject { public final TestObject testInstance(TestObject t){ return t; } }
BinaryOperator<TestObject> binary = SubTestObject::testInstance;
public class TestObject { public SubTestObject testInstance(Object t){ return (SubTestObject) t; } } BinaryOperator<TestObject> binary = TestObject::testInstance;
Comparator c = (Person p1, Person p2) -> p1.getAge().compareTo(p2.getAge());
Comparator c = (p1, p2) -> p1.getAge().compareTo(p2.getAge());
Comparator c = Comparator.comparing(Person::getAge());
public interface Action { void execute(); } public class ActionImpl implements Action { @Override public void execute() { System.out.println("execute with ActionImpl"); } } public static void main(String[] args) { Action action = new Action() { @Override public void execute() { System.out.println("execute with anonymous class"); } }; action.execute(); Action actionImpl = new ActionImpl(); actionImpl.execute(); }
public static void doSomething(Action action) { action.execute(); }
interface InterfaceX { public Integer callMe(Integer x); }
interface InterfaceX { public Double callMe(Integer x); }
interface InterfaceX<T,U> { public T callMe(U x); }
InterfaceX o = new InterfaceX(){ public int callMe (int x, int y) { return x*x; } };
class Q { public static int anyFunction(int x) { return x+5; } }
import java.util.*; class MyClass { private int val; MyClass (int v) { val = v; } int getVal() { return val; } } class ByVal implements Comparator<MyClass> { public int compare(MyClass source, MyClass ref) { return source.getVal() - ref.getVal(); } } public class FindMaxInCol { public static void main(String args[]) { ArrayList<MyClass> myClassList = new ArrayList<MyClass>(); myClassList.add(new MyClass(1)); myClassList.add(new MyClass(0)); myClassList.add(new MyClass(3)); myClassList.add(new MyClass(6)); MyClass maxValObj = Collections.max(myClassList, new ByVal()); } }
import java.util.*; class MyClass { private int val; MyClass (int v) { val = v; } int getVal() { return val; } } public class FindMaxInCol { static int compareMyClass(MyClass source, MyClass ref) { return source.getVal() - ref.getVal(); } public static void main(String args[]) { ArrayList<MyClass> myClassList = new ArrayList<MyClass>(); myClassList.add(new MyClass(1)); myClassList.add(new MyClass(0)); myClassList.add(new MyClass(3)); myClassList.add(new MyClass(6)); MyClass maxValObj = Collections.max(myClassList, FindMaxInCol::compareMyClass); } }
package android.support.annotation; @Retention(CLASS) @Target({FIELD, METHOD, PARAMETER}) public @interface NonNull {}
package edu.umd.cs.findbugs.annotations; @Retention(CLASS) @Target({FIELD, METHOD, PARAMETER, LOCAL_VARIABLE}) public @interface NonNull {}
package org.eclipse.jdt.annotation; @Retention(CLASS) @Target({ TYPE_USE }) public @interface NonNull {}
package org.jetbrains.annotations; @Retention(CLASS) @Target({FIELD, METHOD, PARAMETER, LOCAL_VARIABLE}) public @interface NotNull {String value() default "";}
package javax.annotation; @TypeQualifier @Retention(RUNTIME) public @interface Nonnull { When when() default When.ALWAYS; static class Checker implements TypeQualifierValidator<Nonnull> { public When forConstantValue(Nonnull qualifierqualifierArgument, Object value) { if (value == null) return When.NEVER; return When.ALWAYS; } } }
package org.checkerframework.checker.nullness.qual; @Retention(RUNTIME) @Target({TYPE_USE, TYPE_PARAMETER}) @SubtypeOf(MonotonicNonNull.class) @ImplicitFor( types = { TypeKind.PACKAGE, TypeKind.INT, TypeKind.BOOLEAN, TypeKind.CHAR, TypeKind.DOUBLE, TypeKind.FLOAT, TypeKind.LONG, TypeKind.SHORT, TypeKind.BYTE }, literals = {LiteralKind.STRING} ) @DefaultQualifierInHierarchy @DefaultFor({TypeUseLocation.EXCEPTION_PARAMETER}) @DefaultInUncheckedCodeFor({TypeUseLocation.PARAMETER, TypeUseLocation.LOWER_BOUND}) public @interface NonNull {}
package android.support.annotation; @Retention(CLASS) @Target({METHOD, PARAMETER, FIELD}) public @interface Nullable {}
package edu.umd.cs.findbugs.annotations; @Target({FIELD, METHOD, PARAMETER, LOCAL_VARIABLE}) @Retention(CLASS) public @interface Nullable {}
package org.eclipse.jdt.annotation; @Retention(CLASS) @Target({ TYPE_USE }) public @interface Nullable {}
package org.jetbrains.annotations; @Retention(CLASS) @Target({FIELD, METHOD, PARAMETER, LOCAL_VARIABLE}) public @interface Nullable {String value() default "";}
package javax.annotation; @TypeQualifierNickname @Nonnull(when = When.UNKNOWN) @Retention(RUNTIME) public @interface Nullable {}
package org.checkerframework.checker.nullness.qual; @Retention(RUNTIME) @Target({TYPE_USE, TYPE_PARAMETER}) @SubtypeOf({}) @ImplicitFor( literals = {LiteralKind.NULL}, typeNames = {java.lang.Void.class} ) @DefaultInUncheckedCodeFor({TypeUseLocation.RETURN, TypeUseLocation.UPPER_BOUND}) public @interface Nullable {}
package lombok; @Retention(CLASS) @Target({FIELD, METHOD, PARAMETER, LOCAL_VARIABLE}) public @interface NonNull {}
package javax.validation.constraints; @Retention(RUNTIME) @Target({ FIELD, METHOD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER }) @Constraint(validatedBy = {}) public @interface NotNull { String message() default "{javax.validation.constraints.NotNull.message}"; Class<?>[] groups() default { }; Class<? extends Payload>[] payload() default {}; @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER }) @Retention(RUNTIME) @Documented @interface List { NotNull[] value(); } }
import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import javax.annotation.Nonnull; import javax.annotation.meta.TypeQualifierDefault; /** * This annotation can be applied to a package, class or method to indicate that the class fields, * method return types and parameters in that element are not null by default unless there is: <ul> * <li>An explicit nullness annotation <li>The method overrides a method in a superclass (in which * case the annotation of the corresponding parameter in the superclass applies) <li> there is a * default parameter annotation applied to a more tightly nested element. </ul> * <p/> * @see https: */ @Documented @Nonnull @TypeQualifierDefault( { ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE }) @Retention(RetentionPolicy.RUNTIME) public @interface NotNullByDefault { }
<dependency> <groupId>org.jetbrains</groupId> <artifactId>annotations</artifactId> <version>15.0</version> </dependency>
import android.support.annotation.NonNull; void foobar(@NonNull Foo bar) {}
@javax.annotation.ParametersAreNonnullByDefault package example; package example; public class PublicApi { /** * @param firstname MUST NOT be null * @param lastname MUST NOT be null */ public Person createPerson( @Nullable String firstname, @Nullable String lastname ) { if (firstname == null) throw new IllagalArgumentException(...); if (lastname == null) throw new IllagalArgumentException(...); return doCreatePerson(fistname, lastname, nickname); } @NonNull private Person doCreatePerson( String firstname, String lastname, @Nullable String nickname ) { return new Person(firstname, lastname, nickname); } @CheckForNull private Person getNickname( String firstname, String lastname) { return NICKNAMES.get(firstname + } }
import java.lang.annotation.*; /** * Designates that a field, return value, argument, or variable is * guaranteed to be non-null. */ @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE}) @Documented @Retention(RetentionPolicy.CLASS) public @interface NotNull {} /** * Designates that a field, return value, argument, or variable may be null. */ @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE}) @Documented @Retention(RetentionPolicy.CLASS) public @interface Nullable {}
import static java.util.Objects.requireNonNull; public class Role { private final UUID guid; private final String domain; private final String name; private final Optional<String> description; public Role(UUID guid, String domain, String name, Optional<String> description) { this.guid = requireNonNull(guid); this.domain = requireNonNull(domain); this.name = requireNonNull(name); this.description = requireNonNull(description); }
@java.lang.annotation.Documented @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) @java.lang.annotation.Target({java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.LOCAL_VARIABLE}) public @interface Nullable { }
<dependency> <groupId>javax.validation</groupId> <artifactId>validation-api</artifactId> <version>1.1.0.Final</version> </dependency>
<dependency> <groupId>javax.validation</groupId> <artifactId>validation-api</artifactId> <version>1.1.0.Final</version> </dependency> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-validator</artifactId> <version>5.4.1.Final</version> </dependency>
@Configuration @ValidationConfig public class ValidationConfig implements MyService { @Bean public MethodValidationPostProcessor providePostProcessor() { return new MethodValidationPostProcessor() } }
@Service @Validated public class MyServiceImpl implements MyService { @Override public Something doSomething(@NotNull String myParameter) { } }
Map<String,String> test = new HashMap<String, String>{"test":"test","test":"test"};
Map<String, String> test1 = Map.of( "a", "b", "c", "d" ); Map<String, String> test2 = Map.ofEntries( entry("a", "b"), entry("c", "d") );
Map<String, String> myMap = new HashMap<>() {{ put("a", "b"); put("c", "d"); }};
Map<String, String> myMap = createMap(); private static Map<String, String> createMap() { Map<String,String> myMap = new HashMap<String,String>(); myMap.put("a", "b"); myMap.put("c", "d"); return myMap; }
HashMap<String, String> h = new HashMap<String, String>() {{ put("a","b"); }};
Map<String, Integer> left = ImmutableMap.of("a", 1, "b", 2, "c", 3);
Map<String, String> test = ImmutableMap.of("k1", "v1", "k2", "v2");
Map<String, String> test = ImmutableMap.<String, String>builder() .put("k1", "v1") .put("k2", "v2") ... .build();
Map<String,String> test = new HashMap<String, String>(){{ put("test","test"); put("test","test");}};
Map<String,String> test = new HashMap<String, String>(); test.put("test","test"); test.put("test1","test2");
Map<String,String> test = new HashMap<String, String>(); { test.put("test","test"); test.put("test1","test2"); }
static Map<String,String> test = new HashMap<String, String>(); static { test.put("test","test"); test.put("test1","test2"); }
static Map<String,String> test; { Map<String,String> temp = new HashMap<String, String>(); temp.put("test","test"); temp.put("test1","test2"); test = Collections.unmodifiableMap(temp); }
Map<String,String> test = new HashMap<String, String>() { { put(key1, value1); put(key2, value2); } };
public static HashMap<String, String> build(String... data){ HashMap<String, String> result = new HashMap<String, String>(); if(data.length % 2 != 0) throw new IllegalArgumentException("Odd number of arguments"); String key = null; Integer step = -1; for(String value : data){ step++; switch(step % 2){ case 0: if(value == null) throw new IllegalArgumentException("Null key value"); key = value; continue; case 1: result.put(key, value); break; } } return result; }
HashMap<String,String> data = HashMapBuilder.build("key1","value1","key2","value2");
Object o1 = .... o1.getClass().getSimpleName(); o1.getClass().getName(); o1.getClass().getCanonicalName();
System.out.println(int.class.getName()); System.out.println(int.class.getCanonicalName()); System.out.println(int.class.getSimpleName()); System.out.println(); System.out.println(String.class.getName()); System.out.println(String.class.getCanonicalName()); System.out.println(String.class.getSimpleName()); System.out.println(); System.out.println(HashMap.SimpleEntry.class.getName()); System.out.println(HashMap.SimpleEntry.class.getCanonicalName()); System.out.println(HashMap.SimpleEntry.class.getSimpleName()); System.out.println(); System.out.println(new Serializable(){}.getClass().getName()); System.out.println(new Serializable(){}.getClass().getCanonicalName()); System.out.println(new Serializable(){}.getClass().getSimpleName());
int demo[] = new int[5]; Class<? extends int[]> clzz = demo.getClass(); System.out.println(clzz.getName()); System.out.println(clzz.getCanonicalName()); System.out.println(clzz.getSimpleName()); System.out.println(); Integer demo[] = new Integer[5]; Class<? extends Integer[]> clzz = demo.getClass(); System.out.println(clzz.getName()); System.out.println(clzz.getCanonicalName()); System.out.println(clzz.getSimpleName());
package com.example; public final class TestClassNames { private static void showClass(Class<?> c) { System.out.println("getName(): " + c.getName()); System.out.println("getCanonicalName(): " + c.getCanonicalName()); System.out.println("getSimpleName(): " + c.getSimpleName()); System.out.println("toString(): " + c.toString()); System.out.println(); } private static void x(Runnable r) { showClass(r.getClass()); showClass(java.lang.reflect.Array.newInstance(r.getClass(), 1).getClass()); } public static class NestedClass {} public class InnerClass {} public static void main(String[] args) { class LocalClass {} showClass(void.class); showClass(int.class); showClass(String.class); showClass(Runnable.class); showClass(SomeEnum.class); showClass(SomeAnnotation.class); showClass(int[].class); showClass(String[].class); showClass(NestedClass.class); showClass(InnerClass.class); showClass(LocalClass.class); showClass(LocalClass[].class); Object anonymous = new java.io.Serializable() {}; showClass(anonymous.getClass()); showClass(java.lang.reflect.Array.newInstance(anonymous.getClass(), 1).getClass()); x(() -> {}); } } enum SomeEnum { BLUE, YELLOW, RED; } @interface SomeAnnotation {}
int.class.getName(); int.class.getCanonicalName(); int.class.getSimpleName(); Integer.class.getName(); Integer.class.getCanonicalName(); Integer.class.getSimpleName(); Map.Entry.class.getName(); Map.Entry.class.getCanonicalName(); Map.Entry.class.getSimpleName(); Class<?> anonymousInnerClass = new Cloneable() {}.getClass(); anonymousInnerClass.getName(); anonymousInnerClass.getCanonicalName(); anonymousInnerClass.getSimpleName(); Class<?> primitiveArrayClass = new int[0].getClass(); primitiveArrayClass.getName(); primitiveArrayClass.getCanonicalName(); primitiveArrayClass.getSimpleName(); Class<?> objectArrayClass = new Integer[0].getClass(); objectArrayClass.getName(); objectArrayClass.getCanonicalName(); objectArrayClass.getSimpleName();
package a.b; class C { static class D extends C { } D d; D[] ds; }
scala> case class C() defined class C scala> val c = C() c: C = C() scala> c.getClass.getSimpleName java.lang.InternalError: Malformed class name at java.lang.Class.getSimpleName(Class.java:1330) ... 32 elided scala> c.getClass.getCanonicalName java.lang.InternalError: Malformed class name at java.lang.Class.getSimpleName(Class.java:1330) at java.lang.Class.getCanonicalName(Class.java:1399) ... 32 elided scala> c.getClass.getName res2: String = C
public void printReflectionClassNames(){ StringBuffer buffer = new StringBuffer(); Class clazz= buffer.getClass(); System.out.println("Reflection on String Buffer Class"); System.out.println("Name: "+clazz.getName()); System.out.println("Simple Name: "+clazz.getSimpleName()); System.out.println("Canonical Name: "+clazz.getCanonicalName()); System.out.println("Type Name: "+clazz.getTypeName()); } outputs: Reflection on String Buffer Class Name: java.lang.StringBuffer Simple Name: StringBuffer Canonical Name: java.lang.StringBuffer Type Name: java.lang.StringBuffer
public class Foo { private static final ThreadLocal<SimpleDateFormat> formatter = new ThreadLocal<SimpleDateFormat>(){ @Override protected SimpleDateFormat initialValue() { return new SimpleDateFormat("yyyyMMdd HHmm"); } }; public String formatIt(Date date) { return formatter.get().format(date); } }
class ThreadId { private static final AtomicInteger nextId = new AtomicInteger(0); private static final ThreadLocal<Integer> threadId = ThreadLocal.<Integer>withInitial(()-> {return nextId.getAndIncrement();}); public static int get() { return threadId.get(); } }
public class ThreadLocalDemo1 implements Runnable { private static final ThreadLocal<SimpleDateFormat> dateFormat = new ThreadLocal<SimpleDateFormat>(){ @Override protected SimpleDateFormat initialValue(){ System.out.println("Initializing SimpleDateFormat for - " + Thread.currentThread().getName() ); return new SimpleDateFormat("dd/MM/yyyy"); } }; public static void main(String[] args) { ThreadLocalDemo1 td = new ThreadLocalDemo1(); Thread t1 = new Thread(td, "Thread-1"); Thread t2 = new Thread(td, "Thread-2"); t1.start(); t2.start(); } @Override public void run() { System.out.println("Thread run execution started for " + Thread.currentThread().getName()); System.out.println("Date formatter pattern is " + dateFormat.get().toPattern()); System.out.println("Formatted date is " + dateFormat.get().format(new Date())); } }
ThreadLocal<Cipher> local = ThreadLocal.withInitial(() -> "init value");
ThreadLocal<String> local = new ThreadLocal<String>(){ @Override protected String initialValue() { return "init value"; } };
class NotThreadSafe { public NotThreadSafe(){} } ThreadLocal<NotThreadSafe> container = ThreadLocal.withInitial(NotThreadSafe::new);
Key = One ThreadLocal object shared across threads. value = Mutable object which has to be used synchronously, this will be instantiated for each thread.
class SimpleDateFormatInstancePerThread { private static final ThreadLocal<SimpleDateFormat> dateFormatHolder = new ThreadLocal<SimpleDateFormat>() { @Override protected SimpleDateFormat initialValue() { SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd") { UUID id = UUID.randomUUID(); @Override public String toString() { return id.toString(); }; }; System.out.println("Creating SimpleDateFormat instance " + dateFormat +" for Thread : " + Thread.currentThread().getName()); return dateFormat; } }; /* * Every time there is a call for DateFormat, ThreadLocal will return calling * Thread */ public static DateFormat getDateFormatter() { return dateFormatHolder.get(); } public static void cleanup() { dateFormatHolder.remove(); } }
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() { public Connection initialValue() { return DriverManager.getConnection(DB_URL); } }; public static Connection getConnection() { return connectionHolder.get(); }
import java.util.concurrent.atomic.AtomicInteger; import java.util.stream.IntStream; public class ThreadId { private static final AtomicInteger nextId = new AtomicInteger(1000); private static final ThreadLocal<Integer> threadId = ThreadLocal.withInitial(() -> nextId.getAndIncrement()); public static int get() { return threadId.get(); } public static void main(String[] args) { new Thread(() -> IntStream.range(1, 3).forEach(i -> { System.out.println(Thread.currentThread().getName() + " >> " + new ThreadId().get()); })).start(); new Thread(() -> IntStream.range(1, 3).forEach(i -> { System.out.println(Thread.currentThread().getName() + " >> " + new ThreadId().get()); })).start(); new Thread(() -> IntStream.range(1, 3).forEach(i -> { System.out.println(Thread.currentThread().getName() + " >> " + new ThreadId().get()); })).start(); } }
public enum Direction { NORTH, NORTHEAST, EAST, SOUTHEAST, SOUTH, SOUTHWEST, WEST, NORTHWEST }
for (Direction d : Direction.values()) { System.out.println(d); }
for (Direction direction : EnumSet.allOf(Direction.class)) { }
for (Direction dir : Direction.values()) { System.out.println(dir); }
Stream.of(Direction.values()).forEachOrdered(System.out::println);
Set<Integer> seen = Collections.synchronizedSet(new HashSet<>()); stream.parallel().map(e -> { if (seen.add(e)) return 0; else return e; })...
Set<Direction> directions = EnumSet.allOf(Direction.class); for(Direction direction : directions) { }
Stream.of(Direction.values()).forEach(System.out::println);
for ( Direction d: Direction.values()){ System.out.println(d); }
for ( Direction direction : Direction.values()){ System.out.println(direction.toString()); }
<plugin> <groupId>org.eclipse.tycho</groupId> <artifactId>tycho-compiler-plugin</artifactId> <version>${tycho.version}</version> <configuration> <compilerArgument>-warn:+discouraged,forbidden</compilerArgument> </configuration> </plugin>
a.b.c.d1 (d2 is missing altogether or has restricted access)
C:\Users\Admin>java -X -Xmixed mixed mode execution (default) -Xint interpreted mode execution only -Xbootclasspath:<directories and zip/jar files separated by ;> set search path for bootstrap classes and resources -Xbootclasspath/a:<directories and zip/jar files separated by ;> append to end of bootstrap class path -Xbootclasspath/p:<directories and zip/jar files separated by ;> prepend in front of bootstrap class path -Xdiag show additional diagnostic messages -Xnoclassgc disable class garbage collection -Xincgc enable incremental garbage collection -Xloggc:<file> log GC status to a file with time stamps -Xbatch disable background compilation -Xms<size> set initial Java heap size......................... -Xmx<size> set maximum Java heap size......................... -Xss<size> set java thread stack size -Xprof output cpu profiling data -Xfuture enable strictest checks, anticipating future default -Xrs reduce use of OS signals by Java/VM (see documentation) -Xcheck:jni perform additional checks for JNI functions -Xshare:off do not attempt to use shared class data -Xshare:auto use shared class data if possible (default) -Xshare:on require using shared class data, otherwise fail. -XshowSettings show all settings and continue -XshowSettings:all show all settings and continue -XshowSettings:vm show all vm related settings and continue -XshowSettings:properties show all property settings and continue -XshowSettings:locale show all locale related settings and continue
private Map<String, Choice> nameMap(List<Choice> choices) { final Map<String, Choice> hashMap = new HashMap<>(); for (final Choice choice : choices) { hashMap.put(choice.getName(), choice); } return hashMap; }
private Map<String, Choice> nameMap(List<Choice> choices) { return Maps.uniqueIndex(choices, new Function<Choice, String>() { @Override public String apply(final Choice input) { return input.getName(); } }); }
private Map<String, Choice> nameMap(List<Choice> choices) { return Maps.uniqueIndex(choices, Choice::getName); }
Map<String, Choice> result = choices.stream().collect(Collectors.toMap(Choice::getName, Function.identity()));
Map<String, List<Choice>> result = choices.stream().collect(Collectors.groupingBy(Choice::getName));
Map<String, Choice> result = choices.stream().collect(Collectors.toMap(Choice::getName, c -> c));
Map<String, Choice> result = choices.stream().collect(HashMap<String, Choice>::new, (m, c) -> m.put(c.getName(), c), (m, u) -> {});
Map<String,Choice> map = new HashMap<>(); choices.forEach(e->map.put(e.getName(),e));
public Map<String, Choice> convertListToMap(List<Choice> choices) { return choices.stream() .collect(Collectors.toMap(Choice::getName, choice -> choice, (oldValue, newValue) -> newValue)); }
class Item{ private String code; private String name; public Item(String code, String name) { this.code = code; this.name = name; } }
List<Item> list = new ArrayList<>(); list.add(new Item("code1", "name1")); list.add(new Item("code2", "name2")); Map<String,String> map = list.stream() .collect(Collectors.toMap(Item::getCode, Item::getName));
ListX<Choices> choices; Map<String, Choice> map = choices.toMap(c-> c.getName(),c->c);
Map<String, Collection<ItemType>> items = Arrays.stream(itemFilesDir.listFiles(File::isDirectory)) .map(File::getName) .collect(Collectors.toMap(s->s, this::retrieveBrandItems));
Map<Integer,Item> map = IntStream.range(0,items.size()) .boxed() .collect(Collectors.toMap (i -> i, i -> items.get(i)));
Map<Integer, List<Choice>> choiceMap = choices.stream().collect(Collectors.groupingBy(choice -> choice.getName()));
Map<String, Set<String>> collect = Arrays.asList(Locale.getAvailableLocales()).stream().collect(Collectors .toMap(l -> l.getDisplayCountry(), l -> Collections.singleton(l.getDisplayLanguage())));
public interface KeyFinder<K, E> { K getKey(E e); }
static <K, E> Map<K, E> listToMap(List<E> list, KeyFinder<K, E> finder) { return list.stream().collect(Collectors.toMap(e -> finder.getKey(e) , e -> e)); }
public class BookKeyFinder implements KeyFinder<Long, Book> { @Override public Long getKey(Book e) { return e.getPrice() } }
import static java.util.stream.Collectors.toMap; private static Map<String, Choice> nameMap(List<Choice> choices) { return choices.stream().collect(toMap(Choice::getName, it -> it)); }
StreamEx.of(choices).toMap(Choice::getName, c -> c);
Map<String,Choice> map=list.stream().collect(Collectors.toMap(Choice::getName, s->s));
Map<String,Choice> map= list1.stream().collect(()-> new HashMap<String,Choice>(), (r,s) -> r.put(s.getString(),s),(r,s) -> r.putAll(s));
public class Person { private String name; private int age; public String getAge() { return age; } }
Map<Integer,List<Person>> mapPersons = new HashMap<>(); persons.forEach(p->mapPersons.put(p.getAge(),p));
Map<Integer,List<Person>> mapPersons = persons.stream().collect(Collectors.groupingBy(Person::getAge));
Date date = new Date(); date.setMonth().. date.setYear().. date.setDay().. date.setlong currentTime = date.getTime();
String string = "January 2, 2010"; DateFormat format = new SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH); Date date = format.parse(string); System.out.println(date);
String string = "January 2, 2010"; DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MMMM d, yyyy", Locale.ENGLISH); LocalDate date = LocalDate.parse(string, formatter); System.out.println(date);
Calendar mydate = new GregorianCalendar(); String mystring = "January 2, 2010"; Date thedate = new SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH).parse(mystring); mydate.setTime(thedate); System.out.println("mydate -> "+mydate); System.out.println("year -> "+mydate.get(Calendar.YEAR)); System.out.println("month -> "+mydate.get(Calendar.MONTH)); System.out.println("dom -> "+mydate.get(Calendar.DAY_OF_MONTH)); System.out.println("dow -> "+mydate.get(Calendar.DAY_OF_WEEK)); System.out.println("hour -> "+mydate.get(Calendar.HOUR)); System.out.println("minute -> "+mydate.get(Calendar.MINUTE)); System.out.println("second -> "+mydate.get(Calendar.SECOND)); System.out.println("milli -> "+mydate.get(Calendar.MILLISECOND)); System.out.println("ampm -> "+mydate.get(Calendar.AM_PM)); System.out.println("hod -> "+mydate.get(Calendar.HOUR_OF_DAY));
Calendar now = Calendar.getInstance(); mydate.set(Calendar.YEAR,2009); mydate.set(Calendar.MONTH,Calendar.FEBRUARY); mydate.set(Calendar.DAY_OF_MONTH,25); mydate.set(Calendar.HOUR_OF_DAY,now.get(Calendar.HOUR_OF_DAY)); mydate.set(Calendar.MINUTE,now.get(Calendar.MINUTE)); mydate.set(Calendar.SECOND,now.get(Calendar.SECOND)); System.out.println("mydate -> "+mydate); System.out.println("year -> "+mydate.get(Calendar.YEAR)); System.out.println("month -> "+mydate.get(Calendar.MONTH)); System.out.println("dom -> "+mydate.get(Calendar.DAY_OF_MONTH)); System.out.println("dow -> "+mydate.get(Calendar.DAY_OF_WEEK)); System.out.println("hour -> "+mydate.get(Calendar.HOUR)); System.out.println("minute -> "+mydate.get(Calendar.MINUTE)); System.out.println("second -> "+mydate.get(Calendar.SECOND)); System.out.println("milli -> "+mydate.get(Calendar.MILLISECOND)); System.out.println("ampm -> "+mydate.get(Calendar.AM_PM)); System.out.println("hod -> "+mydate.get(Calendar.HOUR_OF_DAY));
String str_date = "11-June-07"; DateFormat formatter; Date date; formatter = new SimpleDateFormat("dd-MMM-yy"); date = formatter.parse(str_date);
int year = date.getYear(); int day = date.getDayOfMonth(); Month month = date.getMonth(); int monthAsInt = month.getValue();
LocalDateTime dateWithTime = LocalDateTime.parse(strWithDateAndTime, dateTimeFormatter); ZonedDateTime zoned = ZonedDateTime.parse(strWithTimeZone, zoneFormatter);
All letters The following pattern letters are defined: Symbol Meaning Presentation Examples ------ ------- ------------ ------- G era text AD; Anno Domini; A u year year 2004; 04 y year-of-era year 2004; 04 D day-of-year number 189 M/L month-of-year number/text 7; 07; Jul; July; J d day-of-month number 10 Q/q quarter-of-year number/text 3; 03; Q3; 3rd quarter Y week-based-year year 1996; 96 w week-of-week-based-year number 27 W week-of-month number 4 E day-of-week text Tue; Tuesday; T e/c localized day-of-week number/text 2; 02; Tue; Tuesday; T F week-of-month number 3 a am-pm-of-day text PM h clock-hour-of-am-pm (1-12) number 12 K hour-of-am-pm (0-11) number 0 k clock-hour-of-am-pm (1-24) number 0 H hour-of-day (0-23) number 0 m minute-of-hour number 30 s second-of-minute number 55 S fraction-of-second fraction 978 A milli-of-day number 1234 n nano-of-second number 987654321 N nano-of-day number 1234000000 V time-zone ID zone-id America/Los_Angeles; Z; -08:30 z time-zone name zone-name Pacific Standard Time; PST O localized zone-offset offset-O GMT+8; GMT+08:00; UTC-08:00; X zone-offset x zone-offset offset-x +0000; -08; -0830; -08:30; -083015; -08:30:15; Z zone-offset offset-Z +0000; -0800; -08:00;
org.joda.time.DateTime dateTime = new DateTime( date, timeZone );
String input = "January 2, 2010"; java.util.Locale locale = java.util.Locale.US; DateTimeZone timeZone = DateTimeZone.forID( "Pacific/Honolulu" ); DateTimeFormatter formatter = DateTimeFormat.forPattern( "MMMM d, yyyy" ).withZone( timeZone ).withLocale( locale ); DateTime dateTime = formatter.parseDateTime( input ); System.out.println( "dateTime: " + dateTime ); System.out.println( "dateTime in UTC/GMT: " + dateTime.withZone( DateTimeZone.UTC ) );
DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); Date date; try { date = dateFormat.parse("2013-12-4"); System.out.println(date.toString()); String output = dateFormat.format(date); System.out.println(output); } catch (ParseException e) { e.printStackTrace(); }
package be.test.package.time; import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.TimeZone; public class TimeWork { public static void main(String[] args) { TimeZone timezone = TimeZone.getTimeZone("UTC"); List<Long> longs = new ArrayList<>(); List<String> strings = new ArrayList<>(); DateFormat formatter = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss.SSS"); formatter.setTimeZone(timezone); Date now = new Date(); strings.add(formatter.format(now)); strings.add("01-01-1970 00:00:00.000"); strings.add("01-01-1970 00:00:01.000"); strings.add("01-01-1970 00:01:00.000"); strings.add("01-01-1970 01:00:00.000"); strings.add("01-01-1970 10:00:00.000"); strings.add("01-01-1970 12:00:00.000"); strings.add("01-01-1970 24:00:00.000"); strings.add("02-01-1970 00:00:00.000"); strings.add("01-01-1971 00:00:00.000"); strings.add("01-01-2014 00:00:00.000"); strings.add("31-12-1969 23:59:59.000"); strings.add("31-12-1969 23:59:00.000"); strings.add("31-12-1969 23:00:00.000"); longs.add(now.getTime()); longs.add(-1L); longs.add(0L); longs.add(1L); longs.add(1000L); longs.add(60000L); longs.add(3600000L); longs.add(36000000L); longs.add(43200000L); longs.add(86400000L); longs.add(31536000000L); longs.add(1388534400000L); longs.add(7260000L); longs.add(1417706084037L); longs.add(-7260000L); System.out.println("===== String to long ====="); for (String string: strings) { try { Date date = formatter.parse(string); System.out.println("Formated date : " + string + " = Long = " + date.getTime()); } catch (ParseException e) { e.printStackTrace(); } } System.out.println("===== Long to String ====="); for (Long lo : longs) { Date date = new Date(lo); String string = formatter.format(date); System.out.println("Formated date : " + string + " = Long = " + lo); } } }
===== String to long ===== Formated date : 05-12-2014 10:17:34.873 = Long = 1417774654873 Formated date : 01-01-1970 00:00:00.000 = Long = 0 Formated date : 01-01-1970 00:00:01.000 = Long = 1000 Formated date : 01-01-1970 00:01:00.000 = Long = 60000 Formated date : 01-01-1970 01:00:00.000 = Long = 3600000 Formated date : 01-01-1970 10:00:00.000 = Long = 36000000 Formated date : 01-01-1970 12:00:00.000 = Long = 43200000 Formated date : 01-01-1970 24:00:00.000 = Long = 86400000 Formated date : 02-01-1970 00:00:00.000 = Long = 86400000 Formated date : 01-01-1971 00:00:00.000 = Long = 31536000000 Formated date : 01-01-2014 00:00:00.000 = Long = 1388534400000 Formated date : 31-12-1969 23:59:59.000 = Long = -1000 Formated date : 31-12-1969 23:59:00.000 = Long = -60000 Formated date : 31-12-1969 23:00:00.000 = Long = -3600000 ===== Long to String ===== Formated date : 05-12-2014 10:17:34.873 = Long = 1417774654873 Formated date : 31-12-1969 23:59:59.999 = Long = -1 Formated date : 01-01-1970 00:00:00.000 = Long = 0 Formated date : 01-01-1970 00:00:00.001 = Long = 1 Formated date : 01-01-1970 00:00:01.000 = Long = 1000 Formated date : 01-01-1970 00:01:00.000 = Long = 60000 Formated date : 01-01-1970 01:00:00.000 = Long = 3600000 Formated date : 01-01-1970 10:00:00.000 = Long = 36000000 Formated date : 01-01-1970 12:00:00.000 = Long = 43200000 Formated date : 02-01-1970 00:00:00.000 = Long = 86400000 Formated date : 01-01-1971 00:00:00.000 = Long = 31536000000 Formated date : 01-01-2014 00:00:00.000 = Long = 1388534400000 Formated date : 01-01-1970 02:01:00.000 = Long = 7260000 Formated date : 04-12-2014 15:14:44.037 = Long = 1417706084037 Formated date : 31-12-1969 21:59:00.000 = Long = -7260000
date="2016-05-06 16:40:32"; public static String setDateParsing(String date) throws ParseException { DateFormat mSDF = new SimpleDateFormat("hh:mm a"); SimpleDateFormat formatter = new SimpleDateFormat("yyyy-mm-dd hh:mm"); return mSDF.format(formatter.parse(date)); }
String oldDate = "Thu Jul 26 15:54:13 GMT+05:30 2018"; DateFormat format = new SimpleDateFormat("EEE LLL dd HH:mm:ss Z yyyy"); Date updateLast = format.parse(oldDate);
String date = get_pump_data.getString("bond_end_date"); DateFormat format = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH); Date datee = (Date)format.parse(date);
class Languages { public static void main(String[] args) { display(); } static void display() { System.out.println("Java is my favorite programming language."); } }
class Student9{ int rollno; String name; static String college = "ITS"; static void change(){ college = "BBDIT"; } Student9(int r, String n){ rollno = r; name = n; } void display (){System.out.println(rollno+" "+name+" "+college);} public static void main(String args[]){ Student9.change(); Student9 s1 = new Student9 (111,"Indian"); Student9 s2 = new Student9 (222,"American"); Student9 s3 = new Student9 (333,"China"); s1.display(); s2.display(); s3.display(); } }
1. new ABCClass(double farenheit).convertFarenheitToCelcium() 2. ABCClass.convertFarenheitToCelcium(double farenheit)
Math.random() Math.sqrt(double) Math.min(int, int) StringUtils.isEmpty(String) StringUtils.isBlank(String)
new MockUp<ClassName>() { @Mock public int doSomething(Input input1, Input input2){ return returnValue; } };
public static int min(int a, int b) { return (a <= b) ? a : b; }
public class World { List<Listener> listeners; void addListener(Listener item) { listeners.add(item); } void doAction(Action goal,Object obj) { setState("i received"); goal.doAction(obj); setState("i finished"); } private string state; } public class WorldTest implements Listener { @Test public void word{ World w= mock(World.class); w.addListener(this); ... ... } } interface Listener { void doAction(); }
Mockito.doThrow(new Exception()).when(instance).methodName();
Mockito.doThrow(new Exception()).doNothing().when(instance).methodName();
World mockWorld = mock(World.class); doAnswer(new Answer<Void>() { public Void answer(InvocationOnMock invocation) { Object[] args = invocation.getArguments(); System.out.println("called with arguments: " + Arrays.toString(args)); return null; } }).when(mockWorld).setState(anyString());
Mockito.doCallRealMethod().when(<objectInstance>).<method>(); <objectInstance>.<method>();
<Object> <objectInstance> = mock(<Object>.class, Mockito.CALLS_REAL_METHODS);
World world = new World(); World spy = Mockito.spy(world); Mockito.doNothing().when(spy).methodToMock();
assertEquals(0,spy.methodToTestThatShouldReturnZero());
doNothing().when(someObject).someMethod(anyObject());
doReturn("something").when(this.world).someMethod(anyObject());
@Test public void testUpdate() { doAnswer(new Answer<Void>() { @Override public Void answer(InvocationOnMock invocation) throws Throwable { Object[] arguments = invocation.getArguments(); if (arguments != null && arguments.length > 1 && arguments[0] != null && arguments[1] != null) { Customer customer = (Customer) arguments[0]; String email = (String) arguments[1]; customer.setEmail(email); } return null; } }).when(daoMock).updateEmail(any(Customer.class), any(String.class)); Customer customer = service.changeEmail("old@test.com", "new@test.com"); assertThat(customer, is(notNullValue())); assertThat(customer.getEmail(), is(equalTo("new@test.com"))); } @Test(expected = RuntimeException.class) public void testUpdate_throwsException() { doThrow(RuntimeException.class).when(daoMock).updateEmail(any(Customer.class), any(String.class)); Customer customer = service.changeEmail("old@test.com", "new@test.com"); } }
doAnswer(new CallsRealMethods()).when(mock) .voidMethod(any(SomeParamClass.class));
doAnswer(Answers.CALLS_REAL_METHODS.get()).when(mock) .voidMethod(any(SomeParamClass.class));
Listener listener = mock(Listener.class); w.addListener(listener); world.doAction(..); verify(listener).doAction();
doAnswer(i -> { return null; }).when(*mock*).*method*(*methodArguments*);
doAnswer(i -> { ((Runnable) i.getArguments()[0]).run(); return null; }).when(executor).execute(any());
public class AssetChangeListenerImpl extends AbstractAssetChangeListener implements AssetChangeListener { @Override public void onChangeEvent(final EventMessage message) throws EventHubClientException { execute(message); } } } public class AbstractAssetChangeListener { protected void execute( final EventMessage message ) throws EventHubClientException { executor.execute( new PublishTask(getClient(), message) ); } } @RunWith(MockitoJUnitRunner.class) public class AssetChangeListenerTest extends AbstractAssetChangeListenerTest { public void testExecute() throws EventHubClientException { EventMessage message = createEventMesage(EventType.CREATE); assetChangeListener.execute(message); verify(assetChangeListener, times(1)).execute(message); } }
for(i=1..n) alg1(); for(i=1..n) alg2(); for(i=1..n) alg2(); for(i=1..n) alg1();
long startTime = System.nanoTime(); System.out.println("Code took "+(System.nanoTime()-startTime)+"nano seconds");
final long endTime, startTime = System.nanoTime(); endTime = System.nanoTime(); System.out.println("Code took "+(endTime-startTime)+"nano seconds");
from(people).where("name", eq("Arthur")).first(); from(people).where("age", lessThan(20)).all(); from(people).where("name", not(contains("Francine"))).all();
List<String> parts = new ArrayList<String>(); FluentIterable<Integer> partsStartingA = FluentIterable.from(parts).filter(new Predicate<String>() { @Override public boolean apply(final String input) { return input.startsWith("a"); } }).transform(new Function<String, Integer>() { @Override public Integer apply(final String input) { return input.length(); } });
class Dto { private int id; private String text; public int getId() { return id; } public int getText() { return text; } }
Filter<Dto> query = CQ.<Dto>filter(testList) .where() .property("id").eq().value(1); Collection<Dto> filtered = query.list();
Filter<Dto> query = CQ.<Dto>filter(testList) .where() .property(Dto::getId) .eq().value(1); Collection<Dto> filtered = query.list();
Filter<Dto> query = CQ.<Dto>filter() .from(testList) .where() .property(Dto::getId).between().value(1).value(2) .and() .property(Dto::grtText).in().value(new string[]{"a","b"});
Filter<Dto> query = CQ.<Dto>filter(testList) .orderBy() .property(Dto::getId) .property(Dto::getName) Collection<Dto> sorted = query.list();
GroupQuery<Integer,Dto> query = CQ.<Dto,Dto>query(testList) .group() .groupBy(Dto::getId) Collection<Grouping<Integer,Dto>> grouped = query.list();
class LeftDto { private int id; private String text; public int getId() { return id; } public int getText() { return text; } } class RightDto { private int id; private int leftId; private String text; public int getId() { return id; } public int getLeftId() { return leftId; } public int getText() { return text; } } class JoinedDto { private int leftId; private int rightId; private String text; public JoinedDto(int leftId,int rightId,String text) { this.leftId = leftId; this.rightId = rightId; this.text = text; } public int getLeftId() { return leftId; } public int getRightId() { return rightId; } public int getText() { return text; } } Collection<LeftDto> leftList = new ArrayList<>(); Collection<RightDto> rightList = new ArrayList<>();
Collection<JoinedDto> results = CQ.<LeftDto, LeftDto>query().from(leftList) .<RightDto, JoinedDto>innerJoin(CQ.<RightDto, RightDto>query().from(rightList)) .on(LeftFyo::getId, RightDto::getLeftId) .transformDirect(selection -> new JoinedDto(selection.getLeft().getText() , selection.getLeft().getId() , selection.getRight().getId()) ) .list();
Filter<Dto> query = CQ.<Dto>filter() .from(testList) .where() .exec(s -> s.getId() + 1).eq().value(2);
List<String> names = Queryable.from(people) .filter(new Predicate<Person>() { public boolean filter(Person p) { return p.age>20; } }) .map (new Converter<Person,String>() { public Integer convert(Person p) { return p.name; } }) .toList();
List<String> names = Queryable.from(people) .filter(p->p.age>20) .map (p->p.name) .toList();
String[] strings = { "bla", "mla", "bura", "bala", "mura", "buma" };
Query<String> stringsStartingWithB = new Query<String>(strings).where( new Query.Func<String, Boolean>(){ public Boolean run(String in) { return in.startsWith("b"); } } );
for(String string : stringsStartingWithB ) { System.out.println(string); }
public static void main(String[] args) { long startTime = System.nanoTime(); int n = 0; for (int i = 0; i < 1000000000; i++) { n += 2 * (i * i); } System.out.println((double) (System.nanoTime() - startTime) / 1000000000 + " s"); System.out.println("n = " + n); }
2*(i*i) | 2*i*i ----------+---------- 0.5183738 | 0.6246434 0.5298337 | 0.6049722 0.5308647 | 0.6603363 0.5133458 | 0.6243328 0.5003011 | 0.6541802 0.5366181 | 0.6312638 0.515149 | 0.6241105 0.5237389 | 0.627815 0.5249942 | 0.6114252 0.5641624 | 0.6781033 0.538412 | 0.6393969 0.5466744 | 0.6608845 0.531159 | 0.6201077 0.5048032 | 0.6511559 0.5232789 | 0.6544526
030 B2: 030 addl R11, RBP 033 movl RBP, R13 036 addl RBP, 039 imull RBP, RBP 03c movl R9, R13 03f addl R9, 043 imull R9, R9 047 sall RBP, 049 sall R9, 04c movl R8, R13 04f addl R8, 053 movl R10, R8 056 movdl XMM1, R8 05b imull R10, R8 05f movl R8, R13 062 addl R8, 066 imull R8, R8 06a sall R10, 06d movl [rsp + 072 sall R8, 075 movl RBX, R13 078 addl RBX, 07b imull RBX, RBX 07e movl RCX, R13 081 addl RCX, 084 imull RCX, RCX 087 sall RBX, 089 sall RCX, 08b movl RDX, R13 08e addl RDX, 091 imull RDX, RDX 094 movl RDI, R13 097 addl RDI, 09a imull RDI, RDI 09d sall RDX, 09f sall RDI, 0a1 movl RAX, R13 0a4 addl RAX, 0a7 imull RAX, RAX 0aa movl RSI, R13 0ad addl RSI, 0b0 imull RSI, RSI 0b3 sall RAX, 0b5 sall RSI, 0b7 movl R10, R13 0ba addl R10, 0be imull R10, R10 0c2 movl R14, R13 0c5 incl R14 0c8 imull R14, R14 0cc sall R10, 0cf sall R14, 0d2 addl R14, R11 0d5 addl R14, R10 0d8 movl R10, R13 0db addl R10, 0df imull R10, R10 0e3 movl R11, R13 0e6 addl R11, 0ea imull R11, R11 0ee sall R10, 0f1 addl R10, R14 0f4 addl R10, RSI 0f7 sall R11, 0fa addl R11, R10 0fd addl R11, RAX 100 addl R11, RDI 103 addl R11, RDX 106 movl R10, R13 109 addl R10, 10d imull R10, R10 111 sall R10, 114 addl R10, R11 117 addl R10, RCX 11a addl R10, RBX 11d addl R10, R8 120 addl R9, R10 123 addl RBP, R9 126 addl RBP, [RSP + 12a addl R13, 12e movl R11, R13 131 imull R11, R13 135 sall R11, 138 cmpl R13, 13f jl B2
05a B3: 05a addl RBX, R11 05d movl [rsp + 061 movl R11, R8 064 addl R11, 068 movl [rsp + 06d movl R11, R8 070 addl R11, 074 movl R10, R9 077 addl R10, 07b movdl XMM2, R10 080 movl RCX, R9 083 addl RCX, 086 movdl XMM1, RCX 08a movl R10, R9 08d addl R10, 091 movdl XMM4, R10 096 movl RCX, R9 099 addl RCX, 09c movdl XMM6, RCX 0a0 movl RBX, R9 0a3 addl RBX, 0a6 movl RCX, R9 0a9 addl RCX, 0ac movl RDX, R9 0af addl RDX, 0b2 addl R9, 0b6 movl R10, R14 0b9 addl R10, 0bd movdl XMM3, R10 0c2 movl RDI, R14 0c5 addl RDI, 0c8 movl RAX, R14 0cb addl RAX, 0ce movl RSI, R14 0d1 addl RSI, 0d4 movl R13, R14 0d7 addl R13, 0db movl R10, R14 0de addl R10, 0e2 movl [rsp + 0e7 movl RBP, R14 0ea addl RBP, 0ed imull RBP, R11 0f1 addl R14, 0f5 imull R14, [RSP + 0fb movl R10, R8 0fe addl R10, 102 movdl R11, XMM3 107 imull R11, R10 10b movl [rsp + 110 movl R10, R8 113 addl R10, 117 imull RDI, R10 11b movl R11, R8 11e addl R11, 122 movdl R10, XMM2 127 imull R10, R11 12b movl [rsp + 130 movl R10, R8 133 addl R10, 137 movdl R11, XMM1 13c imull R11, R10 140 movl [rsp + 145 movl R11, R8 148 addl R11, 14c movdl R10, XMM4 151 imull R10, R11 155 movl [rsp + 15a movl R10, R8 15d addl R10, 161 movdl R11, XMM6 166 imull R11, R10 16a movl [rsp + 16f movl R11, R8 172 addl R11, 176 imull RBX, R11 17a movl R11, R8 17d addl R11, 181 imull RCX, R11 185 movl R10, R8 188 addl R10, 18c imull RDX, R10 190 movl R11, R8 193 incl R11 196 imull R9, R11 19a addl R9, [RSP + 19f addl R9, RDX 1a2 addl R9, RCX 1a5 addl R9, RBX 1a8 addl R9, [RSP + 1ad addl R9, [RSP + 1b2 addl R9, [RSP + 1b7 addl R9, [RSP + 1bc movl R10, R8 1bf addl R10, 1c3 imull R10, RSI 1c7 addl R10, R9 1ca addl R10, RDI 1cd addl R10, [RSP + 1d2 movl R11, R8 1d5 addl R11, 1d9 imull R13, R11 1dd addl R13, R10 1e0 movl R10, R8 1e3 addl R10, 1e7 imull R10, [RSP + 1ed addl R10, R13 1f0 addl RBP, R10 1f3 addl R14, RBP 1f6 movl R10, R8 1f9 addl R10, 1fd cmpl R10, 204 jl B2
vmovdqa ymm0, YMMWORD PTR .LC0[rip] vmovdqa ymm3, YMMWORD PTR .LC1[rip] xor eax, eax vpxor xmm2, xmm2, xmm2 .L2: vpmulld ymm1, ymm0, ymm0 inc eax vpaddd ymm0, ymm0, ymm3 vpslld ymm1, ymm1, 1 vpaddd ymm2, ymm2, ymm1 cmp eax, 125000000 ; 8 calculations per iteration jne .L2 vmovdqa xmm0, xmm2 vextracti128 xmm2, ymm2, 1 vpaddd xmm2, xmm0, xmm2 vpsrldq xmm0, xmm2, 8 vpaddd xmm0, xmm2, xmm0 vpsrldq xmm1, xmm0, 4 vpaddd xmm0, xmm0, xmm1 vmovd eax, xmm0 vzeroupper
int n = 0; for (int i = 0; i < 1000000000; i++) { n += i * i; } n *= 2;
public static void main(String[] args) { long fastVersion = 0; long slowVersion = 0; long optimizedVersion = 0; long modifiedFastVersion = 0; long modifiedSlowVersion = 0; for (int i = 0; i < 10; i++) { fastVersion += fastVersion(); slowVersion += slowVersion(); optimizedVersion += optimizedVersion(); modifiedFastVersion += modifiedFastVersion(); modifiedSlowVersion += modifiedSlowVersion(); } System.out.println("Fast version: " + (double) fastVersion / 1000000000 + " s"); System.out.println("Slow version: " + (double) slowVersion / 1000000000 + " s"); System.out.println("Optimized version: " + (double) optimizedVersion / 1000000000 + " s"); System.out.println("Modified fast version: " + (double) modifiedFastVersion / 1000000000 + " s"); System.out.println("Modified slow version: " + (double) modifiedSlowVersion / 1000000000 + " s"); } private static long fastVersion() { long startTime = System.nanoTime(); int n = 0; for (int i = 0; i < 1000000000; i++) { n += 2 * (i * i); } return System.nanoTime() - startTime; } private static long slowVersion() { long startTime = System.nanoTime(); int n = 0; for (int i = 0; i < 1000000000; i++) { n += 2 * i * i; } return System.nanoTime() - startTime; } private static long optimizedVersion() { long startTime = System.nanoTime(); int n = 0; for (int i = 0; i < 1000000000; i++) { n += i * i; } n *= 2; return System.nanoTime() - startTime; } private static long modifiedFastVersion() { long startTime = System.nanoTime(); int n = 0; for (int i = 0; i < 1000000000; i++) { if (n == 0) n = 1; n += 2 * (i * i); } return System.nanoTime() - startTime; } private static long modifiedSlowVersion() { long startTime = System.nanoTime(); int n = 0; for (int i = 0; i < 1000000000; i++) { if (n == 0) n = 1; n += 2 * i * i; } return System.nanoTime() - startTime; }
Fast version: 5.7274411 s Slow version: 7.6190804 s Optimized version: 5.1348007 s Modified fast version: 7.1492705 s Modified slow version: 7.2952668 s
public static void main(String[] args) { int repeat = 10; long A = 0; long B = 0; for (int i = 0; i < repeat; i++) { A += test(); B += testB(); } System.out.println(A / repeat + " ms"); System.out.println(B / repeat + " ms"); } private static long test() { int n = 0; for (int i = 0; i < 1000; i++) { n += multi(i); } long startTime = System.currentTimeMillis(); for (int i = 0; i < 1000000000; i++) { n += multi(i); } long ms = (System.currentTimeMillis() - startTime); System.out.println(ms + " ms A " + n); return ms; } private static long testB() { int n = 0; for (int i = 0; i < 1000; i++) { n += multiB(i); } long startTime = System.currentTimeMillis(); for (int i = 0; i < 1000000000; i++) { n += multiB(i); } long ms = (System.currentTimeMillis() - startTime); System.out.println(ms + " ms B " + n); return ms; } private static int multiB(int i) { return 2 * (i * i); } private static int multi(int i) { return 2 * i * i; }
... 405 ms A 785527736 327 ms B 785527736 404 ms A 785527736 329 ms B 785527736 404 ms A 785527736 328 ms B 785527736 404 ms A 785527736 328 ms B 785527736 410 ms 333 ms
private static multiB(int arg0) { <localVar:index=0 , name=i , desc=I, sig=null, start=L1, end=L2> L1 { iconst_2 iload0 iload0 imul imul ireturn } L2 { } } private static multi(int arg0) { <localVar:index=0 , name=i , desc=I, sig=null, start=L1, end=L2> L1 { iconst_2 iload0 imul iload0 imul ireturn } L2 { } }
xor edx, edx xor eax, eax .L2: mov ecx, edx imul ecx, edx add edx, 1 lea eax, [rax+rcx*2] cmp edx, 1000000000 jne .L2
static void Main(string[] args) { Stopwatch watch = new Stopwatch(); Console.WriteLine("2 * (i * i)"); for (int a = 0; a < 10; a++) { int n = 0; watch.Restart(); for (int i = 0; i < 1000000000; i++) { n += 2 * (i * i); } watch.Stop(); Console.WriteLine($"result:{n}, {watch.ElapsedMilliseconds}ms"); } Console.WriteLine(); Console.WriteLine("2 * i * i"); for (int a = 0; a < 10; a++) { int n = 0; watch.Restart(); for (int i = 0; i < 1000000000; i++) { n += 2 * i * i; } watch.Stop(); Console.WriteLine($"result:{n}, {watch.ElapsedMilliseconds}ms"); } }
2 * (i * i): 0.458765943 s, n=119860736 2 * i * i: 0.580255126 s, n=119860736
3: ldc 5: invokevirtual 8: invokestatic 8: invokestatic 11: lstore_1 12: iconst_0 13: istore_3 14: iconst_0 15: istore 4 17: iload 4 19: ldc 21: if_icmpge 40 24: iload_3 25: iconst_2 26: iload 4 28: iload 4 30: imul 31: imul 32: iadd 33: istore_3 34: iinc 4, 1 37: goto 17
3: ldc 5: invokevirtual 8: invokestatic 11: lstore_1 12: iconst_0 13: istore_3 14: iconst_0 15: istore 4 17: iload 4 19: ldc 21: if_icmpge 40 24: iload_3 25: iconst_2 26: iload 4 28: imul 29: iload 4 31: imul 32: iadd 33: istore_3 34: iinc 4, 1 37: goto 17
java -version java version "1.8.0_121" Java(TM) SE Runtime Environment (build 1.8.0_121-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
@State(Scope.Benchmark) @Warmup(iterations = 2) @Fork(1) @Measurement(iterations = 10) @OutputTimeUnit(TimeUnit.NANOSECONDS) @BenchmarkMode(Mode.AverageTime) public class MyBenchmark { @Param({ "100", "1000", "1000000000" }) private int size; @Benchmark public int two_square_i() { int n = 0; for (int i = 0; i < size; i++) { n += 2 * (i * i); } return n; } @Benchmark public int square_i_two() { int n = 0; for (int i = 0; i < size; i++) { n += i * i; } return 2*n; } @Benchmark public int two_i_() { int n = 0; for (int i = 0; i < size; i++) { n += 2 * i * i; } return n; } }
Benchmark (size) Mode Samples Score Score error Units o.s.MyBenchmark.square_i_two 100 avgt 10 58,062 1,410 ns/op o.s.MyBenchmark.square_i_two 1000 avgt 10 547,393 12,851 ns/op o.s.MyBenchmark.square_i_two 1000000000 avgt 10 540343681,267 16795210,324 ns/op o.s.MyBenchmark.two_i_ 100 avgt 10 87,491 2,004 ns/op o.s.MyBenchmark.two_i_ 1000 avgt 10 1015,388 30,313 ns/op o.s.MyBenchmark.two_i_ 1000000000 avgt 10 967100076,600 24929570,556 ns/op o.s.MyBenchmark.two_square_i 100 avgt 10 70,715 2,107 ns/op o.s.MyBenchmark.two_square_i 1000 avgt 10 686,977 24,613 ns/op o.s.MyBenchmark.two_square_i 1000000000 avgt 10 652736811,450 27015580,488 ns/op
java version "1.8.0_191" Java(TM) 2 Runtime Environment, Standard Edition (IBM build 1.8.0_191-b12 26_Oct_2018_18_45 Mac OS X x64(SR5 FP25)) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)
0.374653912 s n = 119860736 0.447778698 s n = 119860736
Java version "1.8.0_181" Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
0.414331815 s n = 119860736 0.491430656 s n = 119860736
L0001: add eax,r11d inc r8d mov r11d,r8d imul r11d,r8d shl r11d,1h cmp r8d,r10d jl L0001
L0001: add eax,r11d mov r11d,r8d shl r11d,1h add r11d,2h inc r8d imul r11d,r8d cmp r8d,r10d jl L0001
java version "11" 2018-09-25 Java(TM) SE Runtime Environment 18.9 (build 11+28) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)
Benchmark (size) Mode Cnt Score Error Units LoopTest.fast 1000000000 avgt 5 694,868  36,470 ms/op LoopTest.slow 1000000000 avgt 5 769,840  135,006 ms/op
@BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.MILLISECONDS) @Warmup(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS) @Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS) @State(Scope.Thread) @Fork(1) public class LoopTest { @Param("1000000000") private int size; public static void main(String[] args) throws RunnerException { Options opt = new OptionsBuilder().include(LoopTest.class.getSimpleName()) .jvmArgs("-XX:LoopUnrollLimit=0") .build(); new Runner(opt).run(); } @Benchmark public int slow() { int n = 0; for (int i = 0; i < size; i++) { n += 2 * i * i; } return n; } @Benchmark public int fast() { int n = 0; for (int i = 0; i < size; i++) { n += 2 * (i * i); } return n; } }
17: iconst_2 18: iload 4 20: iload 4 22: imul 23: imul 24: iadd
17: iconst_2 18: iload 4 20: imul 21: iload 4 23: imul 24: iadd
@Warmup(iterations = 5, batchSize = 1) @Measurement(iterations = 5, batchSize = 1) @Fork(1) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.MILLISECONDS) @State(Scope.Benchmark) public class MyBenchmark { @Benchmark public int noBrackets() { int n = 0; for (int i = 0; i < 1000000000; i++) { n += 2 * i * i; } return n; } @Benchmark public int brackets() { int n = 0; for (int i = 0; i < 1000000000; i++) { n += 2 * (i * i); } return n; } }
Benchmark (n) Mode Cnt Score Error Units MyBenchmark.brackets 1000000000 avgt 5 380.889  58.011 ms/op MyBenchmark.noBrackets 1000000000 avgt 5 512.464  11.098 ms/op
Benchmark (n) Mode Cnt Score Error Units MyBenchmark.brackets 1000000000 avgt 5 335.100  23.085 ms/op MyBenchmark.noBrackets 1000000000 avgt 5 331.163  50.670 ms/op
A)Restore view phase B)Apply request values phase C)Process validations phase D)Update model values phase E)Invoke application phase F)Render response phase
/** The proportional set size for dalvik. */ public int dalvikPss; /** The private dirty pages used by dalvik. */ public int dalvikPrivateDirty; /** The shared dirty pages used by dalvik. */ public int dalvikSharedDirty; /** The proportional set size for the native heap. */ public int nativePss; /** The private dirty pages used by the native heap. */ public int nativePrivateDirty; /** The shared dirty pages used by the native heap. */ public int nativeSharedDirty; /** The proportional set size for everything else. */ public int otherPss; /** The private dirty pages used by everything else. */ public int otherPrivateDirty; /** The shared dirty pages used by everything else. */ public int otherSharedDirty;
Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
ActivityManager activityManager = (ActivityManager) context.getSystemService(ACTIVITY_SERVICE); MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); activityManager.getMemoryInfo(memoryInfo); Log.i(TAG, " memoryInfo.availMem " + memoryInfo.availMem + "\n" ); Log.i(TAG, " memoryInfo.lowMemory " + memoryInfo.lowMemory + "\n" ); Log.i(TAG, " memoryInfo.threshold " + memoryInfo.threshold + "\n" ); List<RunningAppProcessInfo> runningAppProcesses = activityManager.getRunningAppProcesses(); Map<Integer, String> pidMap = new TreeMap<Integer, String>(); for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses) { pidMap.put(runningAppProcessInfo.pid, runningAppProcessInfo.processName); } Collection<Integer> keys = pidMap.keySet(); for(int key : keys) { int pids[] = new int[1]; pids[0] = key; android.os.Debug.MemoryInfo[] memoryInfoArray = activityManager.getProcessMemoryInfo(pids); for(android.os.Debug.MemoryInfo pidMemoryInfo: memoryInfoArray) { Log.i(TAG, String.format("** MEMINFO in pid %d [%s] **\n",pids[0],pidMap.get(pids[0]))); Log.i(TAG, " pidMemoryInfo.getTotalPrivateDirty(): " + pidMemoryInfo.getTotalPrivateDirty() + "\n"); Log.i(TAG, " pidMemoryInfo.getTotalPss(): " + pidMemoryInfo.getTotalPss() + "\n"); Log.i(TAG, " pidMemoryInfo.getTotalSharedDirty(): " + pidMemoryInfo.getTotalSharedDirty() + "\n"); } }
ActivityManager activityManager = (ActivityManager) getSystemService(ACTIVITY_SERVICE); MemoryInfo mi = new MemoryInfo(); activityManager.getMemoryInfo(mi); Log.i("memory free", "" + mi.availMem);
Debug.MemoryInfo memInfo = new Debug.MemoryInfo(); Debug.getMemoryInfo(memInfo); long res = memInfo.getTotalPrivateDirty(); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) res += memInfo.getTotalPrivateClean(); return res * 1024L;
<uses-permission android:name="android.permission.FACTORY_TEST"/>
Process process = Runtime.getRuntime().exec("su"); DataOutputStream dataOutputStream = new DataOutputStream(process.getOutputStream()); DataInputStream dataInputStream = new DataInputStream(process.getInputStream()); if (dataInputStream != null && dataOutputStream != null) { dataOutputStream.writeBytes("id\n"); dataOutputStream.flush(); String Uid = dataInputStream.readLine(); if (Uid.contains("uid=0")) { } }
Process process = Runtime.getRuntime().exec("su"); DataOutputStream dataOutputStream = new DataOutputStream(process.getOutputStream()); if (dataOutputStream != null) { dataOutputStream.writeBytes("procrank\n"); dataOutputStream.flush(); BufferedInputStream bufferedInputStream = new BufferedInputStream(process.getInputStream()); try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } byte[] bff = new byte[bufferedInputStream.available()]; bufferedInputStream.read(bff); bufferedInputStream.close(); } }
InputStream stream = new ByteArrayInputStream(exampleString.getBytes(StandardCharsets.UTF_8));
String source = "This is the source of my input stream"; InputStream in = org.apache.commons.io.IOUtils.toInputStream(source, "UTF-8");
public static boolean isNumeric(String str) { try { double d = Double.parseDouble(str); } catch(NumberFormatException nfe) { return false; } return true; }
public static boolean isNumeric(String str) { return str.matches("-?\\d+(\\.\\d+)?"); }
public static boolean isNumeric(String str) { NumberFormat formatter = NumberFormat.getInstance(); ParsePosition pos = new ParsePosition(0); formatter.parse(str, pos); return str.length() == pos.getIndex(); }
android.text.TextUtils.isDigitsOnly(CharSequence str)
public static boolean isNumeric(String str) { for (char c : str.toCharArray()) { if (!Character.isDigit(c)) return false; } return true; }
public static boolean isStringNumeric( String str ) { DecimalFormatSymbols currentLocaleSymbols = DecimalFormatSymbols.getInstance(); char localeMinusSign = currentLocaleSymbols.getMinusSign(); if ( !Character.isDigit( str.charAt( 0 ) ) && str.charAt( 0 ) != localeMinusSign ) return false; boolean isDecimalSeparatorFound = false; char localeDecimalSeparator = currentLocaleSymbols.getDecimalSeparator(); for ( char c : str.substring( 1 ).toCharArray() ) { if ( !Character.isDigit( c ) ) { if ( c == localeDecimalSeparator && !isDecimalSeparatorFound ) { isDecimalSeparatorFound = true; continue; } return false; } } return true; }
String someString = "123123"; boolean isNumeric = someString.chars().allMatch( Character::isDigit );
String s1 = "22"; String s2 = "22.2"; Integer oInt1 = Ints.tryParse(s1); Integer oInt2 = Ints.tryParse(s2); int i1 = -1; if (oInt1 != null) { i1 = oInt1.intValue(); } int i2 = -1; if (oInt2 != null) { i2 = oInt2.intValue(); } System.out.println(i1); System.out.println(i2);
NumberUtils.isNumber("07") NumberUtils.isNumber("08")
public static boolean isNumericRegex(String str) { if (str == null) return false; return str.matches("-?\\d+"); } public static boolean isNumericArray(String str) { if (str == null) return false; char[] data = str.toCharArray(); if (data.length <= 0) return false; int index = 0; if (data[0] == index = 1; for (; index < data.length; index++) { if (data[index] < return false; } return true; } public static boolean isNumericException(String str) { if (str == null) return false; try { Integer.parseInt(str); } catch (NumberFormatException nfe) { return false; } return true; }
Done with: for (int i = 0; i < 10000000; i++)... With only valid numbers ("59815833" and "-59815833"): Array numeric took 395.808192 ms [39.5808192 ns each] Regex took 2609.262595 ms [260.9262595 ns each] Exception numeric took 428.050207 ms [42.8050207 ns each] Array numeric took 355.788273 ms [35.5788273 ns each] Regex took 2746.278466 ms [274.6278466 ns each] Exception numeric took 518.989902 ms [51.8989902 ns each] Array numeric took 317.861267 ms [31.7861267 ns each] Regex took 2505.313201 ms [250.5313201 ns each] Exception numeric took 239.956955 ms [23.9956955 ns each] Array numeric took 400.734616 ms [40.0734616 ns each] Regex took 2663.052417 ms [266.3052417 ns each] Exception numeric took 401.235906 ms [40.1235906 ns each] With invalid characters ("5981a5833" and "a"): Array numeric took 343.205793 ms [34.3205793 ns each] Regex took 2608.739933 ms [260.8739933 ns each] Exception numeric took 7317.201775 ms [731.7201775 ns each] Array numeric took 291.695519 ms [29.1695519 ns each] Regex took 2287.25378 ms [228.725378 ns each] Exception numeric took 7095.969481 ms [709.5969481 ns each] With null: Array numeric took 214.663834 ms [21.4663834 ns each] Regex took 201.395992 ms [20.1395992 ns each] Exception numeric took 233.049327 ms [23.3049327 ns each] Exception numeric took 6603.669427 ms [660.3669427 ns each] if there is no if/null check
public static boolean isNumericArray(String str) { if (str == null) return false; for (char c : str.toCharArray()) if (c < return false; return true;
public static boolean isNumeric(String str) { return str.matches("-?\\d+(.\\d+)?"); }
public static boolean isNumeric(String str) { return str.matches("[+-]?\\d*(\\.\\d+)?"); }
try { NumberFormat.getInstance().parse(value); } catch(ParseException e) { }
isParsable(Integer.class, "11"); isParsable(Double.class, "11.11"); Object dateFormater = new java.text.SimpleDateFormat("yyyy.MM.dd G isParsable(dateFormater, "2001.07.04 AD at 12:08:56 PDT");
import java.lang.reflect.*; /** * METHOD: isParsable<p><p> * * This method will look through the methods of the specified <code>from</code> parameter * looking for a public method name starting with "parse" which has only one String * parameter.<p> * * The <code>parser</code> parameter can be a class or an instantiated object, eg: * <code>Integer.class</code> or <code>new Integer(1)</code>. If you use a * <code>Class</code> type then only static methods are considered.<p> * * When looping through potential methods, it first looks at the <code>Class</code> associated * with the <code>parser</code> parameter, then looks through the methods of the parent * followed by subsequent ancestors, using the first method that matches the criteria specified * above.<p> * * This method will hide any normal parse exceptions, but throws any exceptions due to * programmatic errors, eg: NullPointerExceptions, etc. If you specify a <code>parser</code> * parameter which has no matching parse methods, a NoSuchMethodException will be thrown * embedded within a RuntimeException.<p><p> * * Example:<br> * <code>isParsable(Boolean.class, "true");<br> * isParsable(Integer.class, "11");<br> * isParsable(Double.class, "11.11");<br> * Object dateFormater = new java.text.SimpleDateFormat("yyyy.MM.dd G * isParsable(dateFormater, "2001.07.04 AD at 12:08:56 PDT");<br></code> * <p> * * @param parser The Class type or instantiated Object to find a parse method in. * @param str The String you want to parse * * @return true if a parse method was found and completed without exception * @throws java.lang.NoSuchMethodException If no such method is accessible */ public static boolean isParsable(Object parser, String str) { Class theClass = (parser instanceof Class? (Class)parser: parser.getClass()); boolean staticOnly = (parser == theClass), foundAtLeastOne = false; Method[] methods = theClass.getMethods(); for (int index = 0; index < methods.length; index++) { Method method = methods[index]; if(method.getName().startsWith("parse") && (!staticOnly || Modifier.isStatic(method.getModifiers())) && Modifier.isPublic(method.getModifiers()) && method.getGenericParameterTypes().length == 1 && method.getGenericParameterTypes()[0] == String.class) { try { foundAtLeastOne = true; method.invoke(parser, str); return true; } catch (Exception exception) { /*if(!(exception instanceof IllegalArgumentException) && !(exception instanceof IllegalAccessException) && !(exception instanceof InvocationTargetException)) continue; continue; } } } if(foundAtLeastOne) return false; else throw new RuntimeException(new NoSuchMethodException()); } /** * METHOD: willParse<p><p> * * A convienence method which calls the isParseable method, but does not throw any exceptions * which could be thrown through programatic errors.<p> * * Use of {@link * errors can be caught in development, unless the value of the <code>parser</code> parameter is * unpredictable, or normal programtic exceptions should be ignored.<p> * * See {@link * usability.<p> * * @param parser The Class type or instantiated Object to find a parse method in. * @param str The String you want to parse * * @return true if a parse method was found and completed without exception * @see */ public static boolean willParse(Object parser, String str) { try { return isParsable(parser, str); } catch(Throwable exception) { return false; } }
public static boolean isNumeric(String maybeNumeric) { return maybeNumeric != null && maybeNumeric.matches("[0-9]+"); }
Pattern PATTERN = Pattern.compile( "^(-?0|-?[1-9]\\d*)(\\.\\d+)?(E\\d+)?$" ); public static boolean isNumeric( String value ) { return value != null && PATTERN.matcher( value ).matches(); }
public class NumUtils { /** * Transforms a string to an integer. If no numerical chars returns a String "0". * * @param str * @return retStr */ static String makeToInteger(String str) { String s = str; double d; d = Double.parseDouble(makeToDouble(s)); int i = (int) (d + 0.5D); String retStr = String.valueOf(i); System.out.printf(retStr + " "); return retStr; } /** * Transforms a string to an double. If no numerical chars returns a String "0". * * @param str * @return retStr */ static String makeToDouble(String str) { Boolean dotWasFound = false; String orgStr = str; String retStr; int firstDotPos = 0; Boolean negative = false; if(str.length()==0){ str="0"; } if (str.charAt(0) == negative = true; } if (!str.matches(".*\\d+.*")) { str = "0"; } str = str.replaceAll(",", "."); str = str.replaceAll("[^\\d.]", ""); for (int i_char = 0; i_char < str.length(); i_char++) { if (str.charAt(i_char) == dotWasFound = true; firstDotPos = i_char; break; } } if (dotWasFound) { String befDot = str.substring(0, firstDotPos + 1); String aftDot = str.substring(firstDotPos + 1, str.length()); aftDot = aftDot.replaceAll("\\.", ""); str = befDot + aftDot; } double uglyMethod = Double.parseDouble(str); str = String.valueOf(uglyMethod); str = str.replaceAll("([0-9])\\.0+([^0-9]|$)", "$1$2"); retStr = str; if (negative) { retStr = "-"+retStr; } return retStr; } static boolean isNumeric(String str) { try { double d = Double.parseDouble(str); } catch (NumberFormatException nfe) { return false; } return true; } }
public static boolean isNumeric(String str) { return str.matches("^(?:(?:\\-{1})?\\d+(?:\\.{1}\\d+)?)$"); }
1 -- **VALID** 1. -- INVALID 1.. -- INVALID 1.1 -- **VALID** 1.1.1 -- INVALID -1 -- **VALID** --1 -- INVALID -1. -- INVALID -1.1 -- **VALID** -1.1.1 -- INVALID
import java.util.Date; public class IsNumeric { public static boolean isNumericOne(String s) { return s.matches("-?\\d+(\\.\\d+)?"); } public static boolean isNumericTwo(String s) { try { Double.parseDouble(s); return true; } catch (Exception e) { return false; } } public static void main(String [] args) { String test = "12345.F"; long before = new Date().getTime(); for(int x=0;x<1000000;++x) { isNumericOne(test); } long after = new Date().getTime(); System.out.println(after-before); } }
boolean isNumber(String str){ return str.replaceAll("[0-9]","").length() == 0; }
public static boolean isDigitsOnly(CharSequence str) { final int len = str.length(); for (int i = 0; i < len; i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; }
public static boolean isNumber(int num) { return (num >= 48 && c <= 57); } public static boolean isNumber(String s) { boolean isNumber = true; for(int i = 0; i < s.length() && isNumber; i++) { char c = s.charAt(i); isNumber = isNumber & ( (c >= ); } return isInteger; } public static boolean isInteger(String s) { boolean isInteger = true; for(int i = 0; i < s.length() && isInteger; i++) { char c = s.charAt(i); isInteger = isInteger & ((c >= } return isInteger; } public static boolean isNumeric(String s) { try { Double.parseDouble(s); return true; } catch (Exception e) { return false; } }
public static boolean isNumericString(String input) { boolean result = false; if(input != null && input.length() > 0) { char[] charArray = input.toCharArray(); for(char c : charArray) { if(c >= result = true; } else { result = false; break; } } } return result; }
public static boolean isNumeric(String inputData) { Scanner sc = new Scanner(inputData); return sc.hasNextInt(); }
boolean parseInteger(String s, out int number) { try { number = Integer.parseInt(myString); return true; } catch(NumberFormatException e) { return false; } }
public static boolean isNumeric(String str) { NumberFormat formatter = NumberFormat.getInstance(); ParsePosition pos = new ParsePosition(0); formatter.parse(str, pos); return str.length() == pos.getIndex(); }
System.out.println(isNumeric("94328948243242352525243242524243425452342343948923"));
public static boolean isNumeric(String str) { try { int number = Integer.parseInt(str); return true; } catch (Exception e) { return false; } }
private boolean isValidStringNumber(String stringNumber) { if(stringNumber.isEmpty()) { return false; } stringNumber = stringNumber.replaceAll(" ", ""); char [] charNumber = stringNumber.toCharArray(); for(int i =0 ; i<charNumber.length ;i++) { if(!Character.isDigit(charNumber[i])) { return false; } } return true; }
private boolean isValidStringTrueNumber(String stringNumber) { if(stringNumber.isEmpty()) { return false; } stringNumber = stringNumber.replaceAll(" ", ""); int countOfDecimalPoint = 0; boolean decimalPointPassed = false; boolean commaFound = false; int countOfDigitsBeforeDecimalPoint = 0; int countOfDigitsAfterDecimalPoint =0 ; int commaCounter=0; int countOfDigitsBeforeFirstComma = 0; char [] charNumber = stringNumber.toCharArray(); for(int i =0 ; i<charNumber.length ;i++) { if((commaCounter>3)||(commaCounter<0)) { return false; } if(!Character.isDigit(charNumber[i])) { if(charNumber[i]== { if(decimalPointPassed) { return false; } commaFound = true; commaCounter +=3; } else if(charNumber[i]== { decimalPointPassed = true; countOfDecimalPoint++; } else { return false; } } else { if ((commaCounter>=0)&&(commaFound)) { if(!decimalPointPassed) { commaCounter--; } } if(!commaFound) { countOfDigitsBeforeFirstComma++; } if(!decimalPointPassed) { countOfDigitsBeforeDecimalPoint++; } else { countOfDigitsAfterDecimalPoint++; } } } if((commaFound)&&(countOfDigitsBeforeFirstComma>3)) { return false; } if(countOfDecimalPoint>1) { return false; } if((decimalPointPassed)&&((countOfDigitsBeforeDecimalPoint==0)||(countOfDigitsAfterDecimalPoint==0))) { return false; } return true; }
var re = new RegExp("^-?\d+([,\.]\d+)?([eE]-?\d+)?$"); re.test("-6546"); re.test("-6546355e-4456"); re.test("-6546.355e-4456"); re.test("-6546.35.5e-4456"); re.test("-6546.35.5e-4456.6");
public static boolean isNumber(String str){ int i=0, len=str.length(); boolean a=false,b=false,c=false, d=false; if(i<len && (str.charAt(i)== while( i<len && isDigit(str.charAt(i)) ){ i++; a=true; } if(i<len && (str.charAt(i)== while( i<len && isDigit(str.charAt(i)) ){ i++; b=true; } if(i<len && (str.charAt(i)== if(i<len && (str.charAt(i)== while( i<len && isDigit(str.charAt(i)) ){ i++; d=true;} return i==len && (a||b) && (!c || (c && d)); } static boolean isDigit(char c){ return c== }
string.chars().unordered().parallel().allMatch( i ->
public enum Elvis { INSTANCE; private final String[] favoriteSongs = { "Hound Dog", "Heartbreak Hotel" }; public void printFavorites() { System.out.println(Arrays.toString(favoriteSongs)); } }
public final class Foo { private static final Foo INSTANCE = new Foo(); private Foo() { if (INSTANCE != null) { throw new IllegalStateException("Already instantiated"); } } public static Foo getInstance() { return INSTANCE; } public Object clone() throws CloneNotSupportedException{ throw new CloneNotSupportedException("Cannot clone instance of this class"); } }
public final class Foo { private static class FooLoader { private static final Foo INSTANCE = new Foo(); } private Foo() { if (FooLoader.INSTANCE != null) { throw new IllegalStateException("Already instantiated"); } } public static Foo getInstance() { return FooLoader.INSTANCE; } }
public final class Foo implements Serializable { private static final long serialVersionUID = 1L; private static class FooLoader { private static final Foo INSTANCE = new Foo(); } private Foo() { if (FooLoader.INSTANCE != null) { throw new IllegalStateException("Already instantiated"); } } public static Foo getInstance() { return FooLoader.INSTANCE; } @SuppressWarnings("unused") private Foo readResolve() { return FooLoader.INSTANCE; } }
public class Foo { private static final Foo INSTANCE = new Foo(); private Foo() { if (INSTANCE != null) { throw new IllegalStateException("Already instantiated"); } } public static Foo getInstance() { return INSTANCE; } }
class Foo { private static Foo INSTANCE = null; private Foo() { if (INSTANCE != null) { throw new IllegalStateException("Already instantiated"); } } public static Foo getInstance() { if (INSTANCE == null) { INSTANCE = new Foo(); } return INSTANCE; } }
class Foo { private static Foo INSTANCE = null; public static Foo getInstance() { synchronized (Foo.class) { if (INSTANCE == null) { INSTANCE = new Foo(); } } return INSTANCE; } }
class Foo { private static volatile Foo INSTANCE = null; public static Foo getInstance() { if (INSTANCE == null) { synchronized (Foo.class) { if (INSTANCE == null) { INSTANCE = new Foo(); } } } return INSTANCE; } }
class Foo implements Serializable { private static final long serialVersionUID = 1L; private static volatile Foo INSTANCE = null; @SuppressWarnings("unused") private Object readResolve() { return INSTANCE; } }
public final class Foo implements Serializable { private static final long serialVersionUID = 1L; private static class FooLoader { private static final Foo INSTANCE = new Foo(); } public static Foo getInstance() { return FooLoader.INSTANCE; } @SuppressWarnings("unused") private Foo readResolve() { return FooLoader.INSTANCE; } }
public class Foo { private static final Foo INSTANCE = new Foo(); }
class Bar { private static class BarHolder { public static Bar bar = new Bar(); } public static Bar getBar() { return BarHolder.bar; } }
class Foo { private static volatile Bar bar = null; public static Bar getBar() { if (bar == null) { synchronized(Foo.class) { if (bar == null) bar = new Bar(); } } return bar; } }
public class A { private static final A INSTANCE = new A(); private A() {} public static A getInstance() { return INSTANCE; } }
/** * Singleton pattern example using Java Enumj */ public enum EasySingleton{ INSTANCE; }
/** * Singleton pattern example with Double checked Locking */ public class DoubleCheckedLockingSingleton{ private static volatile DoubleCheckedLockingSingleton INSTANCE; private DoubleCheckedLockingSingleton(){} public static DoubleCheckedLockingSingleton getInstance(){ if(INSTANCE == null){ synchronized(DoubleCheckedLockingSingleton.class){ if(INSTANCE == null){ INSTANCE = new DoubleCheckedLockingSingleton(); } } } return INSTANCE; } }
/** * Singleton pattern example with static factory method */ public class Singleton{ private static final Singleton INSTANCE = new Singleton(); private Singleton(){} public static Singleton getSingleton(){ return INSTANCE; } }
public class MySingleton { private static MySingleton instance = null; private MySingleton() {} public static synchronized MySingleton getInstance() { if(instance == null) { instance = new MySingleton(); } return instance; } }
public class MySingleton { private MySingleton() {} private static class MySingletonHolder { public final static MySingleton instance = new MySingleton(); } public static MySingleton getInstance() { return MySingletonHolder.instance; } }
public class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton() {} public static Singleton getInstance() { return Singleton.INSTANCE; } protected Object clone() { throw new CloneNotSupportedException(); } }
public class Singleton { private static Singleton instance = null; private Singleton() {} public static Singleton getInstance() { if(null == instance) { synchronized(Singleton.class) { if(null == instance) { instance = new Singleton(); } } } return instance; } protected Object clone() { throw new CloneNotSupportedException(); } }
/** * Singleton pattern example using Java Enum */ public enum Singleton { INSTANCE; public void execute (String arg) { } }
There are 4 ways to create a singleton in java. 1- eager initialization singleton public class Test{ private static final Test test = new Test(); private Test(){} public static Test getTest(){ return test; }  2- lazy initialization singleton (thread safe) public class Test { private static volatile Test test; private Test(){} public static Test getTest() { if(test == null) { synchronized(Test.class) { if(test == null){test = new Test(); } } } return test;  3- Bill Pugh Singleton with Holder Pattern (Preferably the best one) public class Test { private Test(){} private static class TestHolder{ private static final Test test = new Test(); } public static Test getInstance(){ return TestHolder.test; } } 4- enum singleton public enum MySingleton { INSTANCE; private MySingleton() { System.out.println("Here"); } }
public class MySingleton { private static MySingleton INSTANCE; public static MySingleton getInstance() { if (INSTANCE == null) { INSTANCE = new MySingleton(); } return INSTANCE; } ... }
private static MySingleton INSTANCE; public static synchronized MySingleton getInstance() { if (INSTANCE == null) { INSTANCE = new MySingleton(); } return INSTANCE; }
private static MySingleton INSTANCE; public static MySingleton getInstance() { if (INSTANCE == null) { synchronize(MySingleton.class) { INSTANCE = new MySingleton(); } } return INSTANCE; }
private static MySingleton INSTANCE; public static MySingleton getInstance() { if (INSTANCE == null) { synchronized(MySingleton.class) { if (INSTANCE == null) { INSTANCE = createInstance(); } } } return INSTANCE; }
private static volatile MySingleton INSTANCE; public static MySingleton getInstance() { if (INSTANCE == null) { synchronized(MySingleton.class) { if (INSTANCE == null) { INSTANCE = createInstance(); } } } return INSTANCE; }
private static volatile MySingleton INSTANCE; public static MySingleton getInstance() { MySingleton result = INSTANCE; if (result == null) { synchronized(MySingleton.class) { result = INSTANCE; if (result == null) { INSTANCE = result = createInstance(); } } } return result; }
public class Singleton { private static final Singleton INSTANCE = new Singleton(); /** The constructor must be private to prevent external instantiation */ private Singleton(){} /** The public static method allowing to get the instance */ public static Singleton getInstance() { return INSTANCE; } }
public class Singleton { private Singleton(){} /** The public static method allowing to get the instance */ public static Singleton getInstance() { return SingletonHolder.INSTANCE; } /** * The static inner class responsible for creating your instance only on demand, * because the static fields of a class are only initialized when the class * is explicitly called and a class initialization is synchronized such that only * one thread can perform it, this rule is also applicable to inner static class * So here INSTANCE will be created only when SingletonHolder.INSTANCE * will be called */ private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } }
public static final INSTANCE == .... private Object readResolve() { return INSTANCE; }
public enum SingletonEnum { INSTANCE; public void doSomething(){ System.out.println("This is a singleton"); } }
public class Singleton { private static volatile Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class){ if (instance == null) { instance = new Singleton(); } } } return instance ; } }
public class Singleton { private static final Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } public void doSomething(){ System.out.println("This is a singleton"); } }
public class SingletonImpl { private static SingletonImpl instance; public static SingletonImpl getInstance() { if (instance == null) { instance = new SingletonImpl(); } return instance; } public static void setInstance(SingletonImpl impl) { instance = impl; } public void a() { System.out.println("Default Method"); } }
public class SingletonMock extends SingletonImpl { @Override public void a() { System.out.println("Mock Method"); } }
public class SingletonImpl { private static final SingletonImpl instance = new SingletonImpl(); private static SingletonImpl alt; public static void setInstance(SingletonImpl inst) { alt = inst; } public static SingletonImpl getInstance() { if (alt != null) { return alt; } return instance; } public void a() { System.out.println("Default Method"); } } public class SingletonMock extends SingletonImpl { @Override public void a() { System.out.println("Mock Method"); } }
public class Singleton { private static Singleton singleInstance = new Singleton(); private Singleton() {} public static Singleton getSingleInstance() { return singleInstance; } }
public class Singleton<T> implements Supplier<T> { private boolean initialized; private Supplier<T> singletonSupplier; public Singleton(T singletonValue) { this.singletonSupplier = () -> singletonValue; } public Singleton(Supplier<T> supplier) { this.singletonSupplier = () -> { synchronized (supplier) { if (!initialized) { T singletonValue = supplier.get(); singletonSupplier = () -> singletonValue; initialized = true; } return singletonSupplier.get(); } }; } @Override public T get() { return singletonSupplier.get(); } }
public class Singleton { private static Singleton instance = null; static { instance = new Singleton(); } private Singleton() { if(instance!=null) { throw new ErrorYouWant("Singleton double-instantiation, should never happen!"); } } public static getSingleton() { return instance; } }
public class Singleton { private static final Singleton INSTANCE = new Singleton(); private Singleton(){ if (INSTANCE != null) throw new IllegalStateException (Already instantiated...); } public synchronized static Singleton getInstance() { return INSTANCE; } }
1. String stringValueOf = String.valueOf( 2. String stringValueOfCharArray = String.valueOf(new char[]{x}); 3. String characterToString = Character.toString( 4. String characterObjectToString = new Character( 5. String concatBlankString = 6. String fromCharArray = new String(new char[]{x});
public String(char value[]) { this.value = Arrays.copyOf(value, value.length); }
String(char[] value, boolean share) { this.value = value; }
char c = String s = String.valueOf(c); String s = Character.toString(c); String s = new String(new char[]{c}); String s = String.valueOf(new char[]{c}); String s = new Character(c).toString(); String s = "" + c;
String str = String.valueOf( String str = Character.toString( String str =
@BenchmarkMode(Mode.Throughput) @Fork(1) @State(Scope.Thread) @Warmup(iterations = 10, time = 1, batchSize = 1000, timeUnit = TimeUnit.SECONDS) @Measurement(iterations = 10, time = 1, batchSize = 1000, timeUnit = TimeUnit.SECONDS) public class CharToStringConversion { private char c = @Benchmark public String stringValueOf() { return String.valueOf(c); } @Benchmark public String stringValueOfCharArray() { return String.valueOf(new char[]{c}); } @Benchmark public String characterToString() { return Character.toString(c); } @Benchmark public String characterObjectToString() { return new Character(c).toString(); } @Benchmark public String concatBlankStringPre() { return c + ""; } @Benchmark public String concatBlankStringPost() { return "" + c; } @Benchmark public String fromCharArray() { return new String(new char[]{c}); } }
Benchmark Mode Cnt Score Error Units CharToStringConversion.characterObjectToString thrpt 10 82132.021  6841.497 ops/s CharToStringConversion.characterToString thrpt 10 118232.069  8242.847 ops/s CharToStringConversion.concatBlankStringPost thrpt 10 136960.733  9779.938 ops/s CharToStringConversion.concatBlankStringPre thrpt 10 137244.446  9113.373 ops/s CharToStringConversion.fromCharArray thrpt 10 85464.842  3127.211 ops/s CharToStringConversion.stringValueOf thrpt 10 119281.976  7053.832 ops/s CharToStringConversion.stringValueOfCharArray thrpt 10 86563.837  6436.527 ops/s
public static String toString(char c) { return String.valueOf(c); }
public static String valueOf(char c) { char data[] = {c}; return new String(data, true); }
char c = String s = Character.toString(c); s = new Character(c).toString(); s = c + ""; s = String.valueOf(c); s = String.format("%c", c); Formatter formatter = new Formatter(); s = formatter.format("%c", c).toString(); formatter.close();
Char[] CharArray={ String text = String.copyValueOf(CharArray);
editView.setFilters(new InputFilter[]{new InputFilter() { @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { String prefix = "http: String destination = dest.toString(); if (destination.startsWith(prefix) && (dstart <= prefix.length() - 1)) { int newEnd = (dend >= prefix.length()) ? dend : prefix.length(); SpannableStringBuilder builder = new SpannableStringBuilder( destination.substring(dstart, newEnd)); builder.append(source); if (source instanceof Spanned) { TextUtils.copySpansFrom( (Spanned) source, 0, source.length(), null, builder, newEnd); } return builder; } else { return null; } } }});
try (BufferedReader br = new BufferedReader(new FileReader(file))) { String line; while ((line = br.readLine()) != null) { } }
try(BufferedReader br = new BufferedReader(new FileReader(file))) { for(String line; (line = br.readLine()) != null; ) { } }
try (Stream<String> stream = Files.lines(Paths.get(fileName))) { stream.forEach(System.out::println); }
FileInputStream fstream = new FileInputStream("textfile.txt"); BufferedReader br = new BufferedReader(new InputStreamReader(fstream)); String strLine; while ((strLine = br.readLine()) != null) { System.out.println (strLine); } fstream.close();
try (Stream<String> lines = Files.lines(Paths.get(filename), Charset.defaultCharset())) { lines.forEachOrdered(line -> process(line)); }
try (Stream<String> lines = Files.lines(file, Charset.defaultCharset())) { lines.forEachOrdered(System.out::println); }
InputStream ins = null; Reader r = null; BufferedReader br = null; try { String s; ins = new FileInputStream("textfile.txt"); r = new InputStreamReader(ins, "UTF-8"); br = new BufferedReader(r); while ((s = br.readLine()) != null) { System.out.println(s); } } catch (Exception e) { System.err.println(e.getMessage()); } finally { if (br != null) { try { br.close(); } catch(Throwable t) { } } if (r != null) { try { r.close(); } catch(Throwable t) { } } if (ins != null) { try { ins.close(); } catch(Throwable t) { } } }
File f = new File("textfile.txt"); f.withReader("UTF-8") { br -> br.eachLine { line -> println line; } }
try (Stream<String> lines = Files.lines (file, StandardCharsets.UTF_8)) { for (String line : (Iterable<String>) lines::iterator) { ; } }
import java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public static void readText throws FileNotFoundException { Scanner scan = new Scanner(new File("samplefilename.txt")); while(scan.hasNextLine()){ String line = scan.nextLine(); } }
try { BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), "Cp1252")); String line; while ((line = br.readLine()) != null) { } br.close(); } catch (IOException e) { e.printStackTrace(); }
String folderPath = "C:/folderOfMyFile"; Path path = Paths.get(folderPath, "myFileName.csv"); Charset charset = Charset.forName("UTF-8"); try (BufferedReader reader = Files.newBufferedReader(path , charset)) { while ((line = reader.readLine()) != null ) { String[] lineVariables = line.split(","); } } catch (IOException e) { System.err.println(e); }
import java.io..File; import java.io.IOException; import java.nio.file.Files; public class ReadFile_Files_ReadAllBytes { public static void main(String [] pArgs) throws IOException { String fileName = "c:\\temp\\sample-1GB.txt"; File file = new File(fileName); byte [] fileBytes = Files.readAllBytes(file.toPath()); char singleChar; for(byte b : fileBytes) { singleChar = (char) b; System.out.print(singleChar); } } }
import java.io.File; import java.io.IOException; import java.nio.file.Files; import java.util.stream.Stream; public class ReadFile_Files_Lines { public static void main(String[] pArgs) throws IOException { String fileName = "c:\\temp\\sample-1GB.txt"; File file = new File(fileName); try (Stream linesStream = Files.lines(file.toPath())) { linesStream.forEach(line -> { System.out.println(line); }); } } }
import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class ReadFile_BufferedReader_ReadLine { public static void main(String [] args) throws IOException { String fileName = "c:\\temp\\sample-1GB.txt"; FileReader fileReader = new FileReader(fileName); try (BufferedReader bufferedReader = new BufferedReader(fileReader)) { String line; while((line = bufferedReader.readLine()) != null) { System.out.println(line); } } }
package com.java.java8; import java.nio.file.Files; import java.nio.file.Paths; import java.util.stream.Stream; /** * The Class ReadLargeFile. * * @author Ankit Sood Apr 20, 2017 */ public class ReadLargeFile { /** * The main method. * * @param args * the arguments */ public static void main(String[] args) { try { Stream<String> stream = Files.lines(Paths.get("C:\\Users\\System\\Desktop\\demoData.txt")); stream.forEach(System.out::println); } catch (Exception e) { e.printStackTrace(); } } }
try( BufferedReader reader = new BufferedReader( ... ) ) { reader.lines().foreach( line -> processLine( line ) ); }
try (Stream<String> stream = Files.lines(Paths.get(fileName))) { stream.forEach(System.out::println); }
import java.io.*; import java.util.Scanner; import java.io.FileNotFoundException; public class readByLine { public readByLine() throws FileNotFoundException { Scanner linReader = new Scanner(new File("dataFile.txt")); while (linReader.hasNext()) { String line = linReader.nextLine(); System.out.println(line); } linReader.close(); } public static void main(String args[]) throws FileNotFoundException { new readByLine(); } }
BufferedReader br; FileInputStream fin; try { fin = new FileInputStream(fileName); br = new BufferedReader(new InputStreamReader(fin)); /*Path pathToFile = Paths.get(fileName); br = Files.newBufferedReader(pathToFile,StandardCharsets.US_ASCII);*/ String line = br.readLine(); while (line != null) { String[] attributes = line.split(","); Movie movie = createMovie(attributes); movies.add(movie); line = br.readLine(); } fin.close(); br.close(); } catch (FileNotFoundException e) { System.out.println("Your Message"); } catch (IOException e) { System.out.println("Your Message"); }
void readResource(InputStream source) throws IOException { BufferedReader stream = null; try { stream = new BufferedReader(new InputStreamReader(source)); while (true) { String line = stream.readLine(); if(line == null) { break; } System.out.println(line) } } finally { closeQuiet(stream); } } static void closeQuiet(Closeable closeable) { if (closeable != null) { try { closeable.close(); } catch (IOException ignore) { } } }
File file = new File("/home/user/file.txt"); try { List<String> lines = FileUtils.readLines(file); } catch (IOException e) { e.printStackTrace(); }
Files.lines(Paths.get("input.txt")).forEach(s -> stringBuffer.append(s);
import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; public class ReadTextFile { public static void main(String[] args) throws IOException { try { File f = new File("src/com/data.txt"); BufferedReader b = new BufferedReader(new FileReader(f)); String readLine = ""; System.out.println("Reading file using Buffered Reader"); while ((readLine = b.readLine()) != null) { System.out.println(readLine); } } catch (IOException e) { e.printStackTrace(); } } }
InputStream is; byte[] bytes = IOUtils.toByteArray(is);
InputStream is = ... ByteArrayOutputStream buffer = new ByteArrayOutputStream(); int nRead; byte[] data = new byte[16384]; while ((nRead = is.read(data, 0, data.length)) != -1) { buffer.write(data, 0, nRead); } return buffer.toByteArray();
InputStream is;  byte[] array = is.readAllBytes();
byte[] bytes = ByteStreams.toByteArray(inputStream);
... byte[] bytes = new byte[(int) file.length()]; DataInputStream dis = new DataInputStream(new FileInputStream(file)); dis.readFully(bytes); ...
public static byte[] getBytesFromInputStream(InputStream is) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream(); byte[] buffer = new byte[0xFFFF]; for (int len = is.read(buffer); len != -1; len = is.read(buffer)) { os.write(buffer, 0, len); } return os.toByteArray(); }
BufferedImage image = ImageIO.read(new File("image.jpg"));
public static byte[] readFully(InputStream is, int length, boolean readAll) throws IOException { byte[] output = {}; if (length == -1) length = Integer.MAX_VALUE; int pos = 0; while (pos < length) { int bytesToRead; if (pos >= output.length) { bytesToRead = Math.min(length - pos, output.length + 1024); if (output.length < pos + bytesToRead) { output = Arrays.copyOf(output, pos + bytesToRead); } } else { bytesToRead = output.length - pos; } int cc = is.read(output, pos, bytesToRead); if (cc < 0) { if (readAll && length != Integer.MAX_VALUE) { throw new EOFException("Detect premature EOF"); } else { if (output.length != pos) { output = Arrays.copyOf(output, pos); } break; } } pos += cc; } return output; }
byte[] data = new byte[(int) file.length()]; DataInputStream dis = new DataInputStream(new FileInputStream(file)); dis.readFully(data); dis.close();
InputStream is = new FileInputStream(file); ByteArrayOutputStream buffer = new ByteArrayOutputStream(); int nRead; byte[] data = new byte[(int) file.length()]; while ((nRead = is.read(data, 0, data.length)) != -1) { buffer.write(data, 0, nRead); }
RandomAccessFile raf = new RandomAccessFile(file, "r"); byte[] data = new byte[(int) raf.length()]; raf.readFully(data);
ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; while (true) { int r = in.read(buffer); if (r == -1) break; out.write(buffer, 0, r); } byte[] ret = out.toByteArray();
public static byte[] getBytesFromFile(File file) throws IOException { InputStream is = new FileInputStream(file); long length = file.length(); if (length > Integer.MAX_VALUE) { } byte[] bytes = new byte[(int)length]; int offset = 0; int numRead = 0; while (offset < bytes.length && (numRead=is.read(bytes, offset, bytes.length-offset)) >= 0) { offset += numRead; } if (offset < bytes.length) { throw new IOException("Could not completely read file "+file.getName()); } is.close(); return bytes; }
Input Stream is ... ByteArrayOutputStream bos = new ByteArrayOutputStream(); int next = in.read(); while (next > -1) { bos.write(next); next = in.read(); } bos.flush(); byte[] result = bos.toByteArray(); bos.close();
final byte[] bytes; try (inputStream) { bytes = inputStream.readAllBytes(); }
public static byte[] readAllBytes(InputStream inputStream) throws IOException { final int bufLen = 4 * 0x400; byte[] buf = new byte[bufLen]; int readLen; IOException exception = null; try { try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) { while ((readLen = inputStream.read(buf, 0, bufLen)) != -1) outputStream.write(buf, 0, readLen); return outputStream.toByteArray(); } } catch (IOException e) { exception = e; throw e; } finally { if (exception == null) inputStream.close(); else try { inputStream.close(); } catch (IOException e) { exception.addSuppressed(e); } } }
@Throws(IOException::class) fun InputStream.readAllBytes(): ByteArray { val bufLen = 4 * 0x400 val buf = ByteArray(bufLen) var readLen: Int = 0 ByteArrayOutputStream().use { o -> this.use { i -> while (i.read(buf, 0, bufLen).also { readLen = it } != -1) o.write(buf, 0, readLen) } return o.toByteArray() } }
InputStream in = ...; ByteArrayOutputStream bos = new ByteArrayOutputStream(); in.transferTo( bos ); byte[] bytes = bos.toByteArray();
/** * method converts {@link InputStream} Object into byte[] array. * * @param stream the {@link InputStream} Object. * @return the byte[] array representation of received {@link InputStream} Object. * @throws IOException if an error occurs. */ public static byte[] streamToByteArray(InputStream stream) throws IOException { byte[] buffer = new byte[1024]; ByteArrayOutputStream os = new ByteArrayOutputStream(); int line = 0; while ((line = stream.read(buffer)) != -1) { os.write(buffer, 0, line); } stream.close(); os.flush(); os.close(); return os.toByteArray(); }
ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int length; while ((length = in.read(buffer)) != -1) out.write(buffer, 0, length); in.close(); byte[] result = out.toByteArray();
import sun.misc.IOUtils; ... InputStream in = ...; byte[] buf = IOUtils.readFully(in, -1, false);
private static byte[] readFully(InputStream input) throws IOException { try (BufferedReader buffer = new BufferedReader(new InputStreamReader(input))) { return buffer.lines().collect(Collectors.joining("\n")).getBytes(<charset_can_be_specified>); } }
/** * Begin setup TCP connection to PC app * to open integrate connection between mobile app and pc app (or mobile app) */ mSocket = new Socket(IP, port); DataOutputStream mDos = new DataOutputStream(mSocket.getOutputStream()); String str = "MobileRequest mDos.write(str.getBytes()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } DataInputStream mDis = new DataInputStream(mSocket.getInputStream()); byte[] data = new byte[mDis.available()]; for (int i = 0; i < data.length; i++) data[i] = mDis.readByte(); String RESPONSE = new String(data);
byte[] buf = new byte[inputStreamLength]; int bytesRead = Math.max(0, inputStream.read(buf)); byte[] contents = bytesRead == inputStreamLength ? buf : Arrays.copyOf(buf, bytesRead);
public static byte[] toByteArray(InputStream is) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream(); try { byte[] b = new byte[4096]; int n = 0; while ((n = is.read(b)) != -1) { output.write(b, 0, n); } return output.toByteArray(); } finally { output.close(); } }
@SuppressWarnings("empty-statement") public static byte[] inputStreamToByte(InputStream is) throws IOException { if (is == null) { return null; } ByteArrayOutputStream r = new ByteArrayOutputStream(2048); byte[] read = new byte[512]; for (int i; -1 != (i = is.read(read)); r.write(read, 0, i)); is.close(); return r.toByteArray(); }
public int readFully(InputStream in, byte[] data) throws IOException { int offset = 0; int bytesRead; boolean read = false; while ((bytesRead = in.read(data, offset, data.length - offset)) != -1) { read = true; offset += bytesRead; if (offset >= data.length) { break; } } return (read) ? offset : -1; }
import org.apache.commons.io.IOUtils; is = s3object.getObjectContent(); content =IOUtils.toByteArray(is);
import com.amazonaws.util.IOUtils; is = s3object.getObjectContent(); content =IOUtils.toByteArray(is);
private static byte[] loadStream (InputStream stream) throws IOException { int available = stream.available(); int expectedSize = available > 0 ? available : -1; return loadStream(stream, expectedSize); } private static byte[] loadStream (InputStream stream, int expectedSize) throws IOException { int basicBufferSize = 0x4000; int initialBufferSize = (expectedSize >= 0) ? expectedSize : basicBufferSize; byte[] buf = new byte[initialBufferSize]; int pos = 0; while (true) { if (pos == buf.length) { int readAhead = -1; if (pos == expectedSize) { readAhead = stream.read(); if (readAhead == -1) { return buf; } } int newBufferSize = Math.max(2 * buf.length, basicBufferSize); buf = Arrays.copyOf(buf, newBufferSize); if (readAhead != -1) { buf[pos++] = (byte)readAhead; } } int len = stream.read(buf, pos, buf.length - pos); if (len < 0) { return Arrays.copyOf(buf, pos); } pos += len; } }
public static byte[] serializeObj(Object obj) throws IOException { ByteArrayOutputStream baOStream = new ByteArrayOutputStream(); ObjectOutputStream objOStream = new ObjectOutputStream(baOStream); objOStream.writeObject(obj); objOStream.flush(); objOStream.close(); return baOStream.toByteArray(); }
BufferedImage img = ... ByteArrayOutputStream baos = new ByteArrayOutputStream(1000); ImageIO.write(img, "jpeg", baos); baos.flush(); byte[] result = baos.toByteArray(); baos.close();
/*InputStream class_InputStream = null; I am reading class from DB class_InputStream = rs.getBinaryStream(1); Your Input stream could be from any source */ int thisLine; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((thisLine = class_InputStream.read()) != -1) { bos.write(thisLine); } bos.flush(); byte [] yourBytes = bos.toByteArray(); if (bos != null){ bos.close(); }
WeakReference weakWidget = new WeakReference(widget);
import java.util.HashMap; public class Test { public static void main(String args[]) { HashMap<Employee, EmployeeVal> aMap = new HashMap<Employee, EmployeeVal>(); Employee emp = new Employee("Vinoth"); EmployeeVal val = new EmployeeVal("Programmer"); aMap.put(emp, val); emp = null; System.gc(); System.out.println("Size of Map" + aMap.size()); } }
import java.util.WeakHashMap; public class Test { public static void main(String args[]) { WeakHashMap<Employee, EmployeeVal> aMap = new WeakHashMap<Employee, EmployeeVal>(); Employee emp = new Employee("Vinoth"); EmployeeVal val = new EmployeeVal("Programmer"); aMap.put(emp, val); emp = null; System.gc(); int count = 0; while (0 != aMap.size()) { ++count; System.gc(); } System.out.println("Took " + count + " calls to System.gc() to result in weakHashMap size of : " + aMap.size()); } }
import java.lang.ref.WeakReference; import java.util.HashMap; public class Test { public static void main(String args[]) { HashMap<Employee, EmployeeVal> map = new HashMap<Employee, EmployeeVal>(); WeakReference<HashMap<Employee, EmployeeVal>> aMap = new WeakReference<HashMap<Employee, EmployeeVal>>( map); map = null; while (null != aMap.get()) { aMap.get().put(new Employee("Vinoth"), new EmployeeVal("Programmer")); System.out.println("Size of aMap " + aMap.get().size()); System.gc(); } System.out.println("Its garbage collected"); } }
File f = new File(filePathString); if(f.exists() && !f.isDirectory()) { }
import java.nio.file.*; Path path = Paths.get(filePathString); if (Files.exists(path)) { } if (Files.notExists(path)) { }
if (Files.isDirectory(path)) { } if (Files.isRegularFile(path)) { }
import java.io.*; public class FileTest { public static void main(String args[]) { File f = new File(args[0]); System.out.println(f + (f.exists()? " is found " : " is missing ")); } }
File f = new File("/path/to/file"); if(f.exists() && f.isFile()) {}
File f = new File("/path/to/file"); if(f.exists() && f.isDirectory()) {}
Path path = Paths.get("/path/to/file"); Files.exists(path) Files.isDirectory(path) Files.isRegularFile(path) Files.isSymbolicLink(path)
File f = new File(filePathString); if(f.exists() && f.isFile()) { }
File tmpDir = new File("/var/tmp"); boolean exists = tmpDir.exists();
String directoryPath = dir.getAbsolutePath() boolean check = new File(new File(directoryPath), aFile.getName()).exists();
File f = new File(new URI("file: if(f.exists() && !f.isDirectory()) { }
File f = new File("c:\\test.txt"); if(f.exists()){ System.out.println("File existed"); }else{ System.out.println("File not found!"); }
import java.io.File; class Test{ public static void main(String[] args){ File f = new File(args[0]); System.out.println(f.exists()); if(f.exists()) { } } }
import java.nio.file.Paths; String file = "myfile.sss"; if(Paths.get(file).toFile().isFile()){ }
File f = new File(C:\\File Path); if(f.exists()){ System.out.println(Exists); }else{ System.out.println(Doesn }
new String("test").equals("test") new String("test") == "test" new String("test") == new String("test") "test" == "test" "test" == "te" + "st" Objects.equals("test", new String("test")) Objects.equals(null, "test") Objects.equals(null, null)
String fooString1 = new String("foo"); String fooString2 = new String("foo"); fooString1 == fooString2; fooString1.equals(fooString2); "bar" == "bar";
String nullString1 = null; String nullString2 = null; System.out.print(nullString1 == nullString2); System.out.print(nullString1.equals(nullString2));
System.out.print(fooString1 != null && fooString1.equals("bar"));
System.out.print(Objects.equals(fooString1, "bar"));
String a="Test"; String b="Test"; if(a==b) ===> true
String Pool b -----------------> "test" <-----------------a
String a="test"; String b=new String("test"); if (a==b) ===> false
String Pool "test" <-------------------- a Heap "test" <-------------------- b
String a="Test"; String b="Test"; if(a.equals(b)) ===> true String a="test"; String b=new String("test"); if(a.equals(b)) ===> true
String a = new String("foo"); String b = new String("foo"); System.out.println(a == b); System.out.println(a.equals(b));
String one = "HELLO"; String two = "HELLO"; String three = new String("HELLO"); String four = "hello"; one == two; one == three; one == four; one.equals(two); one.equals(three); one.equals(four); one.equalsIgnoreCase(four);
String string1 = "foo"; String string2 = "FOO"; if (string1.equals(string2)) { System.out.println("The two strings are the same.") }
String string1 = "foo"; String string2 = "foo"; if (string1.equals(string2)) { System.out.println("The two strings are the same.") }
String string1 = "foo"; String string2 = "FOO"; if (string1.equalsIgnoreCase(string2)) { System.out.println("Ignoring case, the two strings are the same.") }
String string1 = "foo bar"; String string2 = "foo bar"; if (string1.compareTo(string2) == 0) { System.out.println("The two strings are the same.") }
public float simpleSimilarity(String u, String v) { String[] a = u.split(" "); String[] b = v.split(" "); long correct = 0; int minLen = Math.min(a.length, b.length); for (int i = 0; i < minLen; i++) { String aa = a[i]; String bb = b[i]; int minWordLength = Math.min(aa.length(), bb.length()); for (int j = 0; j < minWordLength; j++) { if (aa.charAt(j) == bb.charAt(j)) { correct++; } } } return (float) (((double) correct) / Math.max(u.length(), v.length())); }
String a = "This is the first string."; String b = "this is not 1st string!"; boolean exact = a.equals(b); float similarity = simple_similarity(a,b);
String s1 = "Stack Overflow"; String s2 = "Stack Overflow"; s1 == s2; s1.equals(s2);
String s1 = new String("Stack Overflow"); String s2 = new String("Stack Overflow"); s1 == s2; s1.equals(s2);
str1 = new String("abc"); str2 = new String("abc");
System.out.println((str1.equals(str2))?"TRUE":"FALSE");
System.out.println((str1==str2) ? "TRUE" : "FALSE");
String s1 = new String("abc"); String s2 = new String("abc"); System.out.println(s1 == s2); System.out.println(s1.equals(s2));
Set<String> flavors = new HashSet<String>() {{ add("vanilla"); add("strawberry"); add("chocolate"); add("butter pecan"); }};
Set<String> flavors = Set.of("vanilla", "strawberry", "chocolate", "butter pecan");
2009/05/27 16:35 1,602 DemoApp2$1.class 2009/05/27 16:35 1,976 DemoApp2$10.class 2009/05/27 16:35 1,919 DemoApp2$11.class 2009/05/27 16:35 2,404 DemoApp2$12.class 2009/05/27 16:35 1,197 DemoApp2$13.class 2009/05/27 16:35 1,953 DemoApp2$30.class 2009/05/27 16:35 1,910 DemoApp2$31.class 2009/05/27 16:35 2,007 DemoApp2$32.class 2009/05/27 16:35 926 DemoApp2$33$1$1.class 2009/05/27 16:35 4,104 DemoApp2$33$1.class 2009/05/27 16:35 2,849 DemoApp2$33.class 2009/05/27 16:35 926 DemoApp2$34$1$1.class 2009/05/27 16:35 4,234 DemoApp2$34$1.class 2009/05/27 16:35 2,849 DemoApp2$34.class 2009/05/27 16:35 614 DemoApp2$40.class 2009/05/27 16:35 2,344 DemoApp2$5.class 2009/05/27 16:35 1,551 DemoApp2$6.class 2009/05/27 16:35 1,604 DemoApp2$7.class 2009/05/27 16:35 1,809 DemoApp2$8.class 2009/05/27 16:35 2,022 DemoApp2$9.class
List<String> list = new ArrayList<String>() {{ add("Hello"); add("World!"); }};
List<String> list = new ArrayList<String>() { { add("Hello"); add("World!"); } };
List<Integer> intList = [1, 2, 3, 4]; Set<String> strSet = {"Apple", "Banana", "Cactus"}; Map<String, Integer> truthMap = { "answer" : 42 };
List<String> l = new ArrayList<String>() {{ add("Hello"); add("World!"); }};
List<String> l = new ArrayList<String>(); l.add("Hello"); l.add("World!");
class Test1 { public static void main(String[] s) { long st = System.currentTimeMillis(); List<String> l0 = new ArrayList<String>() {{ add("Hello"); add("World!"); }}; List<String> l1 = new ArrayList<String>() {{ add("Hello"); add("World!"); }}; List<String> l999 = new ArrayList<String>() {{ add("Hello"); add("World!"); }}; System.out.println(System.currentTimeMillis() - st); } }
class Test2 { public static void main(String[] s) { long st = System.currentTimeMillis(); List<String> l0 = new ArrayList<String>(); l0.add("Hello"); l0.add("World!"); List<String> l1 = new ArrayList<String>(); l1.add("Hello"); l1.add("World!"); List<String> l999 = new ArrayList<String>(); l999.add("Hello"); l999.add("World!"); System.out.println(System.currentTimeMillis() - st); } }
Test1 Times (ms) Test2 Times (ms) ---------------- ---------------- 187 0 203 0 203 0 188 0 188 0 187 0 203 0 188 0 188 0 203 0
public class Test { public void add(Object o) { } public Set<String> makeSet() { return new HashSet<String>() { { add("hello"); Test.this.add("hello"); } }; } }
public Set<String> makeSet() { return new HashSet<String>() { { add("hello"); } @Override boolean add(String s){ } }; }
Map source = new HashMap(){{ put("firstName", "John"); put("lastName", "Smith"); put("organizations", new HashMap(){{ put("0", new HashMap(){{ put("id", "1234"); }}); put("abc", new HashMap(){{ put("id", "5678"); }}); }}); }};
Test$1$1$1.class Test$1$1$2.class Test$1$1.class Test$1.class Test.class
public class ReallyHeavyObject { private int[] tonsOfValues; private Resource[] tonsOfResources; public Map quickHarmlessMethod() { Map source = new HashMap(){{ put("firstName", "John"); put("lastName", "Smith"); put("organizations", new HashMap(){{ put("0", new HashMap(){{ put("id", "1234"); }}); put("abc", new HashMap(){{ put("id", "5678"); }}); }}); }}; return source; } }
String[] array = { "John", "Doe" }; Map map = new HashMap() {{ put("John", "Doe"); }};
public class Test { public void test() { Set<String> flavors = new HashSet<String>() {{ add("vanilla"); add("strawberry"); add("chocolate"); add("butter pecan"); }}; } }
public class Test { public void test() { java.util.Set flavors = new HashSet() { final Test this$0; { this$0 = Test.this; super(); add("vanilla"); add("strawberry"); add("chocolate"); add("butter pecan"); } }; } }
public class Sample1 { private static final String someVar; static { String temp = null; ..... someVar = temp; } }
public class Sample2 { private final String someVar; { String temp = null; ..... someVar = temp; } }
public void test() { Set<String> flavors = new HashSet<String>() { { add("vanilla"); add("strawberry"); add("chocolate"); add("butter pecan"); } }; }
public void test() { Set<String> flavors = new MyHashSet(); } class MyHashSet extends HashSet<String>() { public MyHashSet() { add("vanilla"); add("strawberry"); add("chocolate"); add("butter pecan"); } }
Set<String> getFlavors(){ return Collections.unmodifiableSet(flavors) }
package vanilla.java.perfeg.doublebracket; import java.util.*; /** * @author plawrey */ public class DoubleBracketMain { public static void main(String... args) { final List<String> list1 = new ArrayList<String>() { { add("Hello"); add("World"); add("!!!"); } }; List<String> list2 = new ArrayList<String>(list1); Set<String> set1 = new LinkedHashSet<String>() { { addAll(list1); } }; Set<String> set2 = new LinkedHashSet<String>(); set2.addAll(list1); Map<Integer, String> map1 = new LinkedHashMap<Integer, String>() { { put(1, "one"); put(2, "two"); put(3, "three"); } }; Map<Integer, String> map2 = new LinkedHashMap<Integer, String>(); map2.putAll(map1); for (int i = 0; i < 10; i++) { long dbTimes = timeComparison(list1, list1) + timeComparison(set1, set1) + timeComparison(map1.keySet(), map1.keySet()) + timeComparison(map1.values(), map1.values()); long times = timeComparison(list2, list2) + timeComparison(set2, set2) + timeComparison(map2.keySet(), map2.keySet()) + timeComparison(map2.values(), map2.values()); if (i > 0) System.out.printf("double braced collections took %,d ns and plain collections took %,d ns%n", dbTimes, times); } } public static long timeComparison(Collection a, Collection b) { long start = System.nanoTime(); int runs = 10000000; for (int i = 0; i < runs; i++) compareCollections(a, b); long rate = (System.nanoTime() - start) / runs; return rate; } public static void compareCollections(Collection a, Collection b) { if (!a.equals(b) && a.hashCode() != b.hashCode() && !a.toString().equals(b.toString())) throw new AssertionError(); } }
double braced collections took 36 ns and plain collections took 36 ns double braced collections took 34 ns and plain collections took 36 ns double braced collections took 36 ns and plain collections took 36 ns double braced collections took 36 ns and plain collections took 36 ns double braced collections took 36 ns and plain collections took 36 ns double braced collections took 36 ns and plain collections took 36 ns double braced collections took 36 ns and plain collections took 36 ns double braced collections took 36 ns and plain collections took 36 ns double braced collections took 36 ns and plain collections took 36 ns
public static Set<T> setOf(T ... elements) { return new HashSet<T>(Arrays.asList(elements)); }
List<String> aList = Arrays.asList("vanilla", "strawberry", "chocolate");
static public Set<T> setOf(T ... elements) { Set set=new HashSet<T>(elements.size()); for(T elm: elements) { set.add(elm); } return set; }
package literal; public class collection { public static <T> List<T> List(T...elems){ return Arrays.asList( elems ); } }
import static literal.collection.List; import static system.io.*; public class CollectionDemo { public void demoList(){ List<String> slist = List( "a", "b", "c" ); List<Integer> iList = List( 1, 2, 3 ); for( String elem : List( "a", "java", "list" ) ) System.out.println( elem ); } }
Set<String> flavors = ImmutableSet.of( "vanilla", "strawberry", "chocolate", "butter pecan");
long startTime = System.nanoTime(); methodToTime(); long endTime = System.nanoTime(); long duration = (endTime - startTime);
long startTime = System.currentTimeMillis(); doReallyLongThing(); long endTime = System.currentTimeMillis(); System.out.println("That took " + (endTime - startTime) + " milliseconds");
import com.google.common.base.Stopwatch; Stopwatch timer = Stopwatch.createStarted(); LOG.info("Method took: " + timer.stop());
Stopwatch timer = Stopwatch.createUnstarted(); for (...) { timer.start(); methodToTrackTimeFor(); timer.stop(); methodNotToTrackTimeFor(); } LOG.info("Method took: " + timer);
Instant start = Instant.now(); Thread.sleep(5000); Instant end = Instant.now(); System.out.println(Duration.between(start, end));
Date startDate = Calendar.getInstance().getTime(); long d_StartTime = new Date().getTime(); Thread.sleep(1000 * 4); Date endDate = Calendar.getInstance().getTime(); long d_endTime = new Date().getTime(); System.out.format("StartDate : %s, EndDate : %s \n", startDate, endDate); System.out.format("Milli = %s, ( D_Start : %s, D_End : %s ) \n", (d_endTime - d_StartTime),d_StartTime, d_endTime);
long startTime = System.currentTimeMillis(); Thread.sleep(1000 * 4); long endTime = System.currentTimeMillis(); long duration = (endTime - startTime); System.out.format("Milli = %s, ( S_Start : %s, S_End : %s ) \n", duration, startTime, endTime ); System.out.println("Human-Readable format : "+millisToShortDHMS( duration ) );
public static String millisToShortDHMS(long duration) { String res = ""; long days = TimeUnit.MILLISECONDS.toDays(duration); long hours = TimeUnit.MILLISECONDS.toHours(duration) - TimeUnit.DAYS.toHours(TimeUnit.MILLISECONDS.toDays(duration)); long minutes = TimeUnit.MILLISECONDS.toMinutes(duration) - TimeUnit.HOURS.toMinutes(TimeUnit.MILLISECONDS.toHours(duration)); long seconds = TimeUnit.MILLISECONDS.toSeconds(duration) - TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(duration)); long millis = TimeUnit.MILLISECONDS.toMillis(duration) - TimeUnit.SECONDS.toMillis(TimeUnit.MILLISECONDS.toSeconds(duration)); if (days == 0) res = String.format("%02d:%02d:%02d.%04d", hours, minutes, seconds, millis); else res = String.format("%dd %02d:%02d:%02d.%04d", days, hours, minutes, seconds, millis); return res; }
com.google.common.base.Stopwatch g_SW = Stopwatch.createUnstarted(); g_SW.start(); Thread.sleep(1000 * 4); g_SW.stop(); System.out.println("Google StopWatch : "+g_SW);
org.apache.commons.lang3.time.StopWatch sw = new StopWatch(); sw.start(); Thread.sleep(1000 * 4); sw.stop(); System.out.println("Apache StopWatch : "+ millisToShortDHMS(sw.getTime()) );
public static void jodaTime() throws InterruptedException, ParseException{ java.text.SimpleDateFormat ms_SDF = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss.SSS"); String start = ms_SDF.format( new Date() ); Thread.sleep(10000); String end = ms_SDF.format( new Date() ); System.out.println("Start:"+start+"\t Stop:"+end); Date date_1 = ms_SDF.parse(start); Date date_2 = ms_SDF.parse(end); Interval interval = new org.joda.time.Interval( date_1.getTime(), date_2.getTime() ); Period period = interval.toPeriod(); System.out.format("%dY/%dM/%dD, %02d:%02d:%02d.%04d \n", period.getYears(), period.getMonths(), period.getDays(), period.getHours(), period.getMinutes(), period.getSeconds(), period.getMillis()); }
Instant start = java.time.Instant.now(); Thread.sleep(1000); Instant end = java.time.Instant.now(); Duration between = java.time.Duration.between(start, end); System.out.println( between ); System.out.format("%dD, %02d:%02d:%02d.%04d \n", between.toDays(), between.toHours(), between.toMinutes(), between.getSeconds(), between.toMillis());
StopWatch sw = new org.springframework.util.StopWatch(); sw.start("Method-1"); Thread.sleep(500); sw.stop(); sw.start("Method-2"); Thread.sleep(300); sw.stop(); sw.start("Method-3"); Thread.sleep(200); sw.stop(); System.out.println("Total time in milliseconds for all tasks :\n"+sw.getTotalTimeMillis()); System.out.println("Table describing all tasks performed :\n"+sw.prettyPrint()); System.out.format("Time taken by the last task : [%s]:[%d]", sw.getLastTaskName(),sw.getLastTaskTimeMillis()); System.out.println("\n Array of the data for tasks performed  Task Name: Time Taken"); TaskInfo[] listofTasks = sw.getTaskInfo(); for (TaskInfo task : listofTasks) { System.out.format("[%s]:[%d]\n", task.getTaskName(), task.getTimeMillis()); }
Total time in milliseconds for all tasks : 999 Table describing all tasks performed : StopWatch ----------------------------------------- ms % Task name ----------------------------------------- 00500 050% Method-1 00299 030% Method-2 00200 020% Method-3 Time taken by the last task : [Method-3]:[200] Array of the data for tasks performed  Task Name: Time Taken [Method-1]:[500] [Method-2]:[299] [Method-3]:[200]
import java.lang.management.ManagementFactory; import java.lang.management.ThreadMXBean; public class CPUUtils { /** Get CPU time in nanoseconds. */ public static long getCpuTime( ) { ThreadMXBean bean = ManagementFactory.getThreadMXBean( ); return bean.isCurrentThreadCpuTimeSupported( ) ? bean.getCurrentThreadCpuTime( ) : 0L; } /** Get user time in nanoseconds. */ public static long getUserTime( ) { ThreadMXBean bean = ManagementFactory.getThreadMXBean( ); return bean.isCurrentThreadCpuTimeSupported( ) ? bean.getCurrentThreadUserTime( ) : 0L; } /** Get system time in nanoseconds. */ public static long getSystemTime( ) { ThreadMXBean bean = ManagementFactory.getThreadMXBean( ); return bean.isCurrentThreadCpuTimeSupported( ) ? (bean.getCurrentThreadCpuTime( ) - bean.getCurrentThreadUserTime( )) : 0L; } }
Object returnValue = TimeIt.printTime(() -> methodeWithReturnValue());
public class TimeIt { public static <T> T printTime(Callable<T> task) { T call = null; try { long startTime = System.currentTimeMillis(); call = task.call(); System.out.print((System.currentTimeMillis() - startTime) / 1000d + "s"); } catch (Exception e) { } return call; } }
Function<Integer, Integer> yourFunction= (n) -> { return IntStream.range(0, n).reduce(0, (a, b) -> a + b); }; Integer returnValue = TimeIt.printTime2(yourFunction).apply(10000); public static <T, R> Function<T, R> printTime2(Function<T, R> task) { return (t) -> { long startTime = System.currentTimeMillis(); R apply = task.apply(t); System.out.print((System.currentTimeMillis() - startTime) / 1000d + "s"); return apply; }; }
org.apache.commons.lang.time.StopWatch sw = new org.apache.commons.lang.time.StopWatch(); System.out.println("getEventFilterTreeData :: Start Time : " + sw.getTime()); sw.start(); sw.stop(); System.out.println("getEventFilterTreeData :: End Time : " + sw.getTime());
int runs = 0, runsPerRound = 10; long begin = System.nanoTime(), end; do { for (int i=0; i<runsPerRound; ++i) timedMethod(); end = System.nanoTime(); runs += runsPerRound; runsPerRound *= 2; } while (runs < Integer.MAX_VALUE / 2 && 1000000000L > end - begin); System.out.println("Time for timedMethod() is " + 0.000000001 * (end-begin) / runs + " seconds");
public @interface Trace { boolean showParameters(); } @Aspect public class TraceAspect { [...] @Around("tracePointcut() && @annotation(trace) && !within(TraceAspect)") public Object traceAdvice ( ProceedingJintPoint jP, Trace trace ) { Object result; try { result = jp.procced(); } finally { } return result; } [...] }
import java.util.concurrent.TimeUnit; long startTime = System.currentTimeMillis(); ........ ........ ........ long finishTime = System.currentTimeMillis(); String diff = millisToShortDHMS(finishTime - startTime); /** * converts time (in milliseconds) to human-readable format * "<dd:>hh:mm:ss" */ public static String millisToShortDHMS(long duration) { String res = ""; long days = TimeUnit.MILLISECONDS.toDays(duration); long hours = TimeUnit.MILLISECONDS.toHours(duration) - TimeUnit.DAYS.toHours(TimeUnit.MILLISECONDS.toDays(duration)); long minutes = TimeUnit.MILLISECONDS.toMinutes(duration) - TimeUnit.HOURS.toMinutes(TimeUnit.MILLISECONDS.toHours(duration)); long seconds = TimeUnit.MILLISECONDS.toSeconds(duration) - TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(duration)); if (days == 0) { res = String.format("%02d:%02d:%02d", hours, minutes, seconds); } else { res = String.format("%dd%02d:%02d:%02d", days, hours, minutes, seconds); } return res; }
new Timer(""){{ }}.timeMe(); public class Timer { private final String timerName; private long started; public Timer(String timerName) { this.timerName = timerName; this.started = System.currentTimeMillis(); } public void timeMe() { System.out.println( String.format("Execution of timerName, started-System.currentTimeMillis())); } }
String watchTag = "target.SomeMethod"; StopWatch stopWatch = new LoggingStopWatch(watchTag); Result result = null; try { result = target.SomeMethod(); stopWatch.stop(watchTag + ".success"); } catch (Exception e) { stopWatch.stop(watchTag + ".fail", "Exception was " + e); throw e; }
@Loggable(Loggable.DEBUG) public String getSomeResult() { }
long start = System.currentTimeMillis(); long end = System.currentTimeMillis();
long start_time = System.currentTimeMillis(); object.method(); long end_time = System.currentTimeMillis(); long execution_time = end_time - start_time;
StopWatch stopWatch = new StopWatch("Performance Test Result"); stopWatch.start("Method 1"); doSomething1(); stopWatch.stop(); stopWatch.start("Method 2"); doSomething2(); stopWatch.stop(); System.out.println(stopWatch.prettyPrint());
StopWatch ----------------------------------------- ms % Task name ----------------------------------------- 11907 036% Method 1 00922 064% Method 2
@Around("execution(* my.package..*.*(..))") public Object logTime(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); stopWatch.start(); Object retVal = joinPoint.proceed(); stopWatch.stop(); log.info(" execution time: " + stopWatch.getTotalTimeMillis() + " ms"); return retVal; }
long startTime = System.currentTimeMillis(); long finishTime = System.currentTimeMillis(); long elapsedTime = finishTime - startTime;
long startTime = System.nanoTime(); methodCode ... long endTime = System.nanoTime(); double duration = (double)(endTime - startTime) / (Math.pow(10, 9)); Log.v(TAG, "MethodName time (s) = " + duration);
<dependencies> <dependency> <groupId>io.dropwizard.metrics</groupId> <artifactId>metrics-core</artifactId> <version>${metrics.version}</version> </dependency> </dependencies>
final Timer timer = metricsRegistry.timer("some_name"); final Timer.Context context = timer.time(); context.stop();
com.example.ExampleService.exampleMethod count = 2 mean rate = 3.11 calls/minute 1-minute rate = 0.96 calls/minute 5-minute rate = 0.20 calls/minute 15-minute rate = 0.07 calls/minute min = 17.01 milliseconds max = 1006.68 milliseconds mean = 511.84 milliseconds stddev = 699.80 milliseconds median = 511.84 milliseconds 75% <= 1006.68 milliseconds 95% <= 1006.68 milliseconds 98% <= 1006.68 milliseconds 99% <= 1006.68 milliseconds 99.9% <= 1006.68 milliseconds
StopWatch stopWatch = new StopWatch() stopWatch.start(); stopWatch.stop(); stopWatch.getTotalTimeMillis() ;
long startTime = System.currentTimeMillis(); System.out.println("Total time [ms]: " + (System.currentTimeMillis() - startTime));
public class Stopwatch { static long startTime; static long splitTime; static long endTime; public Stopwatch() { start(); } public void start() { startTime = System.currentTimeMillis(); splitTime = System.currentTimeMillis(); endTime = System.currentTimeMillis(); } public void split() { split(""); } public void split(String tag) { endTime = System.currentTimeMillis(); System.out.println("Split time for [" + tag + "]: " + (endTime - splitTime) + " ms"); splitTime = endTime; } public void end() { end(""); } public void end(String tag) { endTime = System.currentTimeMillis(); System.out.println("Final time for [" + tag + "]: " + (endTime - startTime) + " ms"); } }
public static Schedule getSchedule(Activity activity_context) { String scheduleJson = null; Schedule schedule = null; Stopwatch stopwatch = new Stopwatch(); InputStream scheduleJsonInputStream = activity_context.getResources().openRawResource(R.raw.skating_times); stopwatch.split("open raw resource"); scheduleJson = FileToString.convertStreamToString(scheduleJsonInputStream); stopwatch.split("file to string"); schedule = new Gson().fromJson(scheduleJson, Schedule.class); stopwatch.split("parse Json"); stopwatch.end("Method getSchedule"); return schedule; }
Split time for [file to string]: 672 ms Split time for [parse Json]: 893 ms Final time for [get Schedule]: 1565 ms
Instant start = Instant.now(); try { Thread.sleep(7000); } catch (InterruptedException e) { e.printStackTrace(); } Instant end = Instant.now(); System.out.println(Duration.between(start, end));
Execution Time: 9 Minutes, 36 Seconds, 237 MicroSeconds, 806193 NanoSeconds
public class series { public static void main(String[] args) { long startTime = System.nanoTime(); long n = 10_00_000; printFactorial(n); long endTime = System.nanoTime(); printExecutionTime(startTime, endTime); } public static void printExecutionTime(long startTime, long endTime) { long time_ns = endTime - startTime; long time_ms = TimeUnit.NANOSECONDS.toMillis(time_ns); long time_sec = TimeUnit.NANOSECONDS.toSeconds(time_ns); long time_min = TimeUnit.NANOSECONDS.toMinutes(time_ns); long time_hour = TimeUnit.NANOSECONDS.toHours(time_ns); System.out.print("\nExecution Time: "); if(time_hour > 0) System.out.print(time_hour + " Hours, "); if(time_min > 0) System.out.print(time_min % 60 + " Minutes, "); if(time_sec > 0) System.out.print(time_sec % 60 + " Seconds, "); if(time_ms > 0) System.out.print(time_ms % 1E+3 + " MicroSeconds, "); if(time_ns > 0) System.out.print(time_ns % 1E+6 + " NanoSeconds"); } }
myMethod(); myMethod("one", "two", "three"); myMethod("solo"); myMethod(new String[]{"a", "b", "c"});
myMethod("foo", "bar"); myMethod("foo", "bar", "baz"); myMethod(new String[]{"foo", "var", "baz"});
public void myMethod(String... strings){ for(String whatever : strings){ } for( int i = 0; i < strings.length; i++){ } }
class VarargSample { public static void PrintMultipleStrings(String... strings) { for( String s : strings ) { System.out.println(s); } } public static void main(String... args) { PrintMultipleStrings("Hello", "world"); } }
return_type method_name(data_type ... variableName){ }
public class VarargsExample { public void displayData(String ... values){ System.out.println("Number of arguments passed " + values.length); for(String s : values){ System.out.println(s + " "); } } public static void main(String[] args) { VarargsExample vObj = new VarargsExample(); vObj.displayData("var", "args", "are", "passed"); vObj.displayData("Three", "args", "passed"); vObj.displayData(); } } Output Number of arguments passed 4 var args are passed Number of arguments passed 3 Three args passed Number of arguments passed 0
void displayValues(int a, int b, int  values) void displayValues(int a, int b, int  values, int c)
void displayValues(int a, int b, int  values, int  moreValues)
public class OverloadingVarargsExp { public void displayData(String ... values){ System.out.println("Number of arguments passed " + values.length); for(String s : values){ System.out.println(s + " "); } } public void displayData(int ... values){ System.out.println("Number of arguments passed " + values.length); for(int i : values){ System.out.println(i + " "); } } public void displayData(String a, int ... values){ System.out.println(" a " + a); System.out.println("Number of arguments passed " + values.length); for(int i : values){ System.out.println(i + " "); } } public static void main(String[] args) { OverloadingVarargsExp vObj = new OverloadingVarargsExp(); vObj.displayData("var", "args", "are", "passed"); vObj.displayData(10, 20); vObj.displayData("Test", 20, 30); } } Output Number of arguments passed 4 var args are passed Number of arguments passed 2 10 20 a Test Number of arguments passed 2 20 30
public class OverloadingVarargsExp { public void displayData(String ... values){ System.out.println("Number of arguments passed " + values.length); for(String s : values){ System.out.println(s + " "); } } public void displayData(int ... values){ System.out.println("Number of arguments passed " + values.length); for(int i : values){ System.out.println(i + " "); } } public static void main(String[] args) { OverloadingVarargsExp vObj = new OverloadingVarargsExp(); vObj.displayData("var", "args", "are", "passed"); vObj.displayData(10, 20); vObj.displayData(); } }
public void myMethod(String... strings, int ... ints){ }
import java.lang.*; public class MyClassTest { public static void main(String[] args) { for(String str: args) { System.out.println(str); } } }
StringBuilder sb = new StringBuilder(); sb.append(""); sb.append(i); String strI = sb.toString();
simon@lucifer:~$ cat TestClass.java public class TestClass { public static void main(String[] args) { int i = 5; String strI = "" + i; } } simon@lucifer:~$ javac TestClass.java && javap -c TestClass Compiled from "TestClass.java" public class TestClass extends java.lang.Object{ public TestClass(); Code: 0: aload_0 1: invokespecial 4: return public static void main(java.lang.String[]); Code: 0: iconst_5 1: istore_1
9: ldc 11: invokevirtual (Ljava/lang/String;)Ljava/lang/StringBuilder;
14: iload_1 15: invokevirtual (I)Ljava/lang/StringBuilder;
18: invokevirtual ()Ljava/lang/String; 21: astore_2 22: return }
Integer.toString(int n); Integer.toString(int n, int radix);
StringBuilder string = string.append(i).toString(); String string = String.valueOf(i); String string = Integer.toString(i);
String total = Integer.toString(123) + Double.toString(456.789);
String strI = String.valueOf(i); String string = Integer.toString(i);
String hundred = String.valueOf(100); int ten = 10; String ten = String.valueOf(ten)
<plugin> <artifactId>maven-assembly-plugin</artifactId> <executions> <execution> <phase>package</phase> <goals> <goal>single</goal> </goals> </execution> </executions> <configuration> <archive> <manifest> <addClasspath>true</addClasspath> <mainClass>com.package.MainClass</mainClass> </manifest> </archive> <descriptorRefs> <descriptorRef>jar-with-dependencies</descriptorRef> </descriptorRefs> </configuration> </plugin>
Select Jar and next [ give it a name in the next window ] and next and next again and you Just pick a class and Eclipse will automatically build a cool MANIFEST.MF for you.
java -cp yourJarName.jar your.package..your.MainClass
<build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-shade-plugin</artifactId> <version>2.0</version> <executions> <execution> <phase>package</phase> <goals> <goal>shade</goal> </goals> <configuration> <transformers> <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"> <mainClass>org.lazydevs.veetle.api.VeetleAPI</mainClass> </transformer> </transformers> </configuration> </execution> </executions> </plugin> </plugins> </build>
<build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build>
<parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.4.2.RELEASE</version> </parent> <properties> <java.version>1.8</java.version> </properties> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build>
jar -cfm jarfile-name manifest-filename Class-file name
Start-Class: com.myco.eventlogging.MyService Spring-Boot-Classes: BOOT-INF/classes/ Spring-Boot-Lib: BOOT-INF/lib/ Spring-Boot-Version: 1.4.0.RELEASE Created-By: Apache Maven 3.3.9 Build-Jdk: 1.8.0_131 Main-Class: org.springframework.boot.loader.JarLauncher
jar cvfeP test.jar testpackage.Test -C . testpackage/
Manifest-Version: 1.0 Created-By: <JDK Version> (Oracle Corporation) Main-Class: testpackage.Test
Manifest-Version: 1.0 Created-By: 1.8.0_91 (Oracle Corporation) Main-Class: HelloWorldSwing ~ java -jar HelloWorldSwing.jar no main manifest attribute, in HelloWorldSwing.jar
Manifest-Version: 1.0 Main-Class: HelloWorldSwing Created-By: 1.8.0_91 (Oracle Corporation)
META-INF/ META-INF/MANIFEST.MF somepath/ somepath/App.class META-INF/maven/ ...
<manifest> <mainClass>mypackage.MyClass</mainClass> </manifest>
jar cfve app.jar TheNameOfClassWithMainMethod *.class
class first { public static void main (String arg[ ]) { System.out.println("Welcome to the world of Java"); } }
Manifest-Version: 1.0 Created-By: 1.7.0_80 (Oracle Corporation) sony@sony-VPCEH25EN:~/Documents$ java -jar first.jar no main manifest attribute, in first.jar
Manifest-Version: 1.0 Created-By: 1.7.0_80 (Oracle Corporation) Main-Class: first sony@sony-VPCEH25EN:~/Documents$ java -jar first.jar Welcome to the world of Java
DummyBean dum = new DummyBean(); dum.setDummy("foo"); System.out.println(dum.getDummy()); DummyBean dumtwo = dum; System.out.println(dumtwo.getDummy()); dum.setDummy("bar"); System.out.println(dumtwo.getDummy());
class DummyBean { private String dummy; public DummyBean(DummyBean another) { this.dummy = another.dummy; } }
public class Deletable implements Cloneable{ private String str; public Deletable(){ } public void setStr(String str){ this.str = str; } public void display(){ System.out.println("The String is "+str); } protected Object clone() throws CloneNotSupportedException { return super.clone(); } }
Deletable del = new Deletable(); Deletable delTemp = (Deletable ) del.clone();
this.myObjectCloned = SerializationUtils.clone(this.object);
private static Object cloneObject(Object obj){ try{ Object clone = obj.getClass().newInstance(); for (Field field : obj.getClass().getDeclaredFields()) { field.setAccessible(true); field.set(clone, field.get(obj)); } return clone; }catch(Exception e){ return null; } }
private static Object cloneObject(Object obj){ try{ Object clone = obj.getClass().newInstance(); for (Field field : obj.getClass().getDeclaredFields()) { field.setAccessible(true); if(field.get(obj) == null || Modifier.isFinal(field.getModifiers())){ continue; } if(field.getType().isPrimitive() || field.getType().equals(String.class) || field.getType().getSuperclass().equals(Number.class) || field.getType().equals(Boolean.class)){ field.set(clone, field.get(obj)); }else{ Object childObj = field.get(obj); if(childObj == obj){ field.set(clone, clone); }else{ field.set(clone, cloneObject(field.get(obj))); } } } return clone; }catch(Exception e){ return null; } }
import com.google.gson.*; public class SerialUtils { public static String serializeObject(Object o) { Gson gson = new Gson(); String serializedObject = gson.toJson(o); return serializedObject; } public static Object unserializeObject(String s, Object o){ Gson gson = new Gson(); Object object = gson.fromJson(s, o.getClass()); return object; } public static Object cloneObject(Object o){ String s = serializeObject(o); Object object = unserializeObject(s,o); return object; } }
public Object clone() throws CloneNotSupportedException { return super.clone(); }
class UserAccount{ public int id; public String name; }
Gson gson = new Gson(); updateUser = gson.fromJson(gson.toJson(mUser),UserAccount.class);
class UserAccount{ public int id; public String name; public UserAccount(){} public UserAccount(int id, String name) { this.id = id; this.name = name; } public UserAccount(UserAccount in){ this(in.id,in.name); } }
public class DummyBean implements Cloneable { private String dummy; public void setDummy(String dummy) { this.dummy = dummy; } public String getDummy() { return dummy; } @Override public Object clone() throws CloneNotSupportedException { DummyBean cloned = (DummyBean)super.clone(); cloned.setDummy(cloned.getDummy()); return cloned; } }
SomeObjectType copy = new Cloner().deepClone(someObject);
class DB { private String dummy; public DB(DB one) { this.dummy = one.dummy; } }
private Object copyObject(Object objSource) { try { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(objSource); oos.flush(); oos.close(); bos.close(); byte[] byteData = bos.toByteArray(); ByteArrayInputStream bais = new ByteArrayInputStream(byteData); try { objDest = new ObjectInputStream(bais).readObject(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } catch (IOException e) { e.printStackTrace(); } return objDest; }
<dependency> <groupId>com.thoughtworks.xstream</groupId> <artifactId>xstream</artifactId> <version>1.3.1</version> </dependency>
DummyBean dum = new DummyBean(); dum.setDummy("foo"); DummyBean dumCopy = (DummyBean) XSTREAM.fromXML(XSTREAM.toXML(dum));
import net.zerobuilder.BeanBuilder @BeanBuilder public class DummyBean { }
DummyBean bean = new DummyBean(); DummyBean copy = DummyBeanBuilders.dummyBeanUpdater(bean).done();
public class MyClass implements Cloneable { private boolean myField= false; public MyClass (){} @Override public MyClass clone() throws CloneNotSupportedException { try { MyClass clonedMyClass = (MyClass)super.clone(); return clonedMyClass ; } catch (CloneNotSupportedException e) { e.printStackTrace(); return new MyClass(); } } }
MyClass myClass = new MyClass(); MyClass clonedMyClass = myClass.clone();
<build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> </plugins> </build>
<project xmlns="http: xmlns:xsi="http: xsi:schemaLocation="http: <!-- ... --> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.5.1</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> </plugins> </build> <!-- ... --> </project>
<project> [...] <properties> <maven.compiler.source>1.8</maven.compiler.source> <maven.compiler.target>1.8</maven.compiler.target> </properties> [...] </project>
<plugin> <artifactId>maven-compiler-plugin</artifactId> <version>2.3.2</version> <configuration> <source>1.8</source> <target>1.8</target> <encoding>UTF-8</encoding> </configuration> </plugin>
<bytecodeTargetLevel> <module name="your_project_name_main" target="1.8" /> <module name="your_project_name_test" target="1.8" /> </bytecodeTargetLevel>
<plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin>
android { compileOptions { ... sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 ... } }
/** * Returns the Baz object owned by the Bar object owned by Foo owned by this. * A convenience method, equivalent to getFoo().getBar().getBaz() * @return baz */ public Baz fooBarBaz()
/** * Returns the Baz object owned by the Bar object owned by Foo owned by this. * A convenience method, equivalent to {@link getFoo()}.{@link getBar()}.{@link getBaz()} * @return baz */ public Baz fooBarBaz()
interface View { /** * @return true: have read contact and call log permissions, else otherwise * @see */ boolean haveReadContactAndCallLogPermissions(); /** * if not have permissions, request to user for allow * @see */ void requestReadContactAndCallLogPermissions(); }
public class DaemonTest { public static void main(String[] args) { new WorkerThread().start(); try { Thread.sleep(7500); } catch (InterruptedException e) { } System.out.println("Main Thread ending") ; } } class WorkerThread extends Thread { public WorkerThread() { setDaemon(true); } public void run() { int count = 0; while (true) { System.out.println("Hello from Worker "+count++); try { sleep(5000); } catch (InterruptedException e) { } } } }
public class DaemonThread extends Thread { public void run() { System.out.println("Entering run method"); try { System.out.println("In run Method: currentThread() is" + Thread.currentThread()); while (true) { try { Thread.sleep(500); } catch (InterruptedException x) {} System.out.println("In run method: woke up again"); } } finally { System.out.println("Leaving run Method"); } } public static void main(String[] args) { System.out.println("Entering main Method"); DaemonThread t = new DaemonThread(); t.setDaemon(true); t.start(); try { Thread.sleep(3000); } catch (InterruptedException x) {} System.out.println("Leaving main method"); } }
C:\java\thread>javac DaemonThread.java C:\java\thread>java DaemonThread Entering main Method Entering run method In run Method: currentThread() isThread[Thread-0,5,main] In run method: woke up again In run method: woke up again In run method: woke up again In run method: woke up again In run method: woke up again In run method: woke up again Leaving main method C:\j2se6\thread>
public class DeamonThreadTest { public static void main(String[] args) { new WorkerThread(false).start(); try { Thread.sleep(7500); } catch (InterruptedException e) { } System.out.println("Main Thread ending"); } } class WorkerThread extends Thread { boolean isDeamon; public WorkerThread(boolean isDeamon) { this.isDeamon = isDeamon; setDaemon(isDeamon); } public void run() { System.out.println("I am a " + (isDeamon ? "Deamon Thread" : "User Thread (none-deamon)")); int counter = 0; while (counter < 10) { counter++; System.out.println("\tworking from Worker thread " + counter++); try { sleep(5000); } catch (InterruptedException e) { } } System.out.println("\tWorker thread ends. "); } } result when setDeamon(true) ===================================== I am a Deamon Thread working from Worker thread 0 working from Worker thread 1 Main Thread ending Process finished with exit code 0 result when setDeamon(false) ===================================== I am a User Thread (none-deamon) working from Worker thread 0 working from Worker thread 1 Main Thread ending working from Worker thread 2 working from Worker thread 3 working from Worker thread 4 working from Worker thread 5 working from Worker thread 6 working from Worker thread 7 working from Worker thread 8 working from Worker thread 9 Worker thread ends. Process finished with exit code 0
if ( threadShouldDieOnApplicationEnd ) { thread.setDaemon ( true ); } thread.start();
public class DeamonTreadExample { public static void main(String[] args) throws InterruptedException { Thread t = new Thread(() -> { int count = 0; while (true) { count++; try { System.out.println("inside try"+ count); Thread.currentThread().sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println("finally executed"+ count); } } }); t.setDaemon(true); t.start(); Thread.currentThread().sleep(10000); System.out.println("main thread exited"); } }
inside try1 finally executed1 inside try2 finally executed2 inside try3 finally executed3 inside try4 finally executed4 inside try5 finally executed5 inside try6 finally executed6 inside try7 finally executed7 inside try8 finally executed8 inside try9 finally executed9 inside try10 main thread exited
import java.util.*; public class Main { public static void main(String[] args) { int size = 3; String[] array = new String[size]; Arrays.fill(array, ""); for(int i = 0; i <= 100; ) { array[i++%size] += i + " "; } for(String element: array) { System.out.println(element); } } }
1 4 7 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 64 67 70 73 76 79 82 85 88 91 94 97 100 2 5 8 11 14 17 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77 80 83 86 89 92 95 98 101 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99
2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 102 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100
class Main { public static void main(String[] args) { String[] array = { "" }; array[test()] += "a"; } static int test() { System.out.println("evaluated"); return 0; } }
21: aload_2 22: iload_3 23: iinc 3, 1 26: iload_1 27: irem 28: aload_2 29: iload_3 30: iinc 3, 1 33: iload_1 34: irem 35: aaload 36: iload_3 37: invokedynamic 42: aastore
21: aload_2 22: iload_3 23: iinc 3, 1 26: iload_1 27: irem
*combo 1* : JPA + JPA Provider(Hibernate) *combo 2* : only Hiberante which does not need any interface
Log.d("AppDebug","mTextView is null: " + String.valueOf(mTextView == null); Log.d("AppDebug","myString is null: " + String.valueOf(myString== null);
Log. d means Debug e means error w means warning v means verbose i means information wtf means "What a terrible failure". This is similar to Log.e
yourPackageNameAndApp: mTextView is null: true yourPackageNameAndApp: myString is null: false
mTextView = (TextView) findViewById(R.id.textview_id_in_xml);
07-09 08:29:13.474 21144-21144/com.example.khan.abc D/AndroidRuntime: Shutting down VM 07-09 08:29:13.475 21144-21144/com.example.khan.abc E/AndroidRuntime: FATAL EXCEPTION: main Process: com.example.khan.abc, PID: 21144 java.lang.NullPointerException: Attempt to invoke virtual method at com.example.khan.abc.AudioFragment$1.onClick(AudioFragment.java:125) at android.view.View.performClick(View.java:4848) at android.view.View$PerformClick.run(View.java:20262) at android.os.Handler.handleCallback(Handler.java:815) at android.os.Handler.dispatchMessage(Handler.java:104) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5631) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:959) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:754) 07-09 08:29:15.195 21144-21144/com.example.khan.abc I/Process: Sending signal. PID: 21144 SIG: 9
at android.view.View$PerformClick.run(View.java:20262)
at android.os.Handler.handleCallback(Handler.java:815)
public void showToast(String error, Context applicationContext){ LayoutInflater inflater = getLayoutInflater(); View view = inflater.inflate(R.layout.custom_toast, (ViewGroup) findViewById(R.id.toast_root)); TextView text = (TextView) findViewById(R.id.toast_error); text.setText(error); Toast toast = new Toast(applicationContext); toast.setGravity(Gravity.TOP | Gravity.FILL_HORIZONTAL, 0, 0); toast.setDuration(Toast.LENGTH_SHORT); toast.setView(view); toast.show(); }
private boolean defaultOptionalFlagValue = true; public void doSomething(boolean optionalFlag) { ... } public void doSomething() { doSomething(defaultOptionalFlagValue); }
void foo(String a, Integer b) { } void foo(String a) { foo(a, 0); } foo("a", 2); foo("a");
void foo(String a, Integer... b) { Integer b1 = b.length > 0 ? b[0] : 0; Integer b2 = b.length > 1 ? b[1] : 0; } foo("a"); foo("a", 1, 2);
void foo(String a, Object... b) { Integer b1 = 0; String b2 = ""; if (b.length > 0) { if (!(b[0] instanceof Integer)) { throw new IllegalArgumentException("..."); } b1 = (Integer)b[0]; } if (b.length > 1) { if (!(b[1] instanceof String)) { throw new IllegalArgumentException("..."); } b2 = (String)b[1]; } } foo("a"); foo("a", 1); foo("a", 1, "b2");
void foo(String a, Integer b, Integer c) { b = b != null ? b : 0; c = c != null ? c : 0; } foo("a", null, 2);
void foo(String a, Optional<Integer> bOpt) { Integer b = bOpt.isPresent() ? bOpt.get() : 0; } foo("a", Optional.of(2)); foo("a", Optional.<Integer>absent());
class Foo { private final String a; private final Integer b; Foo(String a, Integer b) { this.a = a; this.b = b; } } class FooBuilder { private String a = ""; private Integer b = 0; FooBuilder setA(String a) { this.a = a; return this; } FooBuilder setB(Integer b) { this.b = b; return this; } Foo build() { return new Foo(a, b); } } Foo foo = new FooBuilder().setA("a").build();
void foo(Map<String, Object> parameters) { String a = ""; Integer b = 0; if (parameters.containsKey("a")) { if (!(parameters.get("a") instanceof Integer)) { throw new IllegalArgumentException("..."); } a = (Integer)parameters.get("a"); } if (parameters.containsKey("b")) { } } foo(ImmutableMap.<String, Object>of( "a", "a", "b", 2, "d", "value"));
@SuppressWarnings("unchecked") static <T> T getParm(Map<String, Object> map, String key, T defaultValue) { return (map.containsKey(key)) ? (T) map.get(key) : defaultValue; } void foo(Map<String, Object> parameters) { String a = getParm(parameters, "a", ""); int b = getParm(parameters, "b", 0); } foo(Map.of("a","a", "b",2, "d","value"));
public void addError(String path, String key, Object... params) { }
public void doSomething(boolean... optionalFlag) { }
void SomeMethod(int age, String name) { // } void SomeMethod(int age) { SomeMethod(age, "John Doe"); }
protected void process( Processor processor, String item, @Default("Processor.Size.LARGE") Size size, @Default("red") String color, @Default("1") int quantity) { processor.process(item, size, color, quantity); } public void report(@Default("Hello") String message) { System.out.println("Message: " + message); }
MyObject my = new MyObjectBuilder().setParam1(value) .setParam3(otherValue) .setParam6(thirdValue) .build();
public class NewClass1 { public static void main(String[] args) { try { someMethod(18); someMethod(18, "John Doe"); } catch (Exception e) { e.printStackTrace(); } } static void someMethod(int age, String... names) { if (names.length > 0) { if (names[0] != null) { System.out.println("Age & Name : " + age + " & " + names[0]); } } else { System.out.println("Age : " + age); } } }
public void foo(Object... x) { String first = x.length > 0 ? (String)x[0] : "Hello"; int duration = x.length > 1 ? Integer.parseInt((String) x[1]) : 888; } foo("Hii", ); foo("Hii", 146);
public void load(String name){ } public void load(String name,int age){}
public void methodA(A arg1) { } public void methodA( B arg2,) { } public void methodA(C arg3) { } public void methodA(A arg1, B arg2) { } public void methodA(A arg1, C arg3) { } public void methodA( B arg2, C arg3) { } public void methodA(A arg1, B arg2, C arg3) { }
Object canBeNull() { if (blah) { return new Object(); } else { return null; } } Object optionalObject = canBeNull(); if (optionalObject != null) { } else { }
public class Options { private String someString = "default value"; private int someInt= 0; public Options setSomeString(String someString) { this.someString = someString; return this; } public Options setSomeInt(int someInt) { this.someInt = someInt; return this; } } public static void foo(Consumer<Options> consumer) { Options options = new Options(); consumer.accept(options); System.out.println("someString = " + options.someString + ", someInt = " + options.someInt); }
foo(o -> o.setSomeString("something").setSomeInt(5));
RetDtaTyp NamFnc(String NamPsgVar) { return RetVar; } RetDtaTyp NamFnc(String NamPsgVar) { return RetVar; } RetDtaTyp NamFnc(int NamPsgVar1, String NamPsgVar2) { return RetVar; }
RetDtaTyp NamFnc(int NamPsgVar, String... SrgOpnPsgVar) { if(SrgOpnPsgVar.length == 0) SrgOpnPsgVar = DefSrgVar; return RetVar; }
Stash(int size); Stash(int size, int initQuantity);
Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(source); String title = XPathFactory.newInstance().newXPath().evaluate("
/** * See {@link <a href="http: */ public static final String ACCEPT = "Accept"; /** * See {@link <a href="http: */ public static final String ACCEPT_CHARSET = "Accept-Charset";
List<Dog> dogs = new ArrayList<Dog>(); List<Animal> animals = dogs; animals.add(new Cat()); Dog dog = dogs.get(0);
Object[] objects = new String[10]; objects[0] = Boolean.FALSE;
Dog[] dogs = new Dog[10]; Animal[] animals = dogs; animals[0] = new Cat();
List<Dog> dogs = new ArrayList<>(); List<Animal> animals = dogs; animals.add(new Cat());
public void passOn(Consumer<Animal> consumer, Supplier<Animal> supplier) { consumer.accept(supplier.get()); }
public <A extends Animal> void passOn(Consumer<A> consumer, Supplier<? extends A> supplier) { consumer.accept(supplier.get()); }
public <A extends Animal> void passOn(Consumer<? super A> consumer, Supplier<A> supplier) { consumer.accept(supplier.get()); }
public <A extends Animal> void passOn(Consumer<? super A> consumer, Supplier<? extends A> supplier) { consumer.accept(supplier.get()); }
public interface Animal { String getName(); String getVoice(); } public class Dog implements Animal{ @Override String getName(){return "Dog";} @Override String getVoice(){return "woof!";}
List <Animal> animalGroup = new ArrayList<Animal>(); animalGroup.add(new Dog());
/**Could use Collection<? extends Object> and that is the better choice. * But I am doing this to illustrate how to use DownCastCollection. **/ public static void print(Collection<Object> col){ for(Object obj : col){ System.out.println(obj); } } public static void main(String[] args){ ArrayList<String> list = new ArrayList<>(); list.addAll(Arrays.asList("a","b","c")); print(new DownCastCollection<Object>(list)); }
import java.util.AbstractCollection; import java.util.Collection; import java.util.Iterator; import java.util.NoSuchElementException; public class DownCastCollection<E> extends AbstractCollection<E> implements Collection<E> { private Collection<? extends E> delegate; public DownCastCollection(Collection<? extends E> delegate) { super(); this.delegate = delegate; } @Override public int size() { return delegate ==null ? 0 : delegate.size(); } @Override public boolean isEmpty() { return delegate==null || delegate.isEmpty(); } @Override public boolean contains(Object o) { if(isEmpty()) return false; return delegate.contains(o); } private class MyIterator implements Iterator<E>{ Iterator<? extends E> delegateIterator; protected MyIterator() { super(); this.delegateIterator = delegate == null ? null :delegate.iterator(); } @Override public boolean hasNext() { return delegateIterator != null && delegateIterator.hasNext(); } @Override public E next() { if(!hasNext()) throw new NoSuchElementException("The iterator is empty"); return delegateIterator.next(); } @Override public void remove() { delegateIterator.remove(); } } @Override public Iterator<E> iterator() { return new MyIterator(); } @Override public boolean add(E e) { throw new UnsupportedOperationException(); } @Override public boolean remove(Object o) { if(delegate == null) return false; return delegate.remove(o); } @Override public boolean containsAll(Collection<?> c) { if(delegate==null) return false; return delegate.containsAll(c); } @Override public boolean addAll(Collection<? extends E> c) { throw new UnsupportedOperationException(); } @Override public boolean removeAll(Collection<?> c) { if(delegate == null) return false; return delegate.removeAll(c); } @Override public boolean retainAll(Collection<?> c) { if(delegate == null) return false; return delegate.retainAll(c); } @Override public void clear() { if(delegate == null) return; delegate.clear(); }
List<Dog> dogs = new ArrayList<Dog>(1); List<Animal> animals = dogs; animals.add(new Cat()); Dog dog = dogs.get(0);
Dog[] dogs = new Dog[1]; Object[] animals = dogs; animals[0] = new Cat(); Dog dog = dogs[0];
import java.util.ArrayList; import java.util.List; public class Demonstration { public void normal() { List normal = new ArrayList(1); normal.add("lorem ipsum"); } public void parameterized() { List<String> parameterized = new ArrayList<>(1); parameterized.add("lorem ipsum"); } }
Compiled from "Demonstration.java" public class Demonstration { public Demonstration(); Code: 0: aload_0 1: invokespecial 4: return public void normal(); Code: 0: new 3: dup 4: iconst_1 5: invokespecial 8: astore_1 9: aload_1 10: ldc 12: invokeinterface 17: pop 18: return public void parameterized(); Code: 0: new 3: dup 4: iconst_1 5: invokespecial 8: astore_1 9: aload_1 10: ldc 12: invokeinterface 17: pop 18: return }
public abstract class Shape { public abstract void draw(Canvas c); } public class Circle extends Shape { private int x, y, radius; public void draw(Canvas c) { ... } } public class Rectangle extends Shape { private int x, y, width, height; public void draw(Canvas c) { ... } }
drawAll(circleList); public void drawAll(List<Shape> shapes) { shapes.add(new Rectangle()); }
<T extends Animal> void doSomething<List<T> animals) { }
List<Dog> dogs = new ArrayList<Dog>(); List<Animal> animals = new ArrayList<Animal>(dogs); animals.add(new Cat());
java.lang.OutOfMemoryError: GC overhead limit exceeded
import java.util.*; public class GarbageCollector { public static void main(String... args) { System.out.printf("Testing...%n"); List<Double> list = new ArrayList<Double>(); for (int outer = 0; outer < 10000; outer++) { list.clear(); for (int inner = 0; inner < 10000; inner++) { list.add(Math.random()); } if (outer % 1000 == 0) { System.out.printf("Outer loop at %d%n", outer); } } System.out.printf("Done.%n"); } }
-XX:+UseG1GC -XX:G1HeapRegionSize=n -XX:MaxGCPauseMillis=m -XX:ParallelGCThreads=n -XX:ConcGCThreads=n
android { compileSdkVersion 25 buildToolsVersion defaultConfig { applicationId "yourpackage" minSdkVersion 10 targetSdkVersion 25 versionCode 1 versionName "1.0" multiDexEnabled true } dexOptions { javaMaxHeapSize "4g" } }
set WLS_HOME=%WL_HOME%\server set XMS_SUN_64BIT=**256** set XMS_SUN_32BIT=**256** set XMX_SUN_64BIT=**3072** set XMX_SUN_32BIT=**3072** set XMS_JROCKIT_64BIT=**256** set XMS_JROCKIT_32BIT=**256** set XMX_JROCKIT_64BIT=**1024** set XMX_JROCKIT_32BIT=**1024** if "%JAVA_VENDOR%"=="Sun" ( set WLS_MEM_ARGS_64BIT=**-Xms256m -Xmx512m** set WLS_MEM_ARGS_32BIT=**-Xms256m -Xmx512m** ) else ( set WLS_MEM_ARGS_64BIT=**-Xms512m -Xmx512m** set WLS_MEM_ARGS_32BIT=**-Xms512m -Xmx512m** )
set MEM_PERM_SIZE_64BIT=-XX:PermSize=**256m** set MEM_PERM_SIZE_32BIT=-XX:PermSize=**256m** if "%JAVA_USE_64BIT%"=="true" ( set MEM_PERM_SIZE=%MEM_PERM_SIZE_64BIT% ) else ( set MEM_PERM_SIZE=%MEM_PERM_SIZE_32BIT% ) set MEM_MAX_PERM_SIZE_64BIT=-XX:MaxPermSize=**1024m** set MEM_MAX_PERM_SIZE_32BIT=-XX:MaxPermSize=**1024m**
buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile( signingConfig signingConfigs.sign_config_release } debug { debuggable true signingConfig signingConfigs.sign_config_debug } }
buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile( signingConfig signingConfigs.sign_config_release } debug { debuggable true signingConfig signingConfigs.sign_config_debug } }
-Xms512m -Xmx2024m -XX:MaxPermSize=700m -XX:ReservedCodeCacheSize=480m
d2j-dex2jar.sh -f -o output_jar.jar apk_to_decompile.apk
APK Easy Tool for Windows (GUI tool, friendly) Bytecode Viewer - APK/Java Reverse Engineering Suite URET Android Reverser Toolkit
Description-en: full Python tool to play with Android files Androguard is a full Python tool to play with Android files. * DEX, ODEX * APK * Android * Android resources * Disassemble DEX/ODEX bytecodes * Decompiler for DEX/ODEX files
public class Customer { private String firstName, lastName, Address; int Age; public Customer(String fname, String lname, int age, String address) { firstName = fname; lastName = lname; Age = age; Address = address; } public String printValues() { String data = null; data = "First Name :" + firstName + " Last Name :" + lastName + " Age : " + Age + " Address : " + Address; return data; } }
intent.putExtra("MyClass", obj); getIntent().getSerializableExtra("MyClass");
class MainClass implements Serializable { public MainClass() {} public static class ChildClass implements Serializable { public ChildClass() {} } }
import java.io.Serializable; @SuppressWarnings("serial") public class Deneme implements Serializable { public Deneme(double id, String name) { this.id = id; this.name = name; } public double getId() { return id; } public void setId(double id) { this.id = id; } public String getName() { return this.name; } public void setName(String name) { this.name = name; } private double id; private String name; }
Deneme dene = new Deneme(4,"Mustafa"); Intent i = new Intent(this, Y.class); i.putExtra("sampleObject", dene); startActivity(i);
Intent i = getIntent(); Deneme dene = (Deneme)i.getSerializableExtra("sampleObject");
Intent intent = new Intent(fromClass.this,toClass.class).putExtra("myCustomerObj",customerObj);
Customer customerObjInToClass = getIntent().getExtras().getParcelable("myCustomerObj");
public class Customer implements Parcelable { private String firstName, lastName, address; int age; public Customer(Parcel in ) { readFromParcel( in ); } public static final Parcelable.Creator CREATOR = new Parcelable.Creator() { public LeadData createFromParcel(Parcel in ) { return new Customer( in ); } public Customer[] newArray(int size) { return new Customer[size]; } }; @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(firstName); dest.writeString(lastName); dest.writeString(address); dest.writeInt(age); } private void readFromParcel(Parcel in ) { firstName = in .readString(); lastName = in .readString(); address = in .readString(); age = in .readInt(); }
Gson gson = new Gson(); String myJson = gson.toJson(vp); intent.putExtra("myjson", myjson);
Gson gson = new Gson(); YourObject ob = gson.fromJson(getIntent().getStringExtra("myjson"), YourObject.class);
val gson = Gson() val intent = Intent(this, YourActivity::class.java) intent.putExtra("identifier", gson.toJson(your_object)) startActivity(intent)
val gson = Gson() val yourObject = gson.fromJson<YourObject>(intent.getStringExtra("identifier"), YourObject::class.java)
String fName_temp = yourObject.getFname(); String lName_temp = yourObject.getLname(); String age_temp = yourObject.getAge(); String address_temp = yourObject.getAddress(); Intent i = new Intent(this, ToClass.class); i.putExtra("fname", fName_temp); i.putExtra("lname", lName_temp); i.putExtra("age", age_temp); i.putExtra("address", address_temp); startActivity(i);
String fName = getIntent().getExtras().getInt("fname");
final Object objSent = new Object(); final Bundle bundle = new Bundle(); bundle.putBinder("object_value", new ObjectWrapperForBinder(objSent)); startActivity(new Intent(this, SecondActivity.class).putExtras(bundle)); Log.d(TAG, "original object=" + objSent);
final Object objReceived = ((ObjectWrapperForBinder)getIntent().getExtras().getBinder("object_value")).getData(); Log.d(TAG, "received object=" + objReceived);
public class ObjectWrapperForBinder extends Binder { private final Object mData; public ObjectWrapperForBinder(Object data) { mData = data; } public Object getData() { return mData; } }
package com.example.objectwrapper; interface IDataContract { int func1(String arg1); int func2(String arg1); }
final IDataContract objSent = new IDataContract.Stub() { @Override public int func2(String arg1) throws RemoteException { Log.d(TAG, "func2:: arg1=" + arg1); return 102; } @Override public int func1(String arg1) throws RemoteException { Log.d(TAG, "func1:: arg1=" + arg1); return 101; } }; final Bundle bundle = new Bundle(); bundle.putBinder("object_value", objSent.asBinder()); startActivity(new Intent(this, SecondActivity.class).putExtras(bundle)); Log.d(TAG, "original object=" + objSent);
final IDataContract objReceived = IDataContract.Stub.asInterface(getIntent().getExtras().getBinder("object_value")); try { Log.d(TAG, "received object=" + objReceived + ", func1()=" + objReceived.func1("test1") + ", func2()=" + objReceived.func2("test2")); } catch (RemoteException e) { e.printStackTrace(); }
public class MainActivity extends Activity { private static final String TAG = "MainActivity"; public static final int MSG_OP1 = 1; public static final int MSG_OP2 = 2; public static final String EXTRA_MESSENGER = "messenger"; private final Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { Log.e(TAG, "handleMessage:: msg=" + msg); switch (msg.what) { case MSG_OP1: break; case MSG_OP2: break; default: break; } super.handleMessage(msg); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startActivity(new Intent(this, SecondActivity.class).putExtra(EXTRA_MESSENGER, new Messenger(mHandler))); } }
public class SecondActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); final Messenger messenger = getIntent().getParcelableExtra(MainActivity.EXTRA_MESSENGER); try { messenger.send(Message.obtain(null, MainActivity.MSG_OP1, 101, 1001, "10001")); messenger.send(Message.obtain(null, MainActivity.MSG_OP2, 102, 1002, "10002")); } catch (RemoteException e) { e.printStackTrace(); } } }
package android.os; import android.os.Message; /** @hide */ oneway interface IMessenger { void send(in Message msg); }
public class IntentHelper { private static IntentHelper _instance; private Hashtable<String, Object> _hash; private IntentHelper() { _hash = new Hashtable<String, Object>(); } private static IntentHelper getInstance() { if(_instance==null) { _instance = new IntentHelper(); } return _instance; } public static void addObjectForKey(Object object, String key) { getInstance()._hash.put(key, object); } public static Object getObjectForKey(String key) { IntentHelper helper = getInstance(); Object data = helper._hash.get(key); helper._hash.remove(key); helper = null; return data; } }
Object obj = (Object) IntentHelper.getObjectForKey("key");
SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this); SharedPreferences.Editor editor = sharedPref.edit(); editor.putString("userName", "stackoverlow"); editor.commit();
SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this); String userName = sharedPref.getString("userName", "Not Available");
public class VariableStorage implements Serializable { private String inString; public String getInString() { return inString; } public void setInString(String inString) { this.inString = inString; } }
VariableStorage variableStorage = new VariableStorage(); variableStorage.setInString(inString);
public class CommonUtilities { public static String className = "CommonUtilities"; }
import import java.io.Serializable; public class Customer implements Serializable { private String name; private String city; public Customer() { } public Customer(String name, String city) { this.name= name; this.city=city; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCity() { return city; } public void setCity(String city) { this.city= city; } }
@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_top); Customer cust=new Customer(); cust.setName("abc"); cust.setCity("xyz"); Intent intent=new Intent(abc.this,xyz.class); intent.putExtra("bundle",cust); startActivity(intent); }
Intent intent=getIntent(); Customer cust=(Customer)intent.getSerializableExtra("bundle"); textViewName.setText(cust.getName()); textViewCity.setText(cust.getCity());
public class MyClass implements Serializable{ Here is your instance variable }
Bundle b = new Bundle(); b.putSerializable("name", myClassObject); intent.putExtras(b);
public class Channel implements Serializable, Parcelable { /** */ private static final long serialVersionUID = 4861597073026532544L; private String cid; private String uniqueID; private String name; private String logo; private String thumb; /** * @return The cid */ public String getCid() { return cid; } /** * @param cid * The cid to set */ public void setCid(String cid) { this.cid = cid; } /** * @return The uniqueID */ public String getUniqueID() { return uniqueID; } /** * @param uniqueID * The uniqueID to set */ public void setUniqueID(String uniqueID) { this.uniqueID = uniqueID; } /** * @return The name */ public String getName() { return name; } /** * @param name * The name to set */ public void setName(String name) { this.name = name; } /** * @return the logo */ public String getLogo() { return logo; } /** * @param logo * The logo to set */ public void setLogo(String logo) { this.logo = logo; } /** * @return the thumb */ public String getThumb() { return thumb; } /** * @param thumb * The thumb to set */ public void setThumb(String thumb) { this.thumb = thumb; } public Channel(Parcel in) { super(); readFromParcel(in); } public static final Parcelable.Creator<Channel> CREATOR = new Parcelable.Creator<Channel>() { public Channel createFromParcel(Parcel in) { return new Channel(in); } public Channel[] newArray(int size) { return new Channel[size]; } }; public void readFromParcel(Parcel in) { String[] result = new String[5]; in.readStringArray(result); this.cid = result[0]; this.uniqueID = result[1]; this.name = result[2]; this.logo = result[3]; this.thumb = result[4]; } public int describeContents() { return 0; } public void writeToParcel(Parcel dest, int flags) { dest.writeStringArray(new String[] { this.cid, this.uniqueID, this.name, this.logo, this.thumb}); } }
Bundle bundle = new Bundle(); bundle.putParcelableArrayList("channel",(ArrayList<Channel>) channels); Intent intent = new Intent(ActivityA.this,ActivityB.class); intent.putExtras(bundle); startActivity(intent);
Bundle getBundle = this.getIntent().getExtras(); List<Channel> channelsList = getBundle.getParcelableArrayList("channel");
final Object obj1 = new Object(); final Intent in = new Intent(); in.putExtra(EXTRA_TEST, new Sharable(obj1));
final Sharable s = in.getExtras().getParcelable(EXTRA_TEST); final Object obj2 = s.obj(); public final class Sharable implements Parcelable { private Object mObject; public static final Parcelable.Creator < Sharable > CREATOR = new Parcelable.Creator < Sharable > () { public Sharable createFromParcel(Parcel in ) { return new Sharable( in ); } @Override public Sharable[] newArray(int size) { return new Sharable[size]; } }; public Sharable(final Object obj) { mObject = obj; } public Sharable(Parcel in ) { readFromParcel( in ); } Object obj() { return mObject; } @Override public int describeContents() { return 0; } @Override public void writeToParcel(final Parcel out, int flags) { final long val = SystemClock.elapsedRealtime(); out.writeLong(val); put(val, mObject); } private void readFromParcel(final Parcel in ) { final long val = in .readLong(); mObject = get(val); } private static final HashMap < Long, Object > sSharableMap = new HashMap < Long, Object > (3); synchronized private static void put(long key, final Object obj) { sSharableMap.put(key, obj); } synchronized private static Object get(long key) { return sSharableMap.remove(key); } }
BeanClass cb = intent.getSerializableExtra("class");
public class Qabir { private int age; private String name; Qabir(){ } Qabir(int age,String name){ this.age=age; this.name=name; } public String toJSON(){ return "{age:" + age + ",name:\"" +name +"\"}"; } public void initilizeWithJSONString(String jsonString){ JSONObject json; try { json =new JSONObject(jsonString ); age=json.getInt("age"); name=json.getString("name"); } catch (JSONException e) { e.printStackTrace(); } } }
Qabir q= new Qabir(22,"KQ"); Intent in=new Intent(this,SubActivity.class); in.putExtra("obj", q.toJSON()); startActivity( in);
Qabir q =new Qabir(); q.initilizeWithJSONString(getIntent().getStringExtra("obj"));
Intent intent = new Intent(getBaseContext(), YourActivity.class); intent.putExtra("USER_NAME", "xyz@gmail.com"); startActivity(intent);
String s = getIntent().getStringExtra("USER_NAME");
class Employee{ private String empId; private int age; print Double salary; getters... setters... }
String strEmp = new Gson().toJson(emp); Intent intent = new Intent(getBaseContext(), YourActivity.class); intent.putExtra("EMP", strEmp); startActivity(intent); Bundle bundle = getIntent().getExtras(); String empStr = bundle.getString("EMP"); Gson gson = new Gson(); Type type = new TypeToken<Employee>() { }.getType(); Employee selectedEmp = gson.fromJson(empStr, type);
Bundle bundle = new Bundle(); bundle.putSerializable(key1, value1); bundle.putSerializable(key2, value2); bundle.putSerializable(key3, value3); intent.putExtras(bundle);
Bundle bundle = new Bundle(); for (String key : bundle.keySet()) { value = bundle.getSerializable(key)); }
public class IntentMailBox { static Queue<Object> content = new LinkedList<Object>(); }
IntentMailBox.content.add(level); Intent intent = new Intent(LevelsActivity.this, LevelActivity.class); startActivity(intent);
if (IntentMailBox.content.size()>0) level = (Level) IntentMailBox.content.poll(); else
Intent intent = new Intent(context,SomeActivity.class); intent.putExtra("key",value); startActivity(intent);
public class SomeActivity extends AppCompactActivity { public void onCreate(...){ ... SomeObject someObject = getIntent().getExtras().getParceable("key"); } }
public interface IPayload { public void sayHello(String name, int age); }
public class Activity_1 extends Activity implements IPayload { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); GNLauncher.get().ping(this); } @Override public void sayHello(String name, int age) { Log.d("gnlib_test", "Hello " + name + "! \nYour age is: " + age); } }
public class Activity_2 extends Activity { public void onClick(View v) { ((IPayload)GNLauncher.get().getProxy(this, IPayload.class, Activity_1.class)).sayHello(name, age); } }
Intent ii = new Intent(examreport_select.this, BarChartActivity.class); ii.putExtra("IntentExamResultDetail", (Serializable) your List<ArraList<String>> object here); startActivity(ii);
List<ArrayList<String>> aa = (List<ArrayList<String>>) getIntent() .getSerializableExtra("IntentExamResultDetail");
SupplierDetails poSuppliersDetails = new SupplierDetails();
Intent iPODetails = new Intent(ActivityOne.this, ActivityTwo.class); iPODetails.putExtra("poSuppliersDetails", poSuppliersDetails);
private SupplierDetails supplierDetails; supplierDetails =(SupplierDetails) getIntent().getSerializableExtra("poSuppliersDetails");
startActivity(new Intent(getBaseContext(),GetActivity.class).putExtra("passingkey","passingvalue"));
String myvalue= getIntent().getExtras("passingkey");
public class MyBinder extends Binder { private Object myObject; public MyBinder(Object object) { myObject = object; } public Object getObject() { return myObject; } }
public class MyParcelable implements Parcelable { private Object myObject; public MyParcelable() { } public MyParcelable(Parcel parcel) { myObject = ((MyBinder)parcel.readStrongBinder()).getObject(); } public void setObject(Object object) { myObject = object; } public Object getObject() { return myObject; } public void writeToParcel(Parcel parcel, int flags) { parcel.writeStrongBinder(new MyBinder(myObject)); } public int describeContents() { return myObject == null ? 0 : 1; } public static final Parcelable.Creator<MyParcelable> CREATOR = new Parcelable.Creator<MyParcelable>() { public MyParcelable createFromParcel(Parcel parcel) { return new MyParcelable(parcel); } public MyParcelable[] newArray(int length) { return new MyParcelable[length]; } }; }
Object myObject = "some object"; MyParcelable myParcelable = new MyParcelable(); myParcelable.setObject(myObject); intent.putExtra("MyParcelable", myParcelable);
myParcelable = (MyParcelable) getIntent().getExtras().getParcelable("MyParcelable"); myObject = myParcelable.getObject();
FileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); List items = upload.parseRequest(request);
SEVERE: Servlet.service() for servlet UploadServlet threw exception javax.servlet.ServletException: Servlet execution threw an exception at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:313) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:298) at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:852) at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:588) at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:489) at java.lang.Thread.run(Thread.java:637)
@WebServlet("/upload") @MultipartConfig public class UploadServlet extends HttpServlet { }
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String description = request.getParameter("description"); Part filePart = request.getPart("file"); String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString(); InputStream fileContent = filePart.getInputStream(); }
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List<Part> fileParts = request.getParts().stream().filter(part -> "file".equals(part.getName())).collect(Collectors.toList()); for (Part filePart : fileParts) { String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString(); InputStream fileContent = filePart.getInputStream(); } }
private static String getSubmittedFileName(Part part) { for (String cd : part.getHeader("content-disposition").split(";")) { if (cd.trim().startsWith("filename")) { String fileName = cd.substring(cd.indexOf( return fileName.substring(fileName.lastIndexOf( } } return null; }
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { List<FileItem> items = new ServletFileUpload(new DiskFileItemFactory()).parseRequest(request); for (FileItem item : items) { if (item.isFormField()) { String fieldName = item.getFieldName(); String fieldValue = item.getString(); } else { String fieldName = item.getFieldName(); String fileName = FilenameUtils.getName(item.getName()); InputStream fileContent = item.getInputStream(); } } } catch (FileUploadException e) { throw new ServletException("Cannot parse multipart request.", e); } }
private static String getValue(Part part) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(part.getInputStream(), "UTF-8")); StringBuilder value = new StringBuilder(); char[] buffer = new char[1024]; for (int length = 0; (length = reader.read(buffer)) > 0;) { value.append(buffer, 0, length); } return value.toString(); }
String description = getValue(request.getPart("description"));
<form action="upload" method="post" enctype="multipart/form-data"> <input type="file" name="file" /> <input type="submit" value="Upload"/> </form>
@RequestMapping(value = "/upload", method = RequestMethod.POST) public void handleUpload(@RequestParam("file") MultipartFile file) throws IOException { if (!file.isEmpty()) { byte[] bytes = file.getBytes(); } }
public class ServletCommonfunctions extends HttpServlet implements Connections { private static final long serialVersionUID = 1L; public ServletCommonfunctions() {} protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {} public SortedMap<String, String> savefilesindirectory( HttpServletRequest request, HttpServletResponse response) throws IOException { SortedMap<String, String> key_values = new TreeMap<String, String>(); String dist = null, fact = null; PrintWriter out = response.getWriter(); File file; String filePath = "E:\\FSPATH1\\2KL06CS048\\"; System.out.println("Directory Created ????????????" + new File(filePath).mkdir()); int maxFileSize = 5000 * 1024; int maxMemSize = 5000 * 1024; String contentType = request.getContentType(); if ((contentType.indexOf("multipart/form-data") >= 0)) { DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setSizeThreshold(maxMemSize); factory.setRepository(new File(filePath)); ServletFileUpload upload = new ServletFileUpload(factory); upload.setSizeMax(maxFileSize); try { @SuppressWarnings("unchecked") List<FileItem> fileItems = upload.parseRequest(request); Iterator<FileItem> i = fileItems.iterator(); while (i.hasNext()) { FileItem fi = (FileItem) i.next(); if (!fi.isFormField()) { String fileName = fi.getName(); if (fileName.lastIndexOf("\\") >= 0) { file = new File(filePath + fileName.substring(fileName .lastIndexOf("\\"))); } else { file = new File(filePath + fileName.substring(fileName .lastIndexOf("\\") + 1)); } fi.write(file); } else { key_values.put(fi.getFieldName(), fi.getString()); } } } catch (Exception ex) { System.out.println(ex); } } return key_values; } }
<servlet> <servlet-name>jsp</servlet-name> <servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class> <multipart-config> <max-file-size>3145728</max-file-size> <max-request-size>5242880</max-request-size> </multipart-config> <init-param> <param-name>fork</param-name> <param-value>false</param-value> </init-param> <init-param> <param-name>xpoweredBy</param-name> <param-value>false</param-value> </init-param> <load-on-startup>3</load-on-startup> </servlet>
<multipart-config> <max-file-size>3145728</max-file-size> <max-request-size>5242880</max-request-size> </multipart-config>
<form method="post" enctype="multipart/form-data" name="Form" > <input type="file" name="fFoto" id="fFoto" value="" /></td> <input type="file" name="fResumen" id="fResumen" value=""/>
InputStream isFoto = request.getPart("fFoto").getInputStream(); InputStream isResu = request.getPart("fResumen").getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte buf[] = new byte[8192]; int qt = 0; while ((qt = isResu.read(buf)) != -1) { baos.write(buf, 0, qt); } String sResumen = baos.toString();
<form action="/handleform" method="post" enctype="multipart/form-data"> <input type="text" name="name" /> <input type="text" name="age" /> <input type="file" name="file" /> <input type="submit" /> </form>
@Controller public class FormController { @RequestMapping(value="/handleform",method= RequestMethod.POST) ModelAndView register(@RequestParam String name, @RequestParam int age, @RequestParam MultipartFile file) throws ServletException, IOException { System.out.println(name); System.out.println(age); if(!file.isEmpty()){ byte[] bytes = file.getBytes(); String filename = file.getOriginalFilename(); BufferedOutputStream stream =new BufferedOutputStream(new FileOutputStream(new File("D:/" + filename))); stream.write(bytes); stream.flush(); stream.close(); } return new ModelAndView("index"); } }
Pasted from <http: <?xml version="1.0" encoding="UTF-8" standalone="no"?> <web:web-app xmlns:app="http: <dep:environment> <dep:moduleId> <dep:groupId>DataStar</dep:groupId> <dep:artifactId>DataStar</dep:artifactId> <dep:version>1.0</dep:version> <dep:type>car</dep:type> </dep:moduleId> <!--Don <dep:hidden-classes> <dep:filter>org.apache.commons.io</dep:filter> <dep:filter>org.apache.commons.fileupload</dep:filter> </dep:hidden-classes> <dep:inverse-classloading/> </dep:environment> <web:context-root>/DataStar</web:context-root> </web:web-app>
DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setRepository(new File(DataSources.TORRENTS_DIR())); ServletFileUpload fileUpload = new ServletFileUpload(factory); List<FileItem> items = fileUpload.parseRequest(req.raw()); FileItem item = items.stream() .filter(e -> "the_upload_name".equals(e.getFieldName())) .findFirst().get(); String fileName = item.getName(); item.write(new File(dir, fileName)); log.info(fileName);
<form action="UploadFileServlet" method="post"> <input type="text" name="description" /> <input type="file" name="file" /> <input type="submit" /> </form>
package com.abc..servlet; import java.io.File; --------- -------- /** * Servlet implementation class UploadFileServlet */ public class UploadFileServlet extends HttpServlet { private static final long serialVersionUID = 1L; public UploadFileServlet() { super(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.sendRedirect("../jsp/ErrorPage.jsp"); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out = response.getWriter(); HttpSession httpSession = request.getSession(); String filePathUpload = (String) httpSession.getAttribute("path")!=null ? httpSession.getAttribute("path").toString() : "" ; String path1 = filePathUpload; String filename = null; File path = null; FileItem item=null; boolean isMultipart = ServletFileUpload.isMultipartContent(request); if (isMultipart) { FileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); String FieldName = ""; try { List items = upload.parseRequest(request); Iterator iterator = items.iterator(); while (iterator.hasNext()) { item = (FileItem) iterator.next(); if (fieldname.equals("description")) { description = item.getString(); } } if (!item.isFormField()) { filename = item.getName(); path = new File(path1 + File.separator); if (!path.exists()) { boolean status = path.mkdirs(); } File uploadedFile = new File(path + Filename); item.write(uploadedFile); } } else { f1 = item.getName(); } } response.sendRedirect("welcome.jsp"); } catch (FileUploadException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } }
String loc="./webapps/prjct name/server folder/"+contentid+extension; File uploadFile=new File(loc); item.write(uploadFile);
<form action="upload" method="post" enctype="multipart/form-data"> <input type="file" name="fileattachments" multiple="multiple"/> <input type="submit" /> </form>
<html> <head> <title>File Uploading Form</title> </head> <body> <h3>File Upload:</h3> Select a file to upload: <br /> <form action="UploadServlet" method="post" enctype="multipart/form-data"> <input type="file" name="file" size="50" /> <br /> <input type="submit" value="Upload File" /> </form> </body> </html>
import java.io.*; import java.util.*; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.commons.fileupload.FileItem; import org.apache.commons.fileupload.FileUploadException; import org.apache.commons.fileupload.disk.DiskFileItemFactory; import org.apache.commons.fileupload.servlet.ServletFileUpload; import org.apache.commons.io.output.*; public class UploadServlet extends HttpServlet { private boolean isMultipart; private String filePath; private int maxFileSize = 50 * 1024; private int maxMemSize = 4 * 1024; private File file ; public void init( ){ filePath = getServletContext().getInitParameter("file-upload"); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { isMultipart = ServletFileUpload.isMultipartContent(request); response.setContentType("text/html"); java.io.PrintWriter out = response.getWriter( ); if( !isMultipart ){ out.println("<html>"); out.println("<head>"); out.println("<title>Servlet upload</title>"); out.println("</head>"); out.println("<body>"); out.println("<p>No file uploaded</p>"); out.println("</body>"); out.println("</html>"); return; } DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setSizeThreshold(maxMemSize); factory.setRepository(new File("c:\\temp")); ServletFileUpload upload = new ServletFileUpload(factory); upload.setSizeMax( maxFileSize ); try{ List fileItems = upload.parseRequest(request); Iterator i = fileItems.iterator(); out.println("<html>"); out.println("<head>"); out.println("<title>Servlet upload</title>"); out.println("</head>"); out.println("<body>"); while ( i.hasNext () ) { FileItem fi = (FileItem)i.next(); if ( !fi.isFormField () ) { String fieldName = fi.getFieldName(); String fileName = fi.getName(); String contentType = fi.getContentType(); boolean isInMemory = fi.isInMemory(); long sizeInBytes = fi.getSize(); if( fileName.lastIndexOf("\\") >= 0 ){ file = new File( filePath + fileName.substring( fileName.lastIndexOf("\\"))) ; }else{ file = new File( filePath + fileName.substring(fileName.lastIndexOf("\\")+1)) ; } fi.write( file ) ; out.println("Uploaded Filename: " + fileName + "<br>"); } } out.println("</body>"); out.println("</html>"); }catch(Exception ex) { System.out.println(ex); } } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, java.io.IOException { throw new ServletException("GET method used with " + getClass( ).getName( )+": POST method required."); } }
<servlet> <servlet-name>UploadServlet</servlet-name> <servlet-class>UploadServlet</servlet-class> </servlet> <servlet-mapping> <servlet-name>UploadServlet</servlet-name> <url-pattern>/UploadServlet</url-pattern> </servlet-mapping>
List<? extends Number> foo3 = new ArrayList<Number>(); List<? extends Number> foo3 = new ArrayList<Integer>(); List<? extends Number> foo3 = new ArrayList<Double>();
List<? super Integer> foo3 = new ArrayList<Integer>(); List<? super Integer> foo3 = new ArrayList<Number>(); List<? super Integer> foo3 = new ArrayList<Object>();
public class Collections { public static <T> void copy(List<? super T> dest, List<? extends T> src) { for (int i = 0; i < src.size(); i++) dest.set(i, src.get(i)); } }
1) new ArrayList<C2>(): can store C2 D1 D2 E1 E2 E3 E4 2) new ArrayList<D1>(): can store D1 E1 E2 3) new ArrayList<D2>(): can store D2 E3 E4 4) new ArrayList<E1>(): can store E1 5) new ArrayList<E2>(): can store E2 6) new ArrayList<E3>(): can store E3 7) new ArrayList<E4>(): can store E4
1) new ArrayList<A1>(): can store A1 B1 B2 C1 C2 D1 D2 E1 E2 E3 E4 2) new ArrayList<A2>(): can store A2 B2 C1 C2 D1 D2 E1 E2 E3 E4 3) new ArrayList<A3>(): can store A3 B3 C2 C3 D1 D2 E1 E2 E3 E4 4) new ArrayList<A4>(): can store A4 B3 B4 C2 C3 D1 D2 E1 E2 E3 E4 5) new ArrayList<B2>(): can store B2 C1 C2 D1 D2 E1 E2 E3 E4 6) new ArrayList<B3>(): can store B3 C2 C3 D1 D2 E1 E2 E3 E4 7) new ArrayList<C2>(): can store C2 D1 D2 E1 E2 E3 E4
interface A1{} interface A2{} interface A3{} interface A4{} interface B1 extends A1{} interface B2 extends A1,A2{} interface B3 extends A3,A4{} interface B4 extends A4{} interface C1 extends B2{} interface C2 extends B2,B3{} interface C3 extends B3{} interface D1 extends C1,C2{} interface D2 extends C2{} interface E1 extends D1{} interface E2 extends D1{} interface E3 extends D2{} interface E4 extends D2{}
public class Fruit{} public class Melon extends Fruit{} public class WaterMelon extends Melon{}
WaterMelon waterMelon = fruitExtendedList.get(position)
class A { } class B extends A { } class C extends B { }
|-------------------------|-------------------|---------------------------------| | wildcard | get | assign | |-------------------------|-------------------|---------------------------------| | List<? extends C> | A B C | List<C> | |-------------------------|-------------------|---------------------------------| | List<? extends B> | A B | List<B> List<C> | |-------------------------|-------------------|---------------------------------| | List<? extends A> | A | List<A> List<B> List<C> | |-------------------------|-------------------|---------------------------------|
|-------------------------|-------------------|-------------------------------------------| | wildcard | add | assign | |-------------------------|-------------------|-------------------------------------------| | List<? super C> | C | List<Object> List<A> List<B> List<C> | |-------------------------|-------------------|-------------------------------------------| | List<? super B> | B C | List<Object> List<A> List<B> | |-------------------------|-------------------|-------------------------------------------| | List<? super A> | A B C | List<Object> List<A> | |-------------------------|-------------------|-------------------------------------------|
class Holder<T> { T v; T get() { return v; } void set(T n) { v=n; } } class A { public static void main(String[]args) { Holder<? extends Number> he = new Holder(); Holder<? super Number> hs = new Holder(); Integer i; Number n; Object o; i = hs.get(); n = hs.get(); o = hs.get(); hs.set(i); hs.set(n); hs.set(o); i = he.get(); n = he.get(); o = he.get(); he.set(i); he.set(n); he.set(o); } }
List<?> listUknown = new ArrayList<A>(); List<? extends A> listUknown = new ArrayList<A>(); List<? super A> listUknown = new ArrayList<A>();
int totalFuel(List<? extends Vehicle> list) { int total = 0; for(Vehicle v : list) { total += v.getFuel(); } return total;}
int totalValue(Valuer<? super Vehicle> valuer) { int total = 0; for(Vehicle v : vehicles) { total += valuer.evaluate(v); } return total;}
List<? extends T> Object = new List<T>(); List<? extends T> Object = new List<U>(); List<? extends T> Object = new List<V>();
List<? extends T> Object = new List<S>(); List<? extends T> Object = new List<O>();
List<? super T> Object = new List<T>(); List<? super T> Object = new List<S>(); List<? super T> Object = new List<O>();
List<? super T> Object = new List<U>(); List<? super T> Object = new List<V>();
List<? extends T> Object = new List<T>(); List<? extends T> Object = new List<U>(); List<? extends T> Object = new List<V>();
Object.add(new T()); Object.add(new U()); Object.add(new V()); Object.add(new S()); Object.add(new O());
List<? super T> Object = new List<T>(); List<? super T> Object = new List<S>(); List<? super T> Object = new List<O>();
List<String> messages = Arrays.asList("Hello", "World!", "How", "Are", "You");
1. new ArrayList<String>(); 2. Arrays.asList("A", "B", "C")
1. Lists.newArrayList("Mike", "John", "Lesly"); 2. Lists.asList("A","B", new String [] {"C", "D"});
1. Collections.unmodifiableList(new ArrayList<String>(Arrays.asList("A","B"))); 2. ImmutableList.builder() .add("A") .add("B").build(); 3. ImmutableList.of("A", "B"); 4. ImmutableList.copyOf(Lists.newArrayList("A", "B", "C"));
1. Collections.emptyList(); 2. Collections.EMPTY_LIST;
1. Lists.charactersOf("String") 2. Lists.newArrayList(Splitter.fixedLength(1).split("String"))
String[] myStrings = new String[] {"Elem1","Elem2","Elem3","Elem4","Elem5"}; List mylist = Arrays.asList(myStrings ); Iterator itr= mylist.iterator(); System.out.println("Displaying List Elements,"); while(itr.hasNext()) System.out.println(itr.next());
List<String> list = ImmutableList.of("foo", "bar");
List<Integer> list = new ArrayList<>(Arrays.asList(3, 4));
List<Integer> immutableList = List.of(1, 2); List<Integer> mutableList = new ArrayList<>(List.of(3, 4));
var list1 = List.of(1, 2); var list2 = new ArrayList<>(List.of(3, 4)); var list3 = new ArrayList<String>();
List<String> list = new ArrayList<>(); List list = new ArrayList();
List<String> arrayList = new ArrayList<>(); List<String> linkedList = new LinkedList<>();
Collections.unmodifiableList(Arrays.asList("A", "B", "C"));
import com.google.common.collect.Lists; List<String> strings = Lists.newArrayList(); List<Integer> integers = Lists.newLinkedList();
List<Integer> immutableList = List.of(1, 2, 3, 4, 5); List<Integer> mutableList = new ArrayList<>(immutableList);
List<String> list = new ArrayList<String>(){{ add("a"); add("b"); }};
List<String> arrList = new ArrayList<String>(); arrList.add("one");
List<String> listA = Stream.of("a", "B", "C").collect(Collectors.toList()); List<Integer> listB = IntStream.range(10, 20).boxed().collect(Collectors.toList()); List<Double> listC = DoubleStream.generate(() -> { return new Random().nextDouble(); }).limit(10).boxed().collect(Collectors.toList()); LinkedList<Integer> listD = Stream.iterate(0, x -> x++).limit(10).collect(Collectors.toCollection(LinkedList::new));
List<String> list1 = Lists.mutable.empty(); List<String> list2 = Lists.mutable.of("One", "Two", "Three");
ImmutableList<String> list3 = Lists.immutable.empty(); ImmutableList<String> list4 = Lists.immutable.of("One", "Two", "Three");
MutableIntList list5 = IntLists.mutable.empty(); MutableIntList list6 = IntLists.mutable.of(1, 2, 3); ImmutableIntList list7 = IntLists.immutable.empty(); ImmutableIntList list8 = IntLists.immutable.of(1, 2, 3);
MutableLongList longList = LongLists.mutable.of(1L, 2L, 3L); MutableCharList charList = CharLists.mutable.of( MutableShortList shortList = ShortLists.mutable.of((short) 1, (short) 2, (short) 3); MutableByteList byteList = ByteLists.mutable.of((byte) 1, (byte) 2, (byte) 3); MutableBooleanList booleanList = BooleanLists.mutable.of(true, false); MutableFloatList floatList = FloatLists.mutable.of(1.0f, 2.0f, 3.0f); MutableDoubleList doubleList = DoubleLists.mutable.of(1.0, 2.0, 3.0);
List<String> messages = Arrays.asList("bla1", "bla2", "bla3");
List<String> list1 = Lists.mutable.empty(); List<String> list2 = Lists.mutable.of("One", "Two", "Three");
List<String> singList = Collections.singletonList("stackoverlow");
package com.xxx; public class B { public B() { System.out.println("creating bean B: " + this); } } package com.xxx; public class C { public C() { System.out.println("creating bean C: " + this); } } package com.yyy; import com.xxx.B; import com.xxx.C; public class A { private B bbb; private C ccc; public A() { System.out.println("creating bean A: " + this); } public void setBbb(B bbb) { System.out.println("setting A.bbb with " + bbb); this.bbb = bbb; } public void setCcc(C ccc) { System.out.println("setting A.ccc with " + ccc); this.ccc = ccc; } }
<bean id="bBean" class="com.xxx.B" /> <bean id="cBean" class="com.xxx.C" /> <bean id="aBean" class="com.yyy.A"> <property name="bbb" ref="bBean" /> <property name="ccc" ref="cBean" /> </bean>
creating bean B: com.xxx.B@c2ff5 creating bean C: com.xxx.C@1e8a1f6 creating bean A: com.yyy.A@1e152c5 setting A.bbb with com.xxx.B@c2ff5 setting A.ccc with com.xxx.C@1e8a1f6
package com.yyy; import org.springframework.beans.factory.annotation.Autowired; import com.xxx.B; import com.xxx.C; public class A { private B bbb; private C ccc; public A() { System.out.println("creating bean A: " + this); } @Autowired public void setBbb(B bbb) { System.out.println("setting A.bbb with " + bbb); this.bbb = bbb; } @Autowired public void setCcc(C ccc) { System.out.println("setting A.ccc with " + ccc); this.ccc = ccc; } }
<property name="bbb" ref="bBean" /> <property name="ccc" ref="cBean" />
<bean id="bBean" class="com.xxx.B" /> <bean id="cBean" class="com.xxx.C" /> <bean id="aBean" class="com.yyy.A" />
creating bean B: com.xxx.B@5e5a50 creating bean C: com.xxx.C@54a328 creating bean A: com.yyy.A@a3d4cf
<context:annotation-config /> <bean id="bBean" class="com.xxx.B" /> <bean id="cBean" class="com.xxx.C" /> <bean id="aBean" class="com.yyy.A" />
creating bean B: com.xxx.B@15663a2 creating bean C: com.xxx.C@cd5f8b creating bean A: com.yyy.A@157aa53 setting A.bbb with com.xxx.B@15663a2 setting A.ccc with com.xxx.C@cd5f8b
package com.xxx; import org.springframework.stereotype.Component; @Component public class B { public B() { System.out.println("creating bean B: " + this); } } package com.xxx; import org.springframework.stereotype.Component; @Component public class C { public C() { System.out.println("creating bean C: " + this); } } package com.yyy; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.xxx.B; import com.xxx.C; @Component public class A { private B bbb; private C ccc; public A() { System.out.println("creating bean A: " + this); } @Autowired public void setBbb(B bbb) { System.out.println("setting A.bbb with " + bbb); this.bbb = bbb; } @Autowired public void setCcc(C ccc) { System.out.println("setting A.ccc with " + ccc); this.ccc = ccc; } }
creating bean B: com.xxx.B@1be0f0a creating bean C: com.xxx.C@80d1ff
<context:component-scan base-package="com.xxx,com.yyy" />
creating bean B: com.xxx.B@cd5f8b creating bean C: com.xxx.C@15ac3c9 creating bean A: com.yyy.A@ec4a87 setting A.bbb with com.xxx.B@cd5f8b setting A.ccc with com.xxx.C@15ac3c9
<context:component-scan base-package="com.xxx" /> <bean id="aBean" class="com.yyy.A" />
creating bean B: com.xxx.B@157aa53 creating bean C: com.xxx.C@ec4a87 creating bean A: com.yyy.A@1d64c37 setting A.bbb with com.xxx.B@157aa53 setting A.ccc with com.xxx.C@ec4a87
<context:annotation-config /> <context:component-scan base-package="com.xxx" /> <bean id="aBean" class="com.yyy.A" />
creating bean B: com.xxx.B@157aa53 creating bean C: com.xxx.C@ec4a87 creating bean A: com.yyy.A@1d64c37 setting A.bbb with com.xxx.B@157aa53 setting A.ccc with com.xxx.C@ec4a87
<context:annotation-config /> <context:component-scan base-package="com.xxx" /> <bean id="aBean" class="com.yyy.A" /> <bean id="bla" class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" /> <bean id="bla1" class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" /> <bean id="bla2" class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" /> <bean id="bla3" class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" />
creating bean B: com.xxx.B@157aa53 creating bean C: com.xxx.C@ec4a87 creating bean A: com.yyy.A@25d2b2 setting A.bbb with com.xxx.B@157aa53 setting A.ccc with com.xxx.C@ec4a87
<context:component-scan base-package="org.package"/>
<bean id="serviceBeanA" class="com.something.CarServiceImpl" /> <bean id="serviceBeanB" class="com.something.PersonServiceImpl" /> <bean id="repositoryBeanA" class="com.something.CarRepository" /> <bean id="repositoryBeanB" class="com.something.PersonRepository" />
<context:component-scan /> implicitly enables <context:annotation-config/>
<context:annotation-config/> <!-- is used to activate the annotation for beans --> <context:component-scan base-package="x.y.MyClass" /> <!-- is for the Spring IOC container to look for the beans in the base package. -->
<context:annotation-config/> <!-- activates the annotations --> <context:component-scan base-package="x.y.MyClass" /> <!-- activates the annotations + register the beans by looking inside the base-package -->
<context:component-scan basePackages="" annotation-config="false"/>
[self performSelector:@selector(DoSomething) withObject:nil afterDelay:5];
final Handler handler = new Handler(); handler.postDelayed(new Runnable() { @Override public void run() { } }, 100);
new Timer().schedule(new TimerTask() { @Override public void run() { } }, 2000);
private static final ScheduledExecutorService worker = Executors.newSingleThreadScheduledExecutor(); void someMethod() {  Runnable task = new Runnable() { public void run() { } }; worker.schedule(task, 5, TimeUnit.SECONDS);  }
new Handler(Looper.getMainLooper()).postDelayed(new Runnable() { @Override public void run() { } }, 5000);
runOnUiThread(new Runnable() { @Override public void run() { final Handler handler = new Handler(); handler.postDelayed(new Runnable() { @Override public void run() { } }, 1000); } });
Handler myHandler = new DoSomething(); Message m = new Message(); m.obj = c; myHandler.sendMessageDelayed(m, 1000); class DoSomething extends Handler { @Override public void handleMessage(Message msg) { MyObject o = (MyObject) msg.obj; } }
import java.util.Timer; import java.util.TimerTask; class Test { public static void main( String [] args ) { int delay = 5000; Timer timer = new Timer(); timer.schedule( new TimerTask(){ public void run() { System.out.println("Wait, what..:"); } }, delay); System.out.println("Would it run?"); } }
runOnUiThread(new Runnable() { @Override public void run() { new Handler().postDelayed(new Runnable() { @Override public void run() { } }, 1000); } });
mView.postDelayed(new Runnable() { @Override public void run() { } }, 1000);
new Handler().postDelayed(new Runnable() { @Override public void run() { } }, 100);
final Handler handler = new Handler(); Timer t = new Timer(); t.schedule(new TimerTask() { public void run() { handler.post(new Runnable() { public void run() { } }); } }, 5000);
new Handler().postDelayed(() -> callMyMethod(), 2000);
Handler handler = new Handler(); handler.postDelayed(() -> callMyMethod(), 2000); handler.removeCallbacksAndMessages(null);
new Handler().postDelayed(new Runnable() { @Override public void run() { } }, 5000);
public static void CallWithDelay(long miliseconds, final Activity activity, final String methodName) { new Handler().postDelayed(new Runnable() { @Override public void run() { try { Method method = activity.getClass().getMethod(methodName); method.invoke(activity); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } }, miliseconds); }
Handler().postDelayed({ TODO("Do something") }, 2000)
Timer().schedule(object : TimerTask() { override fun run() { TODO("Do something") } }, 2000)
Timer().schedule(timerTask { TODO("Do something") }, 2000)
Executors.newSingleThreadScheduledExecutor().schedule({ TODO("Do something") }, 2, TimeUnit.SECONDS)
new Handler().postDelayed(new Runnable() { @Override public void run() { } }, 2000);
new Timer().schedule(new TimerTask() { @Override public void run() { } }, 2000);
private static final ScheduledExecutorService worker = Executors.newSingleThreadScheduledExecutor(); Runnable runnable = new Runnable() { public void run() { } }; worker.schedule(runnable, 2, TimeUnit.SECONDS);
import android.os.CountDownTimer; new CountDownTimer(3000, 1000) { public void onTick(long millisUntilFinished) { Log.d("log", millisUntilFinished / 1000); } public void onFinish() { } }.start();
Handler(Looper.getMainLooper()).postDelayed({ if(activity != null && activity?.isFinishing == false){ txtNewInfo.visibility = View.GONE } }, NEW_INFO_SHOW_TIMEOUT_MS)
private fun showFacebookStylePlus1NewsFeedOnPushReceived(){ A35Log.v(TAG, "showFacebookStylePlus1NewsFeedOnPushReceived") if(activity != null && activity?.isFinishing == false){ txtNewInfo.visibility = View.VISIBLE mHandler.postDelayed({ if(activity != null && activity?.isFinishing == false){ txtNewInfo.visibility = View.GONE } }, NEW_INFO_SHOW_TIMEOUT_MS) } }
override fun onPause() { super.onPause() mHandler.removeCallbacks(null) }
fun doActionAfterDelay() launch(UI) { delay(MS_TO_DELAY) actionToTake() } }
fun doActionAfterDelay() = launch(UI){ delay(MS_TO_DELAY) actionToTake() }
var mDelayedJob: Job? = null fun doActionAfterDelay() mDelayedJob = launch(UI) { try { delay(MS_TO_DELAY) actionToTake() }catch(ex: JobCancellationException){ showFancyToast("Delayed Job canceled", true, FancyToast.ERROR, "Delayed Job canceled: ${ex.message}") } } } }
override fun onPause() { super.onPause() if(mDelayedJob != null && mDelayedJob!!.isActive) { A35Log.v(mClassTag, "canceling delayed job") mDelayedJob?.cancel() } }
mLoadJob = launch(UI){ try { withTimeout(4000) { withContext(DefaultDispatcher) { mDeviceModelList.addArrayList(SSDBHelper.getAllDevices()) } } showFancyToast("Loading complete", true, FancyToast.SUCCESS) }catch(ex: JobCancellationException){ showFancyToast("Save canceled", true, FancyToast.ERROR, "Save canceled: ${ex.message}") }catch (ex: TimeoutCancellationException) { showFancyToast("Timed out saving, please try again or press back", true, FancyToast.ERROR, "Timed out saving to database: ${ex.message}") }catch(ex: Exception){ showFancyToast("Error saving to database, please try again or press back", true, FancyToast.ERROR, "Error saving to database: ${ex.message}") } }
final Handler handler = new Handler(Looper.getMainLooper()); handler.postDelayed(new Runnable() { @Override public void run() { } }, 100);
handler.removeMessages(int what); handler.removeCallbacks(Runnable r)
public class SimpleDelayAnimation extends Animation implements Animation.AnimationListener { Runnable callBack; public SimpleDelayAnimation(Runnable runnable, int delayTimeMilli) { setDuration(delayTimeMilli); callBack = runnable; setAnimationListener(this); } @Override public void onAnimationStart(Animation animation) { } @Override public void onAnimationEnd(Animation animation) { callBack.run(); } @Override public void onAnimationRepeat(Animation animation) { } }
view.startAnimation(new SimpleDelayAnimation(delayRunnable, 500));
private static long SLEEP_TIME = 2 . . MyLauncher launcher = new MyLauncher(); launcher.start(); . . private class MyLauncher extends Thread { @Override /** * Sleep for 2 seconds as you can also change SLEEP_TIME 2 to any. */ public void run() { try { Thread.sleep(SLEEP_TIME * 1000); } catch (Exception e) { Log.e(TAG, e.getMessage()); } } }
new Handler().postDelayed(new Runnable() { @Override public void run() { } }, 100);
Observable.timer(delay, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(aLong -> { }, Throwable::printStackTrace);
String[] stringArray = stringStream.toArray(String[]::new);
Stream<String> stringStream = ...; String[] stringArray = stringStream.toArray(size -> new String[size]);
Stream<String> stringStream = Stream.of("a", "b", "c"); String[] stringArray = stringStream.toArray(size -> new String[size]); Arrays.stream(stringArray).forEach(System.out::println);
Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9,10); int[] array = stream.mapToInt(x -> x).toArray();
int[]array2 = IntStream.rangeClosed(1, 10).toArray();
String[] myNewArray3 = myNewStream.toArray(String[]::new);
String[] stringList = {"Bachiri","Taoufiq","Abderrahman"};
Stream<String> stringStream = Arrays.stream(stringList);
Stream<String> myNewStream = stringStream.map(s -> s.toUpperCase());
IntFunction<String[]> intFunction = new IntFunction<String[]>() { @Override public String[] apply(int value) { return new String[value]; } }; String[] myNewArray = myNewStream.toArray(intFunction);
String[] myNewArray2 = myNewStream.toArray(value -> new String[value]);
String[] myNewArray3 = myNewStream.toArray(String[]::new);
public static <T> Collector<T, ?, T[]> toArray( IntFunction<T[]> converter ) { return Collectors.collectingAndThen( Collectors.toList(), list ->list.toArray( converter.apply( list.size() ) ) ); }
List<String> input = Arrays.asList( ..... ); String[] result = input.stream(). .collect( CustomCollectors.**toArray**( String[]::new ) );
Stream<Object> args = Stream.of(BigDecimal.ONE, "Two", 3); System.out.printf("%s, %s, %s!", args.toArray());
String[] stringArray = Arrays.stream(line.split(",")).map(String::trim).toArray(String[]::new);
Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6); Integer[] integers = stream.toArray(it->new Integer[it]);
Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6); int[] arr= stream.mapToInt(x->x.intValue()).toArray();
List<String> persons = new ArrayList<String>(){{add("a"); add("b"); add("c");}}; Stream<String> stream = persons.stream();
try{ String userInput = Long id = Long.parseLong(userInput); }catch(NumberFormatException e){ id = 0; }
try{ File file = new File("my/file/path"); FileInputStream fis = new FileInputStream(file); }catch(FileNotFoundException e){ }
try{ String filePath = File file = new File(filePath); FileInputStream fis = new FileInputStream(file); }catch(FileNotFoundException e){ }
try { attemptLogin(userCredentials); } catch (SQLException sqle) { throw new LoginFailureException("Cannot login!!"); }
try { attemptLogin(userCredentials); } catch (SQLException sqle) { throw new LoginFailureException(sqle); }
try { setStatusMessage("Hello Mr. " + userObject.getName() + ", Welome to my site!); } catch (NullPointerException npe) { sendError("Sorry, your userObject was null. Please contact customer care."); }
if (userObject != null) { setStatusMessage("Hello Mr. " + userObject.getName() + ", Welome to my site!); } else { sendError("Sorry, your userObject was null. Please contact customer care."); }
try { String userAge = (String)request.getParameter("age"); userObject.setAge(Integer.parseInt(strUserAge)); } catch (NumberFormatException npe) { sendError("Sorry, Age is supposed to be an Integer. Please try again."); }
java.lang.Object extended by java.lang.Throwable extended by java.lang.Exception extended by java.lang.RuntimeException extended by java.lang.IllegalArgumentException extended by java.lang.NumberFormatException
String s = "abc"; Object o = s; Integer i = (Integer) o; Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer at Sample.main(Sample.java:9)
public class Foo implements IFoo { @Override public void foo() { System.out.println("I don } }
public class Bar implements IFoo { @Override public void foo() { throw new InterruptedException(); } }
public class Bar implements IFoo { @Override public void foo() throws InterruptedException { throw new InterruptedException(); } }
import java.io.File; import java.nio.file.Files; File file; byte[] fileContent = Files.readAllBytes(file.toPath());
import java.io.RandomAccessFile; RandomAccessFile f = new RandomAccessFile(fileName, "r"); byte[] b = new byte[(int)f.length()]; f.readFully(b);
byte[] array = Files.readAllBytes(new File("/path/to/file").toPath());
public byte[] read(File file) throws IOException, FileTooBigException { if (file.length() > MAX_FILE_SIZE) { throw new FileTooBigException(file); } ByteArrayOutputStream ous = null; InputStream ios = null; try { byte[] buffer = new byte[4096]; ous = new ByteArrayOutputStream(); ios = new FileInputStream(file); int read = 0; while ((read = ios.read(buffer)) != -1) { ous.write(buffer, 0, read); } }finally { try { if (ous != null) ous.close(); } catch (IOException e) { } try { if (ios != null) ios.close(); } catch (IOException e) { } } return ous.toByteArray(); }
public byte[] read(File file) throws IOException, FileTooBigException { if (file.length() > MAX_FILE_SIZE) { throw new FileTooBigException(file); } byte[] buffer = new byte[(int) file.length()]; InputStream ios = null; try { ios = new FileInputStream(file); if (ios.read(buffer) == -1) { throw new IOException( "EOF reached while trying to read the whole file"); } } finally { try { if (ios != null) ios.close(); } catch (IOException e) { } } return buffer; }
public static byte[] readFileToByteArray(File file) throws IOException
import org.apache.commons.io.FileUtils; public class Program { public static void main(String[] args) throws IOException { File file = new File(args[0]); byte[] data = FileUtils.readFileToByteArray(file); ... } }
File f = new File("c:\\wscp.script"); FileInputStream fin = null; FileChannel ch = null; try { fin = new FileInputStream(f); ch = fin.getChannel(); int size = (int) ch.size(); MappedByteBuffer buf = ch.map(MapMode.READ_ONLY, 0, size); byte[] bytes = new byte[size]; buf.get(bytes); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fin != null) { fin.close(); } if (ch != null) { ch.close(); } } catch (IOException e) { e.printStackTrace(); } }
public static byte[] getBytesFromFile(File file) throws IOException { long length = file.length(); if (length > Integer.MAX_VALUE) { throw new IOException("File is too large!"); } byte[] bytes = new byte[(int)length]; int offset = 0; int numRead = 0; InputStream is = new FileInputStream(file); try { while (offset < bytes.length && (numRead=is.read(bytes, offset, bytes.length-offset)) >= 0) { offset += numRead; } } finally { is.close(); } if (offset < bytes.length) { throw new IOException("Could not completely read file "+file.getName()); } return bytes; }
public static byte[] readBytes(InputStream inputStream) throws IOException { byte[] b = new byte[1024]; ByteArrayOutputStream os = new ByteArrayOutputStream(); int c; while ((c = inputStream.read(b)) != -1) { os.write(b, 0, c); } return os.toByteArray(); }
File fff = new File("/path/to/file"); FileInputStream fileInputStream = new FileInputStream(fff); long byteLength = fff.length(); byte[] filecontent = new byte[(int) byteLength]; fileInputStream.read(filecontent, 0, (int) byteLength);
import java.io.*; class ReadBytesFromFile { public static void main(String args[]) throws Exception { File file = null; FileInputStream fileStream = new FileInputStream(file = new File("ByteArrayInputStreamClass.java")); byte[] arr = new byte[(int) file.length()]; fileStream.read(arr, 0, arr.length); for (int X : arr) { System.out.print((char) X); } } }
public static byte[] getFileBytes(File file) throws IOException { ByteArrayOutputStream ous = null; InputStream ios = null; try { byte[] buffer = new byte[4096]; ous = new ByteArrayOutputStream(); ios = new FileInputStream(file); int read = 0; while ((read = ios.read(buffer)) != -1) ous.write(buffer, 0, read); } finally { try { if (ous != null) ous.close(); } catch (IOException e) { } try { if (ios != null) ios.close(); } catch (IOException e) { } } return ous.toByteArray(); }
import java.io.File; import java.nio.file.Files; import java.nio.file.Path; File file = getYourFile(); Path path = file.toPath(); byte[] data = Files.readAllBytes(path);
org.apache.commons.io.FileUtils.readFileToByteArray(file);
RandomAccessFile f = new RandomAccessFile(fileName, "r"); byte[] b = new byte[(int)f.length()]; f.readFully(b);
public void someMethod() { final byte[] buffer = read(new File("test.txt")); } private byte[] read(final File file) { if (file.isDirectory()) throw new RuntimeException("Unsupported operation, file " + file.getAbsolutePath() + " is a directory"); if (file.length() > Integer.MAX_VALUE) throw new RuntimeException("Unsupported operation, file " + file.getAbsolutePath() + " is too big"); Throwable pending = null; FileInputStream in = null; final byte buffer[] = new byte[(int) file.length()]; try { in = new FileInputStream(file); in.read(buffer); } catch (Exception e) { pending = new RuntimeException("Exception occured on reading file " + file.getAbsolutePath(), e); } finally { if (in != null) { try { in.close(); } catch (Exception e) { if (pending == null) { pending = new RuntimeException( "Exception occured on closing file" + file.getAbsolutePath(), e); } } } if (pending != null) { throw new RuntimeException(pending); } } return buffer; }
public static byte[] readBytes(InputStream inputStream) throws IOException { byte[] buffer = new byte[32 * 1024]; int bufferSize = 0; for (;;) { int read = inputStream.read(buffer, bufferSize, buffer.length - bufferSize); if (read == -1) { return Arrays.copyOf(buffer, bufferSize); } bufferSize += read; if (bufferSize == buffer.length) { buffer = Arrays.copyOf(buffer, bufferSize * 2); } } }
Reader reader = null; try { reader = new FileReader(file); char buf[] = new char[8192]; int len; StringBuilder s = new StringBuilder(); while ((len = reader.read(buf)) >= 0) { s.append(buf, 0, len); byte[] byteArray = s.toString().getBytes(); } } catch(FileNotFoundException ex) { } catch(IOException e) { } finally { if (reader != null) { reader.close(); } }
import java.io.File; import java.io.IOException; import java.nio.file.Files; public class ReadFile_Files_ReadAllBytes { public static void main(String [] pArgs) throws IOException { String fileName = "c:\\temp\\sample-10KB.txt"; File file = new File(fileName); byte [] fileBytes = Files.readAllBytes(file.toPath()); char singleChar; for(byte b : fileBytes) { singleChar = (char) b; System.out.print(singleChar); } } }
try { Files.write(Paths.get("myfile.txt"), "the text".getBytes(), StandardOpenOption.APPEND); }catch (IOException e) { }
try(FileWriter fw = new FileWriter("myfile.txt", true); BufferedWriter bw = new BufferedWriter(fw); PrintWriter out = new PrintWriter(bw)) { out.println("the text"); out.println("more text"); } catch (IOException e) { }
try { PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("myfile.txt", true))); out.println("the text"); out.close(); } catch (IOException e) { }
FileWriter fw = null; BufferedWriter bw = null; PrintWriter out = null; try { fw = new FileWriter("myfile.txt", true); bw = new BufferedWriter(fw); out = new PrintWriter(bw); out.println("the text"); out.close(); } catch (IOException e) { } finally { try { if(out != null) out.close(); } catch (IOException e) { } try { if(bw != null) bw.close(); } catch (IOException e) { } try { if(fw != null) fw.close(); } catch (IOException e) { } }
try { String filename= "MyFile.txt"; FileWriter fw = new FileWriter(filename,true); fw.write("add a line\n"); fw.close(); } catch(IOException ioe) { System.err.println("IOException: " + ioe.getMessage()); }
PrintWriter out = null; try { out = new PrintWriter(new BufferedWriter(new FileWriter("writePath", true))); out.println("the text"); }catch (IOException e) { System.err.println(e); }finally{ if(out != null){ out.close(); } }
try(PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("writePath", true)))) { out.println("the text"); }catch (IOException e) { System.err.println(e); }
FileUtils.writeStringToFile(file, "String to append", true);
public static void appendToFile(String targetFile, String s) throws IOException { appendToFile(new File(targetFile), s); } public static void appendToFile(File targetFile, String s) throws IOException { PrintWriter out = null; try { out = new PrintWriter(new BufferedWriter(new FileWriter(targetFile, true))); out.println(s); } finally { if (out != null) { out.close(); } } }
PrintWriter out = null; BufferedWriter bw = null; FileWriter fw = null; try{ fw = new FileWriter("outfilename", true); bw = new BufferedWriter(fw); out = new PrintWriter(bw); out.println("the text"); } catch( IOException e ){ } finally{ try{ if( out != null ){ out.close(); } else if( bw != null ){ bw.close(); } else if( fw != null ){ fw.close(); } else{ } } catch( IOException e ){ } }
try( FileWriter fw = new FileWriter("outfilename", true); BufferedWriter bw = new BufferedWriter(fw); PrintWriter out = new PrintWriter(bw)){ out.println("the text"); } catch( IOException e ){ }
try { final Path path = Paths.get("path/to/filename.txt"); Files.write(path, Arrays.asList("New line to append"), StandardCharsets.UTF_8, Files.exists(path) ? StandardOpenOption.APPEND : StandardOpenOption.CREATE); } catch (final IOException ioe) { }
import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardOpenOption;
Path filePath = Paths.get("someFile.txt"); if (!Files.exists(filePath)) { Files.createFile(filePath); } Files.write(filePath, "Text to be added".getBytes(), StandardOpenOption.APPEND);
Files.write(Paths.get(fileName), msg.getBytes(), StandardOpenOption.APPEND);
String sampleText = "test" + System.getProperty("line.separator"); Files.write(Paths.get(filePath), sampleText.getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
File to = new File("C:/test/test.csv"); for (int i = 0; i < 42; i++) { CharSequence from = "some string" + i + "\n"; Files.append(from, to, Charsets.UTF_8); }
PrintWriter out = null; BufferedWriter bufWriter; try{ bufWriter = Files.newBufferedWriter( Paths.get("log.txt"), Charset.forName("UTF8"), StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE); out = new PrintWriter(bufWriter, true); }catch(IOException e){ } out.println("Text to be appended"); out.close();
FileWriter fileWriter; try { fileWriter = new FileWriter(file,true); BufferedWriter bufferFileWriter = new BufferedWriter(fileWriter); bufferFileWriter.append(obj.toJSONString()); bufferFileWriter.newLine(); bufferFileWriter.close(); } catch (IOException ex) { Logger.getLogger(JsonTest.class.getName()).log(Level.SEVERE, null, ex); }
String str; String path = "C:/Users/...the path..../iin.txt"; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); PrintWriter pw = new PrintWriter(new FileWriter(path, true)); try { while(true) { System.out.println("Enter the text : "); str = br.readLine(); if(str.equalsIgnoreCase("exit")) break; else pw.println(str); } } catch (Exception e) { } finally { pw.close(); }
static void appendStringToFile(Path file, String s) throws IOException { try (BufferedWriter out = Files.newBufferedWriter(file, StandardCharsets.UTF_8, StandardOpenOption.APPEND)) { out.append(s); out.newLine(); } }
public static void main(String[] args) { Path FILE_PATH = Paths.get("C:/temp", "temp.txt"); String text = "\n Welcome to Java 8"; try (BufferedWriter writer = Files.newBufferedWriter(FILE_PATH, StandardCharsets.UTF_8, StandardOpenOption.APPEND)) { writer.write(text); } catch (IOException e) { e.printStackTrace(); } }
try { Stream<String> lines = Files.lines(FILE_PATH); Optional<String> containsJava = lines.filter(l->l.contains("confidential")).findFirst(); if(containsJava.isPresent()){ System.out.println(containsJava.get()); } } catch (IOException e) { e.printStackTrace(); }
FileOutputStream stream = new FileOutputStream(path, true); try { stream.write( string.getBytes("UTF-8") ); } finally { stream.close(); }
public Logger getLogger() { return java.util.logging.Logger.getLogger("MyLogFileName"); } getLogger().log(Level.INFO,"the text you want to append"); ...}... /*********log file resides in server root log files********/
import java.io.BufferedWriter; import java.io.File; import java.io.FileWriter; import java.io.IOException;
public void append() { try { String path = "D:/sample.txt"; File file = new File(path); FileWriter fileWriter = new FileWriter(file,true); BufferedWriter bufferFileWriter = new BufferedWriter(fileWriter); fileWriter.append("Sample text in the file to append"); bufferFileWriter.close(); System.out.println("User Registration Completed"); }catch(Exception ex) { System.out.println(ex); } }
JFileChooser c= new JFileChooser(); c.showOpenDialog(c); File write_file = c.getSelectedFile(); String Content = "Writing into file"; try { RandomAccessFile raf = new RandomAccessFile(write_file, "rw"); long length = raf.length(); raf.setLength(length + 1); raf.seek(raf.length()); raf.writeBytes(Content); raf.close(); } catch (Exception e) { }
FileOutputStream fos = new FileOutputStream("File_Name", true); fos.write(data);
FileOutputStream fos = new FileOutputStream("File_Name");
import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; public class Writer { public static void main(String args[]){ doWrite("output.txt","Content to be appended to file"); } public static void doWrite(String filePath,String contentToBeAppended){ try( FileWriter fw = new FileWriter(filePath, true); BufferedWriter bw = new BufferedWriter(fw); PrintWriter out = new PrintWriter(bw) ) { out.println(contentToBeAppended); } catch( IOException e ){ } } }
private void appendToFile(String filePath, String text) { PrintWriter fileWriter = null; try { fileWriter = new PrintWriter(new BufferedWriter(new FileWriter( filePath, true))); fileWriter.println(text); } catch (IOException ioException) { ioException.printStackTrace(); } finally { if (fileWriter != null) { fileWriter.close(); } } }
public static void appendToFile(String filePath, String text) throws IOException { File file = new File(filePath); if(!file.exists()) { file.createNewFile(); } String fileContents = FileUtils.readFileToString(file); if(file.length() != 0) { fileContents = fileContents.concat(System.lineSeparator()); } fileContents = fileContents.concat(text); FileUtils.writeStringToFile(file, fileContents); }
FileWriter fw=new FileWriter("C:\\file.json",true); fw.write("ssssss"); fw.close();
public static void addDatatoFile(String data1, String data2){ String fullPath = "/home/user/dir/file.csv"; File dir = new File(fullPath); List<String> l = new LinkedList<String>(); try (BufferedReader br = new BufferedReader(new FileReader(dir))) { String line; int count = 0; while ((line = br.readLine()) != null) { if(count == 1){ line += data1; }else if(count == 2){ line += data2; } l.add(line); count++; } br.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } createFileFromList(l, dir); } public static void createFileFromList(List<String> list, File f){ PrintWriter writer; try { writer = new PrintWriter(f, "UTF-8"); for (String d : list) { writer.println(d.toString()); } writer.close(); } catch (FileNotFoundException | UnsupportedEncodingException e) { e.printStackTrace(); } }
JFileChooser chooser= new JFileChooser(); chooser.showOpenDialog(chooser); File file = chooser.getSelectedFile(); String Content = "What you want to append to file"; try { RandomAccessFile random = new RandomAccessFile(file, "rw"); long length = random.length(); random.setLength(length + 1); random.seek(random.length()); random.writeBytes(Content); random.close(); } catch (Exception exception) { }
/********************************************************************** * it will write content to a specified file * * @param keyString * @throws IOException *********************************************************************/ public static void writeToFile(String keyString,String textFilePAth) throws IOException { File a = new File(textFilePAth); if (!a.exists()) { a.createNewFile(); } FileWriter fw = new FileWriter(a.getAbsoluteFile(), true); BufferedWriter bw = new BufferedWriter(fw); bw.append(keyString); bw.newLine(); bw.close(); }
String fileName="/home/shriram/Desktop/Images/"+"test.txt"; FileWriter fw=new FileWriter(fileName,true); fw.write("here will be you content to insert or append in file"); fw.close(); FileWriter fw1=new FileWriter(fileName,true); fw1.write("another content will be here to be append in the same file"); fw1.close();
void appendToFile(String filePath, String content) throws IOException{ Path path = Paths.get(filePath); try (BufferedWriter writer = Files.newBufferedWriter(path, StandardOpenOption.APPEND)) { writer.newLine(); writer.append(content); } /* try (BufferedWriter bWriter = Files.newBufferedWriter(path, StandardOpenOption.WRITE, StandardOpenOption.APPEND); PrintWriter pWriter = new PrintWriter(bWriter) ) { pWriter.println(); pWriter.append(content); }*/ }
/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home
/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home
export JAVA_HOME=/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home export PATH=/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/bin:$PATH
export JAVA_HOME=/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home;
public class Pair<A, B> { private A first; private B second; public Pair(A first, B second) { super(); this.first = first; this.second = second; } public int hashCode() { int hashFirst = first != null ? first.hashCode() : 0; int hashSecond = second != null ? second.hashCode() : 0; return (hashFirst + hashSecond) * hashSecond + hashFirst; } public boolean equals(Object other) { if (other instanceof Pair) { Pair otherPair = (Pair) other; return (( this.first == otherPair.first || ( this.first != null && otherPair.first != null && this.first.equals(otherPair.first))) && ( this.second == otherPair.second || ( this.second != null && otherPair.second != null && this.second.equals(otherPair.second))) ); } return false; } public String toString() { return "(" + first + ", " + second + ")"; } public A getFirst() { return first; } public void setFirst(A first) { this.first = first; } public B getSecond() { return second; } public void setSecond(B second) { this.second = second; } }
@Data @AllArgsConstructor(staticName = "of") public class Pair<F, S> { private F first; private S second; }
public class Pair<FIRST, SECOND> implements Comparable<Pair<FIRST, SECOND>> { public final FIRST first; public final SECOND second; private Pair(FIRST first, SECOND second) { this.first = first; this.second = second; } public static <FIRST, SECOND> Pair<FIRST, SECOND> of(FIRST first, SECOND second) { return new Pair<FIRST, SECOND>(first, second); } @Override public int compareTo(Pair<FIRST, SECOND> o) { int cmp = compare(first, o.first); return cmp == 0 ? compare(second, o.second) : cmp; } private static int compare(Object o1, Object o2) { return o1 == null ? o2 == null ? 0 : -1 : o2 == null ? +1 : ((Comparable) o1).compareTo(o2); } @Override public int hashCode() { return 31 * hashcode(first) + hashcode(second); } private static int hashcode(Object o) { return o == null ? 0 : o.hashCode(); } @Override public boolean equals(Object obj) { if (!(obj instanceof Pair)) return false; if (this == obj) return true; return equal(first, ((Pair) obj).first) && equal(second, ((Pair) obj).second); } private boolean equal(Object o1, Object o2) { return o1 == null ? o2 == null : (o1 == o2 || o1.equals(o2)); } @Override public String toString() { return "(" + first + ", " + second + } }
Unit<A> (1 element) Pair<A,B> (2 elements) Triplet<A,B,C> (3 elements) Quartet<A,B,C,D> (4 elements) Quintet<A,B,C,D,E> (5 elements) Sextet<A,B,C,D,E,F> (6 elements) Septet<A,B,C,D,E,F,G> (7 elements) Octet<A,B,C,D,E,F,G,H> (8 elements) Ennead<A,B,C,D,E,F,G,H,I> (9 elements) Decade<A,B,C,D,E,F,G,H,I,J> (10 elements)
Map<String, Object> map = ... ; for (Map.Entry<String, Object> entry : map.entrySet()) { System.out.printf("%s -> %s\n", entry.getKey(), entry.getValue()); }
public class Pair<F, S> { public final F first; public final S second; public Pair(F first, S second) { this.first = first; this.second = second; } @Override public boolean equals(Object o) { if (!(o instanceof Pair)) { return false; } Pair<?, ?> p = (Pair<?, ?>) o; return Objects.equal(p.first, first) && Objects.equal(p.second, second); } @Override public int hashCode() { return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode()); } public static <A, B> Pair <A, B> create(A a, B b) { return new Pair<A, B>(a, b); } }
public class Pair<A extends Comparable<? super A>, B extends Comparable<? super B>> implements Comparable<Pair<A, B>> { public final A first; public final B second; private Pair(A first, B second) { this.first = first; this.second = second; } public static <A extends Comparable<? super A>, B extends Comparable<? super B>> Pair<A, B> of(A first, B second) { return new Pair<A, B>(first, second); } @Override public int compareTo(Pair<A, B> o) { int cmp = o == null ? 1 : (this.first).compareTo(o.first); return cmp == 0 ? (this.second).compareTo(o.second) : cmp; } @Override public int hashCode() { return 31 * hashcode(first) + hashcode(second); } private static int hashcode(Object o) { return o == null ? 0 : o.hashCode(); } @Override public boolean equals(Object obj) { if (!(obj instanceof Pair)) return false; if (this == obj) return true; return equal(first, ((Pair<?, ?>) obj).first) && equal(second, ((Pair<?, ?>) obj).second); } private boolean equal(Object o1, Object o2) { return o1 == o2 || (o1 != null && o1.equals(o2)); } @Override public String toString() { return "(" + first + ", " + second + } }
public class Pair<F, S> implements Comparable<Pair<? extends F, ? extends S>> { public final F first; public final S second; public int compareTo(Pair<? extends F, ? extends S> that) { int cf = compare(first, that.first); return cf == 0 ? compare(second, that.second) : cf; } private static int compare(Object l, Object r) { if (l == null) { return r == null ? 0 : -1; } else { return r == null ? 1 : ((Comparable) (l)).compareTo(r); } } } Pair<Thread, HashMap<String, Integer>> a = ; Pair<Thread, HashMap<String, Integer>> b = ; System.out.println(a.compareTo(b));
public class Pair< F extends Comparable<? super F>, S extends Comparable<? super S> > implements Comparable<Pair<? extends F, ? extends S>> { public final F first; public final S second; public int compareTo(Pair<? extends F, ? extends S> that) { int cf = compare(first, that.first); return cf == 0 ? compare(second, that.second) : cf; } private static < T extends Comparable<? super T> > int compare(T l, T r) { if (l == null) { return r == null ? 0 : -1; } else { return r == null ? 1 : l.compareTo(r); } } } Pair<Thread, HashMap<String, Integer>> a = ; Pair<Thread, HashMap<String, Integer>> b = ; System.out.println(a.compareTo(b));
Pair < Integer , Integer > pr = new Pair<Integer , Integer>() pr.get(key);
interface Pair<L, R> { public L getL(); public R getR(); }
... final Integer v1 = result1; final String v2 = result2; return new Pair<Integer, String>(){ Integer getL(){ return v1; } String getR(){ return v2; } }
class Pairs { static <L,R> Pair<L,R> makePair(final L l, final R r){ return new Pair<L,R>(){ public L getL() { return l; } public R getR() { return r; } }; } }
WeakHashMap<Pair<String, String>, String> map = ...
/** * The class <code>Pair</code> models a container for two objects wherein the * object order is of no consequence for equality and hashing. An example of * using Pair would be as the return type for a method that needs to return two * related objects. Another good use is as entries in a Set or keys in a Map * when only the unordered combination of two objects is of interest.<p> * The term "object" as being a one of a Pair can be loosely interpreted. A * Pair may have one or two <code>null</code> entries as values. Both values * may also be the same object.<p> * Mind that the order of the type parameters T and U is of no importance. A * Pair&lt;T, U> can still return <code>true</code> for method <code>equals</code> * called with a Pair&lt;U, T> argument.<p> * Instances of this class are immutable, but the provided values might not be. * This means the consistency of equality checks and the hash code is only as * strong as that of the value types.<p> */ public class Pair<T, U> implements Cloneable { /** * One of the two values, for the declared type T. */ private final T object1; /** * One of the two values, for the declared type U. */ private final U object2; private final boolean object1Null; private final boolean object2Null; private final boolean dualNull; /** * Constructs a new <code>Pair&lt;T, U&gt;</code> with T object1 and U object2 as * its values. The order of the arguments is of no consequence. One or both of * the values may be <code>null</code> and both values may be the same object. * * @param object1 T to serve as one value. * @param object2 U to serve as the other value. */ public Pair(T object1, U object2) { this.object1 = object1; this.object2 = object2; object1Null = object1 == null; object2Null = object2 == null; dualNull = object1Null && object2Null; } /** * Gets the value of this Pair provided as the first argument in the constructor. * * @return a value of this Pair. */ public T getObject1() { return object1; } /** * Gets the value of this Pair provided as the second argument in the constructor. * * @return a value of this Pair. */ public U getObject2() { return object2; } /** * Returns a shallow copy of this Pair. The returned Pair is a new instance * created with the same values as this Pair. The values themselves are not * cloned. * * @return a clone of this Pair. */ @Override public Pair<T, U> clone() { return new Pair<T, U>(object1, object2); } /** * Indicates whether some other object is "equal" to this one. * This Pair is considered equal to the object if and only if * <ul> * <li>the Object argument is not null, * <li>the Object argument has a runtime type Pair or a subclass, * </ul> * AND * <ul> * <li>the Object argument refers to this pair * <li>OR this pair * <li>OR this pair has one null value and the other pair has one null value and * the remaining non-null values of both pairs are equal * <li>OR both pairs have no null values and have value tuples &lt;v1, v2> of * this pair and &lt;o1, o2> of the other pair so that at least one of the * following statements is true: * <ul> * <li>v1 equals o1 and v2 equals o2 * <li>v1 equals o2 and v2 equals o1 * </ul> * </ul> * In any other case (such as when this pair has two null parts but the other * only one) this method returns false.<p> * The type parameters that were used for the other pair are of no importance. * A Pair&lt;T, U> can return <code>true</code> for equality testing with * a Pair&lt;T, V> even if V is neither a super- nor subtype of U, should * the the value equality checks be positive or the U and V type values * are both <code>null</code>. Type erasure for parameter types at compile * time means that type checks are delegated to calls of the <code>equals</code> * methods on the values themselves. * * @param obj the reference object with which to compare. * @return true if the object is a Pair equal to this one. */ @Override public boolean equals(Object obj) { if(obj == null) return false; if(this == obj) return true; if(!(obj instanceof Pair<?, ?>)) return false; final Pair<?, ?> otherPair = (Pair<?, ?>)obj; if(dualNull) return otherPair.dualNull; if(otherPair.dualNull) return false; if(object1Null) { if(otherPair.object1Null) return object2.equals(otherPair.object2); else if(otherPair.object2Null) return object2.equals(otherPair.object1); else return false; } else if(object2Null) { if(otherPair.object2Null) return object1.equals(otherPair.object1); else if(otherPair.object1Null) return object1.equals(otherPair.object2); else return false; } else { if(object1.equals(otherPair.object1)) return object2.equals(otherPair.object2); else if(object1.equals(otherPair.object2)) return object2.equals(otherPair.object1); else return false; } } /** * Returns a hash code value for the pair. This is calculated as the sum * of the hash codes for the two values, wherein a value that is <code>null</code> * contributes 0 to the sum. This implementation adheres to the contract for * <code>hashCode()</code> as specified for <code>Object()</code>. The returned * value hash code consistently remain the same for multiple invocations * during an execution of a Java application, unless at least one of the pair * values has its hash code changed. That would imply information used for * equals in the changed value(s) has also changed, which would carry that * change onto this class * * @return a hash code for this Pair. */ @Override public int hashCode() { int hashCode = object1Null ? 0 : object1.hashCode(); hashCode += (object2Null ? 0 : object2.hashCode()); return hashCode; } }
public class Pair<K, V> { private final K element0; private final V element1; public static <K, V> Pair<K, V> createPair(K key, V value) { return new Pair<K, V>(key, value); } public Pair(K element0, V element1) { this.element0 = element0; this.element1 = element1; } public K getElement0() { return element0; } public V getElement1() { return element1; } }
Pair<Integer, String> pair = Pair.createPair(1, "test"); pair.getElement0(); pair.getElement1();
Table<Vertex, Vertex, Double> weightedGraph = HashBasedTable.create(); weightedGraph.put(v1, v2, 4); weightedGraph.put(v1, v3, 20); weightedGraph.put(v2, v3, 5); weightedGraph.row(v1); weightedGraph.column(v3);
public class Person { private String name; private int age; @Override public int hashCode() { return new HashCodeBuilder(17, 31). append(name). append(age). toHashCode(); } @Override public boolean equals(Object obj) { if (!(obj instanceof Person)) return false; if (obj == this) return true; Person rhs = (Person) obj; return new EqualsBuilder(). append(name, rhs.name). append(age, rhs.age). isEquals(); } }
Person saved = new Person("John Doe"); Long key = dao.save(saved); dao.flush(); Person retrieved = dao.retrieve(key); saved.getClass().equals(retrieved.getClass());
if (this.getId() == null) { return this == other; } else { return this.getId().equals(other.getId()); }
class A { int field1; A(int field1) { this.field1 = field1; } public boolean equals(Object other) { return (other != null && other instanceof A && ((A) other).field1 == field1); } } class B extends A { int field2; B(int field1, int field2) { super(field1); this.field2 = field2; } public boolean equals(Object other) { return (other != null && other instanceof B && ((B)other).field2 == field2 && super.equals(other)); } }
A a = new A(1); B b = new B(1,1); a.equals(b) == true; b.equals(a) == false;
if (other instanceof B ) return (other != null && ((B)other).field2 == field2 && super.equals(other)); if (other instanceof A) return super.equals(other); else return false;
class Point { private int x; private int y; protected boolean blindlyEquals(Object o) { if (!(o instanceof Point)) return false; Point p = (Point)o; return (p.x == this.x && p.y == this.y); } public boolean equals(Object o) { return (this.blindlyEquals(o) && o.blindlyEquals(this)); } } class ColorPoint extends Point { private Color c; protected boolean blindlyEquals(Object o) { if (!(o instanceof ColorPoint)) return false; ColorPoint cp = (ColorPoint)o; return (super.blindlyEquals(cp) && cp.color == this.color); } }
@Override public int hashCode(){ return Objects.hashCode(this.getDate(), this.datePattern); } @Override public boolean equals(Object obj){ if ( ! obj instanceof DateAndPattern ) { return false; } return Objects.equal(((DateAndPattern)obj).getDate(), this.getDate()) && Objects.equal(((DateAndPattern)obj).getDate(), this.getDatePattern()); }
public boolean equals(Object obj) public int hashCode()
public class Test { private int num; private String data; public boolean equals(Object obj) { if(this == obj) return true; if((obj == null) || (obj.getClass() != this.getClass())) return false; Test test = (Test)obj; return num == test.num && (data == test.data || (data != null && data.equals(test.data))); } public int hashCode() { int hash = 7; hash = 31 * hash + num; hash = 31 * hash + (null == data ? 0 : data.hashCode()); return hash; } }
final class MyClass implements Comparable<MyClass> {  @Override public boolean equals(Object obj) { if (!(obj instanceof MyClass)) return false; return compareTo((MyClass) obj) == 0; } }
public class Tiger { private String color; private String stripePattern; private int height; @Override public boolean equals(Object object) { boolean result = false; if (object == null || object.getClass() != getClass()) { result = false; } else { Tiger tiger = (Tiger) object; if (this.color == tiger.getColor() && this.stripePattern == tiger.getStripePattern()) { result = true; } } return result; } @Override public int hashCode() { int hash = 3; hash = 7 * hash + this.color.hashCode(); hash = 7 * hash + this.stripePattern.hashCode(); return hash; } public static void main(String args[]) { Tiger bengalTiger1 = new Tiger("Yellow", "Dense", 3); Tiger bengalTiger2 = new Tiger("Yellow", "Dense", 2); Tiger siberianTiger = new Tiger("White", "Sparse", 4); System.out.println("bengalTiger1 and bengalTiger2: " + bengalTiger1.equals(bengalTiger2)); System.out.println("bengalTiger1 and siberianTiger: " + bengalTiger1.equals(siberianTiger)); System.out.println("bengalTiger1 hashCode: " + bengalTiger1.hashCode()); System.out.println("bengalTiger2 hashCode: " + bengalTiger2.hashCode()); System.out.println("siberianTiger hashCode: " + siberianTiger.hashCode()); } public String getColor() { return color; } public String getStripePattern() { return stripePattern; } public Tiger(String color, String stripePattern, int height) { this.color = color; this.stripePattern = stripePattern; this.height = height; } }
bengalTiger1 and bengalTiger2: true bengalTiger1 and siberianTiger: false bengalTiger1 hashCode: 1398212510 bengalTiger2 hashCode: 1398212510 siberianTiger hashCode: 1227465966
Intent emailIntent = new Intent(android.content.Intent.ACTION_SEND);
public class MailSenderActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); final Button send = (Button) this.findViewById(R.id.send); send.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { try { GMailSender sender = new GMailSender("username@gmail.com", "password"); sender.sendMail("This is Subject", "This is Body", "user@gmail.com", "user@yahoo.com"); } catch (Exception e) { Log.e("SendMail", e.getMessage(), e); } } }); } }
public class GMailSender extends javax.mail.Authenticator { private String mailhost = "smtp.gmail.com"; private String user; private String password; private Session session; static { Security.addProvider(new com.provider.JSSEProvider()); } public GMailSender(String user, String password) { this.user = user; this.password = password; Properties props = new Properties(); props.setProperty("mail.transport.protocol", "smtp"); props.setProperty("mail.host", mailhost); props.put("mail.smtp.auth", "true"); props.put("mail.smtp.port", "465"); props.put("mail.smtp.socketFactory.port", "465"); props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory"); props.put("mail.smtp.socketFactory.fallback", "false"); props.setProperty("mail.smtp.quitwait", "false"); session = Session.getDefaultInstance(props, this); } protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(user, password); } public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception { try{ MimeMessage message = new MimeMessage(session); DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), "text/plain")); message.setSender(new InternetAddress(sender)); message.setSubject(subject); message.setDataHandler(handler); if (recipients.indexOf( message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients)); else message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients)); Transport.send(message); }catch(Exception e){ } } public class ByteArrayDataSource implements DataSource { private byte[] data; private String type; public ByteArrayDataSource(byte[] data, String type) { super(); this.data = data; this.type = type; } public ByteArrayDataSource(byte[] data) { super(); this.data = data; } public void setType(String type) { this.type = type; } public String getContentType() { if (type == null) return "application/octet-stream"; else return type; } public InputStream getInputStream() throws IOException { return new ByteArrayInputStream(data); } public String getName() { return "ByteArrayDataSource"; } public OutputStream getOutputStream() throws IOException { throw new IOException("Not Supported"); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http: * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @author Alexander Y. Kleymenov * @version $Revision$ */ import java.security.AccessController; import java.security.Provider; public final class JSSEProvider extends Provider { public JSSEProvider() { super("HarmonyJSSE", 1.0, "Harmony JSSE Provider"); AccessController.doPrivileged(new java.security.PrivilegedAction<Void>() { public Void run() { put("SSLContext.TLS", "org.apache.harmony.xnet.provider.jsse.SSLContextImpl"); put("Alg.Alias.SSLContext.TLSv1", "TLS"); put("KeyManagerFactory.X509", "org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"); put("TrustManagerFactory.X509", "org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"); return null; } }); } }
<uses-permission android:name="android.permission.INTERNET" />
private Multipart _multipart; _multipart = new MimeMultipart(); public void addAttachment(String filename,String subject) throws Exception { BodyPart messageBodyPart = new MimeBodyPart(); DataSource source = new FileDataSource(filename); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(filename); _multipart.addBodyPart(messageBodyPart); BodyPart messageBodyPart2 = new MimeBodyPart(); messageBodyPart2.setText(subject); _multipart.addBodyPart(messageBodyPart2); } message.setContent(_multipart);
<uses-permission android:name="android.permission.INTERNET" />
StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy); android.os.NetworkOnMainThreadException
public void onClickMail(View view) { new SendEmailAsyncTask().execute(); } class SendEmailAsyncTask extends AsyncTask <Void, Void, Boolean> { Mail m = new Mail("from@gmail.com", "my password"); public SendEmailAsyncTask() { if (BuildConfig.DEBUG) Log.v(SendEmailAsyncTask.class.getName(), "SendEmailAsyncTask()"); String[] toArr = { "to mail@gmail.com"}; m.setTo(toArr); m.setFrom("from mail@gmail.com"); m.setSubject("Email from Android"); m.setBody("body."); } @Override protected Boolean doInBackground(Void... params) { if (BuildConfig.DEBUG) Log.v(SendEmailAsyncTask.class.getName(), "doInBackground()"); try { m.send(); return true; } catch (AuthenticationFailedException e) { Log.e(SendEmailAsyncTask.class.getName(), "Bad account details"); e.printStackTrace(); return false; } catch (MessagingException e) { Log.e(SendEmailAsyncTask.class.getName(), m.getTo(null) + "failed"); e.printStackTrace(); return false; } catch (Exception e) { e.printStackTrace(); return false; } }
import java.util.Date; import java.util.Properties; import javax.activation.CommandMap; import javax.activation.DataHandler; import javax.activation.DataSource; import javax.activation.FileDataSource; import javax.activation.MailcapCommandMap; import javax.mail.BodyPart; import javax.mail.Multipart; import javax.mail.PasswordAuthentication; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeBodyPart; import javax.mail.internet.MimeMessage; import javax.mail.internet.MimeMultipart; public class Mail extends javax.mail.Authenticator { private String _user; private String _pass; private String[] _to; private String _from; private String _port; private String _sport; private String _host; private String _subject; private String _body; private boolean _auth; private boolean _debuggable; private Multipart _multipart; public Mail() { _host = "smtp.gmail.com"; _port = "465"; _sport = "465"; _user = ""; _pass = ""; _from = ""; _subject = ""; _body = ""; _debuggable = false; _auth = true; _multipart = new MimeMultipart(); MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap(); mc.addMailcap("text/html;; x-java-content-handler=com.sun.mail.handlers.text_html"); mc.addMailcap("text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml"); mc.addMailcap("text/plain;; x-java-content-handler=com.sun.mail.handlers.text_plain"); mc.addMailcap("multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed"); mc.addMailcap("message/rfc822;; x-java-content-handler=com.sun.mail.handlers.message_rfc822"); CommandMap.setDefaultCommandMap(mc); } public Mail(String user, String pass) { this(); _user = user; _pass = pass; } public boolean send() throws Exception { Properties props = _setProperties(); if(!_user.equals("") && !_pass.equals("") && _to.length > 0 && !_from.equals("") && !_subject.equals("") && !_body.equals("")) { Session session = Session.getInstance(props, this); MimeMessage msg = new MimeMessage(session); msg.setFrom(new InternetAddress(_from)); InternetAddress[] addressTo = new InternetAddress[_to.length]; for (int i = 0; i < _to.length; i++) { addressTo[i] = new InternetAddress(_to[i]); } msg.setRecipients(MimeMessage.RecipientType.TO, addressTo); msg.setSubject(_subject); msg.setSentDate(new Date()); BodyPart messageBodyPart = new MimeBodyPart(); messageBodyPart.setText(_body); _multipart.addBodyPart(messageBodyPart); msg.setContent(_multipart); Transport.send(msg); return true; } else { return false; } } public void addAttachment(String filename) throws Exception { BodyPart messageBodyPart = new MimeBodyPart(); DataSource source = new FileDataSource(filename); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(filename); _multipart.addBodyPart(messageBodyPart); } @Override public PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(_user, _pass); } private Properties _setProperties() { Properties props = new Properties(); props.put("mail.smtp.host", _host); if(_debuggable) { props.put("mail.debug", "true"); } if(_auth) { props.put("mail.smtp.auth", "true"); } props.put("mail.smtp.port", _port); props.put("mail.smtp.socketFactory.port", _sport); props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory"); props.put("mail.smtp.socketFactory.fallback", "false"); return props; } public String getBody() { return _body; } public void setBody(String _body) { this._body = _body; } public void setTo(String[] toArr) { this._to=toArr; } public void setFrom(String string) { this._from=string; } public void setSubject(String string) { this._subject=string; } }
@Override public void onCreate(Bundle icicle) { super.onCreate(icicle); setContentView(R.layout.main); Button addImage = (Button) findViewById(R.id.send_email); addImage.setOnClickListener(new View.OnClickListener() { public void onClick(View view) { Mail m = new Mail("gmailusername@gmail.com", "password"); String[] toArr = {"bla@bla.com", "lala@lala.com"}; m.setTo(toArr); m.setFrom("wooo@wooo.com"); m.setSubject("This is an email sent using my Mail JavaMail wrapper from an Android device."); m.setBody("Email body."); try { m.addAttachment("/sdcard/filelocation"); if(m.send()) { Toast.makeText(MailApp.this, "Email was sent successfully.", Toast.LENGTH_LONG).show(); } else { Toast.makeText(MailApp.this, "Email was not sent.", Toast.LENGTH_LONG).show(); } } catch(Exception e) { Log.e("MailApp", "Could not send email", e); } } }); }
import android.util.Log; import java.io.UnsupportedEncodingException; import java.util.List; import java.util.Properties; import javax.mail.Message; import javax.mail.MessagingException; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.AddressException; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; public class GMail { final String emailPort = "587"; final String smtpAuth = "true"; final String starttls = "true"; final String emailHost = "smtp.gmail.com"; String fromEmail; String fromPassword; List<String> toEmailList; String emailSubject; String emailBody; Properties emailProperties; Session mailSession; MimeMessage emailMessage; public GMail() { } public GMail(String fromEmail, String fromPassword, List<String> toEmailList, String emailSubject, String emailBody) { this.fromEmail = fromEmail; this.fromPassword = fromPassword; this.toEmailList = toEmailList; this.emailSubject = emailSubject; this.emailBody = emailBody; emailProperties = System.getProperties(); emailProperties.put("mail.smtp.port", emailPort); emailProperties.put("mail.smtp.auth", smtpAuth); emailProperties.put("mail.smtp.starttls.enable", starttls); Log.i("GMail", "Mail server properties set."); } public MimeMessage createEmailMessage() throws AddressException, MessagingException, UnsupportedEncodingException { mailSession = Session.getDefaultInstance(emailProperties, null); emailMessage = new MimeMessage(mailSession); emailMessage.setFrom(new InternetAddress(fromEmail, fromEmail)); for (String toEmail : toEmailList) { Log.i("GMail", "toEmail: " + toEmail); emailMessage.addRecipient(Message.RecipientType.TO, new InternetAddress(toEmail)); } emailMessage.setSubject(emailSubject); emailMessage.setContent(emailBody, "text/html"); Log.i("GMail", "Email Message created."); return emailMessage; } public void sendEmail() throws AddressException, MessagingException { Transport transport = mailSession.getTransport("smtp"); transport.connect(emailHost, fromEmail, fromPassword); Log.i("GMail", "allrecipients: " + emailMessage.getAllRecipients()); transport.sendMessage(emailMessage, emailMessage.getAllRecipients()); transport.close(); Log.i("GMail", "Email sent successfully."); } }
import android.app.Activity; import android.app.ProgressDialog; import android.os.AsyncTask; import android.util.Log; import java.util.List; public class SendMailTask extends AsyncTask { private ProgressDialog statusDialog; private Activity sendMailActivity; public SendMailTask(Activity activity) { sendMailActivity = activity; } protected void onPreExecute() { statusDialog = new ProgressDialog(sendMailActivity); statusDialog.setMessage("Getting ready..."); statusDialog.setIndeterminate(false); statusDialog.setCancelable(false); statusDialog.show(); } @Override protected Object doInBackground(Object... args) { try { Log.i("SendMailTask", "About to instantiate GMail..."); publishProgress("Processing input...."); GMail androidEmail = new GMail(args[0].toString(), args[1].toString(), (List) args[2], args[3].toString(), args[4].toString()); publishProgress("Preparing mail message...."); androidEmail.createEmailMessage(); publishProgress("Sending email...."); androidEmail.sendEmail(); publishProgress("Email Sent."); Log.i("SendMailTask", "Mail Sent."); } catch (Exception e) { publishProgress(e.getMessage()); Log.e("SendMailTask", e.getMessage(), e); } return null; } @Override public void onProgressUpdate(Object... values) { statusDialog.setMessage(values[0].toString()); } @Override public void onPostExecute(Object result) { statusDialog.dismiss(); } }
<?xml version="1.0" encoding="utf-8"?> <LinearLayout xmlns:android="http: xmlns:tools="http: android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:paddingLeft="20dp" android:paddingRight="20dp" android:paddingTop="30dp"> <TextView android:id="@+id/textView1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingTop="10dp" android:text="From Email" /> <EditText android:id="@+id/editText1" android:layout_width="match_parent" android:layout_height="wrap_content" android:background=" android:cursorVisible="true" android:editable="true" android:ems="10" android:enabled="true" android:inputType="textEmailAddress" android:padding="5dp" android:textColor=" <requestFocus /> </EditText> <TextView android:id="@+id/textView2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingTop="10dp" android:text="Password (For from email)" /> <EditText android:id="@+id/editText2" android:layout_width="match_parent" android:layout_height="wrap_content" android:background=" android:ems="10" android:inputType="textPassword" android:padding="5dp" android:textColor=" <TextView android:id="@+id/textView3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingTop="10dp" android:text="To Email" /> <EditText android:id="@+id/editText3" android:layout_width="match_parent" android:layout_height="wrap_content" android:background=" android:ems="10" android:inputType="textEmailAddress" android:padding="5dp" android:textColor=" <TextView android:id="@+id/textView4" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingTop="10dp" android:text="Subject" /> <EditText android:id="@+id/editText4" android:layout_width="match_parent" android:layout_height="wrap_content" android:background=" android:ems="10" android:padding="5dp" android:textColor=" <TextView android:id="@+id/textView5" android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingTop="10dp" android:text="Body" /> <EditText android:id="@+id/editText5" android:layout_width="match_parent" android:layout_height="wrap_content" android:background=" android:ems="10" android:inputType="textMultiLine" android:padding="35dp" android:textColor=" <Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Send Email" /> </LinearLayout>
import android.app.Activity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; import java.util.Arrays; import java.util.List; public class SendMailActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final Button send = (Button) this.findViewById(R.id.button1); send.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { Log.i("SendMailActivity", "Send Button Clicked."); String fromEmail = ((TextView) findViewById(R.id.editText1)) .getText().toString(); String fromPassword = ((TextView) findViewById(R.id.editText2)) .getText().toString(); String toEmails = ((TextView) findViewById(R.id.editText3)) .getText().toString(); List<String> toEmailList = Arrays.asList(toEmails .split("\\s*,\\s*")); Log.i("SendMailActivity", "To List: " + toEmailList); String emailSubject = ((TextView) findViewById(R.id.editText4)) .getText().toString(); String emailBody = ((TextView) findViewById(R.id.editText5)) .getText().toString(); new SendMailTask(SendMailActivity.this).execute(fromEmail, fromPassword, toEmailList, emailSubject, emailBody); } }); } }
BackgroundMail.newBuilder(this) .withUsername("username@gmail.com") .withPassword("password12345") .withMailto("toemail@gmail.com") .withType(BackgroundMail.TYPE_PLAIN) .withSubject("this is the subject") .withBody("this is the body") .withOnSuccessCallback(new BackgroundMail.OnSuccessCallback() { @Override public void onSuccess() { } }) .withOnFailCallback(new BackgroundMail.OnFailCallback() { @Override public void onFail() { } }) .send();
repositories { maven { url "https: } dependencies { compile }
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/> <uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
public class SendAttachment{ public static void main(String [] args){ String to="abc@abc.com"; final String user="efg@efg.com"; final String password="password"; MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap(); mc.addMailcap("text/html;; x-java-content-handler=com.sun.mail.handlers.text_html"); mc.addMailcap("text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml"); mc.addMailcap("text/plain;; x-java-content-handler=com.sun.mail.handlers.text_plain"); mc.addMailcap("multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed"); mc.addMailcap("message/rfc822;; x-java-content-handler=com.sun.mail.handlers.message_rfc822"); CommandMap.setDefaultCommandMap(mc); Properties properties = System.getProperties(); properties.put("mail.smtp.port", "465"); properties.put("mail.smtp.host", "smtp.gmail.com"); properties.put("mail.smtp.socketFactory.port", "465"); properties.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory"); properties.put("mail.smtp.auth", "true"); properties.put("mail.smtp.port", "465"); Session session = Session.getDefaultInstance(properties, new javax.mail.Authenticator() { protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(user,password); } }); try{ MimeMessage message = new MimeMessage(session); message.setFrom(new InternetAddress(user)); message.addRecipient(Message.RecipientType.TO,new InternetAddress(to)); message.setSubject("Hii"); BodyPart messageBodyPart1 = new MimeBodyPart(); messageBodyPart1.setText("How is This"); MimeBodyPart messageBodyPart2 = new MimeBodyPart(); String filename = Environment.getExternalStorageDirectory().getPath()+"/R2832.zip"; DataSource source = new FileDataSource(filename); messageBodyPart2.setDataHandler(new DataHandler(source)); messageBodyPart2.setFileName("Hello"); Multipart multipart = new MimeMultipart(); multipart.addBodyPart(messageBodyPart1); multipart.addBodyPart(messageBodyPart2); message.setContent(multipart ); Transport.send(message); System.out.println("MESSAGE SENT...."); }catch (MessagingException ex) {ex.printStackTrace();} } }
package com.example.mail; import java.util.Properties; import javax.mail.Message; import javax.mail.MessagingException; import javax.mail.PasswordAuthentication; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; public class SendMailTLS { public static void main(String[] args) { final String username = "username@gmail.com"; final String password = "password"; Properties props = new Properties(); props.put("mail.smtp.auth", "true"); props.put("mail.smtp.starttls.enable", "true"); props.put("mail.smtp.host", "smtp.gmail.com"); props.put("mail.smtp.port", "587"); Session session = Session.getInstance(props, new javax.mail.Authenticator() { protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication("username", "password"); } }); try { Message message = new MimeMessage(session); message.setFrom(new InternetAddress("from-email@gmail.com")); message.setRecipients(Message.RecipientType.TO, InternetAddress.parse("to-email@gmail.com")); message.setSubject("Testing Subject"); message.setText("Dear Mail Crawler," + "\n\n No spam to my email, please!"); Transport.send(message); System.out.println("Done"); } catch (MessagingException e) { throw new RuntimeException(e); } } }
MailSender mailSender = new MailSender(email, password); Mail.MailBuilder builder = new Mail.MailBuilder(); Mail mail = builder .setSender(senderMail) .addRecipient(new Recipient(recipient)) .setText("Hello") .build(); mailSender.sendMail(mail);
MailSender mailSender = new MailSender(email, password); Mail.MailBuilder builder = new Mail.MailBuilder(); Mail mail = builder .setSender(senderMail) .addRecipient(new Recipient(recipient)) .addRecipient(new Recipient(Recipient.TYPE.CC, recipientCC)) .setText("Hello") .setHtml("<h1 style=\"color:red;\">Hello</h1>") .addAttachment(new Attachment(filePath, fileName)) .build(); mailSender.sendMail(mail, new MailSender.OnMailSentListener() { @Override public void onSuccess() { } @Override public void onError(Exception error) { } });
Add jar files mail.jar,activation.jar,additionnal.jar String sub="Thank you for your online registration" ; Mail m = new Mail("emailid", "password"); String[] toArr = {"ekkatrainfo@gmail.com",sEmailId}; m.setFrom("ekkatrainfo@gmail.com"); m.setTo(toArr); m.setSubject(sub); m.setBody(msg); try{ if(m.send()) { } else { } } catch(Exception e) { Log.e("MailApp", "Could not send email", e); } package com.example.ekktra; import java.util.Date; import java.util.Properties; import javax.activation.CommandMap; import javax.activation.DataHandler; import javax.activation.DataSource; import javax.activation.FileDataSource; import javax.activation.MailcapCommandMap; import javax.mail.BodyPart; import javax.mail.Multipart; import javax.mail.PasswordAuthentication; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeBodyPart; import javax.mail.internet.MimeMessage; import javax.mail.internet.MimeMultipart; public class Mail extends javax.mail.Authenticator { private String _user; private String _pass; private String[] _to; private String _from; private String _port; private String _sport; private String _host; private String _subject; private String _body; private boolean _auth; private boolean _debuggable; private Multipart _multipart; public Mail() { _host = "smtp.gmail.com"; _port = "465"; _sport = "465"; _user = ""; _pass = ""; _from = ""; _subject = ""; _body = ""; _debuggable = false; _auth = true; _multipart = new MimeMultipart(); MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap(); mc.addMailcap("text/html;; x-java-content-handler=com.sun.mail.handlers.text_html"); mc.addMailcap("text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml"); mc.addMailcap("text/plain;; x-java-content- handler=com.sun.mail.handlers.text_plain"); mc.addMailcap("multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed"); mc.addMailcap("message/rfc822;; x-java-content- handler=com.sun.mail.handlers.message_rfc822"); CommandMap.setDefaultCommandMap(mc); } public Mail(String user, String pass) { this(); _user = user; _pass = pass; } public boolean send() throws Exception { Properties props = _setProperties(); if(!_user.equals("") && !_pass.equals("") && _to.length > 0 && !_from.equals("") && !_subject.equals("") /*&& !_body.equals("")*/) { Session session = Session.getInstance(props, this); MimeMessage msg = new MimeMessage(session); msg.setFrom(new InternetAddress(_from)); InternetAddress[] addressTo = new InternetAddress[_to.length]; for (int i = 0; i < _to.length; i++) { addressTo[i] = new InternetAddress(_to[i]); } msg.setRecipients(MimeMessage.RecipientType.TO, addressTo); msg.setSubject(_subject); msg.setSentDate(new Date()); BodyPart messageBodyPart = new MimeBodyPart(); messageBodyPart.setText(_body); _multipart.addBodyPart(messageBodyPart); msg.setContent(_multipart); Transport.send(msg); return true; } else { return false; } } public void addAttachment(String filename) throws Exception { BodyPart messageBodyPart = new MimeBodyPart(); DataSource source = new FileDataSource(filename); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(filename); _multipart.addBodyPart(messageBodyPart); } @Override public PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(_user, _pass); } private Properties _setProperties() { Properties props = new Properties(); props.put("mail.smtp.host", _host); if(_debuggable) { props.put("mail.debug", "true"); } if(_auth) { props.put("mail.smtp.auth", "true"); } props.put("mail.smtp.port", _port); props.put("mail.smtp.socketFactory.port", _sport); props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory"); props.put("mail.smtp.socketFactory.fallback", "false"); return props; } public String getBody() { return _body; } public void setBody(String _body) { this._body = _body; } public void setTo(String[] toArr) { this._to=toArr; } public void setFrom(String string) { this._from=string; } public void setSubject(String string) { this._subject=string; } }
MailcapCommandMap mc = (MailcapCommandMap) CommandMap .getDefaultCommandMap(); mc.addMailcap("text/html;; x-java-content-handler=com.sun.mail.handlers.text_html"); mc.addMailcap("text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml"); mc.addMailcap("text/plain;; x-java-content-handler=com.sun.mail.handlers.text_plain"); mc.addMailcap("multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed"); mc.addMailcap("message/rfc822;; x-java-content-handler=com.sun.mail.handlers.message_rfc822"); CommandMap.setDefaultCommandMap(mc);
java.lang.reflect.Method method; try { method = obj.getClass().getMethod(methodName, param1.class, param2.class, ..); } catch (SecurityException e) { ... } catch (NoSuchMethodException e) { ... }
try { method.invoke(obj, arg1, arg2,...); } catch (IllegalArgumentException e) { ... } catch (IllegalAccessException e) { ... } catch (InvocationTargetException e) { ... }
Class<?> c = Class.forName("class name"); Method method = c.getDeclaredMethod("method name", parameterTypes); method.invoke(objectToInvokeOn, params);
package com.mypackage.bean; public class Dog { private String name; private int age; public Dog() { } public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void printDog(String name, int age) { System.out.println(name + " is " + age + " year(s) old."); } }
package com.mypackage.demo; import java.lang.reflect.*; public class ReflectionDemo { public static void main(String[] args) throws Exception { String dogClassName = "com.mypackage.bean.Dog"; Class<?> dogClass = Class.forName(dogClassName); Object dog = dogClass.newInstance(); String methodName = ""; methodName = "setName"; Method setNameMethod = dog.getClass().getMethod(methodName, String.class); setNameMethod.invoke(dog, "Mishka"); methodName = "getName"; Method getNameMethod = dog.getClass().getMethod(methodName); String name = (String) getNameMethod.invoke(dog); methodName = "printDog"; Class<?>[] paramTypes = {String.class, int.class}; Method printDogMethod = dog.getClass().getMethod(methodName, paramTypes); printDogMethod.invoke(dog, name, 3); } }
Constructor<?> dogConstructor = dogClass.getConstructor(String.class, int.class); Object dog = dogConstructor.newInstance("Hachiko", 10);
String dogClassName = "com.mypackage.bean.Dog"; Class<?> dogClass = Class.forName(dogClassName); Object dog = dogClass.newInstance();
Dog dog = new Dog(); Method method = Dog.class.getMethod(methodName, ...); method.invoke(dog, ...);
import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import org.junit.Assert; import org.junit.Test; public class ReflectionTest { private String methodName = "length"; private String valueObject = "Some object"; @Test public void testGetMethod() throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException { Method m = valueObject.getClass().getMethod(methodName, new Class[] {}); Object ret = m.invoke(valueObject, new Object[] {}); Assert.assertEquals(11, ret); } }
/** * Allow for instance call, avoiding certain class circular dependencies. <br /> * Calls even private method if java Security allows it. * @param aninstance instance on which method is invoked (if null, static call) * @param classname name of the class containing the method * (can be null - ignored, actually - if instance if provided, must be provided if static call) * @param amethodname name of the method to invoke * @param parameterTypes array of Classes * @param parameters array of Object * @return resulting Object * @throws CCException if any problem */ public static Object reflectionCall(final Object aninstance, final String classname, final String amethodname, final Class[] parameterTypes, final Object[] parameters) throws CCException { Object res; try { Class aclass; if(aninstance == null) { aclass = Class.forName(classname); } else { aclass = aninstance.getClass(); } final Method amethod = aclass.getDeclaredMethod(amethodname, parameterTypes); AccessController.doPrivileged(new PrivilegedAction() { public Object run() { amethod.setAccessible(true); return null; } }); res = amethod.invoke(aninstance, parameters); } catch (final ClassNotFoundException e) { throw new CCException.Error(PROBLEM_TO_ACCESS+classname+CLASS, e); } catch (final SecurityException e) { throw new CCException.Error(PROBLEM_TO_ACCESS+classname+GenericConstants.HASH_DIESE+ amethodname + METHOD_SECURITY_ISSUE, e); } catch (final NoSuchMethodException e) { throw new CCException.Error(PROBLEM_TO_ACCESS+classname+GenericConstants.HASH_DIESE+ amethodname + METHOD_NOT_FOUND, e); } catch (final IllegalArgumentException e) { throw new CCException.Error(PROBLEM_TO_ACCESS+classname+GenericConstants.HASH_DIESE+ amethodname + METHOD_ILLEGAL_ARGUMENTS+String.valueOf(parameters)+GenericConstants.CLOSING_ROUND_BRACKET, e); } catch (final IllegalAccessException e) { throw new CCException.Error(PROBLEM_TO_ACCESS+classname+GenericConstants.HASH_DIESE+ amethodname + METHOD_ACCESS_RESTRICTION, e); } catch (final InvocationTargetException e) { throw new CCException.Error(PROBLEM_TO_ACCESS+classname+GenericConstants.HASH_DIESE+ amethodname + METHOD_INVOCATION_ISSUE, e); } return res; }
String funClass = "package.myclass"; Class c = Class.forName(funClass); Object o = c.newInstance(); Class[] paramTypes = new Class[1]; paramTypes[0]=String.class; String methodName = "mymethod"; Method m = c.getDeclaredMethod(methodName, paramTypes); m.invoke(o, "testparam");
Object obj; Method method = obj.getClass().getMethod("methodName", null); method.invoke(obj, null);
Object obj = new Point( 100, 200 ); String methodName = "toString"; Class<String> resultType = String.class; MethodType mt = MethodType.methodType( resultType ); MethodHandle methodHandle = MethodHandles.lookup().findVirtual( obj.getClass(), methodName, mt ); String result = resultType.cast( methodHandle.invoke( obj ) ); System.out.println( result );
public class method2 { public int add(int a, int b) { return a + b; } public static void main(String args[]) { try { Class cls = Class.forName("method2"); Class partypes[] = new Class[2]; partypes[0] = Integer.TYPE; partypes[1] = Integer.TYPE; Method meth = cls.getMethod( "add", partypes); method2 methobj = new method2(); Object arglist[] = new Object[2]; arglist[0] = new Integer(37); arglist[1] = new Integer(47); Object retobj = meth.invoke(methobj, arglist); Integer retval = (Integer)retobj; System.out.println(retval.intValue()); } catch (Throwable e) { System.err.println(e); } } }
public static Method method[]; public static MethodClass obj; public static String testMethod="A"; public static void main(String args[]) { obj=new MethodClass(); method=obj.getClass().getMethods(); try { for(int i=0;i<method.length;i++) { String name=method[i].getName(); if(name==testMethod) { method[i].invoke(name,"Test Parameters of A"); } } } catch(Exception ex) { System.out.println(ex.getMessage()); } }
Method method = someVariable.class.getMethod(SomeClass); String status = (String) method.invoke(method);
try { YourClass yourClass = new YourClass(); Method method = YourClass.class.getMethod("yourMethodName", ParameterOfThisMethod.class); method.invoke(yourClass, parameter); } catch (Exception e) { e.printStackTrace(); }
class Student{ int rollno; String name; void m1(int x,int y){ System.out.println("add is" +(x+y)); } private void m3(String name){ this.name=name; System.out.println("danger yappa:"+name); } void m4(){ System.out.println("This is m4"); } }
import java.lang.reflect.Method; public class StudentTest{ public static void main(String[] args){ try{ Class cls=Student.class; Student s=(Student)cls.newInstance(); String x="kichha"; Method mm3=cls.getDeclaredMethod("m3",String.class); mm3.setAccessible(true); mm3.invoke(s,x); Method mm1=cls.getDeclaredMethod("m1",int.class,int.class); mm1.invoke(s,10,20); } catch(Exception e){ e.printStackTrace(); } } }
Class<?> aClass = Class.forName(FULLY_QUALIFIED_CLASS_NAME); Method method = aClass.getMethod(methodName, YOUR_PARAM_1.class, YOUR_PARAM_2.class); method.invoke(OBJECT_TO_RUN_METHOD_ON, YOUR_PARAM_1, YOUR_PARAM_2);
public class MethodInvokerClass { public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, ClassNotFoundException, InvocationTargetException, InstantiationException { Class c = Class.forName(MethodInvokerClass.class.getName()); Object o = c.newInstance(); Class[] paramTypes = new Class[1]; paramTypes[0]=String.class; String methodName = "countWord"; Method m = c.getDeclaredMethod(methodName, paramTypes); m.invoke(o, "testparam"); } public void countWord(String input){ System.out.println("My input "+input); }
public static Object launchProcess(String className, String methodName, Class<?>[] argsTypes, Object[] methodArgs) throws Exception { Class<?> processClass = Class.forName(className); Object process = processClass.newInstance(); Method aMethod = process.getClass().getMethod(methodName,argsTypes); Object res = aMethod.invoke(process, methodArgs); return(res); }
String className = "com.example.helloworld"; String methodName = "print"; Class<?>[] argsTypes = {String.class, String.class}; Object[] methArgs = { "hello", "world" }; launchProcess(className, methodName, argsTypes, methArgs);
public static object methodCaller(String methodName) { if(methodName.equals("getName")) return className.getName(); }
System.out.println(methodCaller(methodName).toString());
public interface ExampleInterface { public void doAction(); public String doThis(int number); } public class sub implements ExampleInterface { public void doAction() { } public String doThis(int number) { } }
public class SuperClass { public int getNb() { return 1; } public int getNb2() { return 2; } } public class SubClass extends SuperClass { @Override public int getNb2() { return 3; } }
Subclass s = new SubClass(); s.getNb(); s.getNb2(); SuperClass sup = new SuperClass(); sup.getNb(); sup.getNb2();
public class ExtendsAndImplementsDemo{ public static void main(String args[]){ Dog dog = new Dog("Tiger",16); Cat cat = new Cat("July",20); System.out.println("Dog:"+dog); System.out.println("Cat:"+cat); dog.remember(); dog.protectOwner(); Learn dl = dog; dl.learn(); cat.remember(); cat.protectOwner(); Climb c = cat; c.climb(); Man man = new Man("Ravindra",40); System.out.println(man); Climb cm = man; cm.climb(); Think t = man; t.think(); Learn l = man; l.learn(); Apply a = man; a.apply(); } } abstract class Animal{ String name; int lifeExpentency; public Animal(String name,int lifeExpentency ){ this.name = name; this.lifeExpentency=lifeExpentency; } public void remember(){ System.out.println("Define your own remember"); } public void protectOwner(){ System.out.println("Define your own protectOwner"); } public String toString(){ return this.getClass().getSimpleName()+":"+name+":"+lifeExpentency; } } class Dog extends Animal implements Learn{ public Dog(String name,int age){ super(name,age); } public void remember(){ System.out.println(this.getClass().getSimpleName()+" can remember for 5 minutes"); } public void protectOwner(){ System.out.println(this.getClass().getSimpleName()+ " will protect owner"); } public void learn(){ System.out.println(this.getClass().getSimpleName()+ " can learn:"); } } class Cat extends Animal implements Climb { public Cat(String name,int age){ super(name,age); } public void remember(){ System.out.println(this.getClass().getSimpleName() + " can remember for 16 hours"); } public void protectOwner(){ System.out.println(this.getClass().getSimpleName()+ " won } public void climb(){ System.out.println(this.getClass().getSimpleName()+ " can climb"); } } interface Climb{ public void climb(); } interface Think { public void think(); } interface Learn { public void learn(); } interface Apply{ public void apply(); } class Man implements Think,Learn,Apply,Climb{ String name; int age; public Man(String name,int age){ this.name = name; this.age = age; } public void think(){ System.out.println("I can think:"+this.getClass().getSimpleName()); } public void learn(){ System.out.println("I can learn:"+this.getClass().getSimpleName()); } public void apply(){ System.out.println("I can apply:"+this.getClass().getSimpleName()); } public void climb(){ System.out.println("I can climb:"+this.getClass().getSimpleName()); } public String toString(){ return "Man :"+name+":Age:"+age; } }
Dog:Dog:Tiger:16 Cat:Cat:July:20 Dog can remember for 5 minutes Dog will protect owner Dog can learn: Cat can remember for 16 hours Cat won Cat can climb Man :Ravindra:Age:40 I can climb:Man I can think:Man I can learn:Man I can apply:Man
public class Bicycle { } public class MountainBike extends Bicycle { }
public interface Relatable { } public class RectanglePlus implements Relatable { }
class AnimalClass { public void doEat() { System.out.println("Animal Eating..."); } public void sleep() { System.out.println("Animal Sleeping..."); } } public class Dog extends AnimalClass implements AnimalInterface, Herbi{ public static void main(String[] args) { AnimalInterface a = new Dog(); Dog obj = new Dog(); obj.doEat(); a.eating(); obj.eating(); obj.herbiEating(); } public void doEat() { System.out.println("Dog eating..."); } @Override public void eating() { System.out.println("Eating through an interface..."); } @Override public void herbiEating() { System.out.println("Herbi eating through an interface..."); } }
public interface AnimalInterface { public void eating(); } interface Herbi { public void herbiEating(); }
interface A{ } class B { } class C implements A,extends B{ }
String withoutWhitespace = StringUtils.deleteWhitespace(whitespaces);
import java.util.Enumeration; import java.util.Hashtable; class SplitIt { public static void main(String args[]) { String person = "name=john age=13 year=2001"; for (String p : person.split("\\s")) { String[] keyValue = p.split("="); System.out.println(keyValue[0] + " = " + keyValue[1]); } } }
public static void main(String[] args) { String s = "name=john age=13 year=2001"; String t = s.replaceAll(" ", ""); System.out.println("s: " + s + ", t: " + t); } Output: s: name=john age=13 year=2001, t: name=johnage=13year=2001
String a="string with multi spaces "; String b= a.replaceAll("\\s+"," "); String c= a.replace(" "," ").replace(" "," ").replace(" "," ").replace(" "," ").replace(" "," ");
String pattern="[\\s]"; String replace=""; part="name=john age=13 year=2001"; Pattern p=Pattern.compile(pattern); Matcher m=p.matcher(part); part=m.replaceAll(replace); System.out.println(part);
import java.util.regex.Matcher; import java.util.regex.Pattern;
import java.util.regex.Matcher; import java.util.regex.Pattern; public class RemovingSpace { /** * @param args * Removing Space Using Matcher */ public static void main(String[] args) { String str= "jld fdkjg jfdg "; String pattern="[\\s]"; String replace=""; Pattern p= Pattern.compile(pattern); Matcher m=p.matcher(str); str=m.replaceAll(replace); System.out.println(str); } }
import java.util.*; public class RemoveSpace { public static void main(String[] args) { String mysz = "name=john age=13 year=2001"; Scanner scan = new Scanner(mysz); String result = ""; while(scan.hasNext()) { result += scan.next(); } System.out.println(result); } }
org.apache.commons.lang3.StringUtils.replace("abc def ", " ", "")
String mysz = "name=john age=13 year=2001"; String[] test = mysz.split(" "); mysz = String.join("", mysz);
public static String removeWhiteSpaces(String str){ String s = ""; char[] arr = str.toCharArray(); for (int i = 0; i < arr.length; i++) { int temp = arr[i]; if(temp!=32 && temp!=9){ s+=arr[i]; } } return s; }
public Address(String street, String city, String state, String zip ) { this.street = street; this.city = city; int position = state.indexOf(" "); if(position >=0) { state = state.substring(0, position) + state.substring(position + 1); }
public static void main(String[] args) { String withSpace = "Remove white space from line"; StringBuilder removeSpace = new StringBuilder(); for (int i = 0; i<withSpace.length();i++){ if(!Character.isWhitespace(withSpace.charAt(i))){ removeSpace=removeSpace.append(withSpace.charAt(i)); } } System.out.println(removeSpace); }
public class RemoveSpacesFromString { public static void main(String[] args) { String newString; String str = "prashant is good" ; int i; char[] strArray = str.toCharArray(); StringBuffer sb = new StringBuffer(); for(i = 0; i<strArray.length; i++) { if(strArray[i]!= { sb.append(strArray[i]); } } System.out.println(sb); /*newString = str.replaceAll(" " , ""); System.out.println(newString);*/ } }
String str="name=john age=13 year=2001"; String s[]=str.split(" "); StringBuilder v=new StringBuilder(); for (String string : s) { v.append(string); } str=v.toString();
public static double sum(Collection<? extends Number> nums) { double s = 0.0; for (Number num : nums) s += num.doubleValue(); return s; }
List<Integer>ints = Arrays.asList(1,2,3); assert sum(ints) == 6.0; List<Double>doubles = Arrays.asList(2.78,3.14); assert sum(doubles) == 5.92; List<Number>nums = Arrays.<Number>asList(1,2,2.78,3.14); assert sum(nums) == 8.92;
List<Integer> ints = new ArrayList<Integer>(); ints.add(1); ints.add(2); List<? extends Number> nums = ints; nums.add(null); assert nums.toString().equals("[1, 2, null]");
public static void count(Collection<? super Integer> ints, int n) { for (int i = 0; i < n; i++) ints.add(i); }
List<Integer>ints = new ArrayList<Integer>(); count(ints, 5); assert ints.toString().equals("[0, 1, 2, 3, 4]"); List<Number>nums = new ArrayList<Number>(); count(nums, 5); nums.add(5.0); assert nums.toString().equals("[0, 1, 2, 3, 4, 5.0]"); List<Object>objs = new ArrayList<Object>(); count(objs, 5); objs.add("five"); assert objs.toString().equals("[0, 1, 2, 3, 4, five]");
List<Object> objs = Arrays.<Object>asList(1,"two"); List<? super Integer> ints = objs; String str = ""; for (Object obj : ints) str += obj.toString(); assert str.equals("1two");
public static double sumCount(Collection<Number> nums, int n) { count(nums, n); return sum(nums); }
public class Test { public class A {} public class B extends A {} public class C extends B {} public void testCoVariance(List<? extends B> myBlist) { B b = new B(); C c = new C(); myBlist.add(b); myBlist.add(c); A a = myBlist.get(0); } public void testContraVariance(List<? super B> myBlist) { B b = new B(); C c = new C(); myBlist.add(b); myBlist.add(c); A a = myBlist.get(0); } }
class Super { void testCoVariance(Object parameter){} Object testContraVariance(){ return null;} } class Sub extends Super { @Override void testCoVariance(String parameter){} @Override String testContraVariance(){ return null;} }
Object name= new String("prem"); List<Number> numbers = new ArrayList<Integer>(); Integer[] myInts = {1,2,3,4}; Number[] myNumber = myInts; myNumber[0] = 3.14; List<String> list=new ArrayList<>(); list.add("prem"); List<Object> listObject=list;
class Shape { void draw() {}} class Circle extends Shape {void draw() {}} class Square extends Shape {void draw() {}} class Rectangle extends Shape {void draw() {}} public class TestContraVariance { /* * Example for an upper bound wildcard (Get values i.e Producer `extends`) * * */ public void testCoVariance(List<? extends Shape> list) { list.add(new Shape()); list.add(new Circle()); list.add(new Square()); list.add(new Rectangle()); Shape shape= list.get(0); /*You can * You can get an object and know that it will be an Shape */ } /* * Example for a lower bound wildcard (Put values i.e Consumer`super`) * */ public void testContraVariance(List<? super Shape> list) { list.add(new Shape()); list.add(new Circle()); list.add(new Square()); list.add(new Rectangle()); Shape shape= list.get(0); Object object= list.get(0); /*You can add a Shape,Circle,Square,Rectangle to a List<? extends Shape> * You can */ } }
List<Integer> intList = Arrays.asList(1,2,3); List<Double> doubleList = Arrays.asList(2.78,3.14); List<Number> numList = Arrays.asList(1,2,2.78,3.14,5); List<Integer> intList2 = new ArrayList<>(); List<Double> doublesList2 = new ArrayList<>(); List<Number> numList2 = new ArrayList<>(); copyElements1(intList,intList2); copyElements1(doubleList,doublesList2); static <T> void copyElements1(Collection<T> src, Collection<T> dest) { for(T n : src){ dest.add(n); } } copyElements1(intList,numList2); copyElements2(intList,numList2); private static <T> void copyElements2(Collection<? extends T> src, Collection<? super T> dest) { for(T n : src){ dest.add(n); } }
class Creature{} class Animal extends Creature{} class Fish extends Animal{} class Shark extends Fish{} class HammerSkark extends Shark{} class DeadHammerShark extends HammerSkark{}
sharks.add(new Shark()); sharks.add(new DeadHammerShark()); sharks.add(new HammerSkark());
Object o; o = sharks.get(2); Animal s; s = sharks.get(2);
- Upper bound Wildcard ( ? extends Type ). - Lower bound Wildcard ( ? super Type ) . - Unbounded Wildcard ( ? ) .
- In Variable An "in" variable serves up data to the code. Imagine a copy method with two arguments: copy(src, dest) The src argument provides the data to be copied, so it is the "in" parameter. - Out Variable An "out" variable holds data for use elsewhere. In the copy example, copy(src, dest) the dest argument accepts data, so it is the "out" parameter. An "in" variable is defined with an upper bounded wildcard, using the extends keyword. An "out" variable is defined with a lower bounded wildcard, using the super keyword. In the case where the "in" variable can be accessed using methods defined in the Object class, use an unbounded wildcard. In the case where the code needs to access the variable as both an "in" and an "out" variable, do not use a wildcard. class NaturalNumber { private int i; public NaturalNumber(int i) { this.i = i; } } class EvenNumber extends NaturalNumber { public EvenNumber(int i) { super(i); } } Consider the following code: List<EvenNumber> le = new ArrayList<>(); List<? extends NaturalNumber> ln = le; ln.add(new NaturalNumber(35)); You can add null. You can invoke clear. You can get the iterator and invoke remove. You can capture the wildcard and write elements that you
Set<T> mySet = new HashSet<T>(Arrays.asList(someArray));
Set<T> mySet = new HashSet<T>(); Collections.addAll(mySet, myArray);
Arrays.stream(intArray).boxed().collect(Collectors.toSet());
T[] array = ... Set<T> set = Sets.newHashSet(array);
String[] strArray = {"eins", "zwei", "drei", "vier"}; Set<String> strSet = Arrays.stream(strArray).collect(Collectors.toSet()); System.out.println(strSet);
Stream.of(T... values).collect(Collectors.toSet());
Set<String> set = Stream.of("A", "B", "C", "D").collect(Collectors.toCollection(HashSet::new)); System.out.println(set); String[] stringArray = {"A", "B", "C", "D"}; Set<String> strSet1 = Arrays.stream(stringArray).collect(Collectors.toSet()); System.out.println(strSet1); Set<String> strSet2 = Arrays.stream(stringArray).collect(Collectors.toCollection(HashSet::new)); System.out.println(strSet2);
public <T> Set<T> GetSetFromArray(T[] array) { return new HashSet<T>(Arrays.asList(array)); }
Set<Integer> set1 = Sets.mutable.of(1, 2, 3, 4, 5); Set<Integer> set2 = Sets.mutable.of(new Integer[]{1, 2, 3, 4, 5}); MutableSet<Integer> mutableSet = Sets.mutable.of(1, 2, 3, 4, 5); ImmutableSet<Integer> immutableSet = Sets.immutable.of(1, 2, 3, 4, 5); Set<Integer> unmodifiableSet = Sets.mutable.of(1, 2, 3, 4, 5).asUnmodifiable(); Set<Integer> synchronizedSet = Sets.mutable.of(1, 2, 3, 4, 5).asSynchronized(); ImmutableSet<Integer> immutableSet = Sets.mutable.of(1, 2, 3, 4, 5).toImmutable();
List list = Arrays.asList(array); list = new LinkedList(Arrays.asList(array)); Set set = new HashSet(Arrays.asList(array));
Object[] objectArray = list.toArray(); MyClass[] array = (MyClass[])list.toArray(new MyClass[list.size()]); objectArray = set.toArray(); array = (MyClass[])set.toArray(new MyClass[set.size()]);
/** * Handy conversion to set */ public class SetUtil { /** * Convert some items to a set * @param items items * @param <T> works on any type * @return a hash set of the input items */ public static <T> Set<T> asSet(T ... items) { return Stream.of(items).collect(Collectors.toSet()); } }
Integer[] boxedArr = Arrays.stream(arr).boxed().toArray(Integer[]::new);
String[] keys = {"blah", "blahblah"} Set<String> myEmptySet = new HashSet<String>(); CollectionUtils.addAll(pythonKeywordSet, keys);
private Map<Integer, Set<Integer>> nobreaks = new HashMap(); nobreaks.put(1, new HashSet(Arrays.asList(new int[]{2, 4, 5}))); System.out.println("expected size is 3: " +nobreaks.get(1).size());
nobreaks.put(1, new HashSet(Arrays.asList( 2, 4, 5 )));
import static edu.stanford.nlp.util.ArrayUtils.asSet; or import static edu.stanford.nlp.util.CollectionUtils.asSet; ... String [] array = {"1", "q"}; Set<String> trackIds = asSet(array);
String[] strs = {"A", "B"}; Set<String> set = Set.copyOf(Arrays.asList(strs));
final Set s = new HashSet<Object>(); for (Object o : a) { s.add(o); }
Set<T> b = new HashSet<>(Arrays.asList(requiredArray));
List<Value> list = new ArrayList<Value>(map.values());
Map<String, String> m = new HashMap<String, String>(); m.put("Hello", "World"); m.put("Apple", "3.14"); m.put("Another", "Element");
List<String> list = new ArrayList<String>(m.keySet());
List<String> list = new ArrayList<String>(m.values());
List<Value> values = map.values().stream().collect(Collectors.toList());
ArrayList<String> list = new ArrayList<String>(map.values());
List<Value> list = new ArrayList<Value>(map.values());
Map<Key,Value> map; List<Value> list = new ArrayList<Value>( new TreeMap<Key Value>( map ));
Map<String, Integer> map = new HashMap<String, Integer>(); map.put("java", 20); map.put("C++", 45); Set <Entry<String, Integer>> set = map.entrySet(); List<Entry<String, Integer>> list = new ArrayList<Entry<String, Integer>>(set);
"Map<String , String > map = new HapshMap<String , String>; map.add("one","java"); map.add("two" ,"spring"); Set<Entry<String,String>> set = map.entrySet(); List<Entry<String , String>> list = new ArrayList<Entry<String , String>> (set); for(Entry<String , String> entry : list ) { System.out.println(entry.getKey()); System.out.println(entry.getValue()); } "
List<Value> list = new ArrayList<Value>(map.values()); List<Value> list = new ArrayList<Value>(); for (Map.Entry<String, String> entry : map.entrySet()) { list.add(entry.getValue()); }
HashMap<Integer, List<String>> map = new HashMap<>(); List<String> list = new ArrayList<String>(); list.add("Java"); list.add("Primefaces"); list.add("JSF"); map.put(1,list); if(map != null){ return new ArrayList<String>((Collection<? extends String>) map.values()); }
public static <T> List<T> ValueListFromMap(HashMap<String, T> map) { List<T> thingList = new ArrayList<>(); for (Map.Entry<String, T> entry : map.entrySet()) { thingList.add(entry.getValue()); } return thingList; }
@Configuration public class ServletConfig { @Bean public EmbeddedServletContainerCustomizer containerCustomizer() { return (container -> { container.setPort(8012); }); } }
HashMap<String, Object> props = new HashMap<>(); props.put("server.port", 9999); new SpringApplicationBuilder() .sources(SampleController.class) .properties(props) .run(args);
System.getProperties().put( "server.port", 80 ); SpringApplication.run(App.class, args);
@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)
@RunWith(SpringRunner.class @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) public class ExampleTest { ... @LocalServerPort int port; }
@SpringBootTest(webEnvironment=WebEnvironment.DEFINED_PORT)
@RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT) @TestPropertySource(properties = "server.port=9192") public class DemoApplicationTests { @Test public void contextLoads() { } }
package com.humoyun; import java.util.HashMap; import java.util.Map; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication application = new SpringApplication(MyApplication.class); Map<String, Object> map = new HashMap<>(); map.put("SERVER_PORT", "8585"); application.setDefaultProperties(map); application.run(args); } }
server.session.timeout=1 server.port = 3029 server.address= deepesh
@Component public class CustomContainer implements EmbeddedServletContainerCustomizer { @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8888); } }
A /config subdirectory of the current directory The current directory A classpath /config package The classpath root
String q = "random word 500 bank $"; String url = "http:
import org.apache.http.client.utils.URIBuilder; URIBuilder ub = new URIBuilder("http: ub.addParameter("q", "random word 500 bank \$"); String url = ub.toString();
String urlStr = "http: URL url= new URL(urlStr); URI uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef());
String addQueryStringToUrlString(String url, final Map<Object, Object> parameters) throws UnsupportedEncodingException { if (parameters == null) { return url; } for (Map.Entry<Object, Object> parameter : parameters.entrySet()) { final String encodedKey = URLEncoder.encode(parameter.getKey().toString(), "UTF-8"); final String encodedValue = URLEncoder.encode(parameter.getValue().toString(), "UTF-8"); if (!url.contains("?")) { url += "?" + encodedKey + "=" + encodedValue; } else { url += "&" + encodedKey + "=" + encodedValue; } } return url; }
URL url= new URL("http: URI uri = new URI(url.getProtocol(), url.getUserInfo(), IDN.toASCII(url.getHost()), url.getPort(), url.getPath(), url.getQuery(), url.getRef()); String correctEncodedURL=uri.toASCIIString(); System.out.println(correctEncodedURL);
{ "in" : "http: "out" : "http: },{ "in" : "http: "out" : "http: },{ "in" : "http: "out" : "http: }, { "in" : "http: "out" : "http: }
String encodedUrl1 = UriUtils.encodeQuery(query, "UTF-8"); String encodedUrl2 = URLEncoder.encode(query, "UTF-8"); String encodedUrl3 = URLEncoder.encode(query, StandardCharsets.UTF_8.displayName()); System.out.println("url1 " + encodedUrl1 + "\n" + "url2=" + encodedUrl2 + "\n" + "url3=" + encodedUrl3);
/usr/bin/ruby -e "$(curl -fsSL https: brew tap caskroom/versions brew update
$ brew tap caskroom/versions $ brew cask install java8
FROM java:8 COPY . /usr/src/myapp WORKDIR /usr/src/myapp
version: "2" services: java: build: . volumes: - .:/usr/src/myapp
public class HelloWorld { public static void main(String[] args) { System.out.println("Hello, World"); } }
. |_ Dockerfile |_ docker-compose.yml |_ HelloWorld.java
ls -la /Library/Java/JavaVirtualMachines drwxr-xr-x 3 root wheel 96B Nov 16 2014 jdk1.7.0_71.jdk/ drwxr-xr-x 3 root wheel 96B Mar 1 2015 jdk1.8.0_31.jdk/
export JAVA_HOME=YOUR_JAVA_PATH/Contents/Home export PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_71.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_31.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH
java -version java version "1.7.0_71" Java(TM) SE Runtime Environment (build 1.7.0_71-b14)
java -version java version "1.8.0_31" Java(TM) SE Runtime Environment (build 1.8.0_31-b13)
brew update brew tap caskroom/versions brew cask install java8
1) brew cask install java (No need to install cask separately it comes with brew) 2) java -version java version "1.8.0_131" Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_XXX.jdk./Contents/Home export PATH=$JAVA_HOME/bin:$PATH
$ sdk list java ================================================================================ Available Java Versions ================================================================================ * 12.ea.20-open 11.0.1-zulu > * 11.0.1-open 10.0.2-zulu 10.0.2-open 9.0.7-zulu 9.0.4-open 8.0.192-zulu 8.0.191-oracle + 8.0.181-oracle 7.0.181-zulu 1.0.0-rc-10-grl 1.0.0-rc-9-grl 1.0.0-rc-8-grl ================================================================================ + - local version * - installed > - currently in use ================================================================================ $ sdk install java 8.0.191-oracle $ sdk use java 8.0.191-oracle Using java version 8.0.191-oracle in this shell. $ java -version java version "1.8.0_191" Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) $ sdk use java 11.0.1-open Using java version 11.0.1-open in this shell. $ java -version openjdk version "11.0.1" 2018-10-16 OpenJDK Runtime Environment 18.9 (build 11.0.1+13) OpenJDK 64-Bit Server VM 18.9 (build 11.0.1+13, mixed mode) ```
sudo rm -fr /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin sudo rm -fr /Library/PreferencePanes/JavaControlPanel.prefpane
try (PrintWriter out = new PrintWriter("filename.txt")) { out.println(text); }
static void writeStringToFile(File file, String data)
FileUtils.writeStringToFile(new File("test.txt"), "Hello File");
try (PrintStream out = new PrintStream(new FileOutputStream("filename.txt"))) { out.print(text); }
BufferedWriter writer = null; try { writer = new BufferedWriter( new FileWriter( yourfilename)); writer.write( yourstring); } catch ( IOException e) { } finally { try { if ( writer != null) writer.close( ); } catch ( IOException e) { } }
String content = "Hello File!"; String path = "C:/a.txt"; Files.write( Paths.get(path), content.getBytes(), StandardOpenOption.CREATE);
import java.io.*; public class Main { public static void main(String[] args) { try { String str = "SomeMoreTextIsHere"; File newTextFile = new File("C:/thetextfile.txt"); FileWriter fw = new FileWriter(newTextFile); fw.write(str); fw.close(); } catch (IOException iox) { iox.printStackTrace(); } } }
FileUtils.writeStringToFile(new File("FileNameToWrite.txt"), "stringToWrite");
<dependency> <groupId>commons-io</groupId> <artifactId>commons-io</artifactId> <version>2.4</version> </dependency>
File destination = new File("file.txt"); System.out.println(destination.getAbsolutePath()); try { Files.write(text, destination, Charset.forName("UTF-8")); } catch (IOException e) { }
import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; public class StringWriteSample { public static void main(String[] args) { String text = "This is text to be saved in file"; try { Files.write(Paths.get("my-file.txt"), text.getBytes()); } catch (IOException e) { e.printStackTrace(); } } }
import java.io.*; private void stringToFile( String text, String fileName ) { try { File file = new File( fileName ); if ( ! file.exists( ) ) { file.createNewFile( ); } FileWriter fw = new FileWriter( file.getAbsoluteFile( ) ); BufferedWriter bw = new BufferedWriter( fw ); bw.write( text ); bw.close( ); } catch( IOException e ) { System.out.println("Error: " + e); e.printStackTrace( ); } }
import java.nio.file.Files; import java.nio.file.Paths; Files.write(Paths.get(path), lines.getBytes(), StandardOpenOption.WRITE);
import java.io.*; import java.util.*; class WriteText { public static void main(String[] args) { try { String text = "Your sample content to save in a text file."; BufferedWriter out = new BufferedWriter(new FileWriter("sample.txt")); out.write(text); out.close(); } catch (IOException e) { System.out.println("Exception "); } return ; } };
public static void writeToFile(String text, String targetFilePath) throws IOException { Path targetPath = Paths.get(targetFilePath); byte[] bytes = text.getBytes(StandardCharsets.UTF_8); Files.write(targetPath, bytes, StandardOpenOption.CREATE); }
FileUtils.writeStringToFile(new File("log.txt"), "my string", Charset.defaultCharset());
JFileChooser chooser = new JFileChooser(); int returnVal = chooser.showSaveDialog(this); if (returnVal == JFileChooser.APPROVE_OPTION) { FileOutputStream stream = null; PrintStream out = null; try { File file = chooser.getSelectedFile(); stream = new FileOutputStream(file); String text = "Your String goes here"; out = new PrintStream(stream); out.print(text); } catch (Exception ex) { } finally { try { if(stream!=null) stream.close(); if(out!=null) out.close(); } catch (Exception ex) { } } }
finally{ if(writer != null){ try{ writer.flush(); writer.close(); } catch(IOException ioe){ ioe.printStackTrace(); } } }
String NameFile = Name.getText(); ArrayList< String > Text = new ArrayList< String >(); Text.add(TextArea.getText()); SaveFile(NameFile, Text);
path = "C:\\Users\\Paulo Brito\\Desktop\\" + name + ".txt"; File file1 = new File(path); try { if (!file1.exists()) { file1.createNewFile(); } File[] files = file1.listFiles(); FileWriter fw = new FileWriter(file1, true); BufferedWriter bw = new BufferedWriter(fw); for (int i = 0; i < message.size(); i++) { bw.write(message.get(i)); bw.newLine(); } bw.close(); fw.close(); FileReader fr = new FileReader(file1); BufferedReader br = new BufferedReader(fr); fw = new FileWriter(file1, true); bw = new BufferedWriter(fw); while (br.ready()) { String line = br.readLine(); System.out.println(line); bw.write(line); bw.newLine(); } br.close(); fr.close(); } catch (IOException ex) { ex.printStackTrace(); JOptionPane.showMessageDialog(null, "Error in" + ex);
String text = "content"; Path path = Paths.get("path", "to", "file"); Files.write(path, Arrays.asList(text));
jLabel1 = new JLabel("Enter SQL Statements or SQL Commands:"); orderButton = new JButton("Execute"); textArea = new JTextArea(); ... orderButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent ae) { String tempQuery = textArea.getText(); tempQuery = tempQuery.replaceAll("\n", "\r\n"); try (PrintStream out = new PrintStream(new FileOutputStream("C:/Temp/tempQuery.sql"))) { out.print(tempQuery); } catch (FileNotFoundException e) { e.printStackTrace(); } System.out.println(tempQuery); } });
public boolean writeStringToFile(File file, String string, Charset charset) { if (file == null) return false; if (string == null) return false; return writeBytesToFile(file, string.getBytes((charset == null) ? DEFAULT_CHARSET:charset)); } public boolean writeBytesToFile(File file, byte[] data) { if (file == null) return false; if (data == null) return false; FileOutputStream fos; BufferedOutputStream bos; try { fos = new FileOutputStream(file); bos = new BufferedOutputStream(fos); bos.write(data, 0, data.length); bos.flush(); bos.close(); fos.close(); } catch (IOException e) { e.printStackTrace(); Logger.e("!!! IOException"); return false; } return true; }
try { ... } catch (IllegalArgumentException e) { someCode(); } catch (SecurityException e) { someCode(); } catch (IllegalAccessException e) { someCode(); } catch (NoSuchFieldException e) { someCode(); }
try { ... } catch (IOException | SQLException ex) { ... }
try { } catch (Exception exc) { if (exc instanceof IllegalArgumentException || exc instanceof SecurityException || exc instanceof IllegalAccessException || exc instanceof NoSuchFieldException ) { someCode(); } else if (exc instanceof RuntimeException) { throw (RuntimeException) exc; } else { throw new RuntimeException(exc); } }
try { } catch ( IllegalArgumentException | SecurityException | IllegalAccessException |NoSuchFieldException exc) { someCode(); }
catch (IllegalArgumentException | SecurityException e) { ... }
try { } catch(Exception e) { e.printStackTrace(); }
try { ... } catch (RepositoryException re) { someCode(); } catch (Exception e) { someCode(); }
try { ... } catch( IOException | SQLException ex ) { ... }
try { } catch (Exception e) { if (e instanceof RuntimeException) { throw e; } else { } }
Boolean caught = true; Exception e; try { ... caught = false; } catch (TransformerException te) { e = te; } catch (SocketException se) { e = se; } catch (IOException ie) { e = ie; } if (caught) { someCode(); }
try { ....... } catch { catch(IllegalArgumentException | SecurityException | IllegalAccessException | NoSuchFieldException e) }
List<Person> beerDrinkers = persons.stream() .filter(p -> p.getAge() > 16).collect(Collectors.toList());
List<Person> beerDrinkers = select(persons, having(on(Person.class).getAge(), greaterThan(16)));
public interface IPredicate<T> { boolean apply(T type); }
public static <T> Collection<T> filter(Collection<T> target, IPredicate<T> predicate) { Collection<T> result = new ArrayList<T>(); for (T element: target) { if (predicate.apply(element)) { result.add(element); } } return result; }
Predicate<User> isAuthorized = new Predicate<User>() { public boolean apply(User user) { return user.isAuthorized(); } }; Collection<User> authorizedUsers = filter(allUsers, isAuthorized);
public class Predicate { public static Object predicateParams; public static <T> Collection<T> filter(Collection<T> target, IPredicate<T> predicate) { Collection<T> result = new ArrayList<T>(); for (T element : target) { if (predicate.apply(element)) { result.add(element); } } return result; } public static <T> T select(Collection<T> target, IPredicate<T> predicate) { T result = null; for (T element : target) { if (!predicate.apply(element)) continue; result = element; break; } return result; } public static <T> T select(Collection<T> target, IPredicate<T> predicate, T defaultValue) { T result = defaultValue; for (T element : target) { if (!predicate.apply(element)) continue; result = element; break; } return result; } }
List<MyTypeA> missingObjects = (List<MyTypeA>) Predicate.filter(myCollectionOfA, new IPredicate<MyTypeA>() { public boolean apply(MyTypeA objectOfA) { Predicate.predicateParams = objectOfA.getName(); return Predicate.select(myCollectionB, new IPredicate<MyTypeB>() { public boolean apply(MyTypeB objectOfB) { return objectOfB.getName().equals(Predicate.predicateParams.toString()); } }) == null; } });
MyType myObject = Predicate.select(collectionOfMyType, new IPredicate<MyType>() { public boolean apply(MyType objectOfMyType) { return objectOfMyType.isDefault(); }}, collectionOfMyType.get(0));
final UserService userService = ... final Optional<UserModel> userOption = userCollection.stream().filter(u -> { boolean isAuthorized = userService.isAuthorized(u); return isAuthorized; }).findFirst();
final UserService userService = ... final List<UserModel> userOption = userCollection.stream().filter(u -> { boolean isAuthorized = userService.isAuthorized(u); return isAuthorized; }).collect(Collectors.toList());
Iterator<Foo> it = col.iterator(); while( it.hasNext() ) { Foo foo = it.next(); if( !condition(foo) ) it.remove(); }
CollectionUtils.filterInPlace(col, new IPredicate<Foo>(){ public boolean keepIt(Foo foo) { return foo.isBar(); } });
List<Person> olderThan30 = personList.stream(). filter(p -> p.age >= 30). collect(Collectors.toList());
Collection<T> collection = ...; Stream<T> stream = collection.stream().filter(...);
List<Integer> numbers = Arrays.asList(12, 74, 5, 8, 16); numbers.stream().filter(n -> n > 10).forEach(System.out::println);
Observable.from(Arrays.asList(1, 2, 3, 4, 5)) .filter(new Func1<Integer, Boolean>() { public Boolean call(Integer i) { return i % 2 != 0; } }) .subscribe(new Action1<Integer>() { public void call(Integer i) { System.out.println(i); } });
public interface Predicate<T> { public boolean filter(T t); } void filterCollection(Collection<T> col, Predicate<T> predicate) { for (Iterator i = col.iterator(); i.hasNext();) { T obj = i.next(); if (predicate.filter(obj)) { i.remove(); } } }
List<MyObject> myList = ...; filterCollection(myList, new Predicate<MyObject>() { public boolean filter(MyObject obj) { return obj.shouldFilter(); } });
List<Customer> list ...; List<Customer> newList = new ArrayList<>(); for (Customer c : list){ if (c.getName().equals("dd")) newList.add(c); }
List<Customer> newList = list.stream().filter(c -> c.getName().equals("dd")).collect(toList());
List<Integer> jdkList = Arrays.asList(1, 2, 3, 4, 5); MutableList<Integer> ecList = Lists.mutable.with(1, 2, 3, 4, 5);
List<Integer> selected = Lists.mutable.with(1, 2); List<Integer> rejected = Lists.mutable.with(3, 4, 5);
Predicate<Integer> lessThan3 = new Predicate<Integer>() { public boolean accept(Integer each) { return each < 3; } }; Assert.assertEquals(selected, Iterate.select(jdkList, lessThan3)); Assert.assertEquals(selected, ecList.select(lessThan3));
Assert.assertEquals(selected, Iterate.select(jdkList, Predicates.lessThan(3))); Assert.assertEquals(selected, ecList.select(Predicates.lessThan(3)));
Assert.assertEquals( selected, ecList.selectWith(Predicates2.<Integer>lessThan(), 3));
Assert.assertEquals(rejected, Iterate.reject(jdkList, lessThan3)); Assert.assertEquals(rejected, ecList.reject(lessThan3));
Assert.assertEquals(selected, Iterate.select(jdkList, each -> each < 3)); Assert.assertEquals(rejected, Iterate.reject(jdkList, each -> each < 3)); Assert.assertEquals(selected, gscList.select(each -> each < 3)); Assert.assertEquals(rejected, gscList.reject(each -> each < 3));
PartitionIterable<Integer> jdkPartitioned = Iterate.partition(jdkList, lessThan3); Assert.assertEquals(selected, jdkPartitioned.getSelected()); Assert.assertEquals(rejected, jdkPartitioned.getRejected()); PartitionList<Integer> ecPartitioned = gscList.partition(lessThan3); Assert.assertEquals(selected, ecPartitioned.getSelected()); Assert.assertEquals(rejected, ecPartitioned.getRejected());
import static ch.akuhn.util.query.Query.select; import static ch.akuhn.util.query.Query.$result; import ch.akuhn.util.query.Select; Collection<String> collection = ... for (Select<String> each : select(collection)) { each.yield = each.value.length() > 3; } Collection<String> result = $result();
LinkedList<Person> list = ...... LinkedList<Person> filtered = Query.from(list).where(Condition.ensure("age", Op.GTE, 21));
LinkedList<Person> list = .... LinkedList<Person> filtered = Query.from(list).where("x => x.age >= 21");
public static <T, A, R> Collector<T, ?, R> filtering(Predicate<? super T> predicate, Collector<? super T, A, R> downstream)
collection.stream().collect(Collectors.filtering(predicate, collector))
List<Integer> oddNumbers = List.of(1, 19, 15, 10, -10).stream() .collect(Collectors.filtering(i -> i % 2 == 1, Collectors.toList()));
List<Integer> myList = new ArrayList<Integer>(){ 1, 2, 3, 4, 5 } Iterable<Integer> filtered = Iterable.wrap(myList).select(new Predicate1<Integer>() { public Boolean call(Integer n) throws FunctionalException { return n % 2 == 0; } }) for( int n : filtered ) { System.out.println(n); }
for( int n : myList ) { if( n % 2 == 0 ) { System.out.println(n); } }
public abstract class AbstractFilter<T> { /** * Method that returns whether an item is to be included or not. * @param item an item from the given collection. * @return true if this item is to be included in the collection, false in case it has to be removed. */ protected abstract boolean excludeItem(T item); public void filter(Collection<T> collection) { if (CollectionUtils.isNotEmpty(collection)) { Iterator<T> iterator = collection.iterator(); while (iterator.hasNext()) { if (excludeItem(iterator.next())) { iterator.remove(); } } } } }
ArrayList<Item> filtered = new ArrayList<Item>(); for (Item item : items) if (condition(item)) filtered.add(item);
class Dto { private int id; private String text; public int getId() { return id; } public int getText() { return text; } }
Filter<Dto> query = CQ.<Dto>filter(testList) .where() .property("id").eq().value(1); Collection<Dto> filtered = query.list();
Filter<Dto> query = CQ.<Dto>filter(testList) .where() .property(Dto::getId) .eq().value(1); Collection<Dto> filtered = query.list();
Filter<Dto> query = CQ.<Dto>filter() .from(testList) .where() .property(Dto::getId).between().value(1).value(2) .and() .property(Dto::grtText).in().value(new string[]{"a","b"});
Filter<Dto> query = CQ.<Dto>filter(testList) .orderBy() .property(Dto::getId) .property(Dto::getName) Collection<Dto> sorted = query.list();
GroupQuery<Integer,Dto> query = CQ.<Dto,Dto>query(testList) .group() .groupBy(Dto::getId) Collection<Grouping<Integer,Dto>> grouped = query.list();
class LeftDto { private int id; private String text; public int getId() { return id; } public int getText() { return text; } } class RightDto { private int id; private int leftId; private String text; public int getId() { return id; } public int getLeftId() { return leftId; } public int getText() { return text; } } class JoinedDto { private int leftId; private int rightId; private String text; public JoinedDto(int leftId,int rightId,String text) { this.leftId = leftId; this.rightId = rightId; this.text = text; } public int getLeftId() { return leftId; } public int getRightId() { return rightId; } public int getText() { return text; } } Collection<LeftDto> leftList = new ArrayList<>(); Collection<RightDto> rightList = new ArrayList<>();
Collection<JoinedDto> results = CQ.<LeftDto, LeftDto>query().from(leftList) .<RightDto, JoinedDto>innerJoin(CQ.<RightDto, RightDto>query().from(rightList)) .on(LeftFyo::getId, RightDto::getLeftId) .transformDirect(selection -> new JoinedDto(selection.getLeft().getText() , selection.getLeft().getId() , selection.getRight().getId()) ) .list();
Filter<Dto> query = CQ.<Dto>filter() .from(testList) .where() .exec(s -> s.getId() + 1).eq().value(2);
CollectionUtils.filter(list, p -> ((Person) p).getAge() > 16);
public class Filter { public static <T> void List(List<T> list, Chooser<T> chooser) { List<Integer> toBeRemoved = new ArrayList<>(); leftloop: for (int right = 1; right < list.size(); ++right) { for (int left = 0; left < right; ++left) { if (toBeRemoved.contains(left)) { continue; } Keep keep = chooser.choose(list.get(left), list.get(right)); switch (keep) { case LEFT: toBeRemoved.add(right); continue leftloop; case RIGHT: toBeRemoved.add(left); break; case NONE: toBeRemoved.add(left); toBeRemoved.add(right); continue leftloop; } } } Collections.sort(toBeRemoved, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); for (int i : toBeRemoved) { if (i >= 0 && i < list.size()) { list.remove(i); } } } public static <T> void List(List<T> list, Keeper<T> keeper) { Iterator<T> iterator = list.iterator(); while (iterator.hasNext()) { if (!keeper.keep(iterator.next())) { iterator.remove(); } } } public interface Keeper<E> { boolean keep(E obj); } public interface Chooser<E> { Keep choose(E left, E right); } public enum Keep { LEFT, RIGHT, BOTH, NONE; } }
List<String> names = new ArrayList<>(); names.add("Anders"); names.add("Stefan"); names.add("Anders"); Filter.List(names, new Filter.Chooser<String>() { @Override public Filter.Keep choose(String left, String right) { return left.equals(right) ? Filter.Keep.LEFT : Filter.Keep.BOTH; } });
myProducts.stream().filter(prod -> prod.price>10).collect(Collectors.toList())
Collection<Integer> collection = Lists.newArrayList(1, 2, 3, 4, 5); Iterators.removeIf(collection.iterator(), new Predicate<Integer>() { @Override public boolean apply(Integer i) { return i % 2 == 0; } }); System.out.println(collection);
In Java 8, You can directly use this filter method and then do that. List<String> lines = Arrays.asList("java", "pramod", "example"); List<String> result = lines.stream() .filter(line -> !"pramod".equals(line)) .collect(Collectors.toList()); result.forEach(System.out::println);
List<String> newList = new ArrayList<String>(); newList.addAll(listOne); newList.addAll(listTwo);
List<String> newList = new ArrayList<String>(listOne); newList.addAll(listTwo);
List<String> newList = Stream.concat(listOne.stream(), listTwo.stream()) .collect(Collectors.toList());
List<String> newList = ListUtils.union(list1, list2);
List<String> newList = new ArrayList<String>() { { addAll(listOne); addAll(listTwo); } };
public class CompositeUnmodifiableList<E> extends AbstractList<E> { private final List<E> list1; private final List<E> list2; public CompositeUnmodifiableList(List<E> list1, List<E> list2) { this.list1 = list1; this.list2 = list2; } @Override public E get(int index) { if (index < list1.size()) { return list1.get(index); } return list2.get(index-list1.size()); } @Override public int size() { return list1.size() + list2.size(); } }
List<String> newList = new CompositeUnmodifiableList<String>(listOne,listTwo);
List<String> newList = new ArrayList<>(listOne.size() + listTwo.size()); newList.addAll(listOne); newList.addAll(listTwo);
List<String> newList = Stream.of(listOne, listTwo) .flatMap(x -> x.stream()) .collect(Collectors.toList());
List<String> newList = Stream.of(listOne, listTwo, listThree) .flatMap(x -> x.stream()) .collect(Collectors.toList());
List<Object> newList = new ArrayList<>(); Stream.of(list1, list2).forEach(newList::addAll);
List<String> newList = new ArrayList<String>(listOne); newList.addAll(listTwo);
List<String> newList = new ArrayList<String>(listOne); newList.addAll(listTwo);
List<String> result1 = Stream.concat(Stream.concat(list1.stream(),list2.stream()),list3.stream()).collect(Collectors.toList()); List<String> result2 = Stream.of(list1,list2,list3).flatMap(Collection::stream).collect(Collectors.toList());
public static <T> List<T> concatenatedList(List<T>... collections) { return Arrays.stream(collections).flatMap(Collection::stream).collect(Collectors.toList()); }
List<String> result3 = StringUtils.concatenatedList(list1,list2,list3);
(newList = new ArrayList<String>(list1)).addAll(list2);
List<E> li = lol.stream().collect(ArrayList::new, List::addAll, List::addAll);
List<E> ints = Stream.of(list1, list2).collect(ArrayList::new, List::addAll, List::addAll);
List<List<Integer>> lol = Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6)); List<Integer> li = lol.stream().collect(ArrayList::new, List::addAll, List::addAll); System.out.println(lol); System.out.println(li);
List<?> newList = Stream.of(list1, list2).flatMap(List::stream).collect(Collectors.toList());
/** * @param smallLists * @return one big list containing all elements of the small ones, in the same order. */ public static <E> List<E> concatenate (final List<E> ... smallLists) { final ArrayList<E> bigList = new ArrayList<E>(); for (final List<E> list: smallLists) { bigList.addAll(list); } return bigList; }
public List<SomeClass> mergeLists(final List<SomeClass> left, final List<SomeClass> right, String primaryKey) { final Map<Object, SomeClass> mergedList = new LinkedHashMap<>(); Stream.concat(left.stream(), right.stream()) .map(someObject -> new Pair<Object, SomeClass>(someObject.getSomeKey(), someObject)) .forEach(pair-> mergedList.put(pair.getKey(), pair.getValue())); return new ArrayList<>(mergedList.values()); }
@SafeVarargs public static <T> List<T> concat(List<T>... lists) { return Stream.of(lists).flatMap(List::stream).collect(Collectors.toList()); }
public class Lists { private Lists() { } public static List<T> join(List<T>... lists) { List<T> result = new ArrayList<T>(); for(List<T> list : lists) { result.addAll(list); } return results; } }
import static Lists.join; List<T> result = join(list1, list2, list3, list4);
public static <T> List<T> merge(List<T>... args) { final List<T> result = new ArrayList<>(); for (List<T> list : args) { result.addAll(list); } return result; }
public static <E> Collection<E> addAll(Collection<E> dest, Collection<? extends E>... src) { for(Collection<? extends E> c : src) { dest.addAll(c); } return dest; } public static void main(String[] args) { System.out.println(addAll(new ArrayList<Object>(), Arrays.asList(1,2,3), Arrays.asList("a", "b", "c"))); System.out.println(addAll(new ArrayList<Integer>(), Arrays.asList(1,2,3), Arrays.asList(4, 5, 6))); }
public static final EnumSet<MyType> CATEGORY_A = EnumSet.of(A_1, A_2); public static final EnumSet<MyType> CATEGORY_B = EnumSet.of(B_1, B_2, B_3); public static final List<MyType> ALL = Collections.unmodifiableList( new ArrayList<MyType>(CATEGORY_A.size() + CATEGORY_B.size()) {{ addAll(CATEGORY_A); addAll(CATEGORY_B); }} );
public static <T> List<T> merge(@Nonnull final List<T>... list) { int mergedLength = 0; for (List<T> ts : list) { mergedLength += ts.size(); } final List<T> mergedList = new ArrayList<>(mergedLength); for (List<T> ts : list) { mergedList.addAll(ts); } return mergedList; }
Collection mergedList = Collections.list(new sun.misc.CompoundEnumeration(new Enumeration[] { new Vector(list1).elements(), new Vector(list2).elements(), ... }))
List<String> newList = new ArrayList<String>(l1); newList.addAll(l2); for(String w:newList) System.out.printf("%s ", w);
public static void main(String[] args) { List<String> list2 = new ArrayList<>(); List<Pair<Integer, String>> list1 = new ArrayList<>(); list2.add("asd"); list2.add("asdaf"); list1.add(new Pair<>(1, "werwe")); list1.add(new Pair<>(2, "tyutyu")); Stream stream = Stream.concat(list1.stream(), list2.stream()); List<Pair<Integer, String>> res = (List<Pair<Integer, String>>) stream .map(item -> { if (item instanceof String) { return new Pair<>(0, item); } else { return new Pair<>(((Pair<Integer, String>)item).getKey(), ((Pair<Integer, String>)item).getValue()); } }) .collect(Collectors.toList()); }
List<String> newList = new ArrayList<String>(Arrays.asList((listOne.toString().subString(1, listOne.length() - 1) + ", " + listTwo.toString().subString(1, listTwo.length() - 1)).split(", ")));
public class TestApp { /** * @param args */ public static void main(String[] args) { System.out.println("Hi"); Set<List<String>> bcOwnersList = new HashSet<List<String>>(); List<String> bclist = new ArrayList<String>(); List<String> bclist1 = new ArrayList<String>(); List<String> object = new ArrayList<String>(); object.add("BC11"); object.add("C2"); bclist.add("BC1"); bclist.add("BC2"); bclist.add("BC3"); bclist.add("BC4"); bclist.add("BC5"); bcOwnersList.add(bclist); bcOwnersList.add(object); bclist1.add("BC11"); bclist1.add("BC21"); bclist1.add("BC31"); bclist1.add("BC4"); bclist1.add("BC5"); List<String> listList= new ArrayList<String>(); for(List<String> ll : bcOwnersList){ listList = (List<String>) CollectionUtils.union(listList,CollectionUtils.intersection(ll, bclist1)); } /*for(List<String> lists : listList){ test = (List<String>) CollectionUtils.union(test, listList); }*/ for(Object l : listList){ System.out.println(l.toString()); } System.out.println(bclist.contains("BC")); } }
Cannot complete the install because of a conflicting dependency. Software being installed: Android Development Tools 23.0.0.1245622 (com.android.ide.eclipse.adt.feature.feature.group 23.0.0.1245622) Software currently installed: Android Developer Tools 22.2.1.v201309180102-833290 (com.android.ide.eclipse.adt.package.product 22.2.1.v201309180102-833290) Only one of the following can be installed at once: ADT Package 22.6.3.v201404151837-1123206 (com.android.ide.eclipse.adt.package 22.6.3.v201404151837-1123206) ADT Package 23.0.0.1245622 (com.android.ide.eclipse.adt.package 23.0.0.1245622) Cannot satisfy dependency: From: Android Development Tools 23.0.0.1245622 (com.android.ide.eclipse.adt.feature.feature.group 23.0.0.1245622) To: com.android.ide.eclipse.adt.package [23.0.0.1245622] Cannot satisfy dependency: From: Android Development Tools 22.6.3.v201404151837-1123206 (com.android.ide.eclipse.adt.feature.group 22.6.3.v201404151837-1123206) To: com.android.ide.eclipse.adt.package [22.6.3.v201404151837-1123206] Cannot satisfy dependency: From: ADT Package 22.2.1.v201309180102-833290 (com.android.ide.eclipse.adt.package.feature.group 22.2.1.v201309180102-833290) To: com.android.ide.eclipse.adt.feature.group 22.2.0 Cannot satisfy dependency: From: Android Developer Tools 22.2.1.v201309180102-833290 (com.android.ide.eclipse.adt.package.product 22.2.1.v201309180102-833290) To: com.android.ide.eclipse.adt.package.feature.group [22.2.1.v201309180102-833290]
tools/hprof-conv tools/support/annotations.jar tools/proguard
com.android.ide.eclipse.adt_**22.6.2**.v201403212031-1085508
{ "id" : "junk", "stuff" : "things" } MyClass instance = objectMapper.readValue(json, MyClass.class);
[{ "id" : "junk", "stuff" : "things" }, { "id" : "spam", "stuff" : "eggs" }] List<MyClass> entries = ?
import com.fasterxml.jackson.databind.ObjectMapper; ObjectMapper mapper = new ObjectMapper();
MyClass[] myObjects = mapper.readValue(json, MyClass[].class);
List<MyClass> myObjects = mapper.readValue(jsonInput, new TypeReference<List<MyClass>>(){});
List<MyClass> myObjects = mapper.readValue(jsonInput, mapper.getTypeFactory().constructCollectionType(List.class, MyClass.class));
List<MyClass> myObjects = Arrays.asList(mapper.readValue(json, MyClass[].class))
public static <T> List<T> parseJsonArray(String json, Class<T> classOnWhichArrayIsDefined) throws IOException, ClassNotFoundException { ObjectMapper mapper = new ObjectMapper(); Class<T[]> arrayClass = (Class<T[]>) Class.forName("[L" + classOnWhichArrayIsDefined.getName() + ";"); T[] objects = mapper.readValue(json, arrayClass); return Arrays.asList(objects); }
try { ObjectMapper mapper = new ObjectMapper(); JsonFactory f = new JsonFactory(); List<User> lstUser = null; JsonParser jp = f.createJsonParser(new File("C:\\maven\\user.json")); TypeReference<List<User>> tRef = new TypeReference<List<User>>() {}; lstUser = mapper.readValue(jp, tRef); for (User user : lstUser) { System.out.println(user.toString()); } } catch (JsonGenerationException e) { e.printStackTrace(); } catch (JsonMappingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }
ObjectMapper objectMapper = new ObjectMapper(); ObjectReader objectReader = objectMapper.reader().forType(new TypeReference<List<MyClass>>(){});
List<MyClass> result = objectReader.readValue(inputStream);
import java.io.IOException; import java.io.StringWriter; import java.util.List; import com.fasterxml.jackson.core.JsonGenerationException; import com.fasterxml.jackson.core.JsonParseException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.JsonMappingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; /** * * @author TIAGO.MEDICI * */ public class JsonUtils { public static boolean isJSONValid(String jsonInString) { try { final ObjectMapper mapper = new ObjectMapper(); mapper.readTree(jsonInString); return true; } catch (IOException e) { return false; } } public static String serializeAsJsonString(Object object) throws JsonGenerationException, JsonMappingException, IOException { ObjectMapper objMapper = new ObjectMapper(); objMapper.enable(SerializationFeature.INDENT_OUTPUT); objMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); StringWriter sw = new StringWriter(); objMapper.writeValue(sw, object); return sw.toString(); } public static String serializeAsJsonString(Object object, boolean indent) throws JsonGenerationException, JsonMappingException, IOException { ObjectMapper objMapper = new ObjectMapper(); if (indent == true) { objMapper.enable(SerializationFeature.INDENT_OUTPUT); objMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); } StringWriter stringWriter = new StringWriter(); objMapper.writeValue(stringWriter, object); return stringWriter.toString(); } public static <T> T jsonStringToObject(String content, Class<T> clazz) throws JsonParseException, JsonMappingException, IOException { T obj = null; ObjectMapper objMapper = new ObjectMapper(); obj = objMapper.readValue(content, clazz); return obj; } @SuppressWarnings("rawtypes") public static <T> T jsonStringToObjectArray(String content) throws JsonParseException, JsonMappingException, IOException { T obj = null; ObjectMapper mapper = new ObjectMapper(); obj = mapper.readValue(content, new TypeReference<List>() { }); return obj; } public static <T> T jsonStringToObjectArray(String content, Class<T> clazz) throws JsonParseException, JsonMappingException, IOException { T obj = null; ObjectMapper mapper = new ObjectMapper(); mapper = new ObjectMapper().configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); obj = mapper.readValue(content, mapper.getTypeFactory().constructCollectionType(List.class, clazz)); return obj; }
Set<String> h = new HashSet<String>(); h.add("a"); h.add("b");
Set<String> h = new HashSet<>(Arrays.asList("a", "b"));
public static final String[] SET_VALUES = new String[] { "a", "b" }; public static final Set<String> MY_SET = new HashSet<>(Arrays.asList(SET_VALUES));
Set<String> h = new HashSet<String>() {{ add("a"); add("b"); }};
Set<String> set = Stream.of("a", "b").collect(Collectors.toSet());
Set<String> set = Stream.of("a", "b") .collect(Collectors.toCollection(HashSet::new));
Set<String> strSet1 = Stream.of("A", "B", "C", "D") .collect(Collectors.toUnmodifiableSet());
Set<String> strSet6 = Set.of("Apple", "Ball", "Cat", "Dog");
Set<String> strSet1 = Stream.of("A", "B", "C", "D") .collect(Collectors.toCollection(HashSet::new)); Set<String> strSet2 = Arrays.stream(stringArray) .collect(Collectors.toCollection(HashSet::new)); Set<String> strSet3 = stringList.stream() .collect(Collectors.toCollection(HashSet::new));
Set<String> strSet4 = Collections.unmodifiableSet(strSet1);
class ImmutableCollector { public static <T> Collector<T, Set<T>, Set<T>> toImmutableSet() { return Collector.of(HashSet::new, Set::add, (l, r) -> { l.addAll(r); return l; }, Collections::unmodifiablSet); } }
Set<String> strSet4 = Stream.of("A", "B", "C", "D") .collect(ImmutableCollector.toImmutableSet());
import static java.util.stream.Collectors.*; Set<String> strSet5 = Stream.of("A", "B", "C", "D").collect(collectingAndThen( toCollection(HashSet::new),Collections::unmodifiableSet));
Set<String> s = new HashSet<String>() {{ add("a"); add("b"); }}
public static Set<String> newHashSet(String... strings) { HashSet<String> set = new HashSet<String>(); for (String s : strings) { set.add(s); } return set; }
Set<String> h = new HashSet<String>(Arrays.asList("a", "b", "c"));
Set<String> StringSet = Sets.newSet("a", "b", "c");
Set<String> h = new HashSet<String>(); Collections.addAll(h, "a", "b");
public static <T> Set<T> newHashSet(T... objs) { Set<T> set = new HashSet<T>(); for (T o : objs) { set.add(o); } return set; }
Set<MY_ENUM> MY_SET = EnumSet.of( MY_ENUM.value1, MY_ENUM.value2, ... );
Set<String> set = Sets.mutable.with("a", "b"); HashSet<String> hashSet = Sets.mutable.with("a", "b").asLazy().into(new HashSet<String>()); Set<String> synchronizedSet = Sets.mutable.with("a", "b").asSynchronized(); Set<String> unmodifiableSet = Sets.mutable.with("a", "b").asUnmodifiable(); MutableSet<String> mutableSet = Sets.mutable.with("a", "b"); MutableSet<String> synchronizedMutableSet = Sets.mutable.with("a", "b").asSynchronized(); MutableSet<String> unmodifiableMutableSet = Sets.mutable.with("a", "b").asUnmodifiable(); ImmutableSet<String> immutableSet = Sets.immutable.with("a", "b"); ImmutableSet<String> immutableSet2 = Sets.mutable.with("a", "b").toImmutable(); CharSet charSet = CharSets.mutable.with( CharSet synchronizedCharSet = CharSets.mutable.with( CharSet unmodifiableCharSet = CharSets.mutable.with( MutableCharSet mutableCharSet = CharSets.mutable.with( ImmutableCharSet immutableCharSet = CharSets.immutable.with( ImmutableCharSet immutableCharSet2 = CharSets.mutable.with(
import com.google.common.collect.Sets; Sets.newHashSet("a", "b");
import com.google.common.collect.ImmutableSet; ImmutableSet.of("a", "b");
Set<String> h = new HashSet<String>(Arrays.asList(new String[] { "a", "b" }))
Set<String> h = asSet ("a", "b"); public Set<String> asSet(String... values) { return new HashSet<String>(java.util.Arrays.asList(values)); }
Set<String> a = new HashSet<>(new HashSet<String>() {{ add("1"); add("2"); }})
final Set<String> a = Collections.unmodifiableSet(new HashSet<String>(){{ add("1"); add("2"); }})
private final static Set<String> DEFAULT_VALUES = Collections.unmodifiableSet(...); private Set<String> values = DEFAULT_VALUES;
Stream.of("A", "B", "C", "D").collect(Collectors.toCollection(HashSet::new));
public static <T, A extends Set<T>> Collector<T, A, Set<T>> toImmutableSet(Supplier<A> supplier) { return Collector.of( supplier, Set::add, (left, right) -> { left.addAll(right); return left; }, Collections::unmodifiableSet); }
Stream.of("A", "B", "C", "D").collect(toImmutableSet(HashSet::new));
private static Set<Integer> codes1= new HashSet<Integer>(Arrays.asList(1, 2, 3, 4)); private static Set<Integer> codes2 = new HashSet<Integer>(Arrays.asList(5, 6, 7, 8)); private static Set<Integer> h = new HashSet<Integer>(); static{ h.add(codes1); h.add(codes2); }
public static final <T> Set<T> makeSet(@SuppressWarnings("unchecked") T... o) { return new HashSet<T>() { private static final long serialVersionUID = -3634958843858172518L; { for (T x : o) add(x); } }; }
public interface Builder<T> { T build(); } static class StringSetBuilder implements Builder<Set<String>> { private final Set<String> set = new HashSet<>(); StringSetBuilder add(String pStr) { set.add(pStr); return this; } StringSetBuilder addAll(Set<String> pSet) { set.addAll(pSet); return this; } @Override public Set<String> build() { return set; } }
class SomeChildClass extends ParentClass { public SomeChildClass(String pStr) { super(new StringSetBuilder().add(pStr).build()); } } class ParentClass { public ParentClass(Set<String> pSet) { super(new StringSetBuilder().addAll(pSet).add("my own str").build()); } }
public Database(Context ctx) { this.context = ctx; DBHelper = new DatabaseHelper(context); }
public static class DummySectionFragment extends Fragment{ ... @Override public void onAttach(Activity activity) { super.onAttach(activity); DBHelper = new DatabaseHelper(activity); } }
public class Animal extends Fragment { Context thiscontext; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { thiscontext = container.getContext();
@Override public void onAttach(Activity activity) { super.onAttach(activity); context=activity; }
public Database() { this.context = getActivity(); DBHelper = new DatabaseHelper(this.context); }
@Override public void onAttach(Activity activity) { super.onAttach(activity); context = activity; }
public static class MyFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Context context = inflater.getContext(); } }
void onAttach (Context context) { this.context = context; }
val ctx = context ?: return textViewABC.setTextColor(ContextCompat.getColor(ctx, android.R.color.black))
public void onAttach(Context context) { super.onAttach(context); this.activity = (CashActivity) context; this.money = this.activity.money; }
public static class MyFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Context context = getActivity.getContext(); } }
public class MenuFragment extends Fragment implements View.OnClickListener { private Context mContext; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { FragmentMenuBinding binding=FragmentMenuBinding.inflate(inflater,container,false); View view=binding.getRoot(); mContext=view.getContext(); return view; } }
listView LV=getView().findViewById(R.id.listOFsensors); LV.setAdapter(new ArrayAdapter<String>(getContext(),android.R.layout.simple_list_item_1 ,listSensorType));
/** * Return the {@link FragmentActivity} this fragment is currently associated with. * May return {@code null} if the fragment is associated with a {@link Context} * instead. * * @see */ @Nullable final public FragmentActivity getActivity() { return mHost == null ? null : (FragmentActivity) mHost.getActivity(); }
/** * Return the {@link Context} this fragment is currently associated with. * * @see */ @Nullable public Context getContext() { return mHost == null ? null : mHost.getContext(); }
/** * Called when a fragment is first attached to its context. * {@link */ @CallSuper public void onAttach(Context context) { mCalled = true; final Activity hostActivity = mHost == null ? null : mHost.getActivity(); if (hostActivity != null) { mCalled = false; onAttach(hostActivity); } }
public class FirstFragment extends Fragment { private Context mContext; public FirstFragment() { } @Override public void onAttach(Context context) { super.onAttach(context); mContext=context; } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rooView=inflater.inflate(R.layout.fragment_first, container, false); Toast.makeText(mContext, "THIS IS SAMPLE TOAST", Toast.LENGTH_SHORT).show(); return rooView; } }
public class SomeClass { private String someValue; }
mapper.setSerializationInclusion(Include.NON_NULL);
@JsonInclude(Include.NON_NULL) class Foo { String bar; }
public class Foo { @JsonInclude(JsonInclude.Include.NON_NULL) private String fieldOne; private String fieldTwo; }
@JsonInclude(JsonInclude.Include.NON_NULL) public class Foo { private String fieldOne; private String fieldTwo; @JsonInclude(JsonInclude.Include.ALWAYS) private String fieldThree; }
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
mapper.getSerializationConfig().setSerializationInclusion(Inclusion.NON_NULL);
mapper.setSerializationInclusion(Include.NON_NULL);
spring: jackson: default-property-inclusion: non_null
@JsonInclude(JsonInclude.Include.NON_NULL) @JsonInclude(JsonInclude.Include.NON_EMPTY)
mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
com.fasterxml.jackson.databind.annotation.JsonSerialize
import org.codehaus.jackson.map.annotate.JsonSerialize; import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;
mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
mapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonGenerator jsonGen, SerializerProvider unused) throws IOException { } });
@Configuration public class JsonConfigurations { @Bean public Jackson2ObjectMapperBuilder objectMapperBuilder() { Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder(); builder.serializationInclusion(JsonInclude.Include.NON_NULL); builder.serializationInclusion(JsonInclude.Include.NON_EMPTY); builder.failOnUnknownProperties(false); return builder; } }
mapper.getSerializationConfig().withSerializationInclusion(JsonInclude.Include.NON_NULL);
import com.fasterxml.jackson.annotation.JsonInclude; @JsonInclude(JsonInclude.Include.NON_NULL) public class ApiDTO { }
SimpleDateFormat ISO8601DATEFORMAT = new SimpleDateFormat("yyyy-MM-dd String date = "2010-01-01T12:00:00+01:00".replaceAll("\\+0([0-9]){1}\\:00", "+0$100"); System.out.println(ISO8601DATEFORMAT.parse(date));
DateTimeFormatter parser2 = ISODateTimeFormat.dateTimeNoMillis(); String jtdate = "2010-01-01T12:00:00+01:00"; System.out.println(parser2.parseDateTime(jtdate));
DateTime dt = new DateTime( "2010-01-01T12:00:00+01:00" ) ;
import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; /** * Helper class for handling a most common subset of ISO 8601 strings * (in the following format: "2008-03-01T13:00:00+01:00"). It supports * parsing the "Z" timezone, but many other less-used features are * missing. */ public final class ISO8601 { /** Transform Calendar to ISO 8601 string. */ public static String fromCalendar(final Calendar calendar) { Date date = calendar.getTime(); String formatted = new SimpleDateFormat("yyyy-MM-dd .format(date); return formatted.substring(0, 22) + ":" + formatted.substring(22); } /** Get current date and time formatted as ISO 8601 string. */ public static String now() { return fromCalendar(GregorianCalendar.getInstance()); } /** Transform ISO 8601 string to Calendar. */ public static Calendar toCalendar(final String iso8601string) throws ParseException { Calendar calendar = GregorianCalendar.getInstance(); String s = iso8601string.replace("Z", "+00:00"); try { s = s.substring(0, 22) + s.substring(23); } catch (IndexOutOfBoundsException e) { throw new ParseException("Invalid length", 0); } Date date = new SimpleDateFormat("yyyy-MM-dd calendar.setTime(date); return calendar; } }
DateFormat df1 = new SimpleDateFormat("yyyy-MM-dd String string1 = "2001-07-04T12:08:56.235-0700"; Date result1 = df1.parse(string1); DateFormat df2 = new SimpleDateFormat("yyyy-MM-dd String string2 = "2001-07-04T12:08:56.235-07:00"; Date result2 = df2.parse(string2);
java.util.Date date = Date.from( Instant.parse( "2014-12-12T10:39:40Z" ));
OffsetDateTime odt = OffsetDateTime.parse( "2010-01-01T12:00:00+01:00" );
Instant instant = odt.toInstant(); java.util.Date date = java.util.Date.from( instant );
ISO8601DateFormat df = new ISO8601DateFormat(); Date d = df.parse("2010-07-28T22:25:51Z");
OffsetDateTime.parse ( "2010-01-01T12:00:00+01:00" )
OffsetDateTime odt = OffsetDateTime.parse ( "2010-01-01T12:00:00+01:00" );
OffsetDateTime odtUtc = odt.withOffsetSameInstant( ZoneOffset.UTC );
ZonedDateTime zonedDateTimeMontral = odt.atZoneSameInstant( ZoneId.of( "America/Montreal" ) );
TimeZone tz = TimeZone.getTimeZone("UTC"); DateFormat df = new SimpleDateFormat("yyyy-MM-dd df.setTimeZone(tz); String nowAsISO = df.format(new Date()); System.out.println(nowAsISO); DateFormat df1 = new SimpleDateFormat("yyyy-MM-dd Date finalResult = df1.parse(nowAsISO); System.out.println(finalResult);
javax.xml.datatype.DatatypeFactory.newInstance().newXMLGregorianCalendar("2011-01-01Z").toGregorianCalendar().getTime()
DateFormat format = new SimpleDateFormat("yyyy-MM-dd
import static org.junit.Assert.assertEquals; import java.text.ParseException; import java.util.Date; import org.apache.commons.lang.time.DateUtils; import org.junit.Test; public class ISO8601TimestampFormatTest { @Test public void parse() throws ParseException { Date date = DateUtils.parseDate("2010-01-01T12:00:00+01:00", new String[]{ "yyyy-MM-dd assertEquals("Fri Jan 01 12:00:00 CET 2010", date.toString()); } }
public static Date iso8601Format(String formattedDate) throws ParseException { try { DateFormat df = new SimpleDateFormat("yyyy-MM-dd return df.parse(formattedDate); } catch (IllegalArgumentException ex) { if (formattedDate.endsWith("Z")) formattedDate = formattedDate.replace("Z", "+0000"); else formattedDate = formattedDate.replaceAll("([+-]\\d\\d):(\\d\\d)\\s*$", "$1$2"); DateFormat df1 = new SimpleDateFormat("yyyy-MM-dd return df1.parse(formattedDate); } }
public static Calendar getCalendarFromISO(String datestring) { Calendar calendar = Calendar.getInstance(TimeZone.getDefault(), Locale.getDefault()) ; SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd try { Date date = dateformat.parse(datestring); date.setHours(date.getHours() - 1); calendar.setTime(date); String test = dateformat.format(calendar.getTime()); Log.e("TEST_TIME", test); } catch (ParseException e) { e.printStackTrace(); } return calendar; }
org.springframework.extensions.surf.util.ISO8601DateFormat Date date = ISO8601DateFormat.parse("date in iso8601");
Date d = new SimpleDateFormat( "yyyy-MM-dd Locale.ENGLISH).format(System.currentTimeMillis());
ZonedDateTime zp = ZonedDateTime.parse(string); Date date = Date.from(zp.toInstant());
public static void main(String[] args) throws ParseException { String dateStr = "2016-10-19T14:15:36+08:00"; Date date = javax.xml.bind.DatatypeConverter.parseDateTime(dateStr).getTime(); System.out.println(date); }
<dependency> <groupId>fr.turri</groupId> <artifactId>jISO8601</artifactId> <version>0.2</version> </dependency>
import fr.turri.jiso8601.*; ... Calendar cal = Iso8601Deserializer.toCalendar("1985-03-04"); Date date = Iso8601Deserializer.toDate("1985-03-04T12:34:56Z");
[hh]:[mm] [hh][mm] [hh] Eg: "18:30Z", "22:30+04", "1130-0700", and "15:00-03:30" all mean the same time. - 06:30PM UTC
public class ISO8601DateFormatter { private static final DateFormat DATE_FORMAT_1 = new SimpleDateFormat("yyyy-MM-dd private static final DateFormat DATE_FORMAT_2 = new SimpleDateFormat("yyyy-MM-dd private static final String UTC_PLUS = "+"; private static final String UTC_MINUS = "-"; public static Date toDate(String iso8601string) throws ParseException { iso8601string = iso8601string.trim(); if(iso8601string.toUpperCase().indexOf("Z")>0){ iso8601string = iso8601string.toUpperCase().replace("Z", "+0000"); }else if(((iso8601string.indexOf(UTC_PLUS))>0)){ iso8601string = replaceColon(iso8601string, iso8601string.indexOf(UTC_PLUS)); iso8601string = appendZeros(iso8601string, iso8601string.indexOf(UTC_PLUS), UTC_PLUS); }else if(((iso8601string.indexOf(UTC_MINUS))>0)){ iso8601string = replaceColon(iso8601string, iso8601string.indexOf(UTC_MINUS)); iso8601string = appendZeros(iso8601string, iso8601string.indexOf(UTC_MINUS), UTC_MINUS); } Date date = null; if(iso8601string.contains(":")) date = DATE_FORMAT_1.parse(iso8601string); else{ date = DATE_FORMAT_2.parse(iso8601string); } return date; } public static String toISO8601String(Date date){ return DATE_FORMAT_1.format(date); } private static String replaceColon(String sourceStr, int offsetIndex){ if(sourceStr.substring(offsetIndex).contains(":")) return sourceStr.substring(0, offsetIndex) + sourceStr.substring(offsetIndex).replace(":", ""); return sourceStr; } private static String appendZeros(String sourceStr, int offsetIndex, String offsetChar){ if((sourceStr.length()-1)-sourceStr.indexOf(offsetChar,offsetIndex)<=2) return sourceStr + "00"; return sourceStr; }
public static Date fromISO8601_( String string ) { try { return new SimpleDateFormat ( "yyyy-MM-dd } catch ( ParseException e ) { return Exceptions.handle (Date.class, "Not a valid ISO8601", e); } }
1994-11-05T08:15:30-05:00 corresponds November 5, 1994, 8:15:30 am, US Eastern Standard Time. 1994-11-05T13:15:30Z corresponds to the same instant.
final static int SHORT_ISO_8601_TIME_LENGTH = "1994-11-05T08:15:30Z".length (); final static int LONG_ISO_8601_TIME_LENGTH = "1994-11-05T08:15:30-05:00".length (); public static Date fromISO8601( String string ) { if (isISO8601 ( string )) { char [] charArray = Reflection.toCharArray ( string ); int year = CharScanner.parseIntFromTo ( charArray, 0, 4 ); int month = CharScanner.parseIntFromTo ( charArray, 5, 7 ); int day = CharScanner.parseIntFromTo ( charArray, 8, 10 ); int hour = CharScanner.parseIntFromTo ( charArray, 11, 13 ); int minute = CharScanner.parseIntFromTo ( charArray, 14, 16 ); int second = CharScanner.parseIntFromTo ( charArray, 17, 19 ); TimeZone tz ; if (charArray[19] == tz = TimeZone.getTimeZone ( "GMT" ); } else { StringBuilder builder = new StringBuilder ( 9 ); builder.append ( "GMT" ); builder.append( charArray, 19, LONG_ISO_8601_TIME_LENGTH - 19); String tzStr = builder.toString (); tz = TimeZone.getTimeZone ( tzStr ) ; } return toDate ( tz, year, month, day, hour, minute, second ); } else { return null; } }
public static int parseIntFromTo ( char[] digitChars, int offset, int to ) { int num = digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - } } } } } } } } return num; } public static boolean isISO8601( String string ) { boolean valid = true; if (string.length () == SHORT_ISO_8601_TIME_LENGTH) { valid &= (string.charAt ( 19 ) == } else if (string.length () == LONG_ISO_8601_TIME_LENGTH) { valid &= (string.charAt ( 19 ) == valid &= (string.charAt ( 22 ) == } else { return false; } valid &= (string.charAt ( 4 ) == (string.charAt ( 7 ) == (string.charAt ( 10 ) == (string.charAt ( 13 ) == (string.charAt ( 16 ) == return valid; }
@Test public void testIsoShortDate() { String test = "1994-11-05T08:15:30Z"; Date date = Dates.fromISO8601 ( test ); Date date2 = Dates.fromISO8601_ ( test ); assertEquals(date2.toString (), date.toString ()); puts (date); } @Test public void testIsoLongDate() { String test = "1994-11-05T08:11:22-05:00"; Date date = Dates.fromISO8601 ( test ); Date date2 = Dates.fromISO8601_ ( test ); assertEquals(date2.toString (), date.toString ()); puts (date); }
var d=new Date(); var s = JSON.stringify(d); document.write(s); document.write("<br />"+d); "2013-12-14T01:55:33.412Z" Fri Dec 13 2013 17:55:33 GMT-0800 (PST)
/* var d=new Date(); var s = JSON.stringify(d); document.write(s); document.write("<br />"+d); "2013-12-14T01:55:33.412Z" Fri Dec 13 2013 17:55:33 GMT-0800 (PST) */ @Test public void jsonJavaScriptDate() { String test = "2013-12-14T01:55:33.412Z"; Date date = Dates.fromJsonDate ( test ); Date date2 = Dates.fromJsonDate_ ( test ); assertEquals(date2.toString (), "" + date); puts (date); }
public static Date fromJsonDate_( String string ) { try { return new SimpleDateFormat ( "yyyy-MM-dd } catch ( ParseException e ) { return Exceptions.handle (Date.class, "Not a valid JSON date", e); } }
public static Date fromJsonDate( String string ) { return fromJsonDate ( Reflection.toCharArray ( string ), 0, string.length () ); }
public static Date fromJsonDate( char[] charArray, int from, int to ) { if (isJsonDate ( charArray, from, to )) { int year = CharScanner.parseIntFromTo ( charArray, from + 0, from + 4 ); int month = CharScanner.parseIntFromTo ( charArray, from +5, from +7 ); int day = CharScanner.parseIntFromTo ( charArray, from +8, from +10 ); int hour = CharScanner.parseIntFromTo ( charArray, from +11, from +13 ); int minute = CharScanner.parseIntFromTo ( charArray, from +14, from +16 ); int second = CharScanner.parseIntFromTo ( charArray, from +17, from +19 ); int miliseconds = CharScanner.parseIntFromTo ( charArray, from +20, from +23 ); TimeZone tz = TimeZone.getTimeZone ( "GMT" ); return toDate ( tz, year, month, day, hour, minute, second, miliseconds ); } else { return null; } }
public static boolean isJsonDate( char[] charArray, int start, int to ) { boolean valid = true; final int length = to -start; if (length != JSON_TIME_LENGTH) { return false; } valid &= (charArray [ start + 19 ] == if (!valid) { return false; } valid &= (charArray[ start +4 ] == (charArray[ start +7 ] == (charArray[ start +10 ] == (charArray[ start +13 ] == (charArray[ start +16 ] == return valid; }
public static int parseIntFromTo ( char[] digitChars, int offset, int to ) { int num = digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - if ( ++offset < to ) { num = ( num * 10 ) + ( digitChars[ offset ] - } } } } } } } } return num; }
Benchmark Mode Thr Count Sec Mean Mean error Units BoonCharArrayBenchmark.roundRobin thrpt 16 10 1 724815,875 54339,825 ops/s JacksonObjectBenchmark.roundRobin thrpt 16 10 1 580014,875 145097,700 ops/s JsonSmartBytesBenchmark.roundRobin thrpt 16 10 1 575548,435 64202,618 ops/s JsonSmartStringBenchmark.roundRobin thrpt 16 10 1 541212,220 45144,815 ops/s GSONStringBenchmark.roundRobin thrpt 16 10 1 522947,175 65572,427 ops/s BoonDirectBytesBenchmark.roundRobin thrpt 16 10 1 521528,912 41366,197 ops/s JacksonASTBenchmark.roundRobin thrpt 16 10 1 512564,205 300704,545 ops/s GSONReaderBenchmark.roundRobin thrpt 16 10 1 446322,220 41327,496 ops/s JsonSmartStreamBenchmark.roundRobin thrpt 16 10 1 276399,298 130055,340 ops/s JsonSmartReaderBenchmark.roundRobin thrpt 16 10 1 86789,825 17690,031 ops/s
Exception in thread "main" java.lang.VerifyError: (class: TestThrow, method: ma\ in signature: ([Ljava/lang/String;)V) Can only throw Throwable objects Could not find the main class: TestThrow. Program will exit.
public class ChuckNorrisException extends RuntimeException { public ChuckNorrisException() { } } public class TestVillain { public static void main(String[] args) { try { throw new ChuckNorrisException(); } catch(Throwable t) { System.out.println("Gotcha!"); } finally { System.out.println("The end."); } } }
javac -cp . TestVillain.java ChuckNorrisException.java
java -cp . TestVillain Exception in thread "main" java.lang.VerifyError: (class: TestVillain, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects Could not find the main class: TestVillain. Program will exit.
java -Xverify:none -cp . TestVillain The end. Exception in thread "main"
public static class JulesWinnfield extends Exception { JulesWinnfield() { System.err.println("Say System.exit(25-17); } } public static void main(String[] args) { try { throw new JulesWinnfield(); } catch(JulesWinnfield jw) { System.out.println("There } }
public static class JulesWinnfield extends Exception { JulesWinnfield() throws JulesWinnfield, VincentVega { throw new VincentVega(); } } public static class VincentVega extends Exception { VincentVega() throws JulesWinnfield, VincentVega { throw new JulesWinnfield(); } } public static void main(String[] args) throws VincentVega { try { throw new JulesWinnfield(); } catch(JulesWinnfield jw) { } catch(VincentVega vv) { } }
public class ChuckNorrisException extends Exception { public ChuckNorrisException() { System.exit(1); } }
package chuck; import java.io.PrintStream; import java.io.PrintWriter; public class ChuckNorrisException extends Exception { public ChuckNorrisException() { } @Override public Throwable getCause() { return null; } @Override public String getMessage() { return toString(); } @Override public void printStackTrace(PrintWriter s) { super.printStackTrace(s); } @Override public void printStackTrace(PrintStream s) { super.printStackTrace(s); } }
package chuck; import javassist.*; public class Expendables { private static Class clz; public static ChuckNorrisException getChuck() { try { if (clz == null) { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get("chuck.ChuckNorrisException"); cc.setSuperclass(pool.get("java.lang.Object")); clz = cc.toClass(); } return (ChuckNorrisException)clz.newInstance(); } catch (Exception ex) { throw new RuntimeException(ex); } } }
package chuck; public class Main { public void roundhouseKick() throws Exception { throw Expendables.getChuck(); } public void foo() { try { roundhouseKick(); } catch (Throwable ex) { System.out.println("Caught " + ex.toString()); } } public static void main(String[] args) { try { System.out.println("before"); new Main().foo(); System.out.println("after"); } finally { System.out.println("finally"); } } }
java -Xverify:none -cp .:<path_to_javassist-3.9.0.GA.jar> chuck.Main
public class SneakyThrow { public static RuntimeException sneak(Throwable t) { throw SneakyThrow.<RuntimeException> throwGivenThrowable(t); } private static <T extends Throwable> RuntimeException throwGivenThrowable(Throwable t) throws T { throw (T) t; } }
try { throw SneakyThrow.sneak(new ChuckNorrisException()); } catch (ChuckNorrisException e) { }
package de.scrum_master.app; public class ChuckNorrisException extends RuntimeException { public ChuckNorrisException(String message) { super(message); } }
package de.scrum_master.aspect; import de.scrum_master.app.ChuckNorrisException; public aspect ChuckNorrisAspect { before(ChuckNorrisException chuck) : handler(*) && args(chuck) { System.out.println("Somebody is trying to catch Chuck Norris - LOL!"); throw chuck; } }
package de.scrum_master.app; public class Application { public static void main(String[] args) { catchAllMethod(); } private static void catchAllMethod() { try { exceptionThrowingMethod(); } catch (Throwable t) { System.out.println("Gotcha, " + t.getClass().getSimpleName() + "!"); } } private static void exceptionThrowingMethod() { throw new ChuckNorrisException("Catch me if you can!"); } }
Throwable exception = ; Thread currentThread = Thread.currentThread(); Thread.UncaughtExceptionHandler uncaughtExceptionHandler = currentThread.getUncaughtExceptionHandler(); uncaughtExceptionHandler.uncaughtException(currentThread, exception);
String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime());
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss"); Date date = new Date(); System.out.println(dateFormat.format(date));
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss"); Calendar cal = Calendar.getInstance(); System.out.println(dateFormat.format(cal.getTime()));
System.out.println(ZonedDateTime.now().format(DateTimeFormatter.RFC_1123_DATE_TIME))
System.out.println( new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(Calendar.getInstance().getTime()) ); System.out.println( new SimpleDateFormat("HH:mm:ss").format(Calendar.getInstance().getTime()) ); System.out.println(new SimpleDateFormat("MM/dd/yyyy").format(Calendar.getInstance().getTime())); System.out.println( new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime()) ); System.out.println( Calendar.getInstance().getTime() ); System.out.println( new Date(System.currentTimeMillis()) ); System.out.println( new Date().toString().substring(0, 10) ); System.out.println( new java.sql.Date(System.currentTimeMillis()) ); Date d = new Date(); System.out.println( (d.getTime() / 1000 / 60 / 60) % 24 + ":" + (d.getTime() / 1000 / 60) % 60 + ":" + (d.getTime() / 1000) % 60 ); System.out.println( new Timestamp(System.currentTimeMillis()) ); System.out.println( ZonedDateTime.now() ); System.out.println( ZonedDateTime.now().format(DateTimeFormatter.RFC_1123_DATE_TIME) ); System.out.println( LocalDate.now(ZoneId.of("Europe/Paris")) ); System.out.println( LocalTime.now().getHour() ); System.out.println( LocalDateTime.now() );
ZonedDateTime.now( ZoneId.of( "America/Montreal" ) )
ZoneId z = ZoneId.of( "America/Montreal" ); ZonedDateTime zdt = instant.atZone( z );
ZonedDateTime do_Not_Do_This = ZonedDateTime.now();
ZoneId z = ZoneId.of( "America/Montreal" ); LocalDate today = LocalDate.now( z );
Instant instant = Instant.now( yourClockGoesHere ) ;
String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime()); System.out.println(timeStamp );
Date d = new Date(System.currentTimeMillis()); System.out.print(d);
Date date=Calendar.getInstance().getTime(); System.out.println(date);
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss"); Calendar cal = Calendar.getInstance(); System.out.println(dateFormat.format(cal.getTime()));
import java.util.Date; class Demostration{ public static void main(String[]args){ Date date = new Date(); System.out.println(date); } }
import java.util.Date; public class Main { public static void main(String[]args){ Date date = new Date(); long timeInMilliSeconds = date.getTime(); System.out.println(timeInMilliSeconds); } }
import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; class Demostration{ public static void main(String[]args){ Date date=new Date(); DateFormat dateFormat=new SimpleDateFormat("yyyy-MM-dd"); String formattedDate=dateFormat.format(date); System.out.println(formattedDate); } }
import java.util.Calendar; class Demostration{ public static void main(String[]args){ Calendar calendar=Calendar.getInstance(); System.out.println(calendar.getTime()); } }
SimpleDateFormat sdf = new SimpleDateFormat("yyyy:MM:dd::HH:mm:ss"); System.out.println(sdf.format(System.currentTimeMillis()));
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss"); Date date = new Date(); System.out.println(dateFormat.format(date));
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss"); Calendar cal = Calendar.getInstance(); System.out.println(dateFormat.format(cal));
DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss"); LocalDateTime now = LocalDateTime.now(); System.out.println(dtf.format(now));
DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd"); LocalDate localDate = LocalDate.now(); System.out.println(dtf.format(localDate));
import java.time.LocalDate; import java.time.LocalTime; import java.time.LocalDateTime; import java.time.Month; public class DataTimeChecker { public static void main(String args[]) { DataTimeChecker dateTimeChecker = new DataTimeChecker(); dateTimeChecker.DateTime(); } public void DateTime() { LocalDateTime currentTime = LocalDateTime.now(); System.out.println("Current DateTime: " + currentTime); LocalDate date1 = currentTime.toLocalDate(); System.out.println("Date : " + date1); Month month = currentTime.getMonth(); int day = currentTime.getDayOfMonth(); int seconds = currentTime.getSecond(); System.out.println("Month : " + month); System.out.println("Day : " + day); System.out.println("Seconds : " + seconds); LocalDateTime date2 = currentTime.withDayOfMonth(17).withYear(2018); System.out.println("Date : " + date2); LocalDate date3 = LocalDate.of(2018, Month.MAY, 17); System.out.println("Date : " + date3); LocalTime date4 = LocalTime.of(4, 45); System.out.println("Date : " + date4); LocalTime date5 = LocalTime.parse("20:15:30"); System.out.println("Date : " + date5); } }
Current DateTime: 2018-05-17T04:40:34.603 Date : 2018-05-17 Month : MAY Day : 17 Seconds : 34 Date : 2018-05-17T04:40:34.603 Date : 2018-05-17 Date : 04:45 Date : 20:15:30
import java.util.*; import java.text.*; public class DateDemo { public static void main(String args[]) { Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat ("E yyyy.MM.dd System.out.println("Current Date: " + ft.format(dNow)); } }
System.out.println( new SimpleDateFormat("yyyy:MM:dd - hh:mm:ss a").format(Calendar.getInstance().getTime()) );
Date dateInstance = new Date(); int year = dateInstance.getYear()+1900; int date = dateInstance.getDate(); int month = dateInstance.getMonth(); int day = dateInstance.getDay(); int hours = dateInstance.getHours(); int min = dateInstance.getMinutes(); int sec = dateInstance.getSeconds(); String dayOfWeek = ""; switch(day){ case 0: dayOfWeek = "Sunday"; break; case 1: dayOfWeek = "Monday"; break; case 2: dayOfWeek = "Tuesday"; break; case 3: dayOfWeek = "Wednesday"; break; case 4: dayOfWeek = "Thursday"; break; case 5: dayOfWeek = "Friday"; break; case 6: dayOfWeek = "Saturday"; break; } System.out.println("Date: " + year +"-"+ month + "-" + date + " "+ dayOfWeek); System.out.println("Time: " + hours +":"+ min + ":" + sec);
Date rightNow = Calendar.getInstance().getTime(); System.out.println(rightNow);
Calendar cal = new GregorianCalendar(); int hours = cal.get(Calendar.HOUR); int minute = cal.get(Calendar.MINUTE); int second = cal.get(Calendar.SECOND); int ap = cal.get(Calendar.AM_PM); String amVSpm; if(ap == 0){ amVSpm = "AM"; }else{ amVSpm = "PM"; } String timer = hours + "-" + minute + "-" + second + " " +amVSpm; System.out.println(timer);
String pattern = "yyyy-MM-dd"; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern); String date = simpleDateFormat.format(new Date()); System.out.println(date);
LocalTime localTime = LocalTime.now(); System.out.println(localTime); LocalTime localTimeWtZone = LocalTime.now(ZoneId.of("GMT+02:30")); System.out.println(localTimeWtZone);
Date currentDate = new Date(System.currentTimeMillis());
./projectname.iml ./projectname.ipr ./projectname.iws ./src/
buildscript { ... } ... dependencies { implementation fileTree(dir: }
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3a%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Fjdk8-downloads-2133151.html; oraclelicense=accept-securebackup-cookie;" "https:
wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3a%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Fjdk8-downloads-2133151.html; oraclelicense=accept-securebackup-cookie;" "https:
wget -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
curl -v -j -k -L -H "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
curl -v -j -k -L -H "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-cookies --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com" "http:
wget -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
curl -L -C - -b "oraclelicense=accept-securebackup-cookie" -O http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
su - echo "deb http: echo "deb-src http: apt-key adv --keyserver keyserver.ubuntu.com --recv-keys EEA14886 apt-get update apt-get install --yes oracle-java7-installer exit
tempWork=/tmp/work locBin=/usr/local/bin javaUsrLib=/usr/lib/jvm sudo mkdir -p $javaUsrLib mkdir -p $tempWork cd $tempWork tar -zxvf $downloadDir/jdk*tar.gz sudo mv -f $tempWork/jdk* $javaUsrLib/ sudo ln -f -s $javaUsrLib/jdk1/bin/* /usr/bin/ export JAVA_HOME="$javaUsrLib/jdk1.7.0_03" tar -zxvf $tempWork/* sudo mv -f $tempWork/jdk1* $javaUsrLib/ sudo ln -f -s $javaUsrLib/jdk1*/bin/* /usr/bin/ sudo rm -rf $tempWork export JAVA_HOME="$javaUsrLib/jdk1.7.0_03" if ! grep "JAVA_HOME=$javaUsrLib/jdk1.7.0_03" /etc/environment then echo "JAVA_HOME=$javaUsrLib/jdk1.7.0_03"| sudo tee -a /etc/environment fi exit 0
curl -L -C - -b "oraclelicense=accept-securebackup-cookie" -O http:
wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http:
wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "http:
wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "http:
wget --no-cookies --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Fjdk6-downloads-1637591.html;" http:
PROXY="my.proxy.local:8080" PROXY_TYPE="--proxy-ntlm" USER="user" PASS= BASE_URL="technetwork/java/javase/downloads" BASE_URL_OUTPUT="$(curl -s -k ${PROXY_TYPE} -x "http: JAVA_ENVIRONMENTS=("JRE" "JDK") for JAVA_ENVIRONMENT in "${JAVA_ENVIRONMENTS[@]}" do echo echo "JAVA_ENVIRONMENT="$JAVA_ENVIRONMENT echo for (( JAVA_BASE_VERSION = 8; JAVA_BASE_VERSION <= 10; JAVA_BASE_VERSION += 2 )) do echo "JAVA_BASE_VERSION="$JAVA_BASE_VERSION DOWNLOAD_SITE="$(echo $BASE_URL_OUTPUT | grep -m 1 -io "${JAVA_ENVIRONMENT}${JAVA_BASE_VERSION}-downloads-[0-9]*.html" -- | tail -1)" echo "DOWNLOAD_SITE="$DOWNLOAD_SITE DOWNLOAD_LINK_OUTPUT="$(curl -s -k ${PROXY_TYPE} -x "http: echo "DOWNLOAD_LINK_OUTPUT="$DOWNLOAD_LINK_OUTPUT done done
ME=<myOracleID> PW=<myOraclePW> PATCH_FILE=p13079846_17000_Linux-x86-64.zip echo "Get real URL from the persistent link" wget -o getrealurl.out --no-cookies --no-check-certificate --user=$ME \ --password=$PW --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com" \ https: patch_file=$PATCH_FILE wait REALURL=`grep "^--" getrealurl.out |tail -1 |sed -e wget -O $PATCH_FILE $REALURL
passphrase="Hard to crack string. Use /dev/urandom for inspiration." gpg --batch --symmetric --force-mdc --passphrase-fd 0 \ oracle-java8-jdk_8_amd64.deb <<< "$passphrase"
jdk-download< <version> <platform> [<build>] * <version> - Something like "8u40" * <platform> - Usually i586 or x64 * <build> - The internal build number used by oracle, to avoid guessing and trying to download starting from 99 to 1 (build 0, really?!!)
wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2F%2F%www.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "http:
wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "http:
wget --no-cookies --header "Cookie: s_nr=1359635827494; s_cc=true; gpw_e24=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Fjdk6downloads-1902814.html; s_sq=%5B%5BB%5D%5D; gpv_p24=no%20value" http:
wget \ --no-cookies \ --header "Cookie: oraclelicense=accept-securebackup-cookie" \ http: -O java.tar.gz
sudo wget --no-check-certificate --no-cookies --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com" "http:
class Foo<T> { final Class<T> typeParameterClass; public Foo(Class<T> typeParameterClass) { this.typeParameterClass = typeParameterClass; } public void bar() { } }
import org.springframework.core.GenericTypeResolver; public abstract class AbstractHibernateDao<T extends DomainObject> implements DataAccessObject<T> { @Autowired private SessionFactory sessionFactory; private final Class<T> genericType; private final String RECORD_COUNT_HQL; private final String FIND_ALL_HQL; @SuppressWarnings("unchecked") public AbstractHibernateDao() { this.genericType = (Class<T>) GenericTypeResolver.resolveTypeArgument(getClass(), AbstractHibernateDao.class); this.RECORD_COUNT_HQL = "select count(*) from " + this.genericType.getName(); this.FIND_ALL_HQL = "from " + this.genericType.getName() + " t "; }
Type mySuperclass = myFoo.getClass().getGenericSuperclass(); Type tType = ((ParameterizedType)mySuperclass).getActualTypeArguments()[0];
import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.util.ArrayDeque; import java.util.Deque; import java.util.NoSuchElementException; /** * Captures and silently ignores stack exceptions upon popping. */ public abstract class SilentStack<E> extends ArrayDeque<E> { public E pop() { try { return super.pop(); } catch( NoSuchElementException nsee ) { return create(); } } public E create() { try { Type sooper = getClass().getGenericSuperclass(); Type t = ((ParameterizedType)sooper).getActualTypeArguments()[ 0 ]; return (E)(Class.forName( t.toString() ).newInstance()); } catch( Exception e ) { return null; } } }
public class Main { private Deque<String> stack = new SilentStack<String>(){}; public static void main( String args[] ) { String s = stack.pop(); System.out.printf( "s = } }
public class Foo<T> { private Class<T> type; public Foo(Class<T> type) { this.type = type; } public Class<T> getType() { return type; } public T newInstance() { return type.newInstance(); } }
Type mySuperclass = myFoo.getClass().getGenericSuperclass(); Type tType = ((ParameterizedType)mySuperclass).getActualTypeArguments()[0]; String className = tType.toString().split(" ")[1]; Class clazz = Class.forName(className);
public abstract class Foo<T> { private Class<T> inferedClass; public Class<T> getGenericClass(){ if(inferedClass == null){ Type mySuperclass = getClass().getGenericSuperclass(); Type tType = ((ParameterizedType)mySuperclass).getActualTypeArguments()[0]; String className = tType.toString().split(" ")[1]; inferedClass = Class.forName(className); } return inferedClass; } }
@SuppressWarnings("unchecked") private Class<T> getGenericTypeClass() { try { String className = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0].getTypeName(); Class<?> clazz = Class.forName(className); return (Class<T>) clazz; } catch (Exception e) { throw new IllegalStateException("Class is not parametrized with generic type!!! Please use extends <> "); } }
interface Factory<T> { T apply(); } <T> void List<T> make10(Factory<T> factory) { List<T> result = new ArrayList<T>(); for (int a = 0; a < 10; a++) result.add(factory.apply()); return result; } class FooFactory<T> implements Factory<Foo<T>> { public Foo<T> apply() { return new Foo<T>(); } } List<Foo<Integer>> foos = make10(new FooFactory<Integer>());
abstract class Foo<T> { abstract Class<T> getTClass(); }
class Bar extends Foo<Whatever> { @Override Class<T> getTClass() { return Whatever.class; } }
import java.lang.reflect.TypeVariable; public static <T> Class<T> getGenericClass() { __<T> ins = new __<T>(); TypeVariable<?>[] cls = ins.getClass().getTypeParameters(); return (Class<T>)cls[0].getClass(); } private final class __<T> { private __() { } }
class Foo<T> { Class<T> clazz = (Class<T>) DAOUtil.getTypeArguments(Foo.class, this.getClass()).get(0); }
public class MyClass<A, B, C> { private Class<A> aType; private Class<B> bType; private Class<C> cType; }
/** * Returns a {@link Type} object to identify generic types * @return type */ private Type getGenericClassType(int index) { Type type = getClass().getGenericSuperclass(); while (!(type instanceof ParameterizedType)) { if (type instanceof ParameterizedType) { type = ((Class<?>) ((ParameterizedType) type).getRawType()).getGenericSuperclass(); } else { type = ((Class<?>) type).getGenericSuperclass(); } } return ((ParameterizedType) type).getActualTypeArguments()[index]; }
public class MyClass<A, B, C> { private Class<A> aType; private Class<B> bType; private Class<C> cType; public MyClass() { this.aType = (Class<A>) getGenericClassType(0); this.bType = (Class<B>) getGenericClassType(1); this.cType = (Class<C>) getGenericClassType(2); } /** * Returns a {@link Type} object to identify generic types * @return type */ private Type getGenericClassType(int index) { Type type = getClass().getGenericSuperclass(); while (!(type instanceof ParameterizedType)) { if (type instanceof ParameterizedType) { type = ((Class<?>) ((ParameterizedType) type).getRawType()).getGenericSuperclass(); } else { type = ((Class<?>) type).getGenericSuperclass(); } } return ((ParameterizedType) type).getActualTypeArguments()[index]; } }
@Getter public abstract class ConfigurationDefinition<T> { private Class<T> type; ... public ConfigurationDefinition(...) { this.type = (Class<T>) ((ParameterizedType) this.getClass().getGenericSuperclass()).getActualTypeArguments()[0]; ... } }
private ConfigurationDefinition<String> myConfigA = new ConfigurationDefinition<String>(...){}; private ConfigurationDefinition<File> myConfigB = new ConfigurationDefinition<File>(...){}; ... Class stringType = myConfigA.getType(); Class fileType = myConfigB.getType();
public <T> T yourMethodSignature(Class<T> type) { Object result = ... if (type.isAssignableFrom(result.getClass())) { return (T)result; } else { } }
public class TestGenerics { public static void main(String[] args) { Type type = TestMySuperGenericType.class.getGenericSuperclass(); Type[] gTypes = ((ParameterizedType)type).getActualTypeArguments(); for(Type gType : gTypes){ System.out.println("Generic type:"+gType.toString()); } } } class GenericClass<T> { public void print(T obj){}; } class TestMySuperGenericType extends GenericClass<Integer> { }
public class TestGenerics { public static void main(String[] args) { Type[] interfaces = TestMySuperGenericType.class.getGenericInterfaces(); for(Type type : interfaces){ Type[] gTypes = ((ParameterizedType)type).getActualTypeArguments(); for(Type gType : gTypes){ System.out.println("Generic type:"+gType.toString()); } } } } interface GenericClass<T> { public void print(T obj); } class TestMySuperGenericType implements GenericClass<Integer> { public void print(Integer obj){} }
public class TestGenerics { public static void main(String[] args) { Type[] interfaces = TestMySuperGenericType.class.getGenericInterfaces(); for(Type type : interfaces){ Type[] gTypes = ((ParameterizedType)type).getActualTypeArguments(); for(Type gType : gTypes){ System.out.println("Generic type:"+gType.toString()); } } } } interface GenericClass<T> { public void print(T obj); } interface TestMySuperGenericType extends GenericClass<Integer> { }
class MyClass extends Foo<T> { .... } MyClass myClassInstance = MyClass.class.newInstance();
boolean atLeastTwo(boolean a, boolean b, boolean c) { if ((a && b) || (b && c) || (a && c)) { return true; } else{ return false; } }
if (someExpression) { return true; } else { return false; }
boolean atLeastTwo(boolean a, boolean b, boolean c) { return a ? (b || c) : (b && c); }
boolean atLeastTwo(boolean a, boolean b, boolean c) { return a && (b || c) || (b && c); }
class Main { static boolean majorityDEAD(boolean a,boolean b,boolean c) { return a; } static boolean majority1(boolean a,boolean b,boolean c) { return a&&b || b&&c || a&&c; } static boolean majority2(boolean a,boolean b,boolean c) { return a ? b||c : b&&c; } static boolean majority3(boolean a,boolean b,boolean c) { return a&b | b&c | c&a; } static boolean majority4(boolean a,boolean b,boolean c) { return (a?1:0)+(b?1:0)+(c?1:0) >= 2; } static int loop1(boolean[] data, int i, int sz1, int sz2) { int sum = 0; for(int j=i;j<i+sz1;j++) { for(int k=j;k<j+sz2;k++) { sum += majority1(data[i], data[j], data[k])?1:0; sum += majority1(data[i], data[k], data[j])?1:0; sum += majority1(data[j], data[k], data[i])?1:0; sum += majority1(data[j], data[i], data[k])?1:0; sum += majority1(data[k], data[i], data[j])?1:0; sum += majority1(data[k], data[j], data[i])?1:0; } } return sum; } static int loop2(boolean[] data, int i, int sz1, int sz2) { int sum = 0; for(int j=i;j<i+sz1;j++) { for(int k=j;k<j+sz2;k++) { sum += majority2(data[i], data[j], data[k])?1:0; sum += majority2(data[i], data[k], data[j])?1:0; sum += majority2(data[j], data[k], data[i])?1:0; sum += majority2(data[j], data[i], data[k])?1:0; sum += majority2(data[k], data[i], data[j])?1:0; sum += majority2(data[k], data[j], data[i])?1:0; } } return sum; } static int loop3(boolean[] data, int i, int sz1, int sz2) { int sum = 0; for(int j=i;j<i+sz1;j++) { for(int k=j;k<j+sz2;k++) { sum += majority3(data[i], data[j], data[k])?1:0; sum += majority3(data[i], data[k], data[j])?1:0; sum += majority3(data[j], data[k], data[i])?1:0; sum += majority3(data[j], data[i], data[k])?1:0; sum += majority3(data[k], data[i], data[j])?1:0; sum += majority3(data[k], data[j], data[i])?1:0; } } return sum; } static int loop4(boolean[] data, int i, int sz1, int sz2) { int sum = 0; for(int j=i;j<i+sz1;j++) { for(int k=j;k<j+sz2;k++) { sum += majority4(data[i], data[j], data[k])?1:0; sum += majority4(data[i], data[k], data[j])?1:0; sum += majority4(data[j], data[k], data[i])?1:0; sum += majority4(data[j], data[i], data[k])?1:0; sum += majority4(data[k], data[i], data[j])?1:0; sum += majority4(data[k], data[j], data[i])?1:0; } } return sum; } static int loopDEAD(boolean[] data, int i, int sz1, int sz2) { int sum = 0; for(int j=i;j<i+sz1;j++) { for(int k=j;k<j+sz2;k++) { sum += majorityDEAD(data[i], data[j], data[k])?1:0; sum += majorityDEAD(data[i], data[k], data[j])?1:0; sum += majorityDEAD(data[j], data[k], data[i])?1:0; sum += majorityDEAD(data[j], data[i], data[k])?1:0; sum += majorityDEAD(data[k], data[i], data[j])?1:0; sum += majorityDEAD(data[k], data[j], data[i])?1:0; } } return sum; } static void work() { boolean [] data = new boolean [10000]; java.util.Random r = new java.util.Random(0); for(int i=0;i<data.length;i++) data[i] = r.nextInt(2) > 0; long t0,t1,t2,t3,t4,tDEAD; int sz1 = 100; int sz2 = 100; int sum = 0; t0 = System.currentTimeMillis(); for(int i=0;i<data.length-sz1-sz2;i++) sum += loop1(data, i, sz1, sz2); t1 = System.currentTimeMillis(); for(int i=0;i<data.length-sz1-sz2;i++) sum += loop2(data, i, sz1, sz2); t2 = System.currentTimeMillis(); for(int i=0;i<data.length-sz1-sz2;i++) sum += loop3(data, i, sz1, sz2); t3 = System.currentTimeMillis(); for(int i=0;i<data.length-sz1-sz2;i++) sum += loop4(data, i, sz1, sz2); t4 = System.currentTimeMillis(); for(int i=0;i<data.length-sz1-sz2;i++) sum += loopDEAD(data, i, sz1, sz2); tDEAD = System.currentTimeMillis(); System.out.println("a&&b || b&&c || a&&c : " + (t1-t0) + " ms"); System.out.println(" a ? b||c : b&&c : " + (t2-t1) + " ms"); System.out.println(" a&b | b&c | c&a : " + (t3-t2) + " ms"); System.out.println(" a + b + c >= 2 : " + (t4-t3) + " ms"); System.out.println(" DEAD : " + (tDEAD-t4) + " ms"); System.out.println("sum: "+sum); } public static void main(String[] args) throws InterruptedException { while(true) { work(); Thread.sleep(1000); } } }
a&&b || b&&c || a&&c : 1740 ms a ? b||c : b&&c : 1690 ms a&b | b&c | c&a : 835 ms a + b + c >= 2 : 348 ms DEAD : 169 ms sum: 1472612418
a&&b || b&&c || a&&c : 1638 ms a ? b||c : b&&c : 1612 ms a&b | b&c | c&a : 779 ms a + b + c >= 2 : 905 ms DEAD : 221 ms
a&&b || b&&c || a&&c : 4034 ms a ? b||c : b&&c : 2215 ms a&b | b&c | c&a : 1347 ms a + b + c >= 2 : 6589 ms DEAD : 1016 ms
a&&b || b&&c || a&&c : 1358 ms a ? b||c : b&&c : 1187 ms a&b | b&c | c&a : 410 ms a + b + c >= 2 : 602 ms DEAD : 161 ms
a&&b || b&&c || a&&c : 394 ms a ? b||c : b&&c : 435 ms a&b | b&c | c&a : 420 ms a + b + c >= 2 : 640 ms a ^ b ? c : a : 571 ms a != b ? c : a : 487 ms DEAD : 170 ms
| C | !C ------|---|---- A B | 1 | 1 A !B | 1 | 0 !A !B | 0 | 0 !A B | 1 | 0
(C && (A || B)) || (A && B) <---- first row ^ | first column without third case
int howManyBooleansAreTrue = (a ? 1 : 0) + (b ? 1 : 0) + (c ? 1 : 0); return howManyBooleansAreTrue >= 2;
public class CountBooleansTest extends TestCase { public void testThreeFalse() throws Exception { assertFalse(atLeastTwoOutOfThree(false, false, false)); } public void testThreeTrue() throws Exception { assertTrue(atLeastTwoOutOfThree(true, true, true)); } public void testOnes() throws Exception { assertFalse(atLeastTwoOutOfThree(true, false, false)); assertFalse(atLeastTwoOutOfThree(false, true, false)); assertFalse(atLeastTwoOutOfThree(false, false, true)); } public void testTwos() throws Exception { assertTrue(atLeastTwoOutOfThree(false, true, true)); assertTrue(atLeastTwoOutOfThree(true, false, true)); assertTrue(atLeastTwoOutOfThree(true, true, false)); } private static boolean atLeastTwoOutOfThree(boolean b, boolean c, boolean d) { return countBooleans(b, c, d) >= 2; } private static int countBooleans(boolean... bs) { int count = 0; for (boolean b : bs) if (b) count++; return count; } }
0 x 0 = 0 1 x 0 = 0 1 x 1 = 1 0 + 0 = 0 1 + 0 = 1 1 + 1 = 0 (+ carry)
boolean atLeastTwo(boolean a, boolean b, boolean c) { return ((a && b) || (b && c) || (a && c)); }
boolean twoOrMoreAreTrue(boolean a, boolean b, boolean c) { return (a && b) || (a && c) || (b && c); }
boolean moreThanTwo(boolean a, boolean b, boolean c) { return a == b ? a : c; }
boolean moreThanXTrue(int x, boolean[] bs) { int count = 0; for(boolean b : bs) { count += b ? 1 : 0; if(count > x) return true; } return false; }
boolean moreThanXTrue(int x, boolean[] bs) { int count = 0; for(int i < 0; i < bs.length; i++) { count += bs[i] ? 1 : 0; if(count > x) return true; int needed = x - count; int remaining = bs.length - i; if(needed >= remaining) return false; } return false; }
db.values.insert({value: true}); db.values.insert({value: false}); db.values.insert({value: true});
var mapper = function(shouldInclude) { return function() { emit(null, shouldInclude(this) ? 1 : 0); }; } var reducer = function(key, values) { var sum = 0; for(var i = 0; i < values.length; i++) { sum += values[i]; } return sum; }
var result = db.values.mapReduce(mapper(isTrue), reducer).result; containsMinimum(2, result); containsMinimum(1, result); function isTrue(object) { return object.value == true; } function containsMinimum(count, resultDoc) { var record = db[resultDoc].find().next(); return record.value >= count; }
public class X { static boolean a(final boolean a, final boolean b, final boolean c) { return ((a && b) || (b && c) || (a && c)); } static boolean b(final boolean a, final boolean b, final boolean c) { return a ? (b || c) : (b && c); } static boolean c(final boolean a, final boolean b, final boolean c) { return ((a & b) | (b & c) | (c & a)); } static boolean d(final boolean a, final boolean b, final boolean c) { return ((a?1:0)+(b?1:0)+(c?1:0) >= 2); } }
Compiled from "X.java" public class X extends java.lang.Object{ public X(); Code: 0: aload_0 1: invokespecial 4: return static boolean a(boolean, boolean, boolean); Code: 0: iload_0 1: ifeq 8 4: iload_1 5: ifne 24 8: iload_1 9: ifeq 16 12: iload_2 13: ifne 24 16: iload_0 17: ifeq 28 20: iload_2 21: ifeq 28 24: iconst_1 25: goto 29 28: iconst_0 29: ireturn static boolean b(boolean, boolean, boolean); Code: 0: iload_0 1: ifeq 20 4: iload_1 5: ifne 12 8: iload_2 9: ifeq 16 12: iconst_1 13: goto 33 16: iconst_0 17: goto 33 20: iload_1 21: ifeq 32 24: iload_2 25: ifeq 32 28: iconst_1 29: goto 33 32: iconst_0 33: ireturn static boolean c(boolean, boolean, boolean); Code: 0: iload_0 1: iload_1 2: iand 3: iload_1 4: iload_2 5: iand 6: ior 7: iload_2 8: iload_0 9: iand 10: ior 11: ireturn static boolean d(boolean, boolean, boolean); Code: 0: iload_0 1: ifeq 8 4: iconst_1 5: goto 9 8: iconst_0 9: iload_1 10: ifeq 17 13: iconst_1 14: goto 18 17: iconst_0 18: iadd 19: iload_2 20: ifeq 27 23: iconst_1 24: goto 28 27: iconst_0 28: iadd 29: iconst_2 30: if_icmplt 37 33: iconst_1 34: goto 38 37: iconst_0 38: ireturn }
int n = 0; if (a) n++; if (b) n++; if (c) n++; return (n >= 2);
int n = -2; if (a) n++; if (b) n++; if (c) n++; return (n >= 0);
return (Boolean.valueOf(a).hashCode() + Boolean.valueOf(b).hashCode() + Boolean.valueOf(c).hashCode()) < 3705);
boolean atLeastTwo(boolean a, boolean b, boolean c) { if ((a && b) || (b && c) || (a && c)) { return true; } return false; }
boolean atLeastTwo(boolean a, boolean b, boolean c) { return ((a && b) || (b && c) || (a && c)); }
boolean atLeastTwo(boolean a, boolean b, boolean c) { if (a) { return b||c; } else { return b&&C; }
(defn at-least [n & bools] (>= (count (filter true? bools)) n)
boolean atLeast(int howMany, boolean[] boolValues) { int counter = 0; for (boolean b : boolValues) { if (b) { counter++; if (counter == howMany) { return true; } } } return false; }
boolean atLeastTwo(boolean t, boolean f, boolean True) { boolean False = True; if ((t || f) && (True || False)) return "answer" != "42"; if (t && f) return !"France".contains("Paris"); if (False == True) return true == false; return Math.random() > 0.5; }
boolean atLeastTwo(boolean a, boolean b, boolean c) { if ((a || b) && (c)) return true; if (a && b) return true; if (true) return false; return Math.random() > 0.5;
Function ReturnTrueIfTwoIsTrue(bool val1, val2, val3)) { return (System.Convert.ToInt16(val1) + System.Convert.ToInt16(val2) + System.Convert.ToInt16(val3)) > 1; }
int two(int a, int b, int c) { return !a + !b + !c < 2; }
int two(int a, int b, int c) { return !!a + !!b + !!c >= 2; }
boolean testBooleans(Array bools) { int minTrue = ceil(bools.length * .5); int trueCount = 0; for(int i = 0; i < bools.length; i++) { if(bools[i]) { trueCount++; } } return trueCount >= minTrue; }
static boolean five(final boolean a, final boolean b, final boolean c) { return a == b ? a : c; }
static boolean five(boolean, boolean, boolean); Code: 0: iload_0 1: iload_1 2: if_icmpne 9 5: iload_0 6: goto 10 9: iload_2 10: ireturn
one 5242 ms two 6318 ms three (moonshadow) 3806 ms four 7192 ms five (pdox) 3650 ms
public class MyType<E> { class Inner { } static class Nested { } public static void main(String[] args) { MyType mt; MyType.Inner inn; MyType.Nested nest; MyType<Object> mt1; MyType<?> mt2; } }
List names = new ArrayList(); names.add("John"); names.add("Mary"); names.add(Boolean.FALSE);
for (Object o : names) { String name = (String) o; System.out.println(name); }
List<String> names = new ArrayList<String>(); names.add("John"); names.add("Mary"); names.add(Boolean.FALSE);
void appendNewObject(List<Object> list) { list.add(new Object()); }
List<String> names = new ArrayList<String>(); appendNewObject(names);
static void appendNewObject(List<?> list) { list.add(new Object()); } List<String> names = new ArrayList<String>(); appendNewObject(names);
class MyType<E> { List<String> getNames() { return Arrays.asList("John", "Mary"); } public static void main(String[] args) { MyType rawType = new MyType(); List<String> names = rawType.getNames(); for (String str : rawType.getNames()) System.out.print(str); } }
List aList = new ArrayList(); String s = "Hello World!"; aList.add(s); String c = (String)aList.get(0);
List aNumberList = new ArrayList(); String one = "1"; aNumberList.add(one); Integer iOne = (Integer)aNumberList.get(0);
List<String> aNumberList = new ArrayList<String>(); aNumberList.add("one"); Integer iOne = aNumberList.get(0); String sOne = aNumberList.get(0);
List aList = new ArrayList(); List<String> aList = new ArrayList<String>();
class MyCompareAble implements CompareAble { int id; public int compareTo(Object other) {return this.id - ((MyCompareAble)other).id;} } class MyCompareAble implements CompareAble<MyCompareAble> { int id; public int compareTo(MyCompareAble other) {return this.id - other.id;} }
List<String> someStrings = new ArrayList<String>(); someStrings.add("one"); String one = someStrings.get(0);
List someStrings = new ArrayList(); someStrings.add("one"); String one = (String)someStrings.get(0);
Box<String> stringBox = new Box<>(); Box rawBox = stringBox;
Box rawBox = new Box(); Box<Integer> intBox = rawBox;
Box<String> stringBox = new Box<>(); Box rawBox = stringBox; rawBox.set(8);
public class WarningDemo { public static void main(String[] args){ Box<Integer> bi; bi = createBox(); } static Box createBox(){ return new Box(); } }
WarningDemo.java:4: warning: [unchecked] unchecked conversion found : Box required: Box<java.lang.Integer> bi = createBox(); ^ 1 warning
private static List<String> list = new ArrayList<String>();
LinkedList list = new LinkedList(); list.add(new MyObject()); MyObject myObject = (MyObject)list.get(0);
LinkedList<MyObject> list = new LinkedList<MyObject>(); list.add(new MyObject()); MyObject myObject = list.get(0);
private static List<String> list = new ArrayList<String>();
List<String> names = new ArrayList<String>(); names.add("John"); names.add(new Integer(1));
1. ArrayList<String> arr = new ArrayList<String>(); 2. ArrayList<String> arr = new ArrayList(); 3. ArrayList arr = new ArrayList<String>();
Set<Integer> set = new HashSet<Integer>(); set.add(3.45);
private static List<String> list = new ArrayList<String>();
public class StrangeClass<T> { @SuppressWarnings("unchecked") public <X> X getSomethingElse() { return (X)"Testing something else!"; } public static void main(String[] args) { final StrangeClass<String> withGeneric = new StrangeClass<>(); final StrangeClass withoutGeneric = new StrangeClass(); final String value1, value2; value1 = withGeneric.getSomethingElse(); value2 = withoutGeneric.getSomethingElse(); } }
public static void main(String[] args) throws IOException { Map wordMap = new HashMap(); if (args.length > 0) { for (int i = 0; i < args.length; i++) { countWord(wordMap, args[i]); } } else { getWordFrequency(System.in, wordMap); } for (Iterator i = wordMap.entrySet().iterator(); i.hasNext();) { Map.Entry entry = (Map.Entry) i.next(); System.out.println(entry.getKey() + " :\t" + entry.getValue()); }
public static void main(String[] args) throws IOException { Map<String, Integer> wordMap = new HashMap<String, Integer>(); if (args.length > 0) { for (int i = 0; i < args.length; i++) { countWord(wordMap, args[i]); } } else { getWordFrequency(System.in, wordMap); } for (Iterator<Entry<String, Integer>> i = wordMap.entrySet().iterator(); i.hasNext();) { Entry<String, Integer> entry = i.next(); System.out.println(entry.getKey() + " :\t" + entry.getValue()); } }
Exception in thread "main" java.lang.NullPointerException at com.example.myproject.Book.getTitle(Book.java:16) at com.example.myproject.Author.getBookTitles(Author.java:25) at com.example.myproject.Bootstrap.main(Bootstrap.java:14)
Exception in thread "main" java.lang.NullPointerException at com.example.myproject.Book.getTitle(Book.java:16) at com.example.myproject.Author.getBookTitles(Author.java:25) at com.example.myproject.Bootstrap.main(Bootstrap.java:14)
at com.example.myproject.Book.getTitle(Book.java:16)
15 public String getTitle() { 16 System.out.println(title.toString()); 17 return title; 18 }
34 public void getBookIds(int id) { 35 try { 36 book.getId(id); 37 } catch (NullPointerException e) { 38 throw new IllegalStateException("A book has a null property", e) 39 } 40 }
Exception in thread "main" java.lang.IllegalStateException: A book has a null property at com.example.myproject.Author.getBookIds(Author.java:38) at com.example.myproject.Bootstrap.main(Bootstrap.java:14) Caused by: java.lang.NullPointerException at com.example.myproject.Book.getId(Book.java:22) at com.example.myproject.Author.getBookIds(Author.java:36) ... 1 more
Caused by: java.lang.NullPointerException <-- root cause at com.example.myproject.Book.getId(Book.java:22) <-- important line
javax.servlet.ServletException: Something bad happened at com.example.myproject.OpenSessionInViewFilter.doFilter(OpenSessionInViewFilter.java:60) at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157) at com.example.myproject.ExceptionHandlerFilter.doFilter(ExceptionHandlerFilter.java:28) at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157) at com.example.myproject.OutputBufferFilter.doFilter(OutputBufferFilter.java:33) at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157) at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:388) at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216) at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182) at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765) at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:418) at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152) at org.mortbay.jetty.Server.handle(Server.java:326) at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542) at org.mortbay.jetty.HttpConnection$RequestHandler.content(HttpConnection.java:943) at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:756) at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:218) at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404) at org.mortbay.jetty.bio.SocketConnector$Connection.run(SocketConnector.java:228) at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:582) Caused by: com.example.myproject.MyProjectServletException at com.example.myproject.MyServlet.doPost(MyServlet.java:169) at javax.servlet.http.HttpServlet.service(HttpServlet.java:727) at javax.servlet.http.HttpServlet.service(HttpServlet.java:820) at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511) at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166) at com.example.myproject.OpenSessionInViewFilter.doFilter(OpenSessionInViewFilter.java:30) ... 27 more Caused by: org.hibernate.exception.ConstraintViolationException: could not insert: [com.example.myproject.MyEntity] at org.hibernate.exception.SQLStateConverter.convert(SQLStateConverter.java:96) at org.hibernate.exception.JDBCExceptionHelper.convert(JDBCExceptionHelper.java:66) at org.hibernate.id.insert.AbstractSelectingDelegate.performInsert(AbstractSelectingDelegate.java:64) at org.hibernate.persister.entity.AbstractEntityPersister.insert(AbstractEntityPersister.java:2329) at org.hibernate.persister.entity.AbstractEntityPersister.insert(AbstractEntityPersister.java:2822) at org.hibernate.action.EntityIdentityInsertAction.execute(EntityIdentityInsertAction.java:71) at org.hibernate.engine.ActionQueue.execute(ActionQueue.java:268) at org.hibernate.event.def.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:321) at org.hibernate.event.def.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:204) at org.hibernate.event.def.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:130) at org.hibernate.event.def.DefaultSaveOrUpdateEventListener.saveWithGeneratedOrRequestedId(DefaultSaveOrUpdateEventListener.java:210) at org.hibernate.event.def.DefaultSaveEventListener.saveWithGeneratedOrRequestedId(DefaultSaveEventListener.java:56) at org.hibernate.event.def.DefaultSaveOrUpdateEventListener.entityIsTransient(DefaultSaveOrUpdateEventListener.java:195) at org.hibernate.event.def.DefaultSaveEventListener.performSaveOrUpdate(DefaultSaveEventListener.java:50) at org.hibernate.event.def.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:93) at org.hibernate.impl.SessionImpl.fireSave(SessionImpl.java:705) at org.hibernate.impl.SessionImpl.save(SessionImpl.java:693) at org.hibernate.impl.SessionImpl.save(SessionImpl.java:689) at sun.reflect.GeneratedMethodAccessor5.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.hibernate.context.ThreadLocalSessionContext$TransactionProtectionWrapper.invoke(ThreadLocalSessionContext.java:344) at $Proxy19.save(Unknown Source) at com.example.myproject.MyEntityService.save(MyEntityService.java:59) <-- relevant call (see notes below) at com.example.myproject.MyServlet.doPost(MyServlet.java:164) ... 32 more Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...] at org.hsqldb.jdbc.Util.throwError(Unknown Source) at org.hsqldb.jdbc.jdbcPreparedStatement.executeUpdate(Unknown Source) at com.mchange.v2.c3p0.impl.NewProxyPreparedStatement.executeUpdate(NewProxyPreparedStatement.java:105) at org.hibernate.id.insert.AbstractSelectingDelegate.performInsert(AbstractSelectingDelegate.java:57) ... 54 more
at com.example.myproject.MyEntityService.save(MyEntityService.java:59)
Object a = null; a.toString(); Object[] b = new Object[5]; System.out.println(b[10]); int ia = 5; int ib = 0; ia = ia/ib;
try { Socket x = new Socket("1.1.1.1", 6789); x.getInputStream().read() } catch (IOException e) { System.err.println("Connection could not be established, please try again later!") }
int mult(Integer a,Integer b) { try { int result = a/b return result; } catch (Exception e) { System.err.println("Error: Division by zero!"); return 0; } }
package test.stack.trace; public class SomeClass { public void methodA() { methodB(); } public void methodB() { methodC(); } public void methodC() { throw new RuntimeException(); } public static void main(String[] args) { new SomeClass().methodA(); } }
Exception in thread "main" java.lang.RuntimeException at test.stack.trace.SomeClass.methodC(SomeClass.java:18) at test.stack.trace.SomeClass.methodB(SomeClass.java:13) at test.stack.trace.SomeClass.methodA(SomeClass.java:9) at test.stack.trace.SomeClass.main(SomeClass.java:27)
package test.stack.trace; public class SomeClass { ... public void methodC() { RuntimeException e = new RuntimeException(); e.setStackTrace(new StackTraceElement[]{ new StackTraceElement("OtherClass", "methodX", "String.java", 99), new StackTraceElement("OtherClass", "methodY", "String.java", 55) }); throw e; } public static void main(String[] args) { new SomeClass().methodA(); } }
Exception in thread "main" java.lang.RuntimeException at OtherClass.methodX(String.java:99) at OtherClass.methodY(String.java:55)
Exception in thread "main" java.lang.NullPointerException at com.example.myproject.Book.getTitle(Book.java:16) at com.example.myproject.Author.getBookTitles(Author.java:25) at com.example.myproject.Bootstrap.main(Bootstrap.java:14)
public class Test { private static void privateMethod() { throw new RuntimeException(); } public static void main(String[] args) throws Exception { Runnable runnable = new Runnable() { @Override public void run() { privateMethod(); } }; runnable.run(); } }
Exception in thread "main" java.lang.RuntimeException at Test.privateMethod(Test.java:4) at Test.access$000(Test.java:1) at Test$1.run(Test.java:10) at Test.main(Test.java:13)
synchronized (records) { Record rec = records.get(id); if (rec == null) { rec = new Record(id); records.put(id, rec); } return rec; }
public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) { return new SynchronizedMap<>(m); }
private static class SynchronizedMap<K,V> implements Map<K,V>, Serializable { private static final long serialVersionUID = 1978198479659022715L; private final Map<K,V> m; final Object mutex; SynchronizedMap(Map<K,V> m) { this.m = Objects.requireNonNull(m); mutex = this; } SynchronizedMap(Map<K,V> m, Object mutex) { this.m = m; this.mutex = mutex; } public int size() { synchronized (mutex) {return m.size();} } public boolean isEmpty() { synchronized (mutex) {return m.isEmpty();} } public boolean containsKey(Object key) { synchronized (mutex) {return m.containsKey(key);} } public boolean containsValue(Object value) { synchronized (mutex) {return m.containsValue(value);} } public V get(Object key) { synchronized (mutex) {return m.get(key);} } public V put(K key, V value) { synchronized (mutex) {return m.put(key, value);} } public V remove(Object key) { synchronized (mutex) {return m.remove(key);} } public void putAll(Map<? extends K, ? extends V> map) { synchronized (mutex) {m.putAll(map);} } public void clear() { synchronized (mutex) {m.clear();} } private transient Set<K> keySet; private transient Set<Map.Entry<K,V>> entrySet; private transient Collection<V> values; public Set<K> keySet() { synchronized (mutex) { if (keySet==null) keySet = new SynchronizedSet<>(m.keySet(), mutex); return keySet; } } public Set<Map.Entry<K,V>> entrySet() { synchronized (mutex) { if (entrySet==null) entrySet = new SynchronizedSet<>(m.entrySet(), mutex); return entrySet; } } public Collection<V> values() { synchronized (mutex) { if (values==null) values = new SynchronizedCollection<>(m.values(), mutex); return values; } } public boolean equals(Object o) { if (this == o) return true; synchronized (mutex) {return m.equals(o);} } public int hashCode() { synchronized (mutex) {return m.hashCode();} } public String toString() { synchronized (mutex) {return m.toString();} } @Override public V getOrDefault(Object k, V defaultValue) { synchronized (mutex) {return m.getOrDefault(k, defaultValue);} } @Override public void forEach(BiConsumer<? super K, ? super V> action) { synchronized (mutex) {m.forEach(action);} } @Override public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) { synchronized (mutex) {m.replaceAll(function);} } @Override public V putIfAbsent(K key, V value) { synchronized (mutex) {return m.putIfAbsent(key, value);} } @Override public boolean remove(Object key, Object value) { synchronized (mutex) {return m.remove(key, value);} } @Override public boolean replace(K key, V oldValue, V newValue) { synchronized (mutex) {return m.replace(key, oldValue, newValue);} } @Override public V replace(K key, V value) { synchronized (mutex) {return m.replace(key, value);} } @Override public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) { synchronized (mutex) {return m.computeIfAbsent(key, mappingFunction);} } @Override public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { synchronized (mutex) {return m.computeIfPresent(key, remappingFunction);} } @Override public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { synchronized (mutex) {return m.compute(key, remappingFunction);} } @Override public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) { synchronized (mutex) {return m.merge(key, value, remappingFunction);} } private void writeObject(ObjectOutputStream s) throws IOException { synchronized (mutex) {s.defaultWriteObject();} } }
public interface UserLister { List<User> getUsers(); }
public class UserListerDB implements UserLister { public List<User> getUsers() { } }
public class SomeView { private UserLister userLister; public void render() { List<User> users = userLister.getUsers(); view.render(users); } }
UserLister userLister = new UserListerCommaSeparatedFile();
public interface FourWheel { public void drive(); } public class Sedan implements FourWheel { public void drive() { } } public class SUV implements FourWheel { public void drive() { } }
public class RoadTrip { private FourWheel myCarForTrip; }
public class BaseView { protected UserLister userLister; public BaseView() { userLister = new UserListerDB(); } } public class SomeView extends BaseView { public SomeView() { super(); } public void render() { List<User> users = userLister.getUsers(); view.render(users); } }
@Component public class UserListerDB implements UserLister { public List<User> getUsers() { } }
public interface Lunch { public void eat(); } public class Buffet implements Lunch { public void eat() { } } public class Plated implements Lunch { public void eat() { } }
public class LunchDecide { private Lunch todaysLunch; public LunchDecide(){ this.todaysLunch = new Buffet(); } }
public class LunchDecide { private Lunch todaysLunch; public LunchDecide(Lunch todaysLunch){ this.todaysLunch = todaysLunch } }
public class WaterContainer { private int size; private int brand; ...etc public static int convertToGallon(int liters)... public static int convertToLiters(int gallon)... }
android { ... defaultConfig { ... jackOptions { enabled true } } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } }
android { compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 }
android { ... compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } }
android { ... defaultConfig { ... jackOptions { enabled true } } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } }
Legacy javac toolchain: javac (.java  .class)  dx (.class  .dex) New Jack toolchain: Jack (.java  .jack  .dex)
buildscript { repositories { ... jcenter() } dependencies { ... classpath ... } }
apply plugin: apply plugin: android { ... compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } ... }
import java.lang.instrument.Instrumentation; public class ObjectSizeFetcher { private static Instrumentation instrumentation; public static void premain(String args, Instrumentation inst) { instrumentation = inst; } public static long getObjectSize(Object o) { return instrumentation.getObjectSize(o); } }
public class C { private int x; private int y; public static void main(String [] args) { System.out.println(ObjectSizeFetcher.getObjectSize(new C())); } }
Running 64-bit HotSpot VM. Using compressed oop with 0-bit shift. Using compressed klass with 3-bit shift. Objects are 8 bytes aligned. Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
java.util.regex.Pattern object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (0000 0001 0000 0000 0000 0000 0000 0000) 4 4 (object header) 00 00 00 00 (0000 0000 0000 0000 0000 0000 0000 0000) 8 4 (object header) cb cf 00 20 (1100 1011 1100 1111 0000 0000 0010 0000) 12 4 int Pattern.flags 0 16 4 int Pattern.capturingGroupCount 1 20 4 int Pattern.localCount 0 24 4 int Pattern.cursor 48 28 4 int Pattern.patternLength 0 32 1 boolean Pattern.compiled true 33 1 boolean Pattern.hasSupplementary false 34 2 (alignment/padding gap) N/A 36 4 String Pattern.pattern (object) 40 4 String Pattern.normalizedPattern (object) 44 4 Node Pattern.root (object) 48 4 Node Pattern.matchRoot (object) 52 4 int[] Pattern.buffer null 56 4 Map Pattern.namedGroups null 60 4 GroupHead[] Pattern.groupNodes null 64 4 int[] Pattern.temp null 68 4 (loss due to the next object alignment) Instance size: 72 bytes (reported by Instrumentation API) Space losses: 2 bytes internal + 4 bytes external = 6 bytes total
java.util.regex.Pattern instance footprint: COUNT AVG SUM DESCRIPTION 1 112 112 [C 3 272 816 [Z 1 24 24 java.lang.String 1 72 72 java.util.regex.Pattern 9 24 216 java.util.regex.Pattern$1 13 24 312 java.util.regex.Pattern$5 1 16 16 java.util.regex.Pattern$Begin 3 24 72 java.util.regex.Pattern$BitClass 3 32 96 java.util.regex.Pattern$Curly 1 24 24 java.util.regex.Pattern$Dollar 1 16 16 java.util.regex.Pattern$LastNode 1 16 16 java.util.regex.Pattern$Node 2 24 48 java.util.regex.Pattern$Single 40 1840 (total)
java.util.regex.Pattern object externals: ADDRESS SIZE TYPE PATH VALUE d5e5f290 16 java.util.regex.Pattern$Node .root.next.atom.next (object) d5e5f2a0 120 (something else) (somewhere else) (something else) d5e5f318 16 java.util.regex.Pattern$LastNode .root.next.next.next.next.next.next.next (object) d5e5f328 21664 (something else) (somewhere else) (something else) d5e647c8 24 java.lang.String .pattern (object) d5e647e0 112 [C .pattern.value [^, [, a, -, z, A, -, Z, 0, -, 9, _, ., +, -, ], +, @, [, a, -, z, A, -, Z, 0, -, 9, -, ], +, \, ., [, a, -, z, A, -, Z, 0, -, 9, -, ., ], +, $] d5e64850 448 (something else) (somewhere else) (something else) d5e64a10 72 java.util.regex.Pattern (object) d5e64a58 416 (something else) (somewhere else) (something else) d5e64bf8 16 java.util.regex.Pattern$Begin .root (object) d5e64c08 24 java.util.regex.Pattern$BitClass .root.next.atom.val$rhs (object) d5e64c20 272 [Z .root.next.atom.val$rhs.bits [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false] d5e64d30 24 java.util.regex.Pattern$1 .root.next.atom.val$lhs.val$lhs.val$lhs.val$lhs.val$lhs.val$lhs (object) d5e64d48 24 java.util.regex.Pattern$1 .root.next.atom.val$lhs.val$lhs.val$lhs.val$lhs.val$lhs.val$rhs (object) d5e64d60 24 java.util.regex.Pattern$5 .root.next.atom.val$lhs.val$lhs.val$lhs.val$lhs.val$lhs (object) d5e64d78 24 java.util.regex.Pattern$1 .root.next.atom.val$lhs.val$lhs.val$lhs.val$lhs.val$rhs (object) d5e64d90 24 java.util.regex.Pattern$5 .root.next.atom.val$lhs.val$lhs.val$lhs.val$lhs (object) d5e64da8 24 java.util.regex.Pattern$5 .root.next.atom.val$lhs.val$lhs.val$lhs (object) d5e64dc0 24 java.util.regex.Pattern$5 .root.next.atom.val$lhs.val$lhs (object) d5e64dd8 24 java.util.regex.Pattern$5 .root.next.atom.val$lhs (object) d5e64df0 24 java.util.regex.Pattern$5 .root.next.atom (object) d5e64e08 32 java.util.regex.Pattern$Curly .root.next (object) d5e64e28 24 java.util.regex.Pattern$Single .root.next.next (object) d5e64e40 24 java.util.regex.Pattern$BitClass .root.next.next.next.atom.val$rhs (object) d5e64e58 272 [Z .root.next.next.next.atom.val$rhs.bits [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false] d5e64f68 24 java.util.regex.Pattern$1 .root.next.next.next.atom.val$lhs.val$lhs.val$lhs (object) d5e64f80 24 java.util.regex.Pattern$1 .root.next.next.next.atom.val$lhs.val$lhs.val$rhs (object) d5e64f98 24 java.util.regex.Pattern$5 .root.next.next.next.atom.val$lhs.val$lhs (object) d5e64fb0 24 java.util.regex.Pattern$1 .root.next.next.next.atom.val$lhs.val$rhs (object) d5e64fc8 24 java.util.regex.Pattern$5 .root.next.next.next.atom.val$lhs (object) d5e64fe0 24 java.util.regex.Pattern$5 .root.next.next.next.atom (object) d5e64ff8 32 java.util.regex.Pattern$Curly .root.next.next.next (object) d5e65018 24 java.util.regex.Pattern$Single .root.next.next.next.next (object) d5e65030 24 java.util.regex.Pattern$BitClass .root.next.next.next.next.next.atom.val$rhs (object) d5e65048 272 [Z .root.next.next.next.next.next.atom.val$rhs.bits [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false] d5e65158 24 java.util.regex.Pattern$1 .root.next.next.next.next.next.atom.val$lhs.val$lhs.val$lhs.val$lhs (object) d5e65170 24 java.util.regex.Pattern$1 .root.next.next.next.next.next.atom.val$lhs.val$lhs.val$lhs.val$rhs (object) d5e65188 24 java.util.regex.Pattern$5 .root.next.next.next.next.next.atom.val$lhs.val$lhs.val$lhs (object) d5e651a0 24 java.util.regex.Pattern$1 .root.next.next.next.next.next.atom.val$lhs.val$lhs.val$rhs (object) d5e651b8 24 java.util.regex.Pattern$5 .root.next.next.next.next.next.atom.val$lhs.val$lhs (object) d5e651d0 24 java.util.regex.Pattern$5 .root.next.next.next.next.next.atom.val$lhs (object) d5e651e8 24 java.util.regex.Pattern$5 .root.next.next.next.next.next.atom (object) d5e65200 32 java.util.regex.Pattern$Curly .root.next.next.next.next.next (object) d5e65220 120 (something else) (somewhere else) (something else) d5e65298 24 java.util.regex.Pattern$Dollar .root.next.next.next.next.next.next (object)
Serializable ser; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(ser); oos.close(); return baos.size();
System.out.println(ObjectSizeCalculator.getObjectSize(new gnu.trove.map.hash.TObjectIntHashMap<String>(12000, 0.6f, -1))); System.out.println(ObjectSizeCalculator.getObjectSize(new HashMap<String, Integer>(100000))); System.out.println(ObjectSizeCalculator.getObjectSize(3)); System.out.println(ObjectSizeCalculator.getObjectSize(new int[]{1, 2, 3, 4, 5, 6, 7 })); System.out.println(ObjectSizeCalculator.getObjectSize(new int[100]));
long heapSize = Runtime.getRuntime().totalMemory(); long heapMaxSize = Runtime.getRuntime().maxMemory(); long heapFreeSize = Runtime.getRuntime().freeMemory();
<dependency> <groupId>com.carrotsearch</groupId> <artifactId>java-sizeof</artifactId> <version>0.0.3</version> </dependency>
private static final int NR_BITS = Integer.valueOf(System.getProperty("sun.arch.data.model")); private static final int BYTE = 8; private static final int WORD = NR_BITS/BYTE; private static final int MIN_SIZE = 16; public static int sizeOf(Class src){ // List<Field> instanceFields = new LinkedList<Field>(); do{ if(src == Object.class) return MIN_SIZE; for (Field f : src.getDeclaredFields()) { if((f.getModifiers() & Modifier.STATIC) == 0){ instanceFields.add(f); } } src = src.getSuperclass(); }while(instanceFields.isEmpty()); // long maxOffset = 0; for (Field f : instanceFields) { long offset = UtilUnsafe.UNSAFE.objectFieldOffset(f); if(offset > maxOffset) maxOffset = offset; } return (((int)maxOffset/WORD) + 1)*WORD; } class UtilUnsafe { public static final sun.misc.Unsafe UNSAFE; static { Object theUnsafe = null; Exception exception = null; try { Class<?> uc = Class.forName("sun.misc.Unsafe"); Field f = uc.getDeclaredField("theUnsafe"); f.setAccessible(true); theUnsafe = f.get(uc); } catch (Exception e) { exception = e; } UNSAFE = (sun.misc.Unsafe) theUnsafe; if (UNSAFE == null) throw new Error("Could not obtain access to sun.misc.Unsafe", exception); } private UtilUnsafe() { } }
import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.IdentityHashMap; import java.util.Stack; import sun.misc.Unsafe; /** Usage: * MemoryUtil.sizeOf( object ) * MemoryUtil.deepSizeOf( object ) * MemoryUtil.ADDRESS_MODE */ public class MemoryUtil { private MemoryUtil() { } public static enum AddressMode { /** Unknown address mode. Size calculations may be unreliable. */ UNKNOWN, /** 32-bit address mode using 32-bit references. */ MEM_32BIT, /** 64-bit address mode using 64-bit references. */ MEM_64BIT, /** 64-bit address mode using 32-bit compressed references. */ MEM_64BIT_COMPRESSED_OOPS } /** The detected runtime address mode. */ public static final AddressMode ADDRESS_MODE; private static final Unsafe UNSAFE; private static final long ADDRESS_SIZE; private static final long REFERENCE_SIZE; private static final long OBJECT_BASE_SIZE; private static final long OBJECT_ALIGNMENT = 8; /** Use the offset of a known field to determine the minimum size of an object. */ private static final Object HELPER_OBJECT = new Object() { byte b; }; static { try { Field f = Unsafe.class.getDeclaredField( "theUnsafe" ); f.setAccessible( true ); UNSAFE = (Unsafe) f.get( null ); OBJECT_BASE_SIZE = UNSAFE.objectFieldOffset( HELPER_OBJECT.getClass().getDeclaredField( "b" ) ); ADDRESS_SIZE = UNSAFE.addressSize(); REFERENCE_SIZE = UNSAFE.arrayIndexScale( Object[].class ); if( ADDRESS_SIZE == 4 ) { ADDRESS_MODE = AddressMode.MEM_32BIT; } else if( ADDRESS_SIZE == 8 && REFERENCE_SIZE == 8 ) { ADDRESS_MODE = AddressMode.MEM_64BIT; } else if( ADDRESS_SIZE == 8 && REFERENCE_SIZE == 4 ) { ADDRESS_MODE = AddressMode.MEM_64BIT_COMPRESSED_OOPS; } else { ADDRESS_MODE = AddressMode.UNKNOWN; } } catch( Exception e ) { throw new Error( e ); } } /** Return the size of the object excluding any referenced objects. */ public static long shallowSizeOf( final Object object ) { Class<?> objectClass = object.getClass(); if( objectClass.isArray() ) { long size = UNSAFE.arrayBaseOffset( objectClass ) + UNSAFE.arrayIndexScale( objectClass ) * Array.getLength( object ); return padSize( size ); } else { long size = OBJECT_BASE_SIZE; do { for( Field field : objectClass.getDeclaredFields() ) { if( (field.getModifiers() & Modifier.STATIC) == 0 ) { long offset = UNSAFE.objectFieldOffset( field ); if( offset >= size ) { size = offset + 1; } } } objectClass = objectClass.getSuperclass(); } while( objectClass != null ); return padSize( size ); } } private static final long padSize( final long size ) { return (size + (OBJECT_ALIGNMENT - 1)) & ~(OBJECT_ALIGNMENT - 1); } /** Return the size of the object including any referenced objects. */ public static long deepSizeOf( final Object object ) { IdentityHashMap<Object,Object> visited = new IdentityHashMap<Object,Object>(); Stack<Object> stack = new Stack<Object>(); if( object != null ) stack.push( object ); long size = 0; while( !stack.isEmpty() ) { size += internalSizeOf( stack.pop(), stack, visited ); } return size; } private static long internalSizeOf( final Object object, final Stack<Object> stack, final IdentityHashMap<Object,Object> visited ) { Class<?> c = object.getClass(); if( c.isArray() && !c.getComponentType().isPrimitive() ) { for( int i = Array.getLength( object ) - 1; i >= 0; i-- ) { Object val = Array.get( object, i ); if( val != null && visited.put( val, val ) == null ) { stack.add( val ); } } } else { for( ; c != null; c = c.getSuperclass() ) { for( Field field : c.getDeclaredFields() ) { if( (field.getModifiers() & Modifier.STATIC) == 0 && !field.getType().isPrimitive() ) { field.setAccessible( true ); try { Object val = field.get( object ); if( val != null && visited.put( val, val ) == null ) { stack.add( val ); } } catch( IllegalArgumentException e ) { throw new RuntimeException( e ); } catch( IllegalAccessException e ) { throw new RuntimeException( e ); } } } } } return shallowSizeOf( object ); } }
System.gc(); Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); do your job here System.gc(); Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
public class Test1 { class Nested { } static class StaticNested { } static long getFreeMemory () { long init = Runtime.getRuntime().freeMemory(), init2; int count = 0; do { System.out.println("waiting..." + init); System.gc(); try { Thread.sleep(250); } catch (Exception x) { } init2 = init; init = Runtime.getRuntime().freeMemory(); if (init == init2) ++ count; else count = 0; } while (count < 5); System.out.println("ok..." + init); return init; } Test1 () throws InterruptedException { Object[] s = new Object[10000]; Object[] n = new Object[10000]; Object[] t = new Object[10000]; long init = getFreeMemory(); long afters = getFreeMemory(); for (int j = 0; j < 10000; ++ j) n[j] = new Nested(); long aftersn = getFreeMemory(); for (int j = 0; j < 10000; ++ j) t[j] = new StaticNested(); long aftersnt = getFreeMemory(); System.out.println("separate: " + -(afters - init) + " each=" + -(afters - init) / 10000); System.out.println("nested: " + -(aftersn - afters) + " each=" + -(aftersn - afters) / 10000); System.out.println("static nested: " + -(aftersnt - aftersn) + " each=" + -(aftersnt - aftersn) / 10000); } public static void main (String[] args) throws InterruptedException { new Test1(); } }
nested: 160000 each=16 static nested: 160000 each=16
long heapSizeBefore = Runtime.getRuntime().totalMemory(); ... long heapSizeAfter = Runtime.getRuntime().totalMemory(); long size = heapSizeAfter - heapSizeBefore;
import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class ObjectSizeCalculator { private Object getFirstObjectReference(Object o) { String objectType = o.getClass().getTypeName(); if (objectType.substring(objectType.length()-2).equals("[]")) { try { if (objectType.equals("java.lang.Object[]")) return ((Object[])o)[0]; else if (objectType.equals("int[]")) return ((int[])o)[0]; else throw new RuntimeException("Not Implemented !"); } catch (IndexOutOfBoundsException e) { return null; } } return o; } public int getObjectSizeInBytes(Object o) { final String STRING_JAVA_TYPE_NAME = "java.lang.String"; if (o == null) return 0; String objectType = o.getClass().getTypeName(); boolean isArray = objectType.substring(objectType.length()-2).equals("[]"); Object objRef = getFirstObjectReference(o); if (objRef != null && !(objRef instanceof Serializable)) throw new RuntimeException("Object must be serializable for measuring it try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(o); oos.close(); byte[] bytes = baos.toByteArray(); for (int i = bytes.length - 1, j = 0; i != 0; i--, j++) { if (objectType != STRING_JAVA_TYPE_NAME) { if (bytes[i] == 112) if (isArray) return j - 4; else return j; } else { if (bytes[i] == 0) return j - 1; } } } catch (Exception e) { return -1; } return -1; } }
int [] intArray = new int [1]; will require 4 bytes. long [] longArray = new long [1]; will require 8 bytes.
Object[] objectArray = new Object[1]; will require 4 bytes. The object can be any user defined Object. Long [] longArray = new Long [1]; will require 4 bytes.
class ReferenceMemoryTest { public String refStr; public Object refObj; public Double refDoub; }
Serializable myObject; ObjectOutputStream oos = new ObjectOutputStream (new FileOutputStream ("obj.ser")); oos.write (myObject); oos.close ();
public class Singleton { private static volatile Singleton _instance; public static Singleton getInstance() { if (_instance == null) { synchronized (Singleton.class) { if (_instance == null) _instance = new Singleton(); } } return _instance; } }
public class Singleton{ private static Singleton _instance; public static Singleton getInstance(){ if(_instance == null){ synchronized(Singleton.class){ if(_instance == null) _instance = new Singleton(); } } return _instance; }
public class Foo extends Thread { private volatile boolean close = false; public void run() { while(!close) { } } public void close() { close = true; } }
package io.netty.example.telnet; import java.util.ArrayList; import java.util.List; public class Main { public static volatile int a = 0; public static void main(String args[]) throws InterruptedException{ List<Thread> list = new ArrayList<Thread>(); for(int i = 0 ; i<11 ;i++){ list.add(new Pojo()); } for (Thread thread : list) { thread.start(); } Thread.sleep(20000); System.out.println(a); } } class Pojo extends Thread{ int a = 10001; public void run() { while(a-->0){ try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } Main.a++; System.out.println("a = "+Main.a); } } }
package io.netty.example.telnet; import java.util.ArrayList; import java.util.List; import java.util.concurrent.atomic.AtomicInteger; public class Main { public static volatile AtomicInteger a = new AtomicInteger(0); public static void main(String args[]) throws InterruptedException{ List<Thread> list = new ArrayList<Thread>(); for(int i = 0 ; i<11 ;i++){ list.add(new Pojo()); } for (Thread thread : list) { thread.start(); } Thread.sleep(20000); System.out.println(a.get()); } } class Pojo extends Thread{ int a = 10001; public void run() { while(a-->0){ try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } Main.a.incrementAndGet(); System.out.println("a = "+Main.a); } } }
thread 0 prints 0 thread 1 prints 1 thread 2 prints 2 thread 3 prints 3 thread 0 prints 0 thread 1 prints 1 thread 2 prints 2 thread 3 prints 3 thread 0 prints 0 thread 1 prints 1 thread 2 prints 2 thread 3 prints 3
public class Solution { static volatile int counter = 0; static int print = 0; public static void main(String[] args) { Thread[] ths = new Thread[4]; for (int i = 0; i < ths.length; i++) { ths[i] = new Thread(new MyRunnable(i, ths.length)); ths[i].start(); } } static class MyRunnable implements Runnable { final int thID; final int total; public MyRunnable(int id, int total) { thID = id; this.total = total; } @Override public void run() { while (true) { if (thID == counter) { System.out.println("thread " + thID + " prints " + print); print++; if (print == total) print = 0; counter++; if (counter == total) counter = 0; } else { try { Thread.sleep(30); } catch (InterruptedException e) { } } } } } }
Only in jdk-10.0.1/bin: javapackager Only in jdk-10.0.1/bin: javaws Only in jdk-10.0.1/bin: jcontrol Only in jdk-10.0.1/bin: jmc Only in jdk-10.0.1/bin: jweblauncher Only in jdk-10.0.1/lib: ant-javafx.jar Only in jdk-10.0.1/lib: deploy Only in jdk-10.0.1/lib: deploy.jar Only in jdk-10.0.1/lib: desktop Only in jdk-10.0.1/lib: fontconfig.bfc Only in jdk-10.0.1/lib: fontconfig.properties.src Only in jdk-10.0.1/lib: fontconfig.RedHat.6.bfc Only in jdk-10.0.1/lib: fontconfig.RedHat.6.properties.src Only in jdk-10.0.1/lib: fontconfig.SuSE.11.bfc Only in jdk-10.0.1/lib: fontconfig.SuSE.11.properties.src Only in jdk-10.0.1/lib: fonts Only in jdk-10.0.1/lib: javafx.properties Only in jdk-10.0.1/lib: javafx-swt.jar Only in jdk-10.0.1/lib: java.jnlp.jar Only in jdk-10.0.1/lib: javaws.jar Only in jdk-10.0.1/lib: jdk.deploy.jar Only in jdk-10.0.1/lib: jdk.javaws.jar Only in jdk-10.0.1/lib: jdk.plugin.jar Only in jdk-10.0.1/lib: jfr Only in jdk-10.0.1/lib: libavplugin-53.so Only in jdk-10.0.1/lib: libavplugin-54.so Only in jdk-10.0.1/lib: libavplugin-55.so Only in jdk-10.0.1/lib: libavplugin-56.so Only in jdk-10.0.1/lib: libavplugin-57.so Only in jdk-10.0.1/lib: libavplugin-ffmpeg-56.so Only in jdk-10.0.1/lib: libavplugin-ffmpeg-57.so Only in jdk-10.0.1/lib: libbci.so Only in jdk-10.0.1/lib: libcmm.so Only in jdk-10.0.1/lib: libdecora_sse.so Only in jdk-10.0.1/lib: libdeploy.so Only in jdk-10.0.1/lib: libfxplugins.so Only in jdk-10.0.1/lib: libglassgtk2.so Only in jdk-10.0.1/lib: libglassgtk3.so Only in jdk-10.0.1/lib: libglass.so Only in jdk-10.0.1/lib: libgstreamer-lite.so Only in jdk-10.0.1/lib: libjavafx_font_freetype.so Only in jdk-10.0.1/lib: libjavafx_font_pango.so Only in jdk-10.0.1/lib: libjavafx_font.so Only in jdk-10.0.1/lib: libjavafx_iio.so Only in jdk-10.0.1/lib: libjfxmedia.so Only in jdk-10.0.1/lib: libjfxwebkit.so Only in jdk-10.0.1/lib: libnpjp2.so Only in jdk-10.0.1/lib: libprism_common.so Only in jdk-10.0.1/lib: libprism_es2.so Only in jdk-10.0.1/lib: libprism_sw.so Only in jdk-10.0.1/lib: librm.so Only in jdk-10.0.1/lib: libt2k.so Only in jdk-10.0.1/lib: locale Only in jdk-10.0.1/lib: missioncontrol Only in jdk-10.0.1/lib: oblique-fonts Only in jdk-10.0.1/lib: plugin.jar Only in jdk-10.0.1/lib: plugin-legacy.jar Only in jdk-10.0.1/lib/security: blacklist Only in jdk-10.0.1/lib/security: public_suffix_list.dat Only in jdk-10.0.1/lib/security: trusted.libraries Only in openjdk-10.0.1: man`
XMLGregorianCalendar xgc = DatatypeFactory.newInstance().newXMLGregorianCalendar(new DateTime().toGregorianCalendar());
Set<Foo> lSet = new TreeSet<Foo>(someComparator); lSet.addAll(myList);
List<Integer> mylist = Arrays.asList(100, 101, 102); Set<Integer> myset = mylist.stream().collect(Collectors.toSet()));
import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; public class ListToSet { public static void main(String[] args) { List<String> alphaList = new ArrayList<String>(); alphaList.add("A"); alphaList.add("B"); alphaList.add("C"); alphaList.add("A"); alphaList.add("B"); System.out.println("List values ....."); for (String alpha : alphaList) { System.out.println(alpha); } Set<String> alphaSet = new HashSet<String>(alphaList); System.out.println("\nSet values ....."); for (String alpha : alphaSet) { System.out.println(alpha); } } }
if(myList != null){ Set<Foo> foo = new HashSet<Foo>(myList); }
List < UserEntity > vList= new ArrayList<>(); vList= service(...); Set<UserEntity> vSet= vList.stream().collect(Collectors.toSet());
Set<T> set=new HashSet<T>(); Set<T> set; if(list != null){ set = new HashSet<T>(list); }
list.stream().<here goes some preprocessing>.collect(Collectors.toSet());
List<Integer> sourceList = new ArrayList(); sourceList.add(1); sourceList.add(2); sourceList.add(3); sourceList.add(4); Set<Integer> set1 = new HashSet<>(sourceList); Set<Integer> set2 = sourceList.stream().collect(Collectors.toSet()); Set<Integer> set3 = sourceList.stream().collect(Collectors.toCollection(HashSet::new)); Set<Integer> set4 = Sets.newHashSet(sourceList); Set<Integer> set5 = new HashSet<>(4); CollectionUtils.addAll(set5, sourceList);
Set<Foo> mySet = Optional.ofNullable(myList).map(HashSet::new).orElse(null);
public void listFilesForFolder(final File folder) { for (final File fileEntry : folder.listFiles()) { if (fileEntry.isDirectory()) { listFilesForFolder(fileEntry); } else { System.out.println(fileEntry.getName()); } } } final File folder = new File("/home/you/Desktop"); listFilesForFolder(folder);
try (Stream<Path> paths = Files.walk(Paths.get("/home/you/Desktop"))) { paths .filter(Files::isRegularFile) .forEach(System.out::println); }
File folder = new File("/Users/you/folder/"); File[] listOfFiles = folder.listFiles(); for (File file : listOfFiles) { if (file.isFile()) { System.out.println(file.getName()); } }
Files.walk(Paths.get("/path/to/folder")) .filter(Files::isRegularFile) .forEach(System.out::println);
Files.walk(Paths.get("/path/to/folder")) .filter(Files::isRegularFile) .collect(Collectors.toList())
List<File> filesInFolder = Files.walk(Paths.get("/path/to/folder")) .filter(Files::isRegularFile) .map(Path::toFile) .collect(Collectors.toList());
try (Stream<Path> filePathStream=Files.walk(Paths.get("/home/you/Desktop"))) { filePathStream.forEach(filePath -> { if (Files.isRegularFile(filePath)) { System.out.println(filePath); } }); }
import java.io.File; public class ReadFilesFromFolder { public static File folder = new File("C:/Documents and Settings/My Documents/Downloads"); static String temp = ""; public static void main(String[] args) { System.out.println("Reading files under the folder "+ folder.getAbsolutePath()); listFilesForFolder(folder); } public static void listFilesForFolder(final File folder) { for (final File fileEntry : folder.listFiles()) { if (fileEntry.isDirectory()) { listFilesForFolder(fileEntry); } else { if (fileEntry.isFile()) { temp = fileEntry.getName(); if ((temp.substring(temp.lastIndexOf( System.out.println("File= " + folder.getAbsolutePath()+ "\\" + fileEntry.getName()); } } } } }
private static final String ROOT_FILE_PATH="/"; File f=new File(ROOT_FILE_PATH); File[] allSubFiles=f.listFiles(); for (File file : allSubFiles) { if(file.isDirectory()) { System.out.println(file.getAbsolutePath()+" is directory"); } else { System.out.println(file.getAbsolutePath()+" is file"); } }
Path dir = ...; try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) { for (Path file: stream) { System.out.println(file.getFileName()); } } catch (IOException | DirectoryIteratorException x) { System.err.println(x); }
DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() { public boolean accept(Path file) throws IOException { try { return (Files.isRegularFile(path)); } catch (IOException x) { System.err.println(x); return false; } } };
Files.walkFileTree(Paths.get(dir), new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { System.out.println("file: " + file); return FileVisitResult.CONTINUE; } });
public static ArrayList<File> listFilesForFolder(final File folder, final boolean recursivity, final String patternFileFilter) { boolean filteredFile = false; final ArrayList<File> output = new ArrayList<File> (); for (final File fileEntry : folder.listFiles()) { if (fileEntry.isDirectory()) { if (recursivity) { output.addAll(listFilesForFolder(fileEntry, recursivity, patternFileFilter)); } } else { if (patternFileFilter.length() == 0) { filteredFile = true; } else { filteredFile = Pattern.matches(patternFileFilter, fileEntry.getName()); } if (filteredFile) { output.add(fileEntry); } } } return output; }
File fl = new File(dir); File[] files = fl.listFiles(new FileFilter() { public boolean accept(File file) { return file.isFile(); } });
static File mainFolder = new File("Folder"); public static void main(String[] args) { lf.getFiles(lf.mainFolder); } public void getFiles(File f) { File files[]; if (f.isFile()) { String name=f.getName(); } else { files = f.listFiles(); for (int i = 0; i < files.length; i++) { getFiles(files[i]); } } }
private static void addfiles (File input,ArrayList<File> files) { if(input.isDirectory()) { ArrayList <File> path = new ArrayList<File>(Arrays.asList(input.listFiles())); for(int i=0 ; i<path.size();++i) { if(path.get(i).isDirectory()) { addfiles(path.get(i),files); } if(path.get(i).isFile()) { files.add(path.get(i)); } } } if(input.isFile()) { files.add(input); } }
import java.io.File; public class List { public static void main(String[] args) { for (String f : args) { listDir(f); } } private static void listDir(String dir) { File f = new File(dir); File[] list = f.listFiles(); if (list == null) { return; } for (File entry : list) { System.out.println(entry.getName()); if (entry.isDirectory()) { listDir(entry.getAbsolutePath()); } } } }
final File keysFileFolder = new File(<path>); File[] fileslist = keysFileFolder.listFiles(); if(fileslist != null) { }
File directory = new File("/user/folder"); File[] myarray; myarray=new File[10]; myarray=directory.listFiles(); for (int j = 0; j < myarray.length; j++) { File path=myarray[j]; FileReader fr = new FileReader(path); BufferedReader br = new BufferedReader(fr); String s = ""; while (br.ready()) { s += br.readLine() + "\n"; } }
package com; import java.io.File; /** * * @author ?Mukesh */ public class ListFiles { static File mainFolder = new File("D:\\Movies"); public static void main(String[] args) { ListFiles lf = new ListFiles(); lf.getFiles(lf.mainFolder); long fileSize = mainFolder.length(); System.out.println("mainFolder size in bytes is: " + fileSize); System.out.println("File size in KB is : " + (double)fileSize/1024); System.out.println("File size in MB is :" + (double)fileSize/(1024*1024)); } public void getFiles(File f){ File files[]; if(f.isFile()) System.out.println(f.getAbsolutePath()); else{ files = f.listFiles(); for (int i = 0; i < files.length; i++) { getFiles(files[i]); } } } }
int[] count = {0}; try { Files.walkFileTree(Paths.get(dir.getPath()), new HashSet<FileVisitOption>(Arrays.asList(FileVisitOption.FOLLOW_LINKS)), Integer.MAX_VALUE, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file , BasicFileAttributes attrs) throws IOException { System.out.printf("Visiting file %s\n", file); ++count[0]; return FileVisitResult.CONTINUE; } @Override public FileVisitResult visitFileFailed(Path file , IOException e) throws IOException { System.err.printf("Visiting failed for %s\n", file); return FileVisitResult.SKIP_SUBTREE; } @Override public FileVisitResult preVisitDirectory(Path dir , BasicFileAttributes attrs) throws IOException { System.out.printf("About to visit directory %s\n", dir); return FileVisitResult.CONTINUE; } }); } catch (IOException e) { e.printStackTrace(); }
import java.io.File; import java.util.ArrayList; import java.util.List; public class AvoidNullExp { public static void main(String[] args) { List<File> fileList =new ArrayList<>(); final File folder = new File("g:/master"); new AvoidNullExp().listFilesForFolder(folder, fileList); } public void listFilesForFolder(final File folder,List<File> fileList) { File[] filesInFolder = folder.listFiles(); if (filesInFolder != null) { for (final File fileEntry : filesInFolder) { if (fileEntry.isDirectory()) { System.out.println("DIR : "+fileEntry.getName()); listFilesForFolder(fileEntry,fileList); } else { System.out.println("FILE : "+fileEntry.getName()); fileList.add(fileEntry); } } } } }
import java.io.File; import java.io.IOException; public class Hello { public static void main(final String[] args) throws IOException { System.out.println("List down all the files present on the server directory"); File file1 = new File("/prog/FileTest/src/Test"); File[] files = file1.listFiles(); if (null != files) { for (int fileIntList = 0; fileIntList < files.length; fileIntList++) { String ss = files[fileIntList].toString(); if (null != ss && ss.length() > 0) { System.out.println("File: " + (fileIntList + 1) + " :" + ss.substring(ss.lastIndexOf("\\") + 1, ss.length())); } } } } }
/** * Function to read all mp3 files from sdcard and store the details in an * ArrayList */ public ArrayList<HashMap<String, String>> getPlayList() { ArrayList<HashMap<String, String>> songsList=new ArrayList<>(); File home = new File(MEDIA_PATH); if (home.listFiles(new FileExtensionFilter()).length > 0) { for (File file : home.listFiles(new FileExtensionFilter())) { HashMap<String, String> song = new HashMap<String, String>(); song.put( "songTitle", file.getName().substring(0, (file.getName().length() - 4))); song.put("songPath", file.getPath()); songsList.add(song); } } return songsList; } /** * Class to filter files which have a .mp3 extension * */ class FileExtensionFilter implements FilenameFilter { @Override public boolean accept(File dir, String name) { return (name.endsWith(".mp3") || name.endsWith(".MP3")); } }
void getFiles(){ String dirPath = "E:/folder_name"; File dir = new File(dirPath); String[] files = dir.list(); if (files.length == 0) { System.out.println("The directory is empty"); } else { for (String aFile : files) { System.out.println(aFile); } } }
class MyFileUtils { public static void loadFilesForFolder(final File folder, List<String> fileList){ for (final File fileEntry : folder.listFiles()) { if (fileEntry.isDirectory()) { loadFilesForFolder(fileEntry, fileList); } else { fileList.add( fileEntry.getParent() + File.separator + fileEntry.getName() ); } } } }
import MyFileUtils; List<String> fileList = new ArrayList<String>(); final File folder = new File("/home/you/Desktop"); MyFileUtils.loadFilesForFolder(folder, fileList); for (String fileName : fileList){ System.out.println(fileName); }
ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); URL resource = contextClassLoader.getResource(""); File file = new File(resource.toURI()); File[] files = file.listFiles(); for (File f : files) { System.out.println(f.getName()); }
URL resource = contextClassLoader.getResource("res");
public static Map<String,List<File>> getFileNames(String dirName,Map<String,List<File>> filesContainer,final String fileExt){ String dirPath = dirName; List<File>files = new ArrayList<>(); Map<String,List<File>> completeFiles = filesContainer; if(completeFiles == null) { completeFiles = new HashMap<>(); } File file = new File(dirName); FileFilter fileFilter = new FileFilter() { @Override public boolean accept(File file) { boolean acceptFile = false; if(file.isDirectory()) { acceptFile = true; }else if (file.getName().toLowerCase().endsWith(fileExt)) { acceptFile = true; } return acceptFile; } }; for(File dirfile : file.listFiles(fileFilter)) { if(dirfile.isFile() && dirfile.getName().toLowerCase().endsWith(fileExt)) { files.add(dirfile); }else if(dirfile.isDirectory()) { if(!files.isEmpty()) { completeFiles.put(dirPath, files); } getFileNames(dirfile.getAbsolutePath(),completeFiles,fileExt); } } if(!files.isEmpty()) { completeFiles.put(dirPath, files); } return completeFiles; }
private static void addfiles(File inputValVal, ArrayList<File> files) { if(inputVal.isDirectory()) { ArrayList <File> path = new ArrayList<File>(Arrays.asList(inputVal.listFiles())); for(int i=0; i<path.size(); ++i) { if(path.get(i).isDirectory()) { addfiles(path.get(i),files); } if(path.get(i).isFile()) { files.add(path.get(i)); } } } if(inputVal.isFile()) { files.add(inputVal); } }
public static void main(String[] args) throws IOException{ File[] files = new File(args[0].replace("\\", "\\\\")).listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(".txt"); } }); ArrayList<String> filedir = new ArrayList<String>(); String FILE_TEST = null; for (i=0; i<files.length; i++){ filedir.add(files[i].toString()); CSV_FILE_TEST=filedir.get(i) try(Reader testreader = Files.newBufferedReader(Paths.get(FILE_TEST)); ){ }}}
package com.commandline.folder; import java.io.File; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.stream.Stream; public class FolderReadingDemo { public static void main(String[] args) { String str = args[0]; final File folder = new File(str); listFilesForFolder(str); } public static void listFilesForFolder(String str) { try (Stream<Path> paths = Files.walk(Paths.get(str))) { paths.filter(Files::isRegularFile).forEach(System.out::println); } catch (Exception e) { e.printStackTrace(); } } public static void listFilesForFolder(final File folder) { for (final File fileEntry : folder.listFiles()) { if (fileEntry.isDirectory()) { listFilesForFolder(fileEntry); } else { System.out.println(fileEntry.getName()); } } } }
public static List<File> listLocalFilesAndDirsAllLevels(File baseDir) { List<File> collectedFilesAndDirs = new ArrayList<>(); Deque<File> remainingDirs = new ArrayDeque<>(); if(baseDir.exists()) { remainingDirs.add(baseDir); while(!remainingDirs.isEmpty()) { File dir = remainingDirs.removeLast(); List<File> filesInDir = Arrays.asList(dir.listFiles()); for(File fileOrDir : filesInDir) { collectedFilesAndDirs.add(fileOrDir); if(fileOrDir.isDirectory()) { remainingDirs.add(fileOrDir); } } } } return collectedFilesAndDirs; }
public void listFilesForFolder(final File folder,List<File> fileList) { File[] filesInFolder = folder.listFiles(); if (filesInFolder != null) { for (final File fileEntry : filesInFolder) { if (fileEntry.isDirectory()) { listFilesForFolder(fileEntry,fileList); } else { fileList.add(fileEntry); } } } } List<File> fileList = new List<File>(); final File folder = new File("/home/you/Desktop"); listFilesForFolder(folder);
import java.io.File; public class Test { public void test1() { System.out.println("TEST 1"); } public static void main(String[] args) throws SecurityException, ClassNotFoundException{ File actual = new File("src"); File list[] = actual.listFiles(); for(int i=0; i<list.length; i++){ String substring = list[i].getName().substring(0, list[i].getName().indexOf(".")); if(list[i].isFile() && list[i].getName().contains(".java")){ if(Class.forName(substring).getMethods()[0].getName().contains("main")){ System.out.println("CLASS NAME "+Class.forName(substring).getName()); } } } } }
import java.applet.Applet; import java.awt.*; public class Hello extends Applet { public void paint (Graphics page) { page.drawString ("Hello World!", 50, 50); } }
root@tecadmin ~ java version "1.8.0_51" Java(TM) SE Runtime Environment (build 1.8.0_51-b16) Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)
abstract class my { public void mymethod() { System.out.print("Abstract"); } } class poly { public static void main(String a[]) { my m = new my() {}; m.mymethod(); } }
abstract class My { public void myMethod() { System.out.print("Abstract"); } }
class Poly extends My { public static void main(String a[]) { My m = new My() {}; m.myMethod(); } }
Poly$1.class, Poly$2.class, Poly$3.class, ... so on
public static final void main(final String[] args) { final my m1 = new my() { }; final my m2 = new my() { }; System.out.println(m1 == m2); System.out.println(m1.getClass().toString()); System.out.println(m2.getClass().toString()); }
abstract class my { public void mymethod() { System.out.print("Abstract"); } }
public class poly extends my { public static void main(String[] a) { my m = new poly.1(); m.mymethod(); } }
public abstract class AbstractGridManager { private LifecicleAlgorithmIntrface lifecicleAlgorithm; abstract public Grid initGrid(); public Grid calculateNextLifecicle(Grid grid){ return this.getLifecicleAlgorithm().calculateNextLifecicle(grid); } public LifecicleAlgorithmIntrface getLifecicleAlgorithm() { return lifecicleAlgorithm; } public void setLifecicleAlgorithm(LifecicleAlgorithmIntrface lifecicleAlgorithm) { this.lifecicleAlgorithm = lifecicleAlgorithm; } }
public class FileInputGridManager extends AbstractGridManager { private String filePath; abstract public Grid initGrid(); public class FileInputGridManager extends AbstractGridManager { private String filePath; abstract public Grid initGrid(); public Grid initGrid(String filePath) { List<Cell> cells = new ArrayList<>(); char[] chars; File file = new File(filePath); return grid; } }
public class GridManagerFactory { public static AbstractGridManager getGridManager(LifecicleAlgorithmIntrface lifecicleAlgorithm, String... args){ AbstractGridManager manager = null; if(args.length == 2){ CommandLineGridManager clManager = new CommandLineGridManager(); clManager.setWidth(Integer.parseInt(args[0])); clManager.setHeight(Integer.parseInt(args[1])); ... manager = clManager; } else if(args.length == 1){ FileInputGridManager fiManager = new FileInputGridManager(); fiManager.setFilePath(args[0]); ... manager = fiManager ; } else{ manager = new CommandLineGridManager(); } manager.setLifecicleAlgorithm(lifecicleAlgorithm); return manager; } }
abstract class Figure { double dim1; double dim2; Figure(double a, double b) { dim1 = a; dim2 = b; } abstract double area(); } class Rectangle extends Figure { Rectangle(double a, double b) { super(a, b); } double area() { System.out.println("Inside Area for Rectangle."); return dim1 * dim2; } } class Triangle extends Figure { Triangle(double a, double b) { super(a, b); } double area() { System.out.println("Inside Area for Triangle."); return dim1 * dim2 / 2; } } class AbstractAreas { public static void main(String args[]) { Rectangle r = new Rectangle(9, 5); Triangle t = new Triangle(10, 8); Figure figref; figref = r; System.out.println("Area is " + figref.area()); figref = t; System.out.println("Area is " + figref.area()); } }
public interface Application { public String myFunction(String abc); }
public void testMyFunction() throws Exception { Application mock = mock(Application.class); when(mock.myFunction(anyString())).thenAnswer(new Answer<String>() { @Override public String answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); return (String) args[0]; } }); assertEquals("someString",mock.myFunction("someString")); assertEquals("anotherString",mock.myFunction("anotherString")); }
import static org.mockito.Mockito.when; import static org.mockito.AdditionalAnswers.returnsFirstArg; when(myMock.myFunction(anyString())).then(returnsFirstArg());
doAnswer(returnsFirstArg()).when(myMock).myFunction(anyString());
when(myMock.myFunction(anyString()).then(i -> i.getArgumentAt(0, String.class));
public class RoomService { public Room findByName(String roomName) {...} public void persist(Room room) {...} }
RoomService roomService = mock(RoomService.class); final Map<String, Room> roomMap = new HashMap<String, Room>(); doAnswer(new Answer<Void>() { @Override public Void answer(InvocationOnMock invocation) throws Throwable { Object[] arguments = invocation.getArguments(); if (arguments != null && arguments.length > 0 && arguments[0] != null) { Room room = (Room) arguments[0]; roomMap.put(room.getName(), room); } return null; } }).when(roomService).persist(any(Room.class)); when(roomService.findByName(anyString())).thenAnswer(new Answer<Room>() { @Override public Room answer(InvocationOnMock invocation) throws Throwable { Object[] arguments = invocation.getArguments(); if (arguments != null && arguments.length > 0 && arguments[0] != null) { String key = (String) arguments[0]; if (roomMap.containsKey(key)) { return roomMap.get(key); } } return null; } });
String name = "room"; Room room = new Room(name); roomService.persist(room); assertThat(roomService.findByName(name), equalTo(room)); assertNull(roomService.findByName("none"));
public void testMyFunction() throws Exception { Application mock = mock(Application.class); when(mock.myFunction(anyString())).thenAnswer( invocation -> { Object[] args = invocation.getArguments(); return args[0]; }); assertEquals("someString", mock.myFunction("someString")); assertEquals("anotherString", mock.myFunction("anotherString")); }
public void testMyFunction() throws Exception { Application mock = mock(Application.class); when(mock.myFunction(anyString())).thenAnswer( invocation -> invocation.getArgument(0)); assertEquals("someString", mock.myFunction("someString")); assertEquals("anotherString", mock.myFunction("anotherString")); }
private Hashtable<InputObject, OutputObject> table = new Hashtable<InputObject, OutputObject>(); table.put(input1, ouput1); table.put(input2, ouput2); ... when(mockObject.method(any(InputObject.class))).thenAnswer( new Answer<OutputObject>() { @Override public OutputObject answer(final InvocationOnMock invocation) throws Throwable { InputObject input = (InputObject) invocation.getArguments()[0]; if (table.containsKey(input)) { return table.get(input); } else { return null; } } } );
ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class); verify(mock).myFunction(argument.capture()); assertEquals("the expected value here", argument.getValue());
for (int i = 10; i >= 0; i--) { long l = Double.doubleToLongBits(i + 0.5); double x; do { x = Double.longBitsToDouble(l); System.out.println(x + " rounded is " + Math.round(x)); l--; } while (Math.round(x) > i); }
10.5 rounded is 11 10.499999999999998 rounded is 10 9.5 rounded is 10 9.499999999999998 rounded is 9 8.5 rounded is 9 8.499999999999998 rounded is 8 7.5 rounded is 8 7.499999999999999 rounded is 7 6.5 rounded is 7 6.499999999999999 rounded is 6 5.5 rounded is 6 5.499999999999999 rounded is 5 4.5 rounded is 5 4.499999999999999 rounded is 4 3.5 rounded is 4 3.4999999999999996 rounded is 3 2.5 rounded is 3 2.4999999999999996 rounded is 2 1.5 rounded is 2 1.4999999999999998 rounded is 1 0.5 rounded is 1 0.49999999999999994 rounded is 1 0.4999999999999999 rounded is 0
static void print(double d) { System.out.printf("%016x\n", Double.doubleToLongBits(d)); } public static void main(String args[]) { double a = 0.5; double b = 0.49999999999999994; print(a); print(b); print(a+b); print(1.0); }
public static long round(double a) { if (a != 0x1.fffffffffffffp-2) return (long)floor(a + 0.5d); else return 0; }
public static long round(double a) { return (long)Math.floor(a + 0.5d); }
public static long round(double a) { if (a != 0x1.fffffffffffffp-2) { return (long)Math.floor(a + 0.5d); } else { return 0; } }
10.5 rounded is 11 10.499999999999998 rounded is 10 9.5 rounded is 10 9.499999999999998 rounded is 9 8.5 rounded is 9 8.499999999999998 rounded is 8 7.5 rounded is 8 7.499999999999999 rounded is 7 6.5 rounded is 7 6.499999999999999 rounded is 6 5.5 rounded is 6 5.499999999999999 rounded is 5 4.5 rounded is 5 4.499999999999999 rounded is 4 3.5 rounded is 4 3.4999999999999996 rounded is 3 2.5 rounded is 3 2.4999999999999996 rounded is 2 1.5 rounded is 2 1.4999999999999998 rounded is 1 0.5 rounded is 1 0.49999999999999994 rounded is 0
System.out.println("Enter numerical value"); int option; option = input.nextInt(); System.out.println("Enter 1st string"); String string1 = input.nextLine(); System.out.println("Enter 2nd string"); String string2 = input.nextLine();
Enter numerical value 3 Enter 1st string Enter 2nd string
int option = input.nextInt(); input.nextLine(); String str1 = input.nextLine();
int option = 0; try { option = Integer.parseInt(input.nextLine()); } catch (NumberFormatException e) { e.printStackTrace(); } String str1 = input.nextLine();
System.out.print("Insert a number: "); int number = input.nextInt(); input.nextLine(); System.out.print("Text1: "); String text1 = input.nextLine(); System.out.print("Text2: "); String text2 = input.nextLine();
int num1 = sc.nextInt(); int num2 = sc.nextInt(); String name = sc.next();
public static Scanner input = new Scanner(System.in); public static void main(String[] args) { System.out.print("Insert a number: "); int number = input.nextInt(); System.out.print("Text1: "); String text1 = input.next(); System.out.print("Text2: "); String text2 = input.next(); }
Scanner scanner = new Scanner(System.in); int option = scanner.nextInt(); scanner.nextLine();
class ScanReader { /** * @author Nikunj Khokhar */ private byte[] buf = new byte[4 * 1024]; private int index; private BufferedInputStream in; private int total; public ScanReader(InputStream inputStream) { in = new BufferedInputStream(inputStream); } private int scan() throws IOException { if (index >= total) { index = 0; total = in.read(buf); if (total <= 0) return -1; } return buf[index++]; } public char scanChar(){ int c=scan(); while (isWhiteSpace(c))c=scan(); return (char)c; } public int scanInt() throws IOException { int integer = 0; int n = scan(); while (isWhiteSpace(n)) n = scan(); int neg = 1; if (n == neg = -1; n = scan(); } while (!isWhiteSpace(n)) { if (n >= integer *= 10; integer += n - n = scan(); } } return neg * integer; } public String scanString() throws IOException { int c = scan(); while (isWhiteSpace(c)) c = scan(); StringBuilder res = new StringBuilder(); do { res.appendCodePoint(c); c = scan(); } while (!isWhiteSpace(c)); return res.toString(); } private boolean isWhiteSpace(int n) { if (n == else return false; } public long scanLong() throws IOException { long integer = 0; int n = scan(); while (isWhiteSpace(n)) n = scan(); int neg = 1; if (n == neg = -1; n = scan(); } while (!isWhiteSpace(n)) { if (n >= integer *= 10; integer += n - n = scan(); } } return neg * integer; } public void scanLong(long[] A) throws IOException { for (int i = 0; i < A.length; i++) A[i] = scanLong(); } public void scanInt(int[] A) throws IOException { for (int i = 0; i < A.length; i++) A[i] = scanInt(); } public double scanDouble() throws IOException { int c = scan(); while (isWhiteSpace(c)) c = scan(); int sgn = 1; if (c == sgn = -1; c = scan(); } double res = 0; while (!isWhiteSpace(c) && c != if (c == return res * Math.pow(10, scanInt()); } res *= 10; res += c - c = scan(); } if (c == c = scan(); double m = 1; while (!isWhiteSpace(c)) { if (c == return res * Math.pow(10, scanInt()); } m /= 10; res += (c - c = scan(); } } return res * sgn; } }
import java.io.BufferedInputStream; import java.io.IOException; import java.io.InputStream; class Main{ public static void main(String... as) throws IOException{ ScanReader sc = new ScanReader(System.in); int a=sc.scanInt(); System.out.println(a); } } class ScanReader....
Scanner stringScanner = new Scanner(System.in); Scanner intScanner = new Scanner(System.in); intScanner.nextInt(); String s = stringScanner.nextLine(); System.out.println(s); intScanner.close(); stringScanner.close();
int firstNumber = input.nextInt(); int secondNumber = input.nextInt();
public static void main(String[] args) { Scanner scan = new Scanner(System.in); int i = scan.nextInt(); scan.nextLine(); double d = scan.nextDouble(); scan.nextLine(); String s = scan.nextLine(); System.out.println("String: " + s); System.out.println("Double: " + d); System.out.println("Int: " + i); }
Scanner input = new Scanner(System.in); System.out.println("Enter numerical value"); int option; Scanner input2 = new Scanner(System.in); option = input2.nextInt();
HashMap<String, String> getItems(javax.servlet.http.HttpSession session) { HashMap<String, String> theHash = (HashMap<String, String>)session.getAttribute("attributeKey"); return theHash; }
HashMap getItems(javax.servlet.http.HttpSession session) { HashMap theHash = (HashMap)session.getAttribute("attributeKey"); return theHash; }
HashMap items = getItems(session); items.put("this", "that"); Type safety: The method put(Object, Object) belongs to the raw type HashMap. References to generic type HashMap<K,V> should be parameterized.
@SuppressWarnings("unchecked") Map<String, String> myMap = (Map<String, String>) deserializeMap();
@SuppressWarnings("unchecked") Map<String, Number> map = getMap(); for (String s : map.keySet()); for (Number n : map.values());
public static <K, V> HashMap<K, V> castHash(HashMap input, Class<K> keyClass, Class<V> valueClass) { HashMap<K, V> output = new HashMap<K, V>(); if (input == null) return output; for (Object key: input.keySet().toArray()) { if ((key == null) || (keyClass.isAssignableFrom(key.getClass()))) { Object value = input.get(key); if ((value == null) || (valueClass.isAssignableFrom(value.getClass()))) { K k = keyClass.cast(key); V v = valueClass.cast(value); output.put(k, v); } else { throw new AssertionError( "Cannot cast to HashMap<"+ keyClass.getSimpleName() +", "+ valueClass.getSimpleName() +">" +", value "+ value +" is not a "+ valueClass.getSimpleName() ); } } else { throw new AssertionError( "Cannot cast to HashMap<"+ keyClass.getSimpleName() +", "+ valueClass.getSimpleName() +">" +", key "+ key +" is not a " + keyClass.getSimpleName() ); } } return output; }
public class Objects { /** * Helps to avoid using {@code @SuppressWarnings({"unchecked"})} when casting to a generic type. */ @SuppressWarnings({"unchecked"}) public static <T> T uncheckedCast(Object obj) { return (T) obj; } }
import static Objects.uncheckedCast; ... HashMap<String, String> getItems(javax.servlet.http.HttpSession session) { return uncheckedCast(session.getAttribute("attributeKey")); }
import java.util.AbstractMap; import java.util.Collection; import java.util.HashMap; import java.util.Map; import java.util.Set; public class Attributes extends AbstractMap<String, String> { final Map<String, String> content = new HashMap<String, String>(); @Override public Set<Map.Entry<String, String>> entrySet() { return content.entrySet(); } @Override public Set<String> keySet() { return content.keySet(); } @Override public Collection<String> values() { return content.values(); } @Override public String put(final String key, final String value) { return content.put(key, value); } }
public void dragFinished(StructuredViewer structuredViewer, Class<T> inputElementClazz) { IStructuredSelection selection = (IStructuredSelection) structuredViewer.getSelection(); T firstElement = inputElementClazz.cast(selection.getFirstElement()); Collection<?> unknownTypeCollection = (Collection<?>) structuredViewer.getInput(); unknownTypeCollection.remove(firstElement); Collection<T> knownTypeCollection = new ArrayList<T>(); for (Object object : unknownTypeCollection) { T aT = inputElementClazz.cast(object); knownTypeCollection.add(aT); System.out.println(aT.getClass()); } structuredViewer.refresh(); }
dragFinishedStrategy.dragFinished(viewer, Product.class);
public static void main(String[] args) { Map<String, Integer> map = new HashMap<String, Integer>(); map.put("a", 1); map.put("b", 2); Object obj = map; Map<String, Integer> ok = safeCastMap(obj, String.class, Integer.class); Map<String, String> error = safeCastMap(obj, String.class, String.class); } @SuppressWarnings({"unchecked"}) public static <K, V> Map<K, V> safeCastMap(Object map, Class<K> keyType, Class<V> valueType) { checkMap(map); checkMapContents(keyType, valueType, (Map<?, ?>) map); return (Map<K, V>) map; } private static void checkMap(Object map) { checkType(Map.class, map); } private static <K, V> void checkMapContents(Class<K> keyType, Class<V> valueType, Map<?, ?> map) { for (Map.Entry<?, ?> entry : map.entrySet()) { checkType(keyType, entry.getKey()); checkType(valueType, entry.getValue()); } } private static <K> void checkType(Class<K> expectedType, Object obj) { if (!expectedType.isInstance(obj)) { throw new IllegalArgumentException("Expected " + expectedType + " but was " + obj.getClass() + ": " + obj); } }
Map<String, String> myMap = (Map<String, String>) deserializeMap();
@SuppressWarnings("unchecked") Vector<String> watchedSymbolsClone = (Vector<String>) watchedSymbols.clone(); this.watchedSymbols = watchedSymbolsClone;
this.watchedSymbols = Objects.uncheckedCast(watchedSymbols.clone());
ArrayList<Integer> intList = new ArrayList<Integer>(); intList.add(1); Object intListObject = intList; ArrayList<String> stringList = (ArrayList<String>) intListObject; System.out.println(stringList.get(0));
HashMap<String, String> getItems(javax.servlet.http.HttpSession session) { HashMap<?, ?> theHash = (HashMap<?, ?>)session.getAttribute("attributeKey"); HashMap<String, String> returingHash = new HashMap<>(); for (Entry<?, ?> entry : theHash.entrySet()) { returingHash.put((String) entry.getKey(), (String) entry.getValue()); } return returingHash; }
HashMap<String, Object> test = new HashMap<String, Object>();
@SuppressWarnings("unchecked") public static <K, V> HashMap<K, V> toHashMap(Object input, Class<K> key, Class<V> value) { assert input instanceof Map : input; for (Map.Entry<?, ?> e : ((HashMap<?, ?>) input).entrySet()) { assert key.isAssignableFrom(e.getKey().getClass()) : "Map contains invalid keys"; assert value.isAssignableFrom(e.getValue().getClass()) : "Map contains invalid values"; } if (input instanceof HashMap) return (HashMap<K, V>) input; return new HashMap<K, V>((Map<K, V>) input); }
Object someObject = session.getAttribute("attributeKey"); if(someObject instanceof HashMap) HashMap<String, String> theHash = (HashMap<String, String>)someObject;
public final class Items implements java.io.Serializable { private static final long serialVersionUID = 1L; private Map<String,String> map; public Items(Map<String,String> map) { this.map = New.immutableMap(map); } public Map<String,String> getMap() { return map; } @Override public String toString() { return map.toString(); } } public final class New { public static <K,V> Map<K,V> immutableMap( Map<? extends K, ? extends V> original ) { return Collections.unmodifiableMap( new HashMap<String,String>(original) ); } } static Map<String, String> getItems(HttpSession session) { Items items = (Items) session.getAttribute("attributeKey"); return items.getMap(); }
public abstract class Section<T extends Section> extends Element<Section<T>> { Object attr1; /** * Compare one section object to another. * * @param obj the object being compared with this section object * @return true if this section and the other section are of the same * sub-class of section and their component fields are the same, false * otherwise */ @Override public boolean equals(Object obj) { if (obj == null) { return false; } Section<?> other; if (getClass() != obj.getClass()) { return false; } else { other = (Section<?>) obj; } return this.attr1.equals(other.attr1); } }
... = (HashMap<String, String>)session.getAttribute("attributeKey");
HashMap<?,?> getItems(javax.servlet.http.HttpSession session) { HashMap<?,?> theHash = (HashMap<?,?>)session.getAttribute("attributeKey"); return theHash; }
package scratchpad; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Vector; public class YellowMouse { Map<String, String> getHashMapStudiouslyAvoidingSuppressTag(HttpSession session) { Map<?, ?> theHash = (Map<?, ?>)session.getAttribute("attributeKey"); Map<String, String> yellowMouse = new HashMap<String, String>(); for( Map.Entry<?, ?> entry : theHash.entrySet() ){ yellowMouse.put( (String)entry.getKey(), (String)entry.getValue() ); } return yellowMouse; } Map<String, String> getHashMapUsingNaughtyButNiceUtilityMethod(HttpSession session) { return uncheckedCast( session.getAttribute("attributeKey") ); } @SuppressWarnings({ "unchecked" }) public static synchronized <T> T uncheckedCast(Object obj) { return (T) obj; } }
static Map<String, String> getItems(HttpSession session) { HashMap<?, ?> theHash1 = (HashMap<String,String>)session.getAttribute("attributeKey"); HashMap<String,String> theHash = (HashMap<String,String>)theHash1; return theHash; }
List<String> names = .... for (String name : names) { names.remove(name). }
List<String> names = .... for (String name : names) { while (names.remove(name)); }
List<String> names = .... Iterator<String> i = names.iterator(); while (i.hasNext()) { String s = i.next(); i.remove(); }
List<String> names = .... Iterator<String> it = names.iterator(); while (it.hasNext()) { String name = it.next(); it.remove(); }
for(Iterator<String> i = names.iterator(); i.hasNext();) { String name = i.next(); i.remove(); }
for (String name : new ArrayList<String>(names)) { names.remove(nameToRemove); }
List<String> names = .... for (i=names.size()-1;i>=0;i--) { names.remove(i); }
List<String> names = .... List<String> toRemove= new ArrayList<String>(); for (String name : names) { toRemove.add(name); } names.removeAll(toRemove);
List<String> names = .... List<String> reducedNames = .... for (String name : names) { if (conditionToIncludeMet) reducedNames.add(name); } return reducedNames;
List<Service> services = ... for (int i=0; i<services.size(); i++) { if (!isServicePermitted(user, services.get(i))) services.remove(i); }
List<Service> services = ... List<Service> permittedServices = ... for (Service service:services) { if (isServicePermitted(user, service)) permittedServices.add(service); } return permittedServices;
public static void main(String[] args) { Season.add("Frhling"); Season.add("Sommer"); Season.add("Herbst"); Season.add("WINTER"); for (String s : Season) { if(!s.equals("Sommer")) { System.out.println(s); continue; } Season.remove("Frhling"); } }
if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null;
public Foo acquireFoo(int id) { Foo result = null; if (id > 50) { result = fooService.read(id); } else { result = new Foo(id); } assert result != null; return result; }
int sum(int a, int b) { assert (Integer.MAX_VALUE - a >= b) : "Value of " + a + " + " + b + " is too large to add."; final int result = a + b; assert (result - a == b) : "Sum of " + a + " + " + b + " returned wrong sum " + result; return result; }
void doSomething(Widget widget) { if (widget != null) { widget.someMethod(); ... } }
/** * @param Widget widget Should never be null */ void doSomething(Widget widget) { assert widget != null; widget.someMethod(); ... }
void doSomething(Widget widget) { assert widget != null; if (widget != null) { widget.someMethod(); ... } }
/** * Compare two values using equals(), after checking for null. * @param thisValue (may be null) * @param otherValue (may be null) * @return True if they are both null or if equals() returns true */ public static boolean compare(final Object thisValue, final Object otherValue) { boolean result; if (thisValue == null) { result = otherValue == null; } else { result = thisValue.equals(otherValue); } return result; }
public static boolean compare(final Object thisValue, final Object otherValue) { boolean result; if (thisValue == null) { result = otherValue == null; } else { result = otherValue != null && thisValue.equals(otherValue); } return result; }
public static boolean compare(final Object thisValue, final Object otherValue) { boolean result; if (thisValue == null) { result = otherValue == null; assert otherValue == null || otherValue.equals(null) == false; } else { result = otherValue != null && thisValue.equals(otherValue); assert thisValue.equals(null) == false; } return result; }
switch (fruit) { case apple: break; case pear: break; case banana: break; }
switch (fruit) { case apple: break; case pear: break; case banana: break; default: assert false : "Missing enum value: " + fruit; }
public class Assert { public static void main(String[] args) { assert System.currentTimeMillis() == 0L; } }
public class Assert { static final boolean $assertionsDisabled = !Assert.class.desiredAssertionStatus(); public static void main(String[] args) { if (!$assertionsDisabled) { if (System.currentTimeMillis() != 0L) { throw new AssertionError(); } } } }
javac Assert.java javap -c -constants -private -verbose Assert.class
static final boolean $assertionsDisabled; descriptor: Z flags: ACC_STATIC, ACC_FINAL, ACC_SYNTHETIC
0: ldc 2: invokevirtual 5: ifne 12 8: iconst_1 9: goto 13 12: iconst_0 13: putstatic 16: return
0: getstatic 3: ifne 22 6: invokestatic 9: lconst_0 10: lcmp 11: ifeq 22 14: new 17: dup 18: invokespecial 21: athrow 22: return
public int pop() { assert !isEmpty() : "Stack is empty"; return stack[--num]; }
assert boolean_expression; assert boolean_expression: error_message;
... if (i == 1) { ... } else if (i == 2) { ... } else { assert false : "cannot happen. i is " + i; } ...
public boolean doSomething() { ... } public void someMethod() { assert doSomething(); }
boolean enabled = false; assert enabled = true; if (enabled) { System.out.println("Assertions are enabled"); } else { System.out.println("Assertions are disabled"); }
assert new HashSet<String>(Arrays.asList("Y", "N", null)).contains(value) : value;
assert value == null || value.equals("Y") || value.equals("N") : value;
public static void main(String[] args) { String s1 = "Hello"; assert checkInteger(s1); } private static boolean checkInteger(String s) { try { Integer.parseInt(s); return true; } catch(Exception e) { return false; } }
public class MyClass { public MyClass(int x) {} } public class MySubClass extends MyClass { public MySubClass(int a, int b) { int c = a + b; super(c); } }
public class MySubClass extends MyClass { public MySubClass(int a, int b) { super(a + b); } }
public class MyClass { public MyClass(List list) {} } public class MySubClassA extends MyClass { public MySubClassA(Object item) { List list = new ArrayList(); list.add(item); super(list); } } public class MySubClassB extends MyClass { public MySubClassB(Object item) { super(Arrays.asList(new Object[] { item })); } }
public MySubClassB extends MyClass { public MySubClassB(Object[] myArray) { super(myArray); } }
public MySubClassB extends MyClass { public MySubClassB(Object[] myArray) { someMethodOnSuper(); super(myArray); } }
public class Foo extends Baz { private final Bar myBar; public Foo(String arg1, String arg2) { final Bar b = new Bar(arg1, arg2); super(b.baz()): myBar = b; } }
public class Foo extends Baz { private final Bar myBar; private static Bar makeBar(String arg1, String arg2) { return new Bar(arg1, arg2); } public Foo(String arg1, String arg2) { this(makeBar(arg1, arg2)); } private Foo(Bar bar) { super(bar.baz()); myBar = bar; } }
class Thing { final int x; Thing(int x) { this.x = x; } } class Bad1 extends Thing { final int z; Bad1(int x, int y) { this.z = this.x + this.y; super(x); } } class Bad2 extends Thing { final int y; Bad2(int x, int y) { this.x = 33; this.y = y; super(x); } }
MySubClass: MyClass { public: MySubClass(int a, int b): MyClass(a+b) { } };
public class MySubClassC extends MyClass { public MySubClassC(Object item) { super(createList(item)); } private static List createList(item) { List list = new ArrayList(); list.add(item); return list; } }
class Sup { public Sup(final int x_) { } public Sup(final Sup sup_) { } } class Sub extends Sup { private int x; public Sub(final Sub aSub) { /* for aSub with aSub.x == 0, * the expensive copy constructor is unnecessary: */ /* if (aSub.x == 0) { * super(0); * } else { * super(aSub); * } * above gives error since if-construct before super() is not allowed. */ /* super((aSub.x == 0) ? 0 : aSub); * above gives error since the ?-operator */ super(aSub); } }
public class Test { public static void main(String[] args) { new Child(); } } class Parent { public Parent() { System.out.println("In parent"); } } class Child extends Parent { { System.out.println("In initializer"); } public Child() { super(); System.out.println("In child"); } }
public class MySubClass extends MyClass { public MySubClass(int a, int b) { int c = a + b; super(c); doSomething(c); doSomething2(a); doSomething3(b); } }
public class MySubClass extends MyClass { public MySubClass(int a, int b) { this(a + b); doSomething2(a); doSomething3(b); } private MySubClass(int c) { super(c); doSomething(c); } }
class A { A() { System.out.println("Inside A } } class B extends A { B() { System.out.println("Inside B } } class C extends B { C() { System.out.println("Inside C } } class CallingCons { public static void main(String args[]) { C c = new C(); } }
class Good { int essential1; int essential2; Good(int n) { if (n > 100) throw new IllegalArgumentException("n is too large!"); essential1 = 1 / n; essential2 = n + 2; } } class Bad extends Good { Bad(int n) { try { super(n); } catch (Exception e) { } } public static void main(String[] args) { Bad b = new Bad(0); System.out.println(b.essential1 + b.essential2); } }
class Bad extends Good { Bad(int n) { for (int i = 0; i < n; i++) super(i); } }
public int get() { int x; for (int i = 0; i < 10; i++) x = i; return x; } public int get(int y) { int x; if (y > 0) x = y; return x; } public int get(boolean b) { int x; try { x = 1; } catch (Exception e) { } return x; }
super(new InfoRunnable<ThingToPass>() { public ThingToPass run(Object... args) { } }.run( ));
public class Child extends Parent { public Child(T1 _1, T2 _2, T3 _3) { Statement_1(); Statement_2(); Statement_3(); Statement_9(); super(_1, _2, _3); } }
public class Child extends Parent { public Child(T1 _1, T2 _2, T3 _3) { super(F(_1), _2, _3); } public static T1 F(T1 _1) { Statement_1(); Statement_2(); Statement_3(); Statement_9(); return _1; } }
public class Child extends Parent { public Child(int i, String s, T1 t1) { i = i * 10 - 123; if (s.length() > i) { s = "This is substr s: " + s.substring(0, 5); } else { s = "Asdfg"; } t1.Set(i); T2 t2 = t1.Get(); t2.F(); Object obj = Static_Class.A_Static_Method(i, s, t1); super(obj, i, "some argument", s, t1, t2); } }
public class Child extends Parent { public Child(int i, String s, T1 t1) { super(Arg1(i, s, t1), Arg2(i), "some argument", Arg4(i, s), t1, Arg6(i, t1)); } private static Object Arg1(int i, String s, T1 t1) { i = Arg2(i); s = Arg4(s); return Static_Class.A_Static_Method(i, s, t1); } private static int Arg2(int i) { i = i * 10 - 123; return i; } private static String Arg4(int i, String s) { i = Arg2(i); if (s.length() > i) { s = "This is sub s: " + s.substring(0, 5); } else { s = "Asdfg"; } return s; } private static T2 Arg6(int i, T1 t1) { i = Arg2(i); t1.Set(i); T2 t2 = t1.Get(); t2.F(); return t2; } }
public MyClass { public MyClass(String someArg) { System.out.println(someArg); } }
public MyClass extends Object{ public MyClass(String someArg) { super(); System.out.println(someArg); } }
public MyClass extends Object{ public MyClass(int a) { super(); System.out.println(a); } public MyClass(int a, int b) { this(a); System.out.println(b); } }
public MyClass(int a, SomeObject someObject) { this(someObject.add(a+5)); }
public MyClass extends Object{ public MyClass(int a) { } public MyClass(int a, int b) { this(add(a, b)); } public int add(int a, int b){ return a+b; } }
public MyClass{ public MyClass(int a) { this(a, 5); } public MyClass(int a, int b) { this(a); } }
private final static char[] hexArray = "0123456789ABCDEF".toCharArray(); public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for ( int j = 0; j < bytes.length; j++ ) { int v = bytes[j] & 0xFF; hexChars[j * 2] = hexArray[v >>> 4]; hexChars[j * 2 + 1] = hexArray[v & 0x0F]; } return new String(hexChars); }
import org.apache.commons.codec.binary.Hex; String foo = "I am a string"; byte[] bytes = foo.getBytes(); System.out.println( Hex.encodeHexString( bytes ) );
byte bytes[] = {(byte)0, (byte)0, (byte)134, (byte)0, (byte)61}; System.out.println(javax.xml.bind.DatatypeConverter.printHexBinary(bytes));
public static String byteArrayToHex(byte[] a) { StringBuilder sb = new StringBuilder(a.length * 2); for(byte b: a) sb.append(String.format("%02x", b)); return sb.toString(); }
import com.google.common.io.BaseEncoding; ... byte[] bytes = "Hello world".getBytes(StandardCharsets.UTF_8); final String hex = BaseEncoding.base16().lowerCase().encode(bytes);
static final String HEXES = "0123456789ABCDEF"; public static String getHex( byte [] raw ) { if ( raw == null ) { return null; } final StringBuilder hex = new StringBuilder( 2 * raw.length ); for ( final byte b : raw ) { hex.append(HEXES.charAt((b & 0xF0) >> 4)) .append(HEXES.charAt((b & 0x0F))); } return hex.toString(); }
private static final char[] BYTE2HEX=( "000102030405060708090A0B0C0D0E0F"+ "101112131415161718191A1B1C1D1E1F"+ "202122232425262728292A2B2C2D2E2F"+ "303132333435363738393A3B3C3D3E3F"+ "404142434445464748494A4B4C4D4E4F"+ "505152535455565758595A5B5C5D5E5F"+ "606162636465666768696A6B6C6D6E6F"+ "707172737475767778797A7B7C7D7E7F"+ "808182838485868788898A8B8C8D8E8F"+ "909192939495969798999A9B9C9D9E9F"+ "A0A1A2A3A4A5A6A7A8A9AAABACADAEAF"+ "B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF"+ "C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF"+ "D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF"+ "E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF"+ "F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF").toCharArray(); ; public static String getHexString(byte[] bytes) { final int len=bytes.length; final char[] chars=new char[len<<1]; int hexIndex; int idx=0; int ofs=0; while (ofs<len) { hexIndex=(bytes[ofs++] & 0xFF)<<1; chars[idx++]=BYTE2HEX[hexIndex++]; chars[idx++]=BYTE2HEX[hexIndex]; } return new String(chars); }
md5sum = String.format("%032x", new BigInteger(1, md.digest()));
String byteToHex(final byte[] hash) { Formatter formatter = new Formatter(); for (byte b : hash) { formatter.format("%02x", b); } String result = formatter.toString(); formatter.close(); return result; }
final protected static char[] hexArray = "0123456789ABCDEF".toCharArray(); public static String bytesToHex(byte[] bytes, int offset, int count) { char[] hexChars = new char[count * 2]; for ( int j = 0; j < count; j++ ) { int v = bytes[j+offset] & 0xFF; hexChars[j * 2] = hexArray[v >>> 4]; hexChars[j * 2 + 1] = hexArray[v & 0x0F]; } return new String(hexChars); }
private static String digits = "0123456789abcdef"; public static String toHex(byte[] data){ StringBuffer buf = new StringBuffer(); for (int i = 0; i != data.length; i++) { int v = data[i] & 0xff; buf.append(digits.charAt(v >> 4)); buf.append(digits.charAt(v & 0xf)); } return buf.toString(); }
final static char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray(); final static char BUNDLE_SEP = public static String bytesToHexString(byte[] bytes, int bundleSize ]) { char[] hexChars = new char[(bytes.length * 2) + (bytes.length / bundleSize)]; for (int j = 0, k = 1; j < bytes.length; j++, k++) { int v = bytes[j] & 0xFF; int start = (j * 2) + j/bundleSize; hexChars[start] = HEX_ARRAY[v >>> 4]; hexChars[start + 1] = HEX_ARRAY[v & 0x0F]; if ((k % bundleSize) == 0) { hexChars[start + 2] = BUNDLE_SEP; } } return new String(hexChars).trim(); }
bytesToHexString("..DOOM..".toCharArray().getBytes(), 2); 2E2E 444F 4F4D 2E2E bytesToHexString("..DOOM..".toCharArray().getBytes(), 4); 2E2E444F 4F4D2E2E
import java.math.BigInteger; import static java.lang.System.out; public final class App2 { public static String encode(byte[] bytes) { final int length = bytes.length; if (length == 0) { return "00"; } final int evenLength = (int)(2 * Math.ceil(length / 2.0)); final String format = "%0" + evenLength + "x"; final String result = String.format (format, new BigInteger(bytes)); return result; } public static void main(String[] args) throws Exception { out.println(encode(new byte[] {})); out.println(encode(new byte[] {1})); out.println(encode(new byte[] {0x20, 0x30, 0x40})); out.println(encode("All your base are belong to us.".getBytes())); } }
public static String encode(byte[] bytes) { final int length = bytes.length; if (length == 0) { return "00"; } return new BigInteger(bytes).toString(16); }
public static String getHexString (String s) { byte[] buf = s.getBytes(); StringBuffer sb = new StringBuffer(); for (byte b:buf) { sb.append(String.format("%x", b)); } return sb.toString(); }
class ByteArray: @classmethod def char(cls, args=[]): cls.hexArray = "0123456789ABCDEF".encode( j = 0 length = (cls.hexArray) if j < length: v = j & 0xFF hexChars = [None, None] hexChars[j * 2] = str( cls.hexArray) + str(v) hexChars[j * 2 + 1] = str(cls.hexArray) + str(v) + str(0x0F) return str(hexChars) array = ByteArray() print array.char(args=[])
public static byte[] hexStringToByteArray(String s) { int len = s.length(); byte[] data = new byte[len / 2]; for (int i = 0; i < len; i += 2) { data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16)); } return data; }
public class Base16 { public static class Encoder{ private static char[] toLowerHex={ private static char[] toUpperHex={ private boolean upper; public Encoder(boolean upper) { this.upper=upper; } public String encode(byte[] data){ char[] value=new char[data.length*2]; char[] toHex=upper?toUpperHex:toLowerHex; for(int i=0,j=0;i<data.length;i++){ int octet=data[i]&0xFF; value[j++]=toHex[octet>>4]; value[j++]=toHex[octet&0xF]; } return new String(value); } static final Encoder LOWER=new Encoder(false); static final Encoder UPPER=new Encoder(true); } public static Encoder getEncoder(){ return Encoder.LOWER; } public static Encoder getUpperEncoder(){ return Encoder.UPPER; } }
private static String bytesToHexString(byte[] bytes, int length) { if (bytes == null || length == 0) return null; StringBuilder ret = new StringBuilder(2*length); for (int i = 0 ; i < length ; i++) { int b; b = 0x0f & (bytes[i] >> 4); ret.append("0123456789abcdef".charAt(b)); b = 0x0f & bytes[i]; ret.append("0123456789abcdef".charAt(b)); } return ret.toString(); }
public static String bytesToHex(final byte[] bytes) { final int numBytes = bytes.length; final char[] container = new char[numBytes * 2]; for (int i = 0; i < numBytes; i++) { final int b = bytes[i] & 0xFF; container[i * 2] = Character.forDigit(b >>> 4, 0x10); container[i * 2 + 1] = Character.forDigit(b & 0xF, 0x10); } return new String(container); }
public static String getCurrentTimeStamp() { SimpleDateFormat sdfDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date now = new Date(); String strDate = sdfDate.format(now); return strDate; }
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
public String getCurrentTimeStamp() { return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date()); }
public String getCurrentLocalDateTimeStamp() { return LocalDateTime.now() .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")); }
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss.SSS"); Date date = new Date(); System.out.println(dateFormat.format(date));
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss"); Calendar cal = Calendar.getInstance(); System.out.println(dateFormat.format(cal.getTime()));
ZonedDateTime.now( ZoneId.of( "America/Montreal" ) ).format( DateTimeFormatter.ISO_LOCAL_DATE_TIME ) .replace( "T" , " " )
Instant instant2 = instant.truncatedTo( ChronoUnit.MILLIS ) ;
Instant instant = Instant.now (); String output = instant.toString ();
String output = instant.toString ().replace ( "T" , " " ).replace( "Z" , "" ;
String output = LocalDateTime.now ( ).toString ().replace ( "T", " " );
System.out.println( "Now: " + new DateTime ( DateTimeZone.UTC ) );
int millisOfSecond = myDateTime.getMillisOfSecond ();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
LocalDateTime.now() .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
Calendar calendar = Calendar.getInstance(); long longValue = calendar.getTimeInMillis(); LocalDateTime date = LocalDateTime.ofInstant(Instant.ofEpochMilli(longValue), ZoneId.systemDefault()); String formattedString = date.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")); System.out.println(date.toString()); System.out.println(formattedString);
Date date = new Date(); long longValue2 = date.getTime(); LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(longValue2), ZoneId.systemDefault()); String formattedString = dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")); System.out.println(dateTime.toString()); System.out.println(formattedString);
LocalDateTime date = LocalDateTime.ofInstant(Instant.ofEpochMilli(epochLongValue), ZoneId.systemDefault());
import java.text.SimpleDateFormat; import java.util.Date; public class test { public static void main(String argv[]){ SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); Date now = new Date(); String strDate = sdf.format(now); System.out.println(strDate); } }
String date = String.valueOf(android.text.format.DateFormat.format("dd-MM-yyyy", new java.util.Date()));
DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); System.out.print(dateFormat.format(System.currentTimeMillis())); }
abstract class foo { abstract void bar( ); abstract static void bar2(); }
public class Main { public static void main(String[] args) { Request.setRequest(new RequestImplementationOther()); Request.doSomething(); } public static final class RequestImplementationDefault extends Request { @Override void doSomethingImpl() { System.out.println("I am doing something AAAAAA"); } } public static final class RequestImplementaionOther extends Request { @Override void doSomethingImpl() { System.out.println("I am doing something BBBBBB"); } } public static abstract class Request { abstract void doSomethingImpl(); public static void doSomething() { getRequest().doSomethingImpl(); } private static Request request; private static Request getRequest() { if ( request == null ) { return request = new RequestImplementationDefault(); } return request; } public static Request setRequest(Request r){ return request = r; } } }
import java.io.IOException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; /** * @author Mo. Joseph * @date 16 mar 2012 **/ public abstract class Core { private static Core singleton; private static Core getInstance() { if ( singleton == null ) setInstance( new Core.CoreDefaultImpl() ); return singleton; } public static void setInstance(Core core) { Core.singleton = core; } public static HttpServletRequest getRequest() { return getInstance().getRequestImpl(); } protected abstract HttpServletRequest getRequestImpl(); /** Static inner class CoreDefaultImpl */ public static class CoreDefaultImpl extends Core { protected HttpServletRequest getRequestImpl() { return ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); } } /** Static inner class CoreTestImpl : Alternative implementation */ public static class CoreTestImpl extends Core { protected HttpServletRequest getRequestImpl() { return new MockedRequest(); } } }
class C1 { static void doWork() { ... for (int k: list) doMoreWork(k); ... } private static void doMoreWork(int k) { } } class C2 { static void doWork() { ... for (int k: list) doMoreWork(k); ... } private static void doMoreWork(int k) { } }
abstract class C { static void doWork() { ... for (int k: list) doMoreWork(k); ... } static abstract void doMoreWork(int k); } class C1 extends C { private static void doMoreWork(int k) { } } class C2 extends C { private static void doMoreWork(int k) { } }
abstract class C { void doWork() { ... for (int k: list) doMoreWork(k); ... } abstract void doMoreWork(int k); } class C1 { private static final C c = new C(){ @Override void doMoreWork(int k) { System.out.println("code for C1"); } }; public static void doWork() { c.doWork(); } } class C2 { private static final C c = new C() { @Override void doMoreWork(int k) { System.out.println("code for C2"); } }; public static void doWork() { c.doWork(); } }
abstract class Parent { abstract void run(); } class Child extends Parent { void run() {} }
abstract class Foo { abstract static void bar(); } class Foo2 { @Override static void bar() {} }
interface Demo { public static void main(String [] args) { System.out.println("I am from interface"); } }
public interface SortableObject { public [abstract] static String [] getSortableTypes(); public String getSortableValueByType(String type); }
public class MyDataObject implements SortableObject { final static String [] SORT_TYPES = { "Name","Date of Birth" } static long newDataIndex = 0L ; String fullName ; String sortableDate ; long dataIndex = -1L ; public MyDataObject(String name, int year, int month, int day) { if(name == null || name.length() == 0) throw new IllegalArgumentException("Null/empty name not allowed."); if(!validateDate(year,month,day)) throw new IllegalArgumentException("Date parameters do not compose a legal date."); this.fullName = name ; this.sortableDate = MyUtils.createSortableDate(year,month,day); this.dataIndex = MyDataObject.newDataIndex++ ; } public String toString() { return ""+this.dataIndex+". "this.fullName+" ("+this.sortableDate+")"; } public static String [] getSortableTypes() { return SORT_TYPES ; } public String getSortableValueByType(String type) { int index = MyUtils.getStringArrayIndex(SORT_TYPES, type); switch(index) { case 0: return this.name ; case 1: return this.sortableDate ; } return toString(); } }
public class SortableList<T extends SortableObject>
public interface TimeClient { static public ZoneId getZoneId (String zoneString) { try { return ZoneId.of(zoneString); } catch (DateTimeException e) { System.err.println("Invalid time zone: " + zoneString + "; using default time zone instead."); return ZoneId.systemDefault(); } } default public ZonedDateTime getZonedDateTime(String zoneString) { return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString)); } }
Arrays.asList(new String[] { "String1", "string2" });
public static <T> T[] toArray(T... ts) { return ts; }
void functionCall(String...stringArray) { } functionCall("blah", "hey", "yo");
Menu menu=initMenus(menuHandler, new String[]{"File", "+Save", "+Load", "Edit", "+Copy", ...});
String canonical_path_string = "C:\\Windows\\System32\\"; String absolute_path_string = "C:\\Windows\\System32\\drivers\\..\\"; System.out.println(Paths.get(canonical_path_string).getParent()); System.out.println(Paths.get(absolute_path_string).getParent());
import java.io.File; public class PathTesting { public static void main(String [] args) { File f = new File("test/.././file.txt"); System.out.println(f.getPath()); System.out.println(f.getAbsolutePath()); try { System.out.println(f.getCanonicalPath()); } catch(Exception e) {} } }
test\..\.\file.txt C:\projects\sandbox\trunk\test\..\.\file.txt C:\projects\sandbox\trunk\file.txt
File f1 = new File("/some/path"); String path = f1.getPath(); File dir = new File("/basedir"); File f2 = new File(dir, "/some/path"); path = f2.getPath(); File f3 = new File("./some/path"); path = f3.getPath();
path = f1.getAbsolutePath(); path = f2.getAbsolutePath(); path = f3.getAbsolutePath();
$ /opt/java1.5/bin/jinfo -sysprops 14680 | grep sun.arch.data.model Attaching to process ID 14680, please wait... Debugger attached successfully. Server compiler detected. JVM version is 1.5.0_16-b02 sun.arch.data.model = 32
jinfo [ option ] pid jinfo [ option ] executable core jinfo [ option ] [server-id@]remote-hostname-or-IP
readelf -h {YOUR_JRE_LOCATION_HERE}/bin/java | grep
public static boolean is32Bit() { val javaHome = System.getProperty("java.home"); return javaHome.contains("(x86)"); } public static boolean is64Bit() { return !is32Bit(); }
C:\Program Files (x86)\Java\jdk1.8.0_181\bin\java.exe C:\Program Files\Java\jdk-10.0.2\bin\java.exe
System.out.println(Runtime.class.getPackage().getImplementationVersion());
public final class MyEqualityTest { public static void main( String args[] ) { String s1 = new String( "Test" ); String s2 = new String( "Test" ); System.out.println( "\n1 - PRIMITIVES "); System.out.println( s1 == s2 ); System.out.println( s1.equals( s2 )); A a1 = new A(); A a2 = new A(); System.out.println( "\n2 - OBJECT TYPES / STATIC VARIABLE" ); System.out.println( a1 == a2 ); System.out.println( a1.s == a2.s ); System.out.println( a1.s.equals( a2.s ) ); B b1 = new B(); B b2 = new B(); System.out.println( "\n3 - OBJECT TYPES / NON-STATIC VARIABLE" ); System.out.println( b1 == b2 ); System.out.println( b1.getS() == b2.getS() ); System.out.println( b1.getS().equals( b2.getS() ) ); } } final class A { public static String s; A() { this.s = new String( "aTest" ); } } final class B { private String s; B() { this.s = new String( "aTest" ); } public String getS() { return s; } }
String mango = "mango"; String mango2 = "mango"; System.out.println(mango != mango2); System.out.println(mango == mango2);
String mango = "mango"; String mango3 = new String("mango"); System.out.println(mango != mango3); System.out.println(mango == mango3);
String mango = "mango"; String mango2 = "mango"; String mango3 = new String("mango"); System.out.println(mango != mango2); System.out.println(mango == mango2); System.out.println(mango3 != mango2); System.out.println(mango3 == mango2); System.out.println(mango+" "+ mango2); System.out.println(mango != mango2); System.out.println(mango == mango2); System.out.println(System.identityHashCode(mango)); System.out.println(System.identityHashCode(mango2)); System.out.println(System.identityHashCode(mango3));
false true true false mango mango false true 17225372 17225372 5433634
mango -----> "mango" <------ mango2 mango3 ------> "mango"
mango ---->"mango" mango2 ----> "mang" mango3 -----> "mango"
String foo = new String("abc"); String bar = new String("abc"); if(foo==bar) bar = foo; if(foo==bar)
String foo = new String("abc"); String bar = new String("abc"); if(foo.equals(bar))
public boolean compareFoos(FooEnum x, FooEnum y) { return (x == y); }
String w1 ="Sarat"; String w2 ="Sarat"; String w3 = new String("Sarat"); System.out.println(w1.hashCode()); System.out.println(w2.hashCode()); System.out.println(w3.hashCode()); System.out.println(System.identityHashCode(w1)); System.out.println(System.identityHashCode(w2)); System.out.println(System.identityHashCode(w3)); if(w1==w2) { System.out.println("true"); } else { System.out.println("false"); } if(w2==w3) { System.out.println("true"); } else { System.out.println("false"); } if(w2.equals(w3)) { System.out.println("true"); } else { System.out.println("false"); }
String s1 = new String("Ali"); String s2 = new String("Veli"); String s3 = new String("Ali"); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); System.out.println(s3.hashCode()); System.out.println("(s1==s2):" + (s1 == s2)); System.out.println("(s1==s3):" + (s1 == s3)); System.out.println("s1.equals(s2):" + (s1.equals(s2))); System.out.println("s1.equal(s3):" + (s1.equals(s3))); /*Output 96670 3615852 96670 (s1==s2):false (s1==s3):false s1.equals(s2):false s1.equal(s3):true */
String string1 = "Ravi"; String string2 = "Ravi"; String string3 = new String("Ravi"); String string4 = new String("Prakash"); System.out.println(string1 == string2); System.out.println(string1 == string3);
System.out.println(string1.equals(string2)); System.out.println(string1.equals(string3)); System.out.println(string1.equals(string4));
class A { int id; String str; public A(int id,String str) { this.id=id; this.str=str; } public static void main(String arg[]) { A obj=new A(101,"sam"); A obj1=new A(101,"sam"); obj.equals(obj1) obj==obj1 } }
class A { int id; String str; public A(int id,String str) { this.id=id; this.str=str; } public boolean equals(Object obj) { A a1=(A)obj; return this.id==a1.id; } public static void main(String arg[]) { A obj=new A(101,"sam"); A obj1=new A(101,"sam"); obj.equals(obj1) obj==obj1 } }
public class StringPool { public static void main(String[] args) { String s1 = "Cat"; String s2 = "Cat"; String s3 = new String("Cat"); if (s1 == s2) { System.out.println("true"); } else { System.out.println("false"); } if (s1 == s3) { System.out.println("true"); } else { System.out.println("false"); } if (s1.equals(s3)) { System.out.println("true"); } else { System.out.println("False"); } } }
Long a = 10L; Long b = 10L; if (a == b) { System.out.println("Wrapped primitives behave like values"); }
ArrayList<Long> c = new ArrayList<>(); ArrayList<Long> d = new ArrayList<>(); c.add(a); d.add(b); if (c == d) System.out.println("No way!"); if (c.equals(d)) System.out.println("Yes, this is true.");
assert "ab" == "a" + "b"; Integer i = 1; Integer j = i; assert i == j;
assert new String("a") != new String("a"); Integer i = 128; Integer j = 128; assert i != j;
assert (new String("a")).equals(new String("a")); Integer i = 128; Integer j = 128; assert i.equals(j);
HashMap<Cat, String> cats = new HashMap<>(); Cat cat = new Cat("molly"); cats.put(cat, "This is a cool cat"); System.out.println(cats.get(new Cat("molly"));
public class TEstT{ public static void main(String[] args) { String text1 = new String("apple"); String text2 = new String("apple"); boolean result = text1 == text2; System.out.println("Comparing two strings with == operator: " + result); result = text1.equals(text2); System.out.println("Comparing two Strings with same content using equals method: " + result); text2 = text1; result = (text1 == text2); System.out.println("Comparing two reference pointing to same String with == operator: " + result); } }
try (BufferedReader br = new BufferedReader(new FileReader(path))) { System.out.println(br.readLine()); } catch (Exception e) { ... } finally { ... }
Resource r = new Resource(); try { } finally { r.dispose(); }
public class Closeable implements AutoCloseable { @Override public void close() { System.out.println("closing..."); } public static void main(String[] args) { try (Closeable c = new Closeable()) { System.out.println("trying..."); throw new Exception("throwing..."); } catch (Exception e) { System.out.println("catching..."); } finally { System.out.println("finalizing..."); } } }
* Called by the browser or applet viewer to inform * this applet that it is being reclaimed and that it should destroy * any resources that it has allocated. The stop() method * will always be called before destroy().
@Cleanup ResourceClass resource = new ResourceClass();
@Cleanup("dispose") ResourceClass resource = new ResourceClass();
accessor.getPlaypen().closeCloseables(); accessor.setPlaypen( new Playpen() );
public myDestructor() { variableA = 0; variableB = 0.0; variableC = "NO NAME ENTERED"; variableD = false; }
HttpClient httpClient = new DefaultHttpClient(); HttpContext localContext = new BasicHttpContext(); HttpGet httpGet = new HttpGet("http: HttpResponse response = httpClient.execute(httpGet, localContext);
@XMLObject(" public class Dictionary { @XMLField("Id") private String id; @XMLField("Name") private String name; }
import org.ksoap2.SoapEnvelope; import org.ksoap2.serialization.PropertyInfo; import org.ksoap2.serialization.SoapObject; import org.ksoap2.serialization.SoapPrimitive; import org.ksoap2.serialization.SoapSerializationEnvelope; import org.ksoap2.transport.HttpTransportSE; import android.app.Activity; import android.os.Bundle; import android.widget.TextView; public class WebserviceActivity extends Activity { private static final String NAMESPACE = "https: private static final String URL ="https: private static final String SOAP_ACTION = "https: private static final String METHOD_NAME = "AuthenticateTest"; private TextView lblResult; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); lblResult = (TextView) findViewById(R.id.tv); SoapObject request = new SoapObject(NAMESPACE, METHOD_NAME); request.addProperty("name","44vmMAYrhjfhj66fhJN"); request.addProperty("transactionKey","9MDQ7fghjghjh53H48k7e7n"); SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); envelope.setOutputSoapObject(request); HttpTransportSE androidHttpTransport = new HttpTransportSE(URL); try { androidHttpTransport.call(SOAP_ACTION, envelope); SoapObject resultsRequestSOAP = (SoapObject) envelope.bodyIn; lblResult.setText(resultsRequestSOAP.toString()); System.out.println("Response::"+resultsRequestSOAP.toString()); } catch (Exception e) { System.out.println("Error"+e); } } }
private static String mNAMESPACE=null; private static String mURL=null; public static Context context=null; SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); envelope.dotNet = true; envelope.setOutputSoapObject(Request); envelope.addMapping(mNAMESPACE, "UserCredentials",new UserCredendtials().getClass()); AndroidHttpTransport androidHttpTransport = new AndroidHttpTransport(mURL);
androidHttpTransport.call(SOAP_ACTION, envelope); result = (SoapPrimitive)envelope.getResponse();
ComplexOperationService service = new ComplexOperationService( ); ComplexOperation port= service.getComplexOperationPort(); SomeComplexRequest request = --Get some complex request----; SomeComplexResp resp = port.operate( request );
void callWebService(){ private static final String NAMESPACE = "http: private static final String URL = "http: private static final String METHOD_NAME = "Function_Name"; private static final String SOAP_ACTION = "urn:" + METHOD_NAME; SoapObject request = new SoapObject(NAMESPACE, METHOD_NAME); request.addProperty("parm_name", prm_value); SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); envelope.dotNet = true; envelope.setOutputSoapObject(request); HttpTransportSE androidHttpTransport = new HttpTransportSE(URL); try { androidHttpTransport.call(SOAP_ACTION, envelope); } catch (Exception e) { e.printStackTrace(); } SoapObject obj, obj1, obj2, obj3; obj = (SoapObject) envelope.getResponse(); obj1 = (SoapObject) obj.getProperty("diffgram"); obj2 = (SoapObject) obj1.getProperty("NewDataSet"); for (int i = 0; i < obj2.getPropertyCount(); i++) { obj3 = (SoapObject) obj2.getProperty(i); obj3.getProperty(0).toString(); obj3.getProperty(1).toString(); } }
public final String WSDL_TARGET_NAMESPACE = "http: public final String METHOD_NAME = "FahrenheitToCelsius"; public final String PROPERTY_NAME = "Fahrenheit"; public final String SOAP_ACTION = "http: public final String SOAP_ADDRESS = "http: private class TestAsynk extends AsyncTask<String, Void, String> { @Override protected void onPostExecute(String result) { super.onPostExecute(result); Toast.makeText(getApplicationContext(), String.format("%.2f", Float.parseFloat(result)), Toast.LENGTH_SHORT).show(); } @Override protected String doInBackground(String... params) { SoapObject request = new SoapObject(WSDL_TARGET_NAMESPACE, METHOD_NAME); request.addProperty(PROPERTY_NAME, params[0]); SoapSerializationEnvelope envelope = new SoapSerializationEnvelope( SoapEnvelope.VER11); envelope.dotNet = true; envelope.setOutputSoapObject(request); HttpTransportSE androidHttpTransport = new HttpTransportSE( SOAP_ADDRESS); Object response = null; try { androidHttpTransport.call(SOAP_ACTION, envelope); response = envelope.getResponse(); Log.e("Object response", response.toString()); } catch (Exception e) { e.printStackTrace(); } return response.toString(); } }
String SOAP_ACTION = "YOUR_ACTION_NAME"; String METHOD_NAME = "YOUR_METHOD_NAME"; String NAMESPACE = "YOUR_NAME_SPACE"; String URL = "YOUR_URL"; SoapPrimitive resultString = null; try { SoapObject Request = new SoapObject(NAMESPACE, METHOD_NAME); addPropertyForSOAP(Request); SoapSerializationEnvelope soapEnvelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); soapEnvelope.dotNet = true; soapEnvelope.setOutputSoapObject(Request); HttpTransportSE transport = new HttpTransportSE(URL); transport.call(SOAP_ACTION, soapEnvelope); resultString = (SoapPrimitive) soapEnvelope.getResponse(); Log.i("SOAP Result", "Result Celsius: " + resultString); } catch (Exception ex) { Log.e("SOAP Result", "Error: " + ex.getMessage()); } if(resultString != null) { return resultString.toString(); } else{ return "error"; }
public class WsClient { private static final String SOAP_ACTION = "somme"; private static final String OPERATION_NAME = "somme"; private static final String WSDL_TARGET_NAMESPACE = "http: private static final String SOAP_ADDRESS = "http: public String caclculerSomme() { String res = null; SoapObject request = new SoapObject(WSDL_TARGET_NAMESPACE, OPERATION_NAME); request.addProperty("a", "5"); request.addProperty("b", "2"); SoapSerializationEnvelope envelope = new SoapSerializationEnvelope( SoapEnvelope.VER11); envelope.dotNet = true; envelope.setOutputSoapObject(request); HttpTransportSE httpTransport = new HttpTransportSE(SOAP_ADDRESS); try { httpTransport.call(SOAP_ACTION, envelope); String result = envelope.getResponse().toString(); res = result; System.out.println(" } catch (Exception exception) { System.out.println(" } return res; } }
private static HashMap<String,String> mHeaders = new HashMap<>(); static { mHeaders.put("Accept-Encoding","gzip,deflate"); mHeaders.put("Content-Type", "application/soap+xml"); mHeaders.put("Host", "35.15.85.55:8080"); mHeaders.put("Connection", "Keep-Alive"); mHeaders.put("User-Agent","AndroidApp"); mHeaders.put("Authorization","Basic Q2xpZW50NTkzMzppMjR3s2U="); }public final static InputStream receiveCurrentShipments(String stringUrlShipments) { int status=0; String xmlstring= "<soap:Envelope xmlns:soap=\"http: " <soap:Header/>\n" + " <soap:Body>\n" + " <ser:GetAllOrdersOfShipment>\n" + " <ser:CodeOfBranch></ser:CodeOfBranch>\n" + " </ser:GetAllOrdersOfShipment>\n" + " </soap:Body>\n" + "</soap:Envelope>"; StringBuffer chaine = new StringBuffer(""); HttpURLConnection connection = null; try { URL url = new URL(stringUrlShipments); connection = (HttpURLConnection) url.openConnection(); connection.setRequestProperty("Content-Length", xmlstring.getBytes().length + ""); connection.setRequestProperty("SOAPAction", "http: for(Map.Entry<String, String> entry : mHeaders.entrySet()) { String key = entry.getKey(); String value = entry.getValue(); connection.setRequestProperty(key,value); } connection.setRequestMethod("POST"); connection.setDoInput(true); OutputStream outputStream = connection.getOutputStream(); outputStream.write(xmlstring.getBytes("UTF-8")); outputStream.close(); connection.connect(); status = connection.getResponseCode(); } catch (ProtocolException e) { e.printStackTrace(); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { Log.i("HTTP Client", "HTTP status code : " + status); } InputStream inputStream = null; try { inputStream = connection.getInputStream(); } catch (IOException e) { e.printStackTrace(); } return inputStream; }
HashMap < String, String > str1, HashMap < String, String > str2, HashMap < String, String > str3) { Object response = null; String METHOD_NAME = "CollectMoney"; String NAMESPACE = "http: String URL = "http: String SOAP_ACTION = ""; try { SoapObject RequestParent = new SoapObject(NAMESPACE, METHOD_NAME); SoapObject Request1 = new SoapObject(NAMESPACE, "req"); PropertyInfo pi = new PropertyInfo(); Set mapSet1 = (Set) str1.entrySet(); Iterator mapIterator1 = mapSet1.iterator(); while (mapIterator1.hasNext()) { Map.Entry mapEntry = (Map.Entry) mapIterator1.next(); String keyValue = (String) mapEntry.getKey(); String value = (String) mapEntry.getValue(); pi = new PropertyInfo(); pi.setNamespace("java:com.xxx"); pi.setName(keyValue); pi.setValue(value); Request1.addProperty(pi); } mapSet1 = (Set) str3.entrySet(); mapIterator1 = mapSet1.iterator(); while (mapIterator1.hasNext()) { Map.Entry mapEntry = (Map.Entry) mapIterator1.next(); String keyValue = (String) mapEntry.getKey(); String value = (String) mapEntry.getValue(); pi = new PropertyInfo(); pi.setNamespace("java:com.xxx"); pi.setName(keyValue); pi.setValue(value); Request1.addProperty(pi); } SoapObject HeaderRequest = new SoapObject(NAMESPACE, "XXX"); Set mapSet = (Set) str2.entrySet(); Iterator mapIterator = mapSet.iterator(); while (mapIterator.hasNext()) { Map.Entry mapEntry = (Map.Entry) mapIterator.next(); String keyValue = (String) mapEntry.getKey(); String value = (String) mapEntry.getValue(); pi = new PropertyInfo(); pi.setNamespace("java:com.xxx"); pi.setName(keyValue); pi.setValue(value); HeaderRequest.addProperty(pi); } Request1.addSoapObject(HeaderRequest); RequestParent.addSoapObject(Request1); SoapSerializationEnvelope soapEnvelope = new SoapSerializationEnvelope( SoapEnvelope.VER10); soapEnvelope.dotNet = false; soapEnvelope.setOutputSoapObject(RequestParent); HttpTransportSE transport = new HttpTransportSE(URL, 120000); transport.debug = true; transport.call(SOAP_ACTION, soapEnvelope); response = (Object) soapEnvelope.getResponse(); int cols = ((SoapObject) response).getPropertyCount(); Object objectResponse = (Object) ((SoapObject) response) .getProperty("Resp"); SoapObject subObject_Resp = (SoapObject) objectResponse; modelObject = new ResposeXmlModel(); String MsgId = subObject_Resp.getProperty("MsgId").toString(); modelObject.setMsgId(MsgId); String OrgId = subObject_Resp.getProperty("OrgId").toString(); modelObject.setOrgId(OrgId); String ResCode = subObject_Resp.getProperty("ResCode").toString(); modelObject.setResCode(ResCode); String ResDesc = subObject_Resp.getProperty("ResDesc").toString(); modelObject.setResDesc(ResDesc); String TimeStamp = subObject_Resp.getProperty("TimeStamp") .toString(); modelObject.setTimestamp(ResDesc); return response.toString(); } catch (Exception ex) { ex.printStackTrace(); return null; } }
String string = "Ram is going to school"; String[] arrayOfString = string.split("\\s+");
String str = "Hello World"; String res[] = str.split("\\s+");
import java.util.*; class Demo{ public static void main(String args[]){ Scanner input = new Scanner(System.in); System.out.print("Input String : "); String s1 = input.nextLine(); String[] tokens = s1.split("[\\s\\xA0]+"); System.out.println(tokens.length); for(String s : tokens){ System.out.println(s); } } }
abstract class Product { int multiplyBy; public Product( int multiplyBy ) { this.multiplyBy = multiplyBy; } public int mutiply(int val) { return multiplyBy * val; } } class TimesTwo extends Product { public TimesTwo() { super(2); } } class TimesWhat extends Product { public TimesWhat(int what) { super(what); } }
public abstract class Abs{ int i; int j; public Abs(int i,int j){ this.i = i; this.j = j; System.out.println(i+" "+j); } }
public class Imp extends Abs{ public Imp(int i, int j,int k, int l){ System.out.println("2 arg"); } }
public class Imp extends Abs{ public Imp(int i, int j,int k, int l){ super(i,j); System.out.println("2 arg"); } }
abstract class Product { int value; public Product( int val ) { value= val; } abstract public int multiply(); } class TimesTwo extends Product { public int mutiply() { return value * 2; } }
public abstract class TestEngine { private String engineId; private String engineName; public TestEngine(String engineId , String engineName) { this.engineId = engineId; this.engineName = engineName; } public abstract void scheduleTest(); } public class JavaTestEngine extends TestEngine { private String typeName; public JavaTestEngine(String engineId , String engineName , String typeName) { super(engineId , engineName); this.typeName = typeName; } public void scheduleTest() { } }
abstract class Figure { double dim1; double dim2; Figure(double a, double b) { dim1 = a; dim2 = b; } abstract double area(); } class Rectangle extends Figure { Rectangle(double a, double b) { super(a, b); } double area() { System.out.println("Inside Area for Rectangle."); return dim1 * dim2; } } class Triangle extends Figure { Triangle(double a, double b) { super(a, b); } double area() { System.out.println("Inside Area for Triangle."); return dim1 * dim2 / 2; } } class AbstractAreas { public static void main(String args[]) { Rectangle r = new Rectangle(9, 5); Triangle t = new Triangle(10, 8); Figure figref; figref = r; System.out.println("Area is " + figref.area()); figref = t; System.out.println("Area is " + figref.area()); } }
abstract class Base { Base() { System.out.println("Base Constructor Called"); } abstract void fun(); } class Derived extends Base { Derived() { System.out.println("Derived Constructor Called"); } void fun() { System.out.println("Derived fun() called"); } } class Main { public static void main(String args[]) { Derived d = new Derived(); } }
public abstract class Employee { private String EmpName; abstract double calcSalary(); Employee(String name) { this.EmpName = name; } } class Manager extends Employee{ Manager(String name) { super(name); } double calcSalary() { return 0; } }
@JsonIgnoreProperties(ignoreUnknown = true) public class Foo { ... }
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import org.codehaus.jackson.annotate.JsonIgnoreProperties;
objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
import com.fasterxml.jackson.annotation.JsonIgnoreProperties; @JsonIgnoreProperties(ignoreUnknown = true) public class MyMappingClass { }
import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.ObjectReader; ObjectMapper objectMapper = new ObjectMapper(); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); ObjectReader objectReader = objectMapper.reader(MyMappingClass.class); MyMappingClass myMappingClass = objectReader.readValue(json);
ObjectMapper mapper =new ObjectMapper(); mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false); mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper;
ObjectMapper mapper = new ObjectMapper(); mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
import org.codehaus.jackson.map.DeserializationConfig; ... objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
<dependencies> <!-- https: <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-core</artifactId> <version>2.8.5</version> </dependency> <!-- https: <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-annotations</artifactId> <version>2.8.5</version> </dependency> <!-- https: <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.8.5</version> </dependency> </dependencies>
ObjectMapper objectMapper = new ObjectMapper(); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
@JsonIgnoreProperties(ignoreUnknown = true) public class E1 { private String t1; public String getT1() { return t1; } public void setT1(String t1) { this.t1 = t1; } }
@Bean public Jackson2ObjectMapperBuilder configureObjectMapper() { Jackson2ObjectMapperBuilder oMapper = new Jackson2ObjectMapperBuilder(); oMapper.failOnUnknownProperties(false); return oMapper; }
Map<String, Integer> words = new HashMap<>(); words.put("hello", 3); words.put("world", 4); words.computeIfPresent("hello", (k, v) -> v + 1); System.out.println(words.get("hello"));
TObjectIntHashMap<String> map = new TObjectIntHashMap<String>() map.increment("aaa");
map.put(key, map.containsKey(key) ? map.get(key) + 1 : 1);
if(!map.containsKey(key)) { p.put(key,1); } else { p.put(key, map.getKey()+1); }
if (hashmap.containsKey(key)) { hashmap.put(key, hashmap.get(key)+1); } else { hashmap.put(key,1); }
final Map<String,Integer> map1 = new HashMap<>(); map1.put("A",0); map1.put("B",0); map1.computeIfPresent("B",(k,v)->v+1);
final Map<String,AtomicInteger> map2 = new ConcurrentHashMap<>(); map2.putIfAbsent("A",new AtomicInteger(0)); map2.putIfAbsent("B",new AtomicInteger(0)); map2.get("B").incrementAndGet();
map2.putIfAbsent("B",new AtomicInteger(0)).incrementAndGet();
for (int i =0; i<5; i++){ HashMap<String, Integer> map = new HashMap<String, Integer>(); map.put("beer", 100); int beer = map.get("beer")+i; System.out.println("beer " + beer); System.out .... }
for(String key : someArray) { if(hashMap.containsKey(key) { hashMap.put(hashMap.get(key),value+1); } else { hashMap.put(key,value); } }
String->give the new value; else Double->pass new value;
Integer i = map.get(key); if(i == null) i = (aValue) map.put(key, i + 1);
Integer i = map.get(key); map.put(key, i == null ? newValue : i + 1);
class StringOutputStream extends OutputStream { StringBuilder mBuf; public void write(int byte) throws IOException { mBuf.append((char) byte); } public String getString() { return mBuf.toString(); } }
OutputStream output = new OutputStream() { private StringBuilder string = new StringBuilder(); @Override public void write(int b) throws IOException { this.string.append((char) b ); } public String toString(){ return this.string.toString(); } };
Obj.writeToStream(toWrite, os); try { String out = new String(os.toByteArray(), "UTF-8"); assertTrue(out.contains("testString")); } catch (UnsupportedEncondingException e) { fail("Caught exception: " + e.getMessage()); }
class SomeContainer<E> { E createContents() { return what??? } }
private static class SomeContainer<E> { E createContents(Class<E> clazz) { return clazz.newInstance(); } }
public abstract class Foo<E> { public E instance; public Foo() throws Exception { instance = ((Class)((ParameterizedType)this.getClass(). getGenericSuperclass()).getActualTypeArguments()[0]).newInstance(); ... } }
assert( new Foo<Bar>() {}.instance instanceof Bar );
interface Factory<E> { E create(); } class SomeContainer<E> { private final Factory<E> factory; SomeContainer(Factory<E> factory) { this.factory = factory; } E createContents() { return factory.create(); } }
class SomeContainer<E> { private Supplier<E> supplier; SomeContainer(Supplier<E> supplier) { this.supplier = supplier; } E createContents() { return supplier.get(); } }
SomeContainer<String> stringContainer = new SomeContainer<>(String::new);
SomeContainer<BigInteger> bigIntegerContainer = new SomeContainer<>(() -> new BigInteger(1));
package org.foo.com; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; /** * Basically the same answer as noah */ public class Home<E> { @SuppressWarnings ("unchecked") public Class<E> getTypeParameterClass() { Type type = getClass().getGenericSuperclass(); ParameterizedType paramType = (ParameterizedType) type; return (Class<E>) paramType.getActualTypeArguments()[0]; } private static class StringHome extends Home<String> { } private static class StringBuilderHome extends Home<StringBuilder> { } private static class StringBufferHome extends Home<StringBuffer> { } /** * This prints "String", "StringBuilder" and "StringBuffer" */ public static void main(String[] args) throws InstantiationException, IllegalAccessException { Object object0 = new StringHome().getTypeParameterClass().newInstance(); Object object1 = new StringBuilderHome().getTypeParameterClass().newInstance(); Object object2 = new StringBufferHome().getTypeParameterClass().newInstance(); System.out.println(object0.getClass().getSimpleName()); System.out.println(object1.getClass().getSimpleName()); System.out.println(object2.getClass().getSimpleName()); } }
public final class Foo<T> { private Class<T> typeArgumentClass; public Foo(Class<T> typeArgumentClass) { this.typeArgumentClass = typeArgumentClass; } public void doSomethingThatRequiresNewT() throws Exception { T myNewT = typeArgumentClass.newInstance(); ... } }
Foo<Bar> barFoo = new Foo<Bar>(Bar.class); Foo<Etc> etcFoo = new Foo<Etc>(Etc.class);
import com.google.common.reflect.TypeToken; public class Q26289147 { public static void main(final String[] args) throws IllegalAccessException, InstantiationException { final StrawManParameterizedClass<String> smpc = new StrawManParameterizedClass<String>() {}; final String string = (String) smpc.type.getRawType().newInstance(); System.out.format("string = \"%s\"",string); } static abstract class StrawManParameterizedClass<T> { final TypeToken<T> type = new TypeToken<T>(getClass()) {}; } }
E createContents(Callable<E> makeone) { return makeone.call(); }
public static <E> void append(List<E> list) { E elem = new E(); list.add(elem); }
public static <E> void append(List<E> list, Class<E> cls) throws Exception { E elem = cls.newInstance(); list.add(elem); }
List<String> ls = new ArrayList<>(); append(ls, String.class);
public static class Container<E> { private Class<E> clazz; public Container(Class<E> clazz) { this.clazz = clazz; } public E createContents() throws Exception { return clazz.newInstance(); } }
@SuppressWarnings("unchecked") public Container(E instance) { this.clazz = (Class<E>) instance.getClass(); }
<E> SomeContainer<E> createContainer(Class<E> class);
public class Container<E> { public static <E> Container<E> create(Class<E> c) { return new Container<E>(c); } Class<E> c; public Container(Class<E> c) { super(); this.c = c; } public E createInstance() throws InstantiationException, IllegalAccessException { return c.newInstance(); } }
Abstract class SomeContainer<E> { abstract protected E createContents(); public doWork(){ E obj = createContents(); } } **BlackContainer extends** SomeContainer<Black>{ Black createContents() { return new Black(); } }
public static <E> void append(List<E> list) { E elem = new E(); list.add(elem); }
public static <E> void append(List<E> list, Class<E> cls) throws Exception { E elem = cls.newInstance(); list.add(elem); }
List<String> ls = new ArrayList<>(); append(ls, String.class);
Class.forName(String).getConstructor(arguments types).newInstance(arguments)
import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; interface SomeContainer<E> { E createContents(); } public class Main { @SuppressWarnings("unchecked") public static <E> SomeContainer<E> createSomeContainer() { return (SomeContainer<E>) Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]{ SomeContainer.class }, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Class<?> returnType = method.getReturnType(); return returnType.newInstance(); } }); } public static void main(String[] args) { SomeContainer<String> container = createSomeContainer(); [*] System.out.println("String created: [" +container.createContents()+"]"); } }
Exception in thread "main" java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String at Main.main(Main.java:26) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
public abstract class Clazz<P extends Params, M extends Model> { protected M model; protected void createModel() { Type[] typeArguments = ((ParameterizedType) this.getClass().getGenericSuperclass()).getActualTypeArguments(); for (Type type : typeArguments) { if ((type instanceof Class) && (Model.class.isAssignableFrom((Class) type))) { try { model = ((Class<M>) type).newInstance(); } catch (InstantiationException | IllegalAccessException e) { throw new RuntimeException(e); } } } }
model = ((Class<M>) ((ParameterizedType) this.getClass().getGenericSuperclass()).getActualTypeArguments()[1]).newInstance();
interface Factory<E>{ E create(); } class IntegerFactory implements Factory<Integer>{ private static int i = 0; Integer create() { return i++; } }
return (E)((Class)((ParameterizedType)this.getClass().getGenericSuperclass()).getActualTypeArguments()[0]).newInstance();
import java.lang.reflect.ParameterizedType; public class SomeContainer<E> { E createContents() throws InstantiationException, IllegalAccessException { ParameterizedType genericSuperclass = (ParameterizedType) getClass().getGenericSuperclass(); @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) genericSuperclass.getActualTypeArguments()[0]; return clazz.newInstance(); } public static void main( String[] args ) throws Throwable { SomeContainer< Long > scl = new SomeContainer<>(); Long l = scl.createContents(); System.out.println( l ); } }
E createContents() throws Exception { return TypeTools.resolveRawArgument(SomeContainer.class, getClass()).newInstance(); }
E createContents() throws Exception { return TypeTools.resolveRawArgument(SomeContainer.class, getClass()).newInstance(); }
class SomeStringContainer extends SomeContainer<String>
public class TypeReference<T> { public Class<T> type(){ try { ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass(); if (pt.getActualTypeArguments() == null || pt.getActualTypeArguments().length == 0){ throw new IllegalStateException("Could not define type"); } if (pt.getActualTypeArguments().length != 1){ throw new IllegalStateException("More than one type has been found"); } Type type = pt.getActualTypeArguments()[0]; String typeAsString = type.getTypeName(); return (Class<T>) Class.forName(typeAsString); } catch (Exception e){ throw new IllegalStateException("Could not identify type", e); } } }
import java.lang.reflect.Constructor; public class TypeReferenceTest { private static final String NAME = "Peter"; private static class Person{ final String name; Person(String name) { this.name = name; } } @Test public void erased() { TypeReference<Person> p = new TypeReference<>(); Assert.assertNotNull(p); try { p.type(); Assert.fail(); } catch (Exception e){ Assert.assertEquals("Could not identify type", e.getMessage()); } } @Test public void reified() throws Exception { TypeReference<Person> p = new TypeReference<Person>(){}; Assert.assertNotNull(p); Assert.assertEquals(Person.class.getName(), p.type().getName()); Constructor ctor = p.type().getDeclaredConstructor(NAME.getClass()); Assert.assertNotNull(ctor); Person person = (Person) ctor.newInstance(NAME); Assert.assertEquals(NAME, person.name); } static class TypeReferencePerson extends TypeReference<Person>{} @Test public void reifiedExtenension() throws Exception { TypeReference<Person> p = new TypeReferencePerson(); Assert.assertNotNull(p); Assert.assertEquals(Person.class.getName(), p.type().getName()); Constructor ctor = p.type().getDeclaredConstructor(NAME.getClass()); Assert.assertNotNull(ctor); Person person = (Person) ctor.newInstance(NAME); Assert.assertEquals(NAME, person.name); } }
private static class SomeContainer<E extends Object> { E e; E createContents() throws Exception{ return (E) e.getClass().getDeclaredConstructor().newInstance(); } }
public class SomeContainer<E extends Object> { E object; void resetObject throws Exception{ object = (E) object.getClass().getDeclaredConstructor().newInstance(); } }
final ClassLoader classLoader = ... final Class<?> aClass = classLoader.loadClass("java.lang.Integer"); final Constructor<?> constructor = aClass.getConstructor(int.class); final Object o = constructor.newInstance(123); System.out.println("o = " + o);
String.format("%d min, %d sec", TimeUnit.MILLISECONDS.toMinutes(millis), TimeUnit.MILLISECONDS.toSeconds(millis) - TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(millis)) );
String.format("%02d min, %02d sec", TimeUnit.MILLISECONDS.toMinutes(millis), TimeUnit.MILLISECONDS.toSeconds(millis) - TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(millis)) );
int seconds = (int) (milliseconds / 1000) % 60 ; int minutes = (int) ((milliseconds / (1000*60)) % 60); int hours = (int) ((milliseconds / (1000*60*60)) % 24);
/** * Convert a millisecond duration to a string format * * @param millis A duration to convert to a string form * @return A string of the form "X Days Y Hours Z Minutes A Seconds". */ public static String getDurationBreakdown(long millis) { if(millis < 0) { throw new IllegalArgumentException("Duration must be greater than zero!"); } long days = TimeUnit.MILLISECONDS.toDays(millis); millis -= TimeUnit.DAYS.toMillis(days); long hours = TimeUnit.MILLISECONDS.toHours(millis); millis -= TimeUnit.HOURS.toMillis(hours); long minutes = TimeUnit.MILLISECONDS.toMinutes(millis); millis -= TimeUnit.MINUTES.toMillis(minutes); long seconds = TimeUnit.MILLISECONDS.toSeconds(millis); StringBuilder sb = new StringBuilder(64); sb.append(days); sb.append(" Days "); sb.append(hours); sb.append(" Hours "); sb.append(minutes); sb.append(" Minutes "); sb.append(seconds); sb.append(" Seconds"); return(sb.toString()); }
long time = 1536259; return (new SimpleDateFormat("mm:ss:SSS")).format(new Date(time));
int seconds = (int) ((milliseconds / 1000) % 60); int minutes = (int) ((milliseconds / 1000) / 60);
Instant start = Instant.now(); Thread.sleep(63553); Instant end = Instant.now(); System.out.println(Duration.between(start, end));
long start = System.currentTimeMillis(); long elapsed = System.currentTimeMillis() - start; DateFormat df = new SimpleDateFormat("HH df.setTimeZone(TimeZone.getTimeZone("GMT+0")); System.out.println(df.format(new Date(elapsed)));
int h = (int) ((startTimeInMillis / 1000) / 3600); int m = (int) (((startTimeInMillis / 1000) / 60) % 60); int s = (int) ((startTimeInMillis / 1000) % 60);
String.format("%d min, %d sec", TimeUnit.MILLISECONDS.toSeconds(length)/60, TimeUnit.MILLISECONDS.toSeconds(length) % 60 );
System.out.printf("%tT", millis-TimeZone.getDefault().getRawOffset());
String t = String.format("%tT", millis-TimeZone.getDefault().getRawOffset());
DateTime startTime = new DateTime(); DateTime endTime = new DateTime(); Duration duration = new Duration(startTime, endTime); Period period = duration.toPeriod().normalizedStandard(PeriodType.time()); System.out.println(PeriodFormat.getDefault().print(period));
/** * Convert a millisecond duration to a string format * * @param millis A duration to convert to a string form * @return A string of the form "X Days Y Hours Z Minutes A Seconds B Milliseconds". */ public static String getDurationBreakdown(long millis) { if (millis < 0) { throw new IllegalArgumentException("Duration must be greater than zero!"); } long days = TimeUnit.MILLISECONDS.toDays(millis); long hours = TimeUnit.MILLISECONDS.toHours(millis) % 24; long minutes = TimeUnit.MILLISECONDS.toMinutes(millis) % 60; long seconds = TimeUnit.MILLISECONDS.toSeconds(millis) % 60; long milliseconds = millis % 1000; return String.format("%d Days %d Hours %d Minutes %d Seconds %d Milliseconds", days, hours, minutes, seconds, milliseconds); }
(String.format("%d hr %d min, %d sec", millis/(1000*60*60), (millis%(1000*60*60))/(1000*60), ((millis%(1000*60*60))%(1000*60))/1000))
String millisecToTime(int millisec) { int sec = millisec/1000; int second = sec % 60; int minute = sec / 60; if (minute >= 60) { int hour = minute / 60; minute %= 60; return hour + ":" + (minute < 10 ? "0" + minute : minute) + ":" + (second < 10 ? "0" + second : second); } return minute + ":" + (second < 10 ? "0" + second : second); }
long millis = ... System.out.printf("%1$TM:%1$TS", millis); String str = String.format("%1$TM:%1$TS", millis);
private static final long HOUR = TimeUnit.HOURS.toMillis(1); ... if (millis < HOUR) { System.out.printf("%1$TM:%1$TS%n", millis); } else { System.out.printf("%d:%2$TM:%2$TS%n", millis / HOUR, millis % HOUR); }
long startTime = System.currentTimeMillis(); long endTime=System.currentTimeMillis(); long diff=endTime-startTime; long hours=TimeUnit.MILLISECONDS.toHours(diff); diff=diff-(hours*60*60*1000); long min=TimeUnit.MILLISECONDS.toMinutes(diff); diff=diff-(min*60*1000); long seconds=TimeUnit.MILLISECONDS.toSeconds(diff);
public static String getDurationBreakdown(long millis) { String[] units = {" Days ", " Hours ", " Minutes ", " Seconds "}; Long[] values = new Long[units.length]; if(millis < 0) { throw new IllegalArgumentException("Duration must be greater than zero!"); } values[0] = TimeUnit.MILLISECONDS.toDays(millis); millis -= TimeUnit.DAYS.toMillis(values[0]); values[1] = TimeUnit.MILLISECONDS.toHours(millis); millis -= TimeUnit.HOURS.toMillis(values[1]); values[2] = TimeUnit.MILLISECONDS.toMinutes(millis); millis -= TimeUnit.MINUTES.toMillis(values[2]); values[3] = TimeUnit.MILLISECONDS.toSeconds(millis); StringBuilder sb = new StringBuilder(64); boolean startPrinting = false; for(int i = 0; i < units.length; i++){ if( !startPrinting && values[i] != 0) startPrinting = true; if(startPrinting){ sb.append(values[i]); sb.append(units[i]); } } return(sb.toString()); }
Duration elapsedTime = Duration.ofMillis(millisDiff ); String humanReadableElapsedTime = String.format( "%d hours, %d mins, %d seconds", elapsedTime.toHours(), elapsedTime.toMinutesPart(), elapsedTime.toSecondsPart());
elapsedTime = elapsedTime.plusMillis(500).truncatedTo(ChronoUnit.SECONDS);
long hours = elapsedTime.toHours(); String humanReadableElapsedTime; if (hours == 0) { humanReadableElapsedTime = String.format( "%d mins, %d seconds", elapsedTime.toMinutesPart(), elapsedTime.toSecondsPart()); } else { humanReadableElapsedTime = String.format( "%d hours, %d mins, %d seconds", hours, elapsedTime.toMinutesPart(), elapsedTime.toSecondsPart()); }
String humanReadableElapsedTime = String.format( "%d hours, %02d mins, %02d seconds", elapsedTime.toHours(), elapsedTime.toMinutesPart(), elapsedTime.toSecondsPart());
int seconds = (int)(millis / 1000) % 60 ; int minutes = (int)((millis / (1000*60)) % 60); int hours = (int)((millis / (1000*60*60)) % 24); int days = (int)((millis / (1000*60*60*24)) % 365); int years = (int)(millis / 1000*60*60*24*365); ArrayList<String> timeArray = new ArrayList<String>(); if(years > 0) timeArray.add(String.valueOf(years) + "y"); if(days > 0) timeArray.add(String.valueOf(days) + "d"); if(hours>0) timeArray.add(String.valueOf(hours) + "h"); if(minutes>0) timeArray.add(String.valueOf(minutes) + "min"); if(seconds>0) timeArray.add(String.valueOf(seconds) + "sec"); String time = ""; for (int i = 0; i < timeArray.size(); i++) { time = time + timeArray.get(i); if (i != timeArray.size() - 1) time = time + ", "; } if (time == "") time = "0 sec";
Calendar c1 = Calendar.getInstance(); Calendar c2 = Calendar.getInstance(); c2.add(Calendar.MINUTE, 51); long diff = c2.getTimeInMillis() - c1.getTimeInMillis(); c2.set(Calendar.MINUTE, 0); c2.set(Calendar.HOUR, 0); c2.set(Calendar.SECOND, 0); DateFormat df = new SimpleDateFormat("mm:ss"); long diff1 = c2.getTimeInMillis() + diff; System.out.println(df.format(new Date(diff1)));
/** * Converts milliseconds to "x days, x hours, x mins, x secs" * * @param millis * The milliseconds * @param longFormat * {@code true} to use "seconds" and "minutes" instead of "secs" and "mins" * @return A string representing how long in days/hours/minutes/seconds millis is. */ public static String millisToString(long millis, boolean longFormat) { if (millis < 1000) { return String.format("0 %s", longFormat ? "seconds" : "secs"); } String[] units = { "day", "hour", longFormat ? "minute" : "min", longFormat ? "second" : "sec" }; long[] times = new long[4]; times[0] = TimeUnit.DAYS.convert(millis, TimeUnit.MILLISECONDS); millis -= TimeUnit.MILLISECONDS.convert(times[0], TimeUnit.DAYS); times[1] = TimeUnit.HOURS.convert(millis, TimeUnit.MILLISECONDS); millis -= TimeUnit.MILLISECONDS.convert(times[1], TimeUnit.HOURS); times[2] = TimeUnit.MINUTES.convert(millis, TimeUnit.MILLISECONDS); millis -= TimeUnit.MILLISECONDS.convert(times[2], TimeUnit.MINUTES); times[3] = TimeUnit.SECONDS.convert(millis, TimeUnit.MILLISECONDS); StringBuilder s = new StringBuilder(); for (int i = 0; i < 4; i++) { if (times[i] > 0) { s.append(String.format("%d %s%s, ", times[i], units[i], times[i] == 1 ? "" : "s")); } } return s.toString().substring(0, s.length() - 2); } /** * Converts milliseconds to "x days, x hours, x mins, x secs" * * @param millis * The milliseconds * @return A string representing how long in days/hours/mins/secs millis is. */ public static String millisToString(long millis) { return millisToString(millis, false); }
public static Map<TimeUnit,Long> computeDiff(Date date1, Date date2) { long diffInMillies = date2.getTime() - date1.getTime(); List<TimeUnit> units = new ArrayList<TimeUnit>(EnumSet.allOf(TimeUnit.class)); Collections.reverse(units); Map<TimeUnit,Long> result = new LinkedHashMap<TimeUnit,Long>(); long milliesRest = diffInMillies; for ( TimeUnit unit : units ) { long diff = unit.convert(milliesRest,TimeUnit.MILLISECONDS); long diffInMilliesForUnit = unit.toMillis(diff); milliesRest = milliesRest - diffInMilliesForUnit; result.put(unit,diff); } return result; }
private static long timeDiff(Date date, Date date2, TimeUnit unit) { long milliDiff=date2.getTime()-date.getTime(); long unitDiff = unit.convert(milliDiff, TimeUnit.MILLISECONDS); return unitDiff; }
SimpleDateFormat sdf = new SimpleDateFormat("yy/MM/dd HH:mm:ss"); Date firstDate = sdf.parse("06/24/2017 04:30:00"); Date secondDate = sdf.parse("07/24/2017 05:00:15"); Date thirdDate = sdf.parse("06/24/2017 06:00:15"); System.out.println("days difference: "+timeDiff(firstDate,secondDate,TimeUnit.DAYS)); System.out.println("hours difference: "+timeDiff(firstDate,thirdDate,TimeUnit.HOURS)); System.out.println("minutes difference: "+timeDiff(firstDate,thirdDate,TimeUnit.MINUTES)); System.out.println("seconds difference: "+timeDiff(firstDate,thirdDate,TimeUnit.SECONDS));
public static String formatTime(long millis) { long seconds = Math.round((double) millis / 1000); long hours = TimeUnit.SECONDS.toHours(seconds); if (hours > 0) seconds -= TimeUnit.HOURS.toSeconds(hours); long minutes = seconds > 0 ? TimeUnit.SECONDS.toMinutes(seconds) : 0; if (minutes > 0) seconds -= TimeUnit.MINUTES.toSeconds(minutes); return hours > 0 ? String.format("%02d:%02d:%02d", hours, minutes, seconds) : String.format("%02d:%02d", minutes, seconds); }
public static String intervalToHumanReadableTime(int intervalMins) { if(intervalMins <= 0) { return "0"; } else { long intervalMs = intervalMins * 60 * 1000; long days = TimeUnit.MILLISECONDS.toDays(intervalMs); intervalMs -= TimeUnit.DAYS.toMillis(days); long hours = TimeUnit.MILLISECONDS.toHours(intervalMs); intervalMs -= TimeUnit.HOURS.toMillis(hours); long minutes = TimeUnit.MILLISECONDS.toMinutes(intervalMs); StringBuilder sb = new StringBuilder(12); if (days >= 1) { sb.append(days).append(" day").append(pluralize(days)).append(", "); } if (hours >= 1) { sb.append(hours).append(" hour").append(pluralize(hours)).append(", "); } if (minutes >= 1) { sb.append(minutes).append(" minute").append(pluralize(minutes)); } else { sb.delete(sb.length()-2, sb.length()-1); } return(sb.toString()); } } public static String pluralize(long val) { return (Math.round(val) > 1 ? "s" : ""); }
myStringBuilder.delete(0, myStringBuilder.length());
StringBuilder s = new StringBuilder(); s.append("a"); s.append("a"); s.delete(0, s.length()); System.out.print(s.length());
class MyLogger { StringBuilder strBldr = new StringBuilder(256); public LogMsg( String stuff ) { strBldr.setLength(0); strBldr.append("Info"); strBldr.append(" " + getTimestamp()); strBldr.append(":" + msg); log.write(strBldr.toString()); } }
private void tryReading() { String jsonStr = "{\"wrapper\"\:[{\"id\":\"13\",\"name\":\"Fred\"}]}"; ObjectMapper mapper = new ObjectMapper(); Wrapper wrapper = null; try { wrapper = mapper.readValue(jsonStr , Wrapper.class); } catch (Exception e) { e.printStackTrace(); } System.out.println("wrapper = " + wrapper); }
public Class Student { private String name; private String id; }
public Class Wrapper { private List<Student> students; }
org.codehaus.jackson.map.exc.UnrecognizedPropertyException: Unrecognized field "wrapper" (Class Wrapper), not marked as ignorable at [Source: java.io.StringReader@1198891; line: 1, column: 13] (through reference chain: Wrapper["wrapper"]) at org.codehaus.jackson.map.exc.UnrecognizedPropertyException .from(UnrecognizedPropertyException.java:53)
import com.fasterxml.jackson.annotation.JsonIgnoreProperties @JsonIgnoreProperties class { ... }
ObjectMapper objectMapper = getObjectMapper(); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
private static final ObjectMapper objectMapper = new ObjectMapper() .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
ObjectMapper objectMapper = new ObjectMapper(); objectMapper.configure( DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
ObjectMapper mapper =new ObjectMapper(); mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false); mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper; ObjectMapper objectMapper = new ObjectMapper(); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); projectVO = objectMapper.readValue(yourjsonstring, Test.class);
ObjectMapper mapper = new ObjectMapper(); mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
@JsonIgnoreProperties({ "internalId", "secretKey" }) @JsonIgnoreProperties(ignoreUnknown=true)
ObjectMapper mapper =new ObjectMapper(); mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
public Class Wrapper{ private List<Student> students; }
public Class Wrapper{ private StudentHelper students; @JsonProperty("wrapper") StudentHelper getStudents() { return students; } } public class StudentHelper { @JsonProperty("Student") public List<Student> students; }
import org.codehaus.jackson.annotate.JsonIgnoreProperties; @JsonIgnoreProperties(ignoreUnknown = true)
public Class Wrapper { @JsonProperty("wrapper") private List<Student> students; }
Wrapper = mapper.readValue(jsonStr , Wrapper.class);
public Class Wrapper { private List<Student> students; }
public Class Wrapper { private List<Student> wrapper; }
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
public class Response { private List<Wrapper> wrappers; }
public class Wrapper { private String id; private String name; }
Response response = mapper.readValue(jsonStr , Response.class);
BEFORE @JsonIgnoreExtraProperties(ignoreUnknown=true) public class ChatMessage { public String name; public String message; @JsonIgnore public String ignoreThisField; } dataSnapshot.getValue(ChatMessage.class)
AFTER public class ChatMessage { public String name; public String message; @Exclude public String ignoreThisField; } dataSnapshot.getValue(ChatMessage.class)
W/ClassMapper: No setter/field for ignoreThisProperty found on class com.firebase.migrationguide.ChatMessage
public class Wrapper { private List<Student> wrapper; }
objectMapper.readValue(responseBody, TargetClass.class)
@Data @Builder public class TargetClass { private String a; }
public Class Student { public String name; public String id; }
String jsonStr = "{\"students\"\:[{\"id\":\"13\",\"name\":\"Fred\"}]}";
public class Wrapper { private List<Student> wrapper; }
return new File(MyClass.class.getProtectionDomain().getCodeSource().getLocation() .toURI()).getPath();
String path = Test.class.getProtectionDomain().getCodeSource().getLocation().getPath(); String decodedPath = URLDecoder.decode(path, "UTF-8");
/** * Gets the base location of the given class. * <p> * If the class is directly on the file system (e.g., * "/path/to/my/package/MyClass.class") then it will return the base directory * (e.g., "file:/path/to"). * </p> * <p> * If the class is within a JAR file (e.g., * "/path/to/my-jar.jar!/my/package/MyClass.class") then it will return the * path to the JAR (e.g., "file:/path/to/my-jar.jar"). * </p> * * @param c The class whose location is desired. * @see FileUtils */ public static URL getLocation(final Class<?> c) { if (c == null) return null; try { final URL codeSourceLocation = c.getProtectionDomain().getCodeSource().getLocation(); if (codeSourceLocation != null) return codeSourceLocation; } catch (final SecurityException e) { } catch (final NullPointerException e) { } final URL classResource = c.getResource(c.getSimpleName() + ".class"); if (classResource == null) return null; final String url = classResource.toString(); final String suffix = c.getCanonicalName().replace( if (!url.endsWith(suffix)) return null; final String base = url.substring(0, url.length() - suffix.length()); String path = base; if (path.startsWith("jar:")) path = path.substring(4, path.length() - 2); try { return new URL(path); } catch (final MalformedURLException e) { e.printStackTrace(); return null; } } /** * Converts the given {@link URL} to its corresponding {@link File}. * <p> * This method is similar to calling {@code new File(url.toURI())} except that * it also handles "jar:file:" URLs, returning the path to the JAR file. * </p> * * @param url The URL to convert. * @return A file path suitable for use with e.g. {@link FileInputStream} * @throws IllegalArgumentException if the URL does not correspond to a file. */ public static File urlToFile(final URL url) { return url == null ? null : urlToFile(url.toString()); } /** * Converts the given URL string to its corresponding {@link File}. * * @param url The URL to convert. * @return A file path suitable for use with e.g. {@link FileInputStream} * @throws IllegalArgumentException if the URL does not correspond to a file. */ public static File urlToFile(final String url) { String path = url; if (path.startsWith("jar:")) { final int index = path.indexOf("!/"); path = path.substring(4, index); } try { if (PlatformUtils.isWindows() && path.matches("file:[A-Za-z]:.*")) { path = "file:/" + path.substring(5); } return new File(new URL(path).toURI()); } catch (final MalformedURLException e) { } catch (final URISyntaxException e) { } if (path.startsWith("file:")) { path = path.substring(5); return new File(path); } throw new IllegalArgumentException("Invalid URL: " + url); }
CodeSource codeSource = YourMainClass.class.getProtectionDomain().getCodeSource(); File jarFile = new File(codeSource.getLocation().toURI().getPath()); String jarDir = jarFile.getParentFile().getPath();
package foo; public class Test { public static void main(String[] args) { ClassLoader loader = Test.class.getClassLoader(); System.out.println(loader.getResource("foo/Test.class")); } }
Path path = Paths.get(Test.class.getProtectionDomain().getCodeSource().getLocation().toURI());
public static String getJarContainingFolder(Class aclass) throws Exception { CodeSource codeSource = aclass.getProtectionDomain().getCodeSource(); File jarFile; if (codeSource.getLocation() != null) { jarFile = new File(codeSource.getLocation().toURI()); } else { String path = aclass.getResource(aclass.getSimpleName() + ".class").getPath(); String jarFilePath = path.substring(path.indexOf(":") + 1, path.indexOf("!")); jarFilePath = URLDecoder.decode(jarFilePath, "UTF-8"); jarFile = new File(jarFilePath); } return jarFile.getParentFile().getAbsolutePath(); }
File currentJavaJarFile = new File(Main.class.getProtectionDomain().getCodeSource().getLocation().getPath()); String currentJavaJarFilePath = currentJavaJarFile.getAbsolutePath(); String currentRootDirectoryPath = currentJavaJarFilePath.replace(currentJavaJarFile.getName(), "");
String path = YourMainClassName.class.getProtectionDomain(). getCodeSource().getLocation().getPath(); path = URLDecoder.decode( path, "UTF-8"); BufferedImage img = ImageIO.read( new File(( new File(path).getParentFile().getPath()) + File.separator + "folder" + File.separator + "yourfile.jpg"));
try { return URLDecoder.decode(ClassLoader.getSystemClassLoader().getResource(".").getPath(), "UTF-8"); } catch (UnsupportedEncodingException e) { return ""; }
private String getJarFolder() { String name = getClass().getName().replace( name = getClass().getResource("/" + name + ".class").toString(); name = name.substring(0, name.indexOf(".jar")); name = name.substring(name.lastIndexOf( String s = ""; for (int k=0; k<name.length(); k++) { s += name.charAt(k); if (name.charAt(k) == } return s.replace( }
return new File(MyClass.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()).getParentFile();
URL jarLocationUrl = MyClass.class.getProtectionDomain().getCodeSource().getLocation(); String jarLocation = new File(jarLocationUrl.toString()).getParent();
String path = getClass().getResource("").getPath();
public static String dir() throws URISyntaxException { URI path=Main.class.getProtectionDomain().getCodeSource().getLocation().toURI(); String name= Main.class.getPackage().getName()+".jar"; String path2 = path.getRawPath(); path2=path2.substring(1); if (path2.contains(".jar")) { path2=path2.replace(name, ""); } return path2;}
String folder = MyClassName.class.getProtectionDomain().getCodeSource().getLocation().getPath();
File test = new File(folder); if(file.isDirectory() && file.canRead()) {
String fold= new File(folder).getParentFile().getPath() File test = new File(fold);
URL applicationRootPathURL = getClass().getProtectionDomain().getCodeSource().getLocation(); File applicationRootPath = new File(applicationRootPathURL.getPath()); File myFile; if(applicationRootPath.isDirectory()){ myFile = new File(applicationRootPath, "filename"); } else{ myFile = new File(applicationRootPath.getParentFile(), "filename"); }
String path=new java.io.File(Server.class.getProtectionDomain() .getCodeSource() .getLocation() .getPath()) .getAbsolutePath(); path=path.substring(0, path.lastIndexOf(".")); path=path+System.getProperty("java.class.path");
private String getJarFolder() { String name = this.getClass().getName().replace( String s = this.getClass().getResource("/" + name + ".class").toString(); s = s.replace( s = s.substring(0, s.indexOf(".jar")+4); s = s.substring(s.lastIndexOf( return s.substring(0, s.lastIndexOf(File.separatorChar)+1); }
String path = getBasePathForClass(Main.class); String applicationPath= new File(path + "application.jar").getAbsolutePath(); System.out.println("Directory Path is : "+applicationPath); ProcessBuilder builder = new ProcessBuilder("java", "-jar", applicationPath); builder.redirectErrorStream(true); Process process = builder.start();
/** * Returns the absolute path of the current directory in which the given * class * file is. * * @param classs * @return The absolute path of the current directory in which the class * file is. * @author GOXR3PLUS[StackOverFlow user] + bachden [StackOverFlow user] */ public static final String getBasePathForClass(Class<?> classs) { File file; String basePath = ""; boolean failed = false; try { file = new File(classs.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()); if (file.isFile() || file.getPath().endsWith(".jar") || file.getPath().endsWith(".zip")) { basePath = file.getParent(); } else { basePath = file.getPath(); } } catch (URISyntaxException ex) { failed = true; Logger.getLogger(classs.getName()).log(Level.WARNING, "Cannot firgue out base path for class with way (1): ", ex); } if (failed) { try { file = new File(classs.getClassLoader().getResource("").toURI().getPath()); basePath = file.getAbsolutePath(); } catch (URISyntaxException ex) { Logger.getLogger(classs.getName()).log(Level.WARNING, "Cannot firgue out base path for class with way (2): ", ex); } } if (basePath.endsWith(File.separator + "lib") || basePath.endsWith(File.separator + "bin") || basePath.endsWith("bin" + File.separator) || basePath.endsWith("lib" + File.separator)) { basePath = basePath.substring(0, basePath.length() - 4); } if (basePath.endsWith(File.separator + "build" + File.separator + "classes")) { basePath = basePath.substring(0, basePath.length() - 14); } if (!basePath.endsWith(File.separator)) { basePath = basePath + File.separator; } return basePath; }
private static String getJarPath() throws IOException, URISyntaxException { File f = new File(LicensingApp.class.getProtectionDomain().().getLocation().toURI()); String jarPath = f.getCanonicalPath().toString(); String jarDir = jarPath.substring( 0, jarPath.lastIndexOf( File.separator )); return jarDir; }
try { fooDir = new File(this.getClass().getClassLoader().getResource("").toURI()); } catch (URISyntaxException e) { } fooDirPath = fooDir.toString();
public static void main(String[] args) { System.out.println(findSource(MyClass.class)); System.out.println(findSource(String.class)); } public static String findSource(Class<?> clazz) { String resourceToSearch = java.net.URL location = clazz.getResource(resourceToSearch); String sourcePath = location.getPath(); return sourcePath.replace("file:", "").replace("!" + resourceToSearch, ""); }
URL path = Thread.currentThread().getContextClassLoader().getResource(""); Path p = Paths.get(path.toURI()); String location = p.toString();
String myPath = Thread.currentThread().getContextClassLoader().getResource("filename").getPath();
public class JarpathTest { public static void main(String[] args) { File jarDir = new File(ClassLoader.getSystemClassLoader().getResource(".").getPath()); System.out.println(jarDir.getAbsolutePath()); } }
String workingDir = System.getProperty("user.dir");
export JAVA_HOME="$(/usr/libexec/java_home -v 1.6)" or export JAVA_HOME="$(/usr/libexec/java_home -v 1.7)" or export JAVA_HOME="$(/usr/libexec/java_home -v 1.8)"
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_06.jdk/Contents/Home/
export JAVA_HOME8=`/usr/libexec/java_home --version 1.8` export JAVA_HOME9=`/usr/libexec/java_home --version 9`
export JAVA_HOME=$JAVA_HOME8 export PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME=`/System/Library/Frameworks/JavaVM.framework/Versions/Current/commands/java_home`
export JAVA_HOME = "/Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home"
/System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Home
export JAVA6_HOME=`/usr/libexec/java_home -v 1.6` export JAVA7_HOME=`/usr/libexec/java_home -v 1.7` export JAVA_HOME=$JAVA6_HOME
$JAVA_HOME/bin/java -version java version "11.0.1" 2018-10-16 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.1+13-LTS) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.1+13-LTS, mixed mode)
function setjdk() { if [ $ removeFromPath if [ -n "${JAVA_HOME+x}" ]; then removeFromPath $JAVA_HOME fi export JAVA_HOME=`/usr/libexec/java_home -v $@` export PATH=$JAVA_HOME/bin:$PATH fi } function removeFromPath() { export PATH=$(echo $PATH | sed -E -e "s;:$1;;" -e "s;$1:?;;") } setjdk 1.7
$ ls -ltar /usr/bin/java /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java JAVA_HOME /Library/Java/JavaVirtualMachines/jdk1.7.0_xx.jdk/Contents/Home
/Applications/NetBeans/NetBeans 8.2.app/Contents/Resources/NetBeans/etc/netbeans.conf
netbeans_jdkhome="/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home"
Calendar c = ...; String s = String.format("Duke String s2 = String.format("Use %%n as a platform independent newline.%n");
StringBuilder newLine=new StringBuilder(); newLine.append("abc"); newline.append(System.getProperty("line.separator")); newline.append("def"); String output=newline.toString();
String separator = System.getProperty( "line.separator" ); StringBuilder lines = new StringBuilder( line1 ); lines.append( separator ); lines.append( line2 ); lines.append( separator ); String result = lines.toString( );
if (param == null) { throw new IllegalArgumentException("param cannot be null."); }
public void someMethod(Object mustNotBeNull) { if (mustNotBeNull == null) { throw new NullPointerException("mustNotBeNull must not be null"); } }
if( variable == null ) throw new IllegalArgumentException("The object
Foo(String string, List<?> list) { checkArgument(string.length() > 0); this.string = string; this.list = list; }
throw new IllegalArgumentException(new NullPointerException(NULL_ARGUMENT_IN_METHOD_BAD_BOY_BAD));
jInternalFrame.setSize(300,150); jInternalFrame.setVisible(true);
import org.apache.commons.cli.*; public class Main { public static void main(String[] args) throws Exception { Options options = new Options(); Option input = new Option("i", "input", true, "input file path"); input.setRequired(true); options.addOption(input); Option output = new Option("o", "output", true, "output file"); output.setRequired(true); options.addOption(output); CommandLineParser parser = new DefaultParser(); HelpFormatter formatter = new HelpFormatter(); CommandLine cmd; try { cmd = parser.parse(options, args); } catch (ParseException e) { System.out.println(e.getMessage()); formatter.printHelp("utility-name", options); System.exit(1); } String inputFilePath = cmd.getOptionValue("input"); String outputFilePath = cmd.getOptionValue("output"); System.out.println(inputFilePath); System.out.println(outputFilePath); } }
$> java -jar target/my-utility.jar -i asd Missing required option: o usage: utility-name -i,--input <arg> input file path -o,--output <arg> output file
maven_jar( name = "com_github_pcj_google_options", artifact = "com.github.pcj:google-options:jar:1.0.0", sha1 = "85d54fe6771e5ff0d54827b0a3315c3e12fdd0c7", )
<dependency> <groupId>com.github.pcj</groupId> <artifactId>google-options</artifactId> <version>1.0.0</version> </dependency>
package example; import com.google.devtools.common.options.Option; import com.google.devtools.common.options.OptionsBase; import java.util.List; /** * Command-line options definition for example server. */ public class ServerOptions extends OptionsBase { @Option( name = "help", abbrev = help = "Prints usage info.", defaultValue = "true" ) public boolean help; @Option( name = "host", abbrev = help = "The server host.", category = "startup", defaultValue = "" ) public String host; @Option( name = "port", abbrev = help = "The server port.", category = "startup", defaultValue = "8080" ) public int port; @Option( name = "dir", abbrev = help = "Name of directory to serve static files.", category = "startup", allowMultiple = true, defaultValue = "" ) public List<String> dirs; }
package example; import com.google.devtools.common.options.OptionsParser; import java.util.Collections; public class Server { public static void main(String[] args) { OptionsParser parser = OptionsParser.newOptionsParser(ServerOptions.class); parser.parseAndExitUponError(args); ServerOptions options = parser.getOptions(ServerOptions.class); if (options.host.isEmpty() || options.port < 0 || options.dirs.isEmpty()) { printUsage(parser); return; } System.out.format("Starting server at %s:%d...\n", options.host, options.port); for (String dirname : options.dirs) { System.out.format("\\--> Serving static files at <%s>\n", dirname); } } private static void printUsage(OptionsParser parser) { System.out.println("Usage: java -jar server.jar OPTIONS"); System.out.println(parser.describeOptions(Collections.<String, String>emptyMap(), OptionsParser.HelpVerbosity.LONG)); } }
Map<String, String> argsMap = new HashMap<>(); for (String arg: args) { String[] parts = arg.split("="); argsMap.put(parts[0], parts[1]); }
public static void main(String[] args) { String usage = "--day|-d day --mon|-m month [--year|-y year][--dir|-ds directoriesToSearch]"; ArgumentParser argParser = new ArgumentParser(usage, InputData.class); InputData inputData = (InputData) argParser.parse(args); showData(inputData); new StatsGenerator().generateStats(inputData); }
maven_jar( name = "com_google_guava_guava", artifact = "com.google.guava:guava:19.0", server = "maven2_server", ) maven_jar( name = "com_github_pcj_google_options", artifact = "com.github.pcj:google-options:jar:1.0.0", server = "maven2_server", ) maven_server( name = "maven2_server", url = "http: )
bazel run path/to/your:project -- --var1 something --var2 something -v something
protected boolean displaySensitiveInformation() { return false; }
protected boolean displaySensitiveInformation(Context context) { return true; }
someUIComponent.addMouseListener(new MouseAdapter(){ public void mouseEntered() { ...do something... } });
public class Bigram { private final char first; private final char second; public Bigram(char first, char second) { this.first = first; this.second = second; } public boolean equals(Bigram b) { return b.first == first && b.second == second; } public int hashCode() { return 31 * first + second; } public static void main(String[] args) { Set<Bigram> s = new HashSet<Bigram>(); for (int i = 0; i < 10; i++) for (char ch = s.add(new Bigram(ch, ch)); System.out.println(s.size()); } }
public class NotImplementedException extends RuntimeException { private static final long serialVersionUID = 1L; public NotImplementedException(){} }
public class NotYetImplementedException extends RuntimeException { /** * @deprecated Deprecated to remind you to implement the corresponding code * before releasing the software. */ @Deprecated public NotYetImplementedException() { } /** * @deprecated Deprecated to remind you to implement the corresponding code * before releasing the software. */ @Deprecated public NotYetImplementedException(String message) { super(message); } }
${:import(org.slf4j.Logger,org.slf4j.LoggerFactory)} private static final Logger LOG = LoggerFactory.getLogger(${enclosing_type}.class);
${:import(org.apache.logging.log4j.LogManager,org.apache.logging.log4j.Logger)} private static final Logger LOG = LogManager.getLogger(${enclosing_type}.class);
${:import(org.apache.log4j.Logger)} private static final Logger LOG = Logger.getLogger(${enclosing_type}.class);
${:import(java.util.logging.Logger)} private static final Logger LOG = Logger.getLogger(${enclosing_type}.class.getName());
${:import(java.io.BufferedReader, java.io.FileNotFoundException, java.io.FileReader, java.io.IOException)} BufferedReader in = null; try { in = new BufferedReader(new FileReader(${fileName})); String line; while ((line = in.readLine()) != null) { ${process} } } catch (FileNotFoundException e) { logger.error(e) ; } catch (IOException e) { logger.error(e) ; } finally { if(in != null) in.close(); } ${cursor}
${:import(java.nio.file.Files, java.nio.file.Paths, java.nio.charset.Charset, java.io.IOException, java.io.BufferedReader)} try (BufferedReader in = Files.newBufferedReader(Paths.get(${fileName:var(String)}), Charset.forName("UTF-8"))) { String line = null; while ((line = in.readLine()) != null) { ${cursor} } } catch (IOException e) { }
${:import(java.text.MessageFormat)} MessageFormat.format(${word_selection}, ${cursor})
${lock}.acquire(); try { ${line_selection} ${cursor} } finally { ${lock}.release(); }
static enum Singleton { INSTANCE; private static final ${enclosing_type} singleton = new ${enclosing_type}(); public ${enclosing_type} getSingleton() { return singleton; } } ${cursor}
${type} ${newName} = ${type}.Singleton.INSTANCE.getSingleton();
${:import(java.util.Map.Entry)} for (Entry<${keyType:argType(map, 0)}, ${valueType:argType(map, 1)}> ${entry} : ${map:var(java.util.Map)}.entrySet()) { ${keyType} ${key} = ${entry}.getKey(); ${valueType} ${value} = ${entry}.getValue(); ${cursor} }
for (Entry<String, String> entry : properties.entrySet()) { String key = entry.getKey(); String value = entry.getValue(); | }
private static Log log = LogFactory.getLog(${enclosing_type}.class);
${:import(org.mockito.Mock)}@Mock ${Type} ${mockName};
${:import(org.mockito.invocation.InvocationOnMock,org.mockito.stubbing.Answer)} doThrow(${RuntimeException}.class).when(${mock:localVar}).${mockedMethod}(${args});
${:import(org.mockito.invocation.InvocationOnMock,org.mockito.stubbing.Answer)}doAnswer(new Answer<Object>() { public Object answer(InvocationOnMock invocation) throws Throwable { Object arg1 = invocation.getArguments()[0]; return null; } }).when(${mock:localVar}).${mockedMethod}(${args});
${:importStatic(org.mockito.Mockito.verify,org.mockito.Mockito.times)} verify(${mock:localVar}, times(1)).${mockMethod}(${args});
${:importStatic(org.mockito.Mockito.verify,org.mockito.Mockito.never)}verify(${mock:localVar}, never()).${mockMethod}(${args});
${import:import(java.util.List,com.google.common.collect.Lists)}List<${T}> ${newName} = Lists.newLinkedList();
package ${enclosing_package}; import org.junit.*; import static org.junit.Assert.*; import static org.hamcrest.Matchers.*; import static org.mockito.Matchers.*; import static org.mockito.Mockito.*; import org.mockito.Mockito; import org.slf4j.Logger; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner; import org.junit.runner.RunWith; @RunWith(MockitoJUnitRunner.class) public class ${primary_type_name} { @InjectMocks protected ${testedType} ${testedInstance}; ${cursor} @Mock protected Logger logger; @Before public void setup() throws Exception { } @Test public void shouldXXX() throws Exception { fail("Not implemented."); } }
if( ${word_selection} != null ){ ${cursor} } if( ${word_selection} == null ){ ${cursor} }
for (${iterable_type} ${iterable_element} : ${iterable}) { ${cursor} }
System.out.println("${enclosing_type}.${enclosing_method}()");
private static final ${type} ${name} = new ${type} ${cursor};
throw new IllegalArgumentException("Invalid ${var} " + ${var});
/** * Code Review: Low Importance * * * TODO: Insert problem with code here * */
${imp:import(org.slf4j.Logger,org.slf4j.LoggerFactory)} private static final Logger LOGGER = LoggerFactory .getLogger(${enclosing_type}.class);
private ${Type} ${property}; public ${Type} get${Property}() { return ${property}; } public void set${Property}(${Type} ${property}) { ${propertyChangeSupport}.firePropertyChange("${property}", this.${property}, this.${property} = ${property}); }
private PropertyChangeSupport ${propertyChangeSupport} = new PropertyChangeSupport(this);${:import(java.beans.PropertyChangeSupport,java.beans.PropertyChangeListener)} public void addPropertyChangeListener(PropertyChangeListener listener) { ${propertyChangeSupport}.addPropertyChangeListener(listener); } public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) { ${propertyChangeSupport}.addPropertyChangeListener(propertyName, listener); } public void removePropertyChangeListener(PropertyChangeListener listener) { ${propertyChangeSupport}.removePropertyChangeListener(listener); } public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) { ${propertyChangeSupport}.removePropertyChangeListener(propertyName, listener); }
private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
${:import(javax.swing.SwingUtilities)} SwingUtilities.invokeLater(new Runnable() { @Override public void run() { ${cursor} } });
Display.getCurrent().getSystemColor(SWT.COLOR_${cursor})
PlatformUI.getWorkbench().getDisplay().syncExec(new Runnable(){ public void run(){ ${line_selection}${cursor} } });
/** * The shared instance. */ private static ${enclosing_type} instance = new ${enclosing_type}(); /** * Private constructor. */ private ${enclosing_type}() { super(); } /** * Returns this shared instance. * * @returns The shared instance */ public static ${enclosing_type} getInstance() { return instance; }
${:import(org.apache.commons.lang.builder.EqualsBuilder,org.apache.commons.lang.builder.HashCodeBuilder)} @Override public boolean equals(Object obj) { return EqualsBuilder.reflectionEquals(this, obj); } @Override public int hashCode() { return HashCodeBuilder.reflectionHashCode(this); }
${:import(java.util.List, java.util.LinkedList, java.util.EventListener, java.util.EventObject)} private final List<${eventname}Listener> ${eventname}Listeners = new LinkedList<${eventname}Listener>(); public final void add${eventname}Listener(${eventname}Listener listener) { synchronized(${eventname}Listeners) { ${eventname}Listeners.add(listener); } } public final void remove${eventname}Listener(${eventname}Listener listener) { synchronized(${eventname}Listeners) { ${eventname}Listeners.remove(listener); } } private void raise${eventname}Event(${eventname}Args args) { synchronized(${eventname}Listeners) { for(${eventname}Listener listener : ${eventname}Listeners) listener.on${eventname}(args); } } public interface ${eventname}Listener extends EventListener { public void on${eventname}(${eventname}Args args); } public class ${eventname}Args extends EventObject { public ${eventname}Args(Object source${cursor}) { super(source); } }
@Test public void should${CheckThisAndThat}() { Assert.fail("Not yet implemented"); ${cursor} }${:import(org.junit.Test, org.junit.Assert)}
${:import(org.springframework.beans.factory.annotation.Autowired)} private ${class_to_inject} ${var_name}; @Autowired public void set${class_to_inject}(${class_to_inject} ${var_name}) { this.${var_name} = ${var_name}; } public ${class_to_inject} get${class_to_inject}() { return this.${var_name}; }
@SuppressWarnings("unused") private ${enclosing_type}() { throw new AssertionError(); }
/** * ${cursor}TODO Auto-generated Exception */ public class ${Name}Exception extends Exception { /** * TODO Auto-generated Default Serial Version UID */ private static final long serialVersionUID = 1L; /** * @see Exception */ public ${Name}Exception() { super(); } /** * @see Exception */ public ${Name}Exception(String message) { super(message); } /** * @see Exception */ public ${Name}Exception(Throwable cause) { super(cause); } /** * @see Exception */ public ${Name}Exception(String message, Throwable cause) { super(message, cause); } }
if (${varName} == null) { throw new NullPointerException( "Illegal argument. The argument cannot be null: ${varName}"); }
if (${varName} == null) { throw new NullPointerException( "Illegal argument. The argument cannot be null: ${varName}"); } ${varName} = ${varName}.trim(); if (${varName}.isEmpty()) { throw new IllegalArgumentException( "Illegal argument. The argument cannot be an empty string: ${varName}"); }
if (${varName} == null) { throw new NullPointerException( "Illegal argument. The argument cannot be null: ${varName}"); } if (${varName}.trim().isEmpty()) { throw new IllegalArgumentException( "Illegal argument. The argument cannot be an empty string: ${varName}"); }
if (${varName} == null) { throw new IllegalStateException( "Illegal state. The variable or class field cannot be null: ${varName}"); }
if (${varName} == null) { throw new IllegalStateException( "Illegal state. The variable or class field cannot be null: ${varName}"); } ${varName} = ${varName}.trim(); if (${varName}.isEmpty()) { throw new IllegalStateException( "Illegal state. The variable or class field " + "cannot be an empty string: ${varName}"); }
if (!(${varName} ${testExpression})) { throw new IllegalArgumentException( "Illegal argument. The argument ${varName} (" + ${varName} + ") " + "did not pass the test: ${varName} ${testExpression}"); }
public void copy(String[] from, String[] to) { if (!(from.length == to.length)) { throw new IllegalArgumentException( "Illegal argument. The argument from.length (" + from.length + ") " + "did not pass the test: from.length == to.length"); } }
String msg = "${message}"; Object[] params = {${params}}; MessageFormat.format(msg, params);
if(logger.isDebugEnabled()){ String msg = "${message}"; Object[] params = {${params}}; logger.debug(MessageFormat.format(msg, params)); }
Method to set the <code>I${enclosing_type}</code> implementation that this class will use. * * @param ${enclosing_method_arguments}<code>I${enclosing_type}</code> instance
java.io.FileOutputStream fos = new java.io.FileOutputStream( new java.io.File("c:\\x.x")); fos.write(buffer.toString().getBytes()); fos.flush(); fos.close();
public class Animal { private Map<String,Animal> friends = new HashMap<>(); public void addFriend(String name, Animal animal){ friends.put(name,animal); } public Animal callFriend(String name){ return friends.get(name); } }
Mouse jerry = new Mouse(); jerry.addFriend("spike", new Dog()); jerry.addFriend("quacker", new Duck()); ((Dog) jerry.callFriend("spike")).bark(); ((Duck) jerry.callFriend("quacker")).quack();
jerry.callFriend("spike").bark(); jerry.callFriend("quacker").quack();
public<T extends Animal> T callFriend(String name, T unusedTypeObj){ return (T)friends.get(name); }
public <T extends Animal> T callFriend(String name, Class<T> type) { return type.cast(friends.get(name)); }
jerry.callFriend("spike", Dog.class).bark(); jerry.callFriend("quacker", Duck.class).quack();
jerry.addFriend("quaker", new Duck()); jerry.callFriend("quaker", new Dog());
Mouse jerry = new Mouse(); jerry.addFriend("spike", new Dog()); jerry.addFriend("quacker", new Duck()); jerry.callFriend("spike").talk(); jerry.callFriend("quacker").talk();
@SuppressWarnings("unchecked") public <T extends Animal> T callFriend(String name) { return (T)friends.get(name); }
public <T extends Animal> void addFriend(String name, Class<T> type, T animal); public <T extends Animal> T callFriend(String name, Class<T> type);
public <T extends Animal> T callFriend(String name, Class<T> clazz) { return (T) friends.get(name); }
jerry.callFriend("spike", Dog.class).bark(); jerry.callFriend("quacker", Duck.class).quack();
public abstract class TypedID<T extends Animal> { public final Type type; public final String id; protected TypedID(String id) { this.id = id; Type superclass = getClass().getGenericSuperclass(); if (superclass instanceof Class) { throw new RuntimeException("Missing type parameter."); } this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0]; } }
Mouse jerry = new Mouse(); TypedID<Dog> spike = new TypedID<Dog>("spike") {}; TypedID<Duck> quacker = new TypedID<Duck>("quacker") {}; jerry.addFriend(spike, new Dog()); jerry.addFriend(quacker, new Duck());
jerry.callFriend(spike).bark(); jerry.callFriend(quacker).quack();
public <T> T callFriend(String name) { return (T) friends.get(name); }
public class Test { public static class Animal { private Map<String,Animal> friends = new HashMap<>(); public void addFriend(String name, Animal animal){ friends.put(name,animal); } public <T> T callFriend(String name){ return (T) friends.get(name); } } public static class Dog extends Animal { public void bark() { System.out.println("i am dog"); } } public static class Duck extends Animal { public void quack() { System.out.println("i am duck"); } } public static void main(String [] args) { Animal animals = new Animal(); animals.addFriend("dog", new Dog()); animals.addFriend("duck", new Duck()); Dog dog = animals.callFriend("dog"); dog.bark(); Duck duck = animals.callFriend("duck"); duck.quack(); } }
abstract public class Animal implements Visitable { private Map<String,Animal> friends = new HashMap<String,Animal>(); public void addFriend(String name, Animal animal){ friends.put(name,animal); } public Animal callFriend(String name){ return friends.get(name); } }
public interface Visitable { void accept(Visitor v); }
public interface Visitor { void visit(Dog d); void visit(Duck d); void visit(Mouse m); }
public class Dog extends Animal { public void bark() {} @Override public void accept(Visitor v) { v.visit(this); } }
public class Example implements Visitor { public void main() { Mouse jerry = new Mouse(); jerry.addFriend("spike", new Dog()); jerry.addFriend("quacker", new Duck()); jerry.callFriend("spike").accept(this); jerry.callFriend("quacker").accept(this); } @Override public void visit(Dog d) { d.bark(); } @Override public void visit(Duck d) { d.quack(); } @Override public void visit(Mouse m) { m.squeak(); } }
using System; using System.Collections.Generic; using System.Reflection; namespace GenericsTest { class MainClass { public static void Main (string[] args) { _HasFriends jerry = new Mouse(); jerry.AddFriend("spike", new Dog()); jerry.AddFriend("quacker", new Duck()); jerry.CallFriend<_Animal>("spike").Speak(); jerry.CallFriend<_Animal>("quacker").Speak(); } } interface _HasFriends { void AddFriend(string name, _Animal animal); T CallFriend<T>(string name) where T : _Animal; } interface _Animal { void Speak(); } abstract class AnimalBase : _Animal, _HasFriends { private Dictionary<string, _Animal> friends = new Dictionary<string, _Animal>(); public abstract void Speak(); public void AddFriend(string name, _Animal animal) { friends.Add(name, animal); } public T CallFriend<T>(string name) where T : _Animal { return (T) friends[name]; } } class Mouse : AnimalBase { public override void Speak() { Squeek(); } private void Squeek() { Console.WriteLine ("Squeek! Squeek!"); } } class Dog : AnimalBase { public override void Speak() { Bark(); } private void Bark() { Console.WriteLine ("Woof!"); } } class Duck : AnimalBase { public override void Speak() { Quack(); } private void Quack() { Console.WriteLine ("Quack! Quack!"); } } }
public <T extends MobilePage> T tapSignInButton(Class<T> type) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { return type.getConstructor(AppiumDriver.class).newInstance(appiumDriver); }
public <T extends MobilePage> T tapSignInButton(Class<T> type) { T returnValue = null; try { returnValue = type.getConstructor(AppiumDriver.class).newInstance(appiumDriver); } catch (Exception e) { e.printStackTrace(); } return returnValue; }
import java.lang.reflect.InvocationTargetException; import java.util.HashMap; import java.util.Map; abstract class AnimalExample { private Map<String,Class<?>> friends = new HashMap<String,Class<?>>(); private Map<String,Object> theFriends = new HashMap<String,Object>(); public void addFriend(String name, Object friend){ friends.put(name,friend.getClass()); theFriends.put(name, friend); } public void makeMyFriendSpeak(String name){ try { friends.get(name).getMethod("speak").invoke(theFriends.get(name)); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } } public abstract void speak (); }; class Dog extends Animal { public void speak () { System.out.println("woof!"); } } class Duck extends Animal { public void speak () { System.out.println("quack!"); } } class Cat extends Animal { public void speak () { System.out.println("miauu!"); } } public class AnimalExample { public static void main (String [] args) { Cat felix = new Cat (); felix.addFriend("Spike", new Dog()); felix.addFriend("Donald", new Duck()); felix.makeMyFriendSpeak("Spike"); felix.makeMyFriendSpeak("Donald"); } }
public class Animal { private Map<String,<T extends Animal>> friends = new HashMap<String,<T extends Animal>>(); public <T extends Animal> void addFriend(String name, T animal){ friends.put(name,animal); } public <T extends Animal> T callFriend(String name){ return friends.get(name); }
public class Actor<SELF extends Actor> { public SELF self() { return (SELF)_self; } }
public class MyHttpAppSession extends Actor<MyHttpAppSession> { ... }
public <X,Y> X nextRow(Y cursor) { return (X) getRow(cursor); } private <T> Person getRow(T cursor) { Cursor c = (Cursor) cursor; Person s = null; if (!c.moveToNext()) { c.close(); } else { String id = c.getString(c.getColumnIndex("id")); String name = c.getString(c.getColumnIndex("name")); s = new Person(); s.setId(id); s.setName(name); } return s; }
String dt = "2008-01-01"; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Calendar c = Calendar.getInstance(); c.setTime(sdf.parse(dt)); c.add(Calendar.DATE, 1); dt = sdf.format(c.getTime());
public class DateUtil { public static Date addDays(Date date, int days) { Calendar cal = Calendar.getInstance(); cal.setTime(date); cal.add(Calendar.DATE, days); return cal.getTime(); } }
String sourceDate = "2012-02-29"; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); Date myDate = format.parse(sourceDate); myDate = DateUtil.addDays(myDate, 1);
import java.time.LocalDate; public class DateIncrementer { static public String addOneDay(String date) { return LocalDate.parse(date).plusDays(1).toString(); } }
SimpleDateFormat dateFormat = new SimpleDateFormat( "yyyy-MM-dd" ); Calendar cal = Calendar.getInstance(); cal.setTime( dateFormat.parse( inputString ) ); cal.add( Calendar.DATE, 1 );
DateTimeFormatter parser = ISODateTimeFormat.date(); DateTime date = parser.parseDateTime(dateString); String nextDay = parser.print(date.plusDays(1));
LocalDate januaryFirst = LocalDate.parse("2014-01-01"); LocalDate januarySecond = januaryFirst.plusDays(1);
Calendar cal = Calendar.getInstance(); cal.setTime(yourDate); cal.add(Calendar.DATE, 1); yourDate = cal.getTime();
Date today = new Date(); SimpleDateFormat formattedDate = new SimpleDateFormat("yyyyMMdd"); Calendar c = Calendar.getInstance(); c.add(Calendar.DATE, 1); String tomorrow = (String)(formattedDate.format(c.getTime())); System.out.println("Tomorrows date is " + tomorrow);
LocalDate sourceDate = LocalDate.of(2017, Month.MAY, 27); LocalDate destDate = sourceDate.plusDays(1); DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); String destDate = destDate.format(formatter));
String sourceDate = "2017-05-27"; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Calendar calendar = Calendar.getInstance(); calendar.setTime(sdf.parse(sourceDate)); calendar.add(Calendar.DATE, 1); String destDate = sdf.format(calendar.getTime());
long timeadj = 24*60*60*1000; Date newDate = new Date (oldDate.getTime ()+timeadj);
SimpleDateFormat dateFormat = new SimpleDateFormat( "yyyy-MM-dd" ); Date day = dateFormat.parse(string); Date dayAfter = new Date(day.getTime() + TimeUnit.DAYS.toMillis(1));
private String getNextDate(String givenDate,int noOfDays) { SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); Calendar cal = Calendar.getInstance(); String nextDaysDate = null; try { cal.setTime(dateFormat.parse(givenDate)); cal.add(Calendar.DATE, noOfDays); nextDaysDate = dateFormat.format(cal.getTime()); } catch (ParseException ex) { Logger.getLogger(GR_TravelRepublic.class.getName()).log(Level.SEVERE, null, ex); }finally{ dateFormat = null; cal = null; } return nextDaysDate; }
SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat("yyyy-MM-dd"); Calendar cal = Calendar.getInstance(); cal.set(1970,Calendar.DECEMBER,31); System.out.println(simpleDateFormat1.format(cal.getTime())); cal.add(Calendar.DATE, 1); System.out.println(simpleDateFormat1.format(cal.getTime())); cal.add(Calendar.DATE, -1); System.out.println(simpleDateFormat1.format(cal.getTime()));
LocalDate parsedDate = LocalDate.parse("2015-10-30"); LocalDate addedDate = parsedDate.plusDays(1);
Date date = Date.from(addedDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
String str = addedDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
Date.from(Instant.now().plusSeconds(SECONDS_PER_DAY))
Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getTime()); calendar.add(Calendar.DATE, 1);
public String nextDate(String date){ LocalDate parsedDate = LocalDate.parse(date); LocalDate addedDate = parsedDate.plusDays(1); DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-mm-dd"); return addedDate.format(formatter); }
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date myNewDate = DateUtils.addDays(myDate, 4); Date yesterday = DateUtils.addDays(myDate, -1); String formatedDate = sdf.format(myNewDate);
Date _now = new Date(); Instant _instant = _now.toInstant().minus(5, ChronoUnit.DAYS); Date _newDate = Date.from(_instant);
Date newDate = new Date(); newDate.setDate(newDate.getDate()+1); System.out.println(newDate);
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._
for (int i = 0; i < list.size(); i++) { E element = list.get(i); }
for (Iterator<E> iter = list.iterator(); iter.hasNext(); ) { E element = iter.next(); }
for (ListIterator<E> iter = list.listIterator(); iter.hasNext(); ) { E element = iter.next(); }
Arrays.asList(1,2,3,4).forEach(System.out::println); Arrays.asList(1,2,3,4).stream().forEach(System.out::println);
import java.util.*; public class ListIterationExample { public static void main(String []args){ List<Integer> numbers = new ArrayList<Integer>(); for (Integer i : Arrays.asList(0,1,2,3,4,5,6,7)) numbers.add(i); printList(numbers); for (int index=0; index < numbers.size(); index++) { numbers.set(index, numbers.get(index)*2); } printList(numbers); for (Integer number : numbers) { number++; } printList(numbers); for (Iterator<Integer> iter = numbers.iterator(); iter.hasNext(); ) { Integer number = iter.next(); number++; } printList(numbers); for (ListIterator<Integer> iter = numbers.listIterator(); iter.hasNext(); ) { Integer number = iter.next(); iter.add(number+1); } printList(numbers); for (Iterator<Integer> iter = numbers.iterator(); iter.hasNext(); ) { Integer number = iter.next(); if (number % 2 == 0) iter.remove(); } printList(numbers); for (ListIterator<Integer> iter = numbers.listIterator(); iter.hasNext(); ) { Integer number = iter.next(); iter.set(number/2); } printList(numbers); } public static void printList(List<Integer> numbers) { StringBuilder sb = new StringBuilder(); for (Integer number : numbers) { sb.append(number); sb.append(","); } sb.deleteCharAt(sb.length()-1); System.out.println(sb.toString()); } }
public class IterationDemo { public static void main(String[] args) { List<Integer> list = Arrays.asList(1, 2, 3); list.stream().forEach(elem -> System.out.println("element " + elem)); } }
Arrays.asList(1,2,3,4).forEach(System.out::println);
Arrays.asList(1,2,3,4).stream().forEach(System.out::println); Arrays.asList(1,2,3,4).stream().forEachOrdered(System.out::println);
Arrays.asList(1,2,3,4).parallelStream().forEach(System.out::println);
List<E> sl= list ; while( ! sl.empty() ) { E element= sl.get(0) ; ..... sl= sl.subList(1,sl.size()); }
void visit(List<E> list) { if( list.isEmpty() ) return; E element= list.get(0) ; .... visit(list.subList(1,list.size())); }
void visit(List<E> list,int pos) { if( pos >= list.size() ) return; E element= list.get(pos) ; .... visit(list,pos+1); }
List<String> nameList = new ArrayList<>( Arrays.asList("USA", "USSR", "UK")); nameList.forEach((v) -> System.out.println(v));
for (ListIterator<SomeClass> iterator = list.listIterator(list.size()); iterator.hasPrevious();) { SomeClass item = iterator.previous(); ... item.remove(); }
import java.util.ArrayList; import java.util.List; public class TestA { public static void main(String[] args) { List<String> list = new ArrayList<String>(); list.add("Apple"); list.add("Orange"); list.add("Banana"); list.forEach( (name) -> { System.out.println(name); } ); } }
int i = 0; do{ E element = list.get(i); i++; } while (i < list.size());
js>["Bill","Bob","Steve"].join(" and ") Bill and Bob and Steve
static public String join(List<String> list, String conjunction) { StringBuilder sb = new StringBuilder(); boolean first = true; for (String item : list) { if (first) first = false; else sb.append(conjunction); sb.append(item); } return sb.toString(); }
List<String> list = Arrays.asList("foo", "bar", "baz"); String joined = String.join(" and ", list);
List<Person> list = Arrays.asList( new Person("John", "Smith"), new Person("Anna", "Martinez"), new Person("Paul", "Watson ") ); String joinedFirstNames = list.stream() .map(Person::getFirstName) .collect(Collectors.joining(", "));
Joiner.on(" and ").useForNull("[unknown]").join(names);
Map<String, Integer> ages = .....; String foo = Joiner.on(", ").withKeyValueSeparator(" is ").join(ages);
org.apache.commons.lang.StringUtils.join(list, conjunction);
org.springframework.util.StringUtils.collectionToDelimitedString(list, conjunction);
List<String> list = Arrays.asList("Alice", "Bob", "Charlie") String result = String.join(" and ", list); result = list.stream().collect(Collectors.joining(" and ")); result = list.stream().reduce((t, u) -> t + " and " + u).orElse("");
Arrays.asList("Bill", "Bob", "Steve").stream() .collect(Collectors.joining(" and "));
String.join(" and ", Arrays.asList("Bill", "Bob", "Steve"));
public static String join(Collection<?> col, String delim) { StringBuilder sb = new StringBuilder(); Iterator<?> iter = col.iterator(); if (iter.hasNext()) sb.append(iter.next().toString()); while (iter.hasNext()) { sb.append(delim); sb.append(iter.next().toString()); } return sb.toString(); }
public static String join(List<?> list, String delim) { int len = list.size(); if (len == 0) return ""; StringBuilder sb = new StringBuilder(list.get(0).toString()); for (int i = 1; i < len; i++) { sb.append(delim); sb.append(list.get(i).toString()); } return sb.toString(); }
<?xml version="1.0" encoding="UTF-8"?> <taglib version="2.1" xmlns="http: <function> <name>join</name> <function-class>com.core.util.ReportUtil</function-class> <function-signature>java.lang.String join(java.util.List, java.lang.String)</function-signature> </function> </taglib>
<%@taglib prefix="funnyFmt" uri="tag:com.core.util,2013:funnyFmt"%> ${funnyFmt:join(books, ", ")}
List<String> list = Arrays.asList("Bill", "Bob", "Steve"); String joinedResult = StringUtils.join(list, " and ");
public static String join(String join, String... strings) { if (strings == null || strings.length == 0) { return ""; } else if (strings.length == 1) { return strings[0]; } else { StringBuilder sb = new StringBuilder(); sb.append(strings[0]); for (int i = 1; i < strings.length; i++) { sb.append(join).append(strings[i]); } return sb.toString(); } }
String[] array = new String[] { "7, 7, 7", "Bill", "Bob", "Steve", "[Bill]", "1,2,3", "Apple ][","~,~" }; String joined; joined = join(" and ","7, 7, 7", "Bill", "Bob", "Steve", "[Bill]", "1,2,3", "Apple ][","~,~"); joined = join(" and ", array); System.out.println(joined);
StringJoiner sj = new StringJoiner(" and ", "" , ""); String[] names = {"Bill", "Bob", "Steve"}; for (String name : names) { sj.add(name); } System.out.println(sj);
String aToString = java.util.Arrays.toString(anArray); aToString = aToString.substring(1, aToString.length() - 1);
String aToString = java.util.Arrays.toString(anArray).substring(1).replaceAll("\\]$", "");
String[] array = new String[] { "Bill", "Bob", "Steve","[Bill]","1,2,3","Apple ][" }; String join = " and "; String joined = Arrays.toString(array).replaceAll(", ", join) .replaceAll("(^\\[)|(\\]$)", ""); System.out.println(joined);
String[] array = new String[] { "7, 7, 7","Bill", "Bob", "Steve", "[Bill]", "1,2,3", "Apple ][" }; String join = " and "; for (int i = 0; i < array.length; i++) array[i] = array[i].replaceAll(", ", "~,~"); String joined = Arrays.toString(array).replaceAll(", ", join) .replaceAll("(^\\[)|(\\]$)", "").replaceAll("~,~", ", "); System.out.println(joined);
List<String> list = Arrays.asList("Bill", "Bob", "Steve"); String string = ListAdapter.adapt(list).makeString(" and "); Assert.assertEquals("Bill and Bob and Steve", string);
MutableList<String> list = Lists.mutable.with("Bill", "Bob", "Steve"); String string = list.makeString(" and ");
Assert.assertEquals( "Bill, Bob, Steve", Lists.mutable.with("Bill", "Bob", "Steve").makeString());
static String join( List<String> list , String replacement ) { StringBuilder b = new StringBuilder(); for( String item: list ) { b.append( replacement ).append( item ); } return b.toString().substring( replacement.length() ); }
public static String join(Iterator iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuffer buf = new StringBuffer(256); if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); }
import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; List<String> list = Arrays.asList("Bill","Bob","Steve"). String str = list.stream().collect(Collectors.joining(" and "));
Collectors.joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)
String s = stringList.stream().collect(Collectors.joining(" and ", "prefix_", "_suffix"))
/* * Copyright 2002-2017 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http: * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ public class StringUtils { public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) { if(coll == null || coll.isEmpty()) { return ""; } StringBuilder sb = new StringBuilder(); Iterator<?> it = coll.iterator(); while (it.hasNext()) { sb.append(prefix).append(it.next()).append(suffix); if (it.hasNext()) { sb.append(delim); } } return sb.toString(); } }
java.util.Arrays.toString(anArray).replaceAll(", ", ",") .replaceFirst("^\\[","").replaceFirst("\\]$","");
public static void main(String...aArguments) throws IOException { String usuario = "Jorman"; String password = "14988611"; String strDatos = "Jorman 14988611"; StringTokenizer tokens = new StringTokenizer(strDatos, " "); int nDatos = tokens.countTokens(); String[] datos = new String[nDatos]; int i = 0; while (tokens.hasMoreTokens()) { String str = tokens.nextToken(); datos[i] = str; i++; } if ((datos[0] == usuario)) { System.out.println("WORKING"); } }
String abc = "Awesome" ; String xyz = abc; if(abc == xyz) System.out.println("Refers to same string");
String abc = "Hello World"; String xyz = "Hello World"; if(abc == xyz) System.out.println("Refers to same string"); else System.out.println("Refers to different strings"); if(abc.equals(xyz)) System.out.prinln("Contents of both strings are same"); else System.out.prinln("Contents of strings are different");
new String("test").equals("test") ==> true new String("test") == "test" ==> false new String("test") == new String("test") ==> false "test" == "test" ==> true "test" == "te" + "st" ==> true "test" == "!test".substring(1) ==> false
The == operator checks if the two references point to the same object or not. .equals() checks for the actual string content (value).
Case1) String s1 = "Stack Overflow"; String s2 = "Stack Overflow"; s1 == s1; s1.equals(s2); Reason: String literals created without null are stored in the string pool in the permgen area of the heap. So both s1 and s2 point to the same object in the pool. Case2) String s1 = new String("Stack Overflow"); String s2 = new String("Stack Overflow"); s1 == s2; s1.equals(s2); Reason: If you create a String object using the `new` keyword a separate space is allocated to it on the heap.
public static void main (String... aArguments) throws IOException { String usuario = "Jorman"; String password = "14988611"; String strDatos="Jorman 14988611"; StringTokenizer tokens=new StringTokenizer(strDatos, " "); int nDatos=tokens.countTokens(); String[] datos=new String[nDatos]; int i=0; while(tokens.hasMoreTokens()) { String str=tokens.nextToken(); datos[i]= str.intern(); i++; } if(datos[0]==usuario) { System.out.println ("WORKING"); }
public static void testEquality(){ String str1 = "Hello world."; String str2 = "Hello world."; if (str1 == str2) System.out.print("str1 == str2\n"); else System.out.print("str1 != str2\n"); if(str1.equals(str2)) System.out.print("str1 equals to str2\n"); else System.out.print("str1 doesn String str3 = new String("Hello world."); String str4 = new String("Hello world."); if (str3 == str4) System.out.print("str3 == str4\n"); else System.out.print("str3 != str4\n"); if(str3.equals(str4)) System.out.print("str3 equals to str4\n"); else System.out.print("str3 doesn }
Str1 == str2 Str1 equals str2 Str3! = str4 Str3 equals str4
String s = "Test"; if(s.equals("Test")) { System.out.println("Equal"); }
public class Demo { public static void main(String[] args) { String str1 = "Jorman 14988611"; String str2 = new StringBuffer("Jorman").append(" 14988611").toString(); String str3 = str2.intern(); System.out.println("str1 == str2 " + (str1 == str2)); System.out.println("str1 == str3 " + (str1 == str3)); System.out.println("str1 equals str2 " + (str1.equals(str2))); System.out.println("str1 equals str3 " + (str1.equals(str3))); } }
string name="Harry"; string salary="25000"; string namsal="Harry 25000"; string[] s=namsal.split(" "); for(int i=0;i<s.length;i++) { System.out.println(s[i]); } if(s[0].equals("Harry")) { System.out.println("Task Complete"); }
int[] toIntArray(List<Integer> list){ int[] ret = new int[list.size()]; for(int i = 0;i < ret.length;i++) ret[i] = list.get(i); return ret; }
int[] array = list.stream().mapToInt(i->i).toArray();
List<Integer> list = ... int[] ints = Ints.toArray(list);
List<Integer> myList; ... assign and fill the list int[] intArray = ArrayUtils.toPrimitive(myList.toArray(new Integer[myList.size()]));
static final Integer[] NO_INTS = new Integer[0]; .... int[] intArray2 = ArrayUtils.toPrimitive(myList.toArray(NO_INTS));
int[] toIntArray(List<Integer> list) { int[] ret = new int[list.size()]; int i = 0; for (Integer e : list) ret[i++] = e; return ret; }
int [] ints = list.stream().mapToInt(Integer::intValue).toArray();
public int[] toIntArray(List<Integer> intList){ return intList.stream().mapToInt(Integer::intValue).toArray(); }
int[] toArray(List<Integer> list) { int[] ret = new int[ list.size() ]; int i = 0; for( Iterator<Integer> it = list.iterator(); it.hasNext(); ret[i++] = it.next() ); return ret; }
int[] arr = list.parallelStream().mapToInt(Integer::intValue).toArray();
List<Integer> list = Arrays.asList(1, 2, null, 4, 5);
int[] arr = list.parallelStream().filter(Objects::nonNull).mapToInt(Integer::intValue).toArray();
int[] arr = list.parallelStream().map(i -> i == null ? -1 : i).mapToInt(Integer::intValue).toArray();
int[] arr = list.parallelStream().mapToInt(i -> i == null ? -1 : i.intValue()).toArray();
int[] integers = new int[myList.size()]; for (int i = 0; i < integers.length; i++) { integers[i] = myList.get(i); }
int[] ret = new int[list.size()]; Iterator<Integer> iter = list.iterator(); for (int i=0; iter.hasNext(); i++) { ret[i] = iter.next(); } return ret;
import static com.humaorie.dollar.Dollar.* ... List<Integer> source = ...; int[] ints = $(source).convert().toIntArray();
List<Integer> integers = Lists.mutable.with(1, 2, 3, 4, 5); int[] ints = LazyIterate.adapt(integers).collectInt(i -> i).toArray(); Assert.assertArrayEquals(new int[]{1, 2, 3, 4, 5}, ints);
MutableList<Integer> integers = Lists.mutable.with(1, 2, 3, 4, 5); int[] ints = integers.asLazy().collectInt(i -> i).toArray(); Assert.assertArrayEquals(new int[]{1, 2, 3, 4, 5}, ints);
package mypackage; import java.util.AbstractList; import java.util.Arrays; import java.util.Collections; import java.util.List; public class Test { static List<Integer> intArrayAsList(final int[] a) { if(a == null) throw new NullPointerException(); return new AbstractList<Integer>() { @Override public Integer get(int i) { return a[i]; } @Override public Integer set(int i, Integer val) { final int old = a[i]; a[i] = val; return old; } @Override public int size() { return a.length; } }; } public static void main(final String[] args) { int[] a = {1, 2, 3, 4, 5}; Collections.reverse(intArrayAsList(a)); System.out.println(Arrays.toString(a)); } }
public static void main(String ars[]) { TransformService transformService = (inputs) -> { int[] ints = new int[inputs.size()]; int i = 0; for (Integer element : inputs) { ints[ i++ ] = element; } return ints; }; List<Integer> inputs = new ArrayList<Integer>(5) { {add(10); add(10);} }; int[] results = transformService.transform(inputs); } public interface TransformService { int[] transform(List<Integer> inputs); }
sudo add-apt-repository ppa:openjdk-r/ppa sudo apt update
sudo apt install openjdk-8-jdk sudo apt install openjdk-8-source
sudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install oracle-java7-installer
cd /usr/local tar xzf <the file you just downloaded>
export JAVA_HOME=/usr/local/jdk1.7.0_13 export PATH=$PATH:$JAVA_HOME/bin
tar -xvf ~/Downloads/jdk-7u3-linux-i586.tar.gz sudo mkdir -p /usr/lib/jvm/jdk1.7.0 sudo mv jdk1.7.0_03/* /usr/lib/jvm/jdk1.7.0/ sudo update-alternatives --install "/usr/bin/java" "java" "/usr/lib/jvm/jdk1.7.0/bin/java" 1 sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/lib/jvm/jdk1.7.0/bin/javac" 1 sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/lib/jvm/jdk1.7.0/bin/javaws" 1
JAVA_HOME=/usr/lib/jvm/jdk1.7.0 PATH=$PATH:$HOME/bin:$JAVA_HOME/bin export JAVA_HOME export PATH
sudo add-apt-repository ppa:webupd8team/java sudo apt-get update
$ sudo add-apt-repository ppa:webupd8team/java $ sudo apt-get update $ sudo apt-get install oracle-java8-installer
$ java -version java version "1.8.0_77" Java(TM) SE Runtime Environment (build 1.8.0_77-b03) Java HotSpot(TM) 64-Bit Server VM (build 25.77-b03, mixed mode)
sudo add-apt-repository "deb http: sudo apt-get update sudo apt-get install sun-java6-jre sun-java6-plugin sudo update-alternatives --config java
sudo add-apt-repository "deb http: sudo apt-get update sudo apt-get install sun-java6-jre sun-java6-plugin sudo update-alternatives --config java
sudo apt-add-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install oracle-java8-installer
sudo mv /path/to/jdk1.8.0_20 /usr/lib/jvm/oracle_jdk8
export J2SDKDIR=/usr/lib/jvm/oracle_jdk8 export J2REDIR=/usr/lib/jvm/oracle_jdk8/jre export PATH=$PATH:/usr/lib/jvm/oracle_jdk8/bin:/usr/lib/jvm/oracle_jdk8/db/bin:/usr/lib/jvm/oracle_jdk8/jre/bin export JAVA_HOME=/usr/lib/jvm/oracle_jdk8 export DERBY_HOME=/usr/lib/jvm/oracle_jdk8/db
sudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install oracle-java9-installer
su - echo "deb http: echo "deb-src http: apt-key adv --keyserver hkp: apt-get update apt-get install oracle-java9-installer exit
sudo add-apt-repository -y ppa:webupd8team/java sudo apt-get update echo debconf shared/accepted-oracle-license-v1-1 select true | sudo debconf-set-selections echo debconf shared/accepted-oracle-license-v1-1 seen true | sudo debconf-set-selections sudo apt-get -y install oracle-java8-installer java -version
sudo apt-get update sudo apt-get install default-jre sudo apt-get install default-jdk
sudo add-apt-repository ppa:linuxuprising/java sudo apt-get update sudo apt-get install oracle-java10-installer
/** * -- ex: looping through List of Map objects -- * <code> * for (int i = 0; i < list.size(); i++) { * Map map = (Map)list.get(i); * System.out.println(map.get("wordID")); * System.out.println(map.get("word")); * } * </code> * * @param query - select statement * @return List of Map objects */
-- ex: looping through List of Map objects -- for (int i = 0; i list.size(); i++) { Map map = (Map)list.get(i); System.out.println(map.get("wordID")); System.out.println(map.get("word")); } Parameters query - - select statement Returns: List of Map objects
* <pre> * {@code * Set<String> s; * System.out.println(s); * } * </pre>
/** this methods adds a specific translator from one type to another type. ` * i.e. * <pre> * <code>new BeanTranslator.Builder() * .translate( * new{@code Translator<String, Integer>}(String.class, Integer.class){ * {@literal @}Override * public Integer translate(String instance) { * return Integer.valueOf(instance); * }}) * .build(); * </code> * </pre> * @param translator */
new BeanTranslator.Builder() .translate( new Translator<String, Integer>(String.class, Integer.class){ @Override public Integer translate(String instance) { return Integer.valueOf(instance); }}) .build();
.... * is equivalent to: * <p><blockquote><pre> * char data[] = { * String str = new String(data); * </pre></blockquote><p> * Here are some more examples of how strings can be used: * <p><blockquote><pre> * System.out.println("abc"); * String cde = "cde"; * System.out.println("abc" + cde); * String c = "abc".substring(2,3); * String d = cde.substring(1, 2); * </pre></blockquote> ...
* .. * <pre> * {@code * public List<Object> getObjects() { * return objects; * } * </pre> * ..
* .. * <pre> * {@code * public List<Object> getObjects() * { * return objects; * } * </pre> * ..
* .. * <pre> * {@code * public List<Object> getObjects() * { * return objects; * } * } * </pre> * ..
public List<Object> getObjects() { return objects; } }
/** * <blockquote><pre> * {@code * public Foo(final Class<?> klass) { * super(); * this.klass = klass; * } * } * </pre></blockquote> **/
public Foo(final Class<?> klass) { super(); this.klass = klass; }
/** * test. * * <pre>{@code * <T> void test(Class<? super T> type) { * System.out.printf("hello, world\n"); * } * }</pre> */
<T> void test(Class<? super T> type) { System.out.printf("hello, world\n"); }
/** * test. * * <blockquote><pre>{@code * <T> void test(Class<? super T> type) { * System.out.printf("hello, world\n"); * } * }</pre></blockquote> */
<T> void test(Class<? super T> type) { System.out.printf("hello, world\n"); }
* <pre> * {@code * A-->B * \ * C-->D * \ \ * G E-->F * } *</pre>
* < * pre> * {@code * A-->B * \ * C-->D * \ \ * G E-->F * } * </pre>
*<p><blockquote><pre> * A-->B * \ * C-->D * \ \ * G E-->F * </pre></blockquote>
/** * Example usage: * * <pre>{@code * @Override * public void someOverriddenMethod() {
/** * Example usage: * * <pre>{@code @Override * public int someMethod() { * return 13 + 37; * } * }</pre> */
/** * Bla bla bla, for example: * * <pre> * void X() { * List{@code <String>} a = ...; * ... * } * </pre> * * @param ... * @return ... */ .... your code then goes here ...
/** * <PRE> * insert code as you would anywhere else * </PRE> */
/** * <PRE> * int onmask = SHIFT_DOWN_MASK | BUTTON1_DOWN_MASK; * int offmask = CTRL_DOWN_MASK; * if ((event.getModifiersEx() & (onmask | offmask)) == onmask) { * ... * } * </PRE> */
public class Tests { public static void main(String[] args) throws Exception { int x = 0; while(x<3) { x = x++; System.out.println(x); } } }
public class Tests extends java.lang.Object{ public Tests(); Code: 0: aload_0 1: invokespecial 4: return public static void main(java.lang.String[]) throws java.lang.Exception; Code: 0: iconst_0 1: istore_1 2: iload_1 3: iconst_3 4: if_icmpge 22 7: iload_1 8: iinc 1, 1 11: istore_1 12: getstatic 15: iload_1 16: invokevirtual 19: goto 2 22: return }
public MutableInt postIncrement(MutableInt x) { int valueBeforeIncrement = x.intValue(); x.add(1); return new MutableInt(valueBeforeIncrement); }
MutableInt x = new MutableInt(); x = postIncrement(x);
MutableInt x = new MutableInt(); MutableInt temp = postIncrement(x); x = temp;
MutableInt x = new MutableInt(); MutableInt y = new MutableInt(); MutableInt temp = postIncrement(x); y = temp;
public class Main { public static volatile int x = 0; public static void main(String[] args) { LoopingThread t = new LoopingThread(); System.out.println("Starting background thread..."); t.start(); while (true) { x = x++; } } } class LoopingThread extends Thread { public @Override void run() { while (true) { System.out.println(Main.x); } } }
class test { public static void main(String[] args) { int i=0; i=i++; } }
$ javap -c test Compiled from "test.java" class test extends java.lang.Object{ test(); Code: 0: aload_0 1: invokespecial 4: return public static void main(java.lang.String[]); Code: 0: iconst_0 1: istore_1 2: iload_1 3: iinc 1, 1 6: istore_1 7: return }
public class Autoincrement { public static void main(String[] args) { int x = 0; System.out.println(x++); System.out.println(x); } }
int x = 0; int y = 0; y = x++; System.out.println(x); System.out.println(y);
x = x++; => x = ((x = x + 1) - 1) => x = ((x + 1) - 1) => x = x;
load x increment x add y increment y store x+y to z
load x add y store x+y to z increment x increment y
int x=0; int temp=x++; System.out.println("temp = "+temp); x = temp; System.out.println("x = "+x);
@Controller public class MileageFeeController { @RequestMapping("/mileage/{miles}") @ResponseBody public float mileageFee(@PathVariable int miles) { MileageFeeCalculator calc = new MileageFeeCalculator(); return calc.mileageCharge(miles); } }
@Service public class MileageFeeCalculator { @Autowired private MileageRateService rateService; public float mileageCharge(final int miles) { return (miles * rateService.ratePerMile()); } }
@Service public class MileageRateService { public float ratePerMile() { return 0.565f; } }
java.lang.NullPointerException: null at com.chrylis.example.spring_autowired_npe.MileageFeeCalculator.mileageCharge(MileageFeeCalculator.java:13) at com.chrylis.example.spring_autowired_npe.MileageFeeController.mileageFee(MileageFeeController.java:14) ...
@Controller public class MileageFeeController { @Autowired private MileageFeeCalculator calc; @RequestMapping("/mileage/{miles}") @ResponseBody public float mileageFee(@PathVariable int miles) { return calc.mileageCharge(miles); } }
@Service @Configurable public class MileageFeeCalculator { @Autowired private MileageRateService rateService; public float mileageCharge(final int miles) { return (miles * rateService.ratePerMile()); } }
@Component public class ApplicationContextHolder implements ApplicationContextAware { private static ApplicationContext context; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { context = applicationContext; } public static ApplicationContext getContext() { return context; } }
@Controller public class MileageFeeController { @RequestMapping("/mileage/{miles}") @ResponseBody public float mileageFee(@PathVariable int miles) { MileageFeeCalculator calc = ApplicationContextHolder.getContext().getBean(MileageFeeCalculator.class); return calc.mileageCharge(miles); } }
@Component public class MyDemo { @Autowired private MyService myService; /** * @param args */ public static void main(String[] args) { System.out.println("test"); ApplicationContext ctx=new ClassPathXmlApplicationContext("spring.xml"); System.out.println("ctx>>"+ctx); Customer c1=null; MyDemo myDemo=ctx.getBean(MyDemo.class); System.out.println(myDemo); myDemo.callService(ctx); } public void callService(ApplicationContext ctx) { System.out.println("---callService---"); System.out.println(myService); myService.callMydao(); } }
MileageFeeCalculator calc = new MileageFeeCalculator();
@Controller public class MileageFeeController { @Autowired MileageFeeCalculator calc; @RequestMapping("/mileage/{miles}") @ResponseBody public float mileageFee(@PathVariable int miles) { return calc.mileageCharge(miles); } }
MileageFeeCalculator calc = new MileageFeeCalculator();
public class ConfiguredTenantScopedBeanProcessor implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { String name = "tenant"; System.out.println("Bean factory post processor is initialized"); beanFactory.registerScope("employee", new Employee()); Assert.state(beanFactory instanceof BeanDefinitionRegistry, "BeanFactory was not a BeanDefinitionRegistry, so CustomScope cannot be used."); BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; for (String beanName : beanFactory.getBeanDefinitionNames()) { BeanDefinition definition = beanFactory.getBeanDefinition(beanName); if (name.equals(definition.getScope())) { BeanDefinitionHolder proxyHolder = ScopedProxyUtils.createScopedProxy(new BeanDefinitionHolder(definition, beanName), registry, true); registry.registerBeanDefinition(beanName, proxyHolder.getBeanDefinition()); } } } }
import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.stereotype.Component; @Component public class SpringUtils { public static ApplicationContext ctx; /** * Make Spring inject the application context * and save it on a static variable, * so that it can be accessed from any point in the application. */ @Autowired private void setApplicationContext(ApplicationContext applicationContext) { ctx = applicationContext; } }
MyBean myBean = (MyBean)SpringUtils.ctx.getBean(MyBean.class);
@Service public class MileageFeeCalculator { @Autowired private MileageRateService rateService; public MileageFeeCalculator() { SpringBeanAutowiringSupport.processInjectionBasedOnCurrentContext(this) } public float mileageCharge(final int miles) { return (miles * rateService.ratePerMile()); } }
@RunWith(SpringRunner.class) @SpringBootTest public class MyTests { ....
@Service public class ClassB { private ClassA classA; @Autowired public ClassB(ClassA classA) { this.classA = classA; } public void useClassAObjectHere(){ classA.callMethodOnObjectA(); } }
ApplicationContext context = new ClassPathXmlApplicationContext(new String[] { "common.xml", "token.xml", "pep-config.xml" }); TokenInitializer ti = context.getBean(TokenInitializer.class);
<context:component-scan base-package="package.path"/>
<bean id="someAbac" class="com.pep.SomeAbac" init-method="init"/> <bean id="settings" class="com.pep.Settings"/>
@Test public void convertStringToUpperCaseStreams() { List<String> collected = Stream.of("a", "b", "hello") .map(String::toUpperCase) .collect(Collectors.toList()); assertEquals(asList("A", "B", "HELLO"), collected); }
@Test public void testflatMap() throws Exception { List<Integer> together = Stream.of(asList(1, 2), asList(3, 4)) .flatMap(List::stream) .map(integer -> integer + 1) .collect(Collectors.toList()); assertEquals(asList(2, 3, 4, 5), together); }
public class WordMap { public static void main(String[] args) { List<String> lst = Arrays.asList("STACK","OOOVER"); lst.stream().map(w->w.split("")).distinct().collect(Collectors.toList()); } }
String[] arrayOfWords = {"STACK", "OOOVVVER"}; Stream<String> streamOfWords = Arrays.stream(arrayOfWords); streamOfWords.map(s->s.split("")) .map(Arrays::stream).distinct() .collect(Collectors.toList());
String[] arrayOfWords = {"STACK", "OOOVVVER"}; Stream<String> streamOfWords = Arrays.stream(arrayOfWords); streamOfWords.map(s->s.split("")) .flatMap(Arrays::stream).distinct() .collect(Collectors.toList());
-------- Without flatMap() ------------------------------- collect return: [[Laptop, Phone], [Mouse, Keyboard]] -------- With flatMap() ---------------------------------- collect return: [Laptop, Phone, Mouse, Keyboard]
import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.stream.Collectors; public class Parcel { String name; List<String> items; public Parcel(String name, String... items) { this.name = name; this.items = Arrays.asList(items); } public List<String> getItems() { return items; } public static void main(String[] args) { Parcel amazon = new Parcel("amazon", "Laptop", "Phone"); Parcel ebay = new Parcel("ebay", "Mouse", "Keyboard"); List<Parcel> parcels = Arrays.asList(amazon, ebay); System.out.println("-------- Without flatMap() ---------------------------"); List<List<String>> mapReturn = parcels.stream() .map(Parcel::getItems) .collect(Collectors.toList()); System.out.println("\t collect return: " + mapReturn); System.out.println("\n-------- With flatMap() ------------------------------"); List<String> flatMapReturn = parcels.stream() .map(Parcel::getItems) .flatMap(Collection::stream) .collect(Collectors.toList()); System.out.println("\t collect return: " + flatMapReturn); } }
List<List<Integer>> result = Stream.of(Arrays.asList(1), Arrays.asList(2, 3)) .collect(Collectors.toList());
List<Integer> result = Stream.of(Arrays.asList(1), Arrays.asList(2, 3)) .flatMap(i -> i.stream()) .collect(Collectors.toList());
Optional<Optional<String>> result = Optional.of(42) .map(id -> findById(id)); Optional<String> result = Optional.of(42) .flatMap(id -> findById(id));
String version = computer.map(Computer::getSoundcard) .map(Soundcard::getUSB) .map(USB::getVersion) .orElse("UNKNOWN");
String version = computer.flatMap(Computer::getSoundcard) .flatMap(Soundcard::getUSB) .map(USB::getVersion) .orElse("UNKNOWN");
List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5); List<Integer> newList = intList.stream().map( e -> e * e ).collect(Collectors.toList()); System.out.println(newList);
[1, 2, 3, 4, 5] -> apply e -> e * e -> [ 1*1, 2*2, 3*3, 4*4, 5*5 ] -> [1, 4, 9, 16, 25 ]
List<Student> studentList = new ArrayList<Student>(); studentList.add(new Student("Robert","5st grade", Arrays.asList(new String[]{"history","math","geography"}))); studentList.add(new Student("Martin","8st grade", Arrays.asList(new String[]{"economics","biology"}))); studentList.add(new Student("Robert","9st grade", Arrays.asList(new String[]{"science","math"}))); Set<Student> courses = studentList.stream().flatMap( e -> e.getCourse().stream()).collect(Collectors.toSet()); System.out.println(courses);
[economics, biology, geography, science, history, math]
Stream .of(1,2,3,4,5) .map(myInt -> "preFix_"+myInt) .forEach(System.out::println);
dev_1 = {lang_a,lang_b,lang_c}, dev_2 = {lang_d}, dev_2 = {lang_e,lang_f}
{ {lang_a,lang_b,lang_c}, {lang_d}, {lang_e,lang_f} }
dev_team .stream() .map(dev -> dev.getLanguages()) .flatMap(languages -> languages.stream()) .doWhateverWithYourNewStreamHere();
dev_team .stream() .flatMap(dev -> dev.getLanguages().stream()) .doWhateverWithYourNewStreamHere();
List<Foo> myFoos = new ArrayList<Foo>(); for(Foo foo: myFoos){ for(Bar bar: foo.getMyBars()){ System.out.println(bar.getMyName()); } }
myFoos .stream() .flat(foo -> foo.getMyBars().stream()) .forEach(bar -> System.out.println(bar.getMyName()));
int age = students.stream() .filter(student -> SAURABH.equals(student.getName())) .map(Student::getAge) .findAny() .orElse(0); System.out.printf("*** Age of %s is %d\n",SAURABH, age);
Set<String> names = students.stream() .map(Student::getName) .collect(Collectors.toSet()); System.out.printf("*** All the names from the list is %s\n",names);
Set<String> courses = students.stream() .map(Student::getCourses) .collect(Collectors.toSet())
Set<String> courses = students.stream() .map(Student::getCourses) .flatMap(Arrays::stream) .collect(Collectors.toSet());
String string = "Madam, I am Adam"; boolean b = string.startsWith("Mad"); b = string.endsWith("dam"); b = string.indexOf("I am") >= 0; b = string.matches("(?i)mad.*"); b = string.matches("(?i).*adam"); b = string.matches("(?i).*i am.*");
String container = "aBcDeFg"; String content = "dE"; boolean containerContainsContent = StringUtils.containsIgnoreCase(container, content);
public boolean contains( String haystack, String needle ) { haystack = haystack == null ? "" : haystack; needle = needle == null ? "" : needle; return haystack.toLowerCase().contains( needle.toLowerCase() ) }
if( contains( str1, str2 ) ) { System.out.println( "Found " + str2 + " within " + str1 + "." ); }
public boolean containsIgnoreCase( String haystack, String needle ) { if(needle.equals("")) return true; if(haystack == null || needle == null || haystack .equals("")) return false; Pattern p = Pattern.compile(needle,Pattern.CASE_INSENSITIVE+Pattern.LITERAL); Matcher m = p.matcher(haystack); return m.find(); } example call: String needle = "Need$le"; String haystack = "This is a haystack that might have a need$le in it."; if( containsIgnoreCase( haystack, needle) ) { System.out.println( "Found " + needle + " within " + haystack + "." ); }
String string1 = "AAABBBCCC"; String string2 = "DDDEEEFFF"; String searchForThis = "AABB"; System.out.println("Search1="+string1.toUpperCase().contains(searchForThis.toUpperCase())); System.out.println("Search2="+string2.toUpperCase().contains(searchForThis.toUpperCase()));
(1) List<?> myList = new ArrayList<?>(); (2) ArrayList<?> myList = new ArrayList<?>();
public <T extends List & RandomAccess> void test(T list) { }
public class Test { private final ArrayList<String> strings = new ArrayList<>(); public void addStrings(List<String> add) { strings.addAll(add); } public List<String> getStrings() { return Collections.unmodifiableList(strings); } public ArrayList<String> getStringsCopy() { return new ArrayList<>(strings); } }
public class ExampleData implements java.io.Serializable { private final ArrayList<String> strings = new ArrayList<>();
(1) List<?> myList = new ArrayList<?>(); (2) ArrayList<?> myList = new ArrayList<?>();
public static void main(String[] args) { List<String> list = new ArrayList<String>(); list.add("a"); list.add("b"); ArrayList<String> aList = new ArrayList<String>(); aList.add("a"); aList.add("b"); }
L0 LINENUMBER 9 L0 NEW ArrayList DUP INVOKESPECIAL ArrayList.<init> () : void ASTORE 1 L1 LINENUMBER 10 L1 ALOAD 1: list LDC "a" INVOKEINTERFACE List.add (Object) : boolean POP L2 LINENUMBER 11 L2 ALOAD 1: list LDC "b" INVOKEINTERFACE List.add (Object) : boolean POP
L3 LINENUMBER 13 L3 NEW java/util/ArrayList DUP INVOKESPECIAL java/util/ArrayList.<init> ()V ASTORE 2 L4 LINENUMBER 14 L4 ALOAD 2 LDC "a" INVOKEVIRTUAL java/util/ArrayList.add (Ljava/lang/Object;)Z POP L5 LINENUMBER 15 L5 ALOAD 2 LDC "b" INVOKEVIRTUAL java/util/ArrayList.add (Ljava/lang/Object;)Z POP
ArrayList<Object> myMethod (ArrayList<Object> input) { }
List<Object> list = new ArrayList<Object> (); list.add ("string"); myMethod (list);
private String foo; public String getFoo(){...} public void setFoo(String foo){...};
Controller - Activity can play the role. Use an application class to write the global methods and define, and avoid static variables in the controller label Model - Entity like - user, Product, and Customer class. View - XML layout files. ViewModel - Class with like CartItem and owner models with multiple class properties Service - DataService- All the tables which have logic to get the data to bind the models - UserTable, CustomerTable NetworkService - Service logic binds the logic with network call - Login Service Helpers - StringHelper, ValidationHelper static methods for helping format and validation code. SharedView - fragmets or shared views from the code can be separated here AppConstant - Use the Values folder XML files for constant app level
public MyView extends RenderableView { public MyView(Context c) { super(c); } private int count = 0; public void view() { frameLayout(() -> { size(FILL, WRAP); button(() -> { textColor(Color.RED); text("Clicked " + count); onClick(v -> count++); }); }); }
button(() -> { textColor(Color.RED); text("Clicked " + mModel.getClickCount()); onClick(mController::onButtonClicked); });
BuildOrderHeaderRow() BuildLineItemSubHeaderRow() BuildOrderRow() BuildLineItemSubRow()
Pizza(int size) { ... } Pizza(int size, boolean cheese) { ... } Pizza(int size, boolean cheese, boolean pepperoni) { ... } Pizza(int size, boolean cheese, boolean pepperoni, boolean bacon) { ... }
Pizza pizza = new Pizza(12); pizza.setCheese(true); pizza.setPepperoni(true); pizza.setBacon(true);
public class Pizza { private int size; private boolean cheese; private boolean pepperoni; private boolean bacon; public static class Builder { private final int size; private boolean cheese = false; private boolean pepperoni = false; private boolean bacon = false; public Builder(int size) { this.size = size; } public Builder cheese(boolean value) { cheese = value; return this; } public Builder pepperoni(boolean value) { pepperoni = value; return this; } public Builder bacon(boolean value) { bacon = value; return this; } public Pizza build() { return new Pizza(this); } } private Pizza(Builder builder) { size = builder.size; cheese = builder.cheese; pepperoni = builder.pepperoni; bacon = builder.bacon; } }
Pizza pizza = new Pizza.Builder(12) .cheese(true) .pepperoni(true) .bacon(true) .build();
m.expects(once()) .method("testMethod") .with(eq(1), eq(2)) .returns("someResponse");
Map<String, Integer> m = new HashMap<String, Integer>() .put("a", 1) .put("b", 2) .put("c", 3);
class RestaurantObjectBuilder { IFactory _factory = new DefaultFoodFactory(); public void SetFoodFactory(IFactory customFactory) { _factory = customFactory; } public IFactory GetFoodFactory() { return _factory; } }
public interface IWebRequestBuilder { IWebRequestBuilder BuildHost(string host); IWebRequestBuilder BuildPort(int port); IWebRequestBuilder BuildPath(string path); IWebRequestBuilder BuildQuery(string query); IWebRequestBuilder BuildScheme(string scheme); IWebRequestBuilder BuildTimeout(int timeout); WebRequest Build(); } public class HttpWebRequestBuilder : IWebRequestBuilder { private string _host; private string _path = string.Empty; private string _query = string.Empty; private string _scheme = "http"; private int _port = 80; private int _timeout = -1; public IWebRequestBuilder BuildHost(string host) { _host = host; return this; } public IWebRequestBuilder BuildPort(int port) { _port = port; return this; } public IWebRequestBuilder BuildPath(string path) { _path = path; return this; } public IWebRequestBuilder BuildQuery(string query) { _query = query; return this; } public IWebRequestBuilder BuildScheme(string scheme) { _scheme = scheme; return this; } public IWebRequestBuilder BuildTimeout(int timeout) { _timeout = timeout; return this; } protected virtual void BeforeBuild(HttpWebRequest httpWebRequest) { } public WebRequest Build() { var uri = _scheme + ": var httpWebRequest = WebRequest.CreateHttp(uri); httpWebRequest.Timeout = _timeout; BeforeBuild(httpWebRequest); return httpWebRequest; } } public class ProxyHttpWebRequestBuilder : HttpWebRequestBuilder { private string _proxy = null; public ProxyHttpWebRequestBuilder(string proxy) { _proxy = proxy; } protected override void BeforeBuild(HttpWebRequest httpWebRequest) { httpWebRequest.Proxy = new WebProxy(_proxy); } } public class SearchRequest { private IWebRequestBuilder _requestBuilder; public SearchRequest(IWebRequestBuilder requestBuilder) { _requestBuilder = requestBuilder; } public WebRequest Construct(string searchQuery) { return _requestBuilder .BuildHost("ajax.googleapis.com") .BuildPort(80) .BuildPath("ajax/services/search/web") .BuildQuery("v=1.0&q=" + HttpUtility.UrlEncode(searchQuery)) .BuildScheme("http") .BuildTimeout(-1) .Build(); } public string GetResults(string searchQuery) { var request = Construct(searchQuery); var resp = request.GetResponse(); using (StreamReader stream = new StreamReader(resp.GetResponseStream())) { return stream.ReadToEnd(); } } } class Program { static void Main(string[] args) { var request1 = new SearchRequest(new HttpWebRequestBuilder()); var results1 = request1.GetResults("IBM"); Console.WriteLine(results1); var request2 = new SearchRequest(new ProxyHttpWebRequestBuilder("localhost:80")); var results2 = request2.GetResults("IBM"); Console.WriteLine(results2); } }
public class Complex { private String first; private String second; private String third; public String getFirst(){ return first; } public void setFirst(String first){ this.first=first; } ... public Complex withFirst(String first){ this.first=first; return this; } public Complex withSecond(String second){ this.second=second; return this; } public Complex withThird(String third){ this.third=third; return this; } } Complex complex = new Complex() .withFirst("first value") .withSecond("second value") .withThird("third value");
XMLGregorianCalendarBuilder builder = XMLGregorianCalendarBuilder.newInstance(jdkDate); XMLGregorianCalendar xmlCalendar = builder.excludeMillis().excludeOffset().build();
public class CustomAuthenticationService { private ICloudService _cloudService; private IDatabaseService _databaseService; public CustomAuthenticationService(ICloudService cloudService, IDatabaseService databaseService) { _cloudService = cloudService; _databaseService = databaseService; } public bool IsAuthorized(User user) { return true; }
[Test] public void Given_a_User_With_Permission_When_Verifying_If_Authorized_Then_Authorize_It_Returning_True() { CustomAuthenticationService sut = new CustomAuthenticationServiceBuilder(); User userWithAuthorization = null; var result = sut.IsAuthorized(userWithAuthorization); Assert.That(result, Is.True); }
public class CustomAuthenticationServiceBuilder { private ICloudService _cloudService; private IDatabaseService _databaseService; public CustomAuthenticationServiceBuilder() { _cloudService = new AwsService(); _databaseService = new SqlServerService(); } public CustomAuthenticationServiceBuilder WithAzureService(AzureService azureService) { _cloudService = azureService; return this; } public CustomAuthenticationServiceBuilder WithOracleService(OracleService oracleService) { _databaseService = oracleService; return this; } public CustomAuthenticationService Build() { return new CustomAuthenticationService(_cloudService, _databaseService); } public static implicit operator CustomAuthenticationService (CustomAuthenticationServiceBuilder builder) { return builder.Build(); } }
if (arrayList != null && !arrayList.isEmpty()) { T item = arrayList.get(arrayList.size()-1); }
lastElement = Iterables.getLast(iterableList, null);
lastElementRaw = Iterables.getLast(iterableList, null); lastElement = (lastElementRaw == null) ? Option.none() : Option.some(lastElementRaw);
public final class Lists { private Lists() { } public static <T> T getFirst(List<T> list) { return list != null && !list.isEmpty() ? list.get(0) : null; } public static <T> T getLast(List<T> list) { return list != null && !list.isEmpty() ? list.get(list.size() - 1) : null; } }
import java.util.List; /** * Convenience class that provides a clearer API for obtaining list elements. */ public final class Lists { private Lists() { } /** * Returns the first item in the given list, or null if not found. * * @param <T> The generic list type. * @param list The list that may have a first item. * * @return null if the list is null or there is no first item. */ public static <T> T getFirst( final List<T> list ) { return getFirst( list, null ); } /** * Returns the last item in the given list, or null if not found. * * @param <T> The generic list type. * @param list The list that may have a last item. * * @return null if the list is null or there is no last item. */ public static <T> T getLast( final List<T> list ) { return getLast( list, null ); } /** * Returns the first item in the given list, or t if not found. * * @param <T> The generic list type. * @param list The list that may have a first item. * @param t The default return value. * * @return null if the list is null or there is no first item. */ public static <T> T getFirst( final List<T> list, final T t ) { return isEmpty( list ) ? t : list.get( 0 ); } /** * Returns the last item in the given list, or t if not found. * * @param <T> The generic list type. * @param list The list that may have a last item. * @param t The default return value. * * @return null if the list is null or there is no last item. */ public static <T> T getLast( final List<T> list, final T t ) { return isEmpty( list ) ? t : list.get( list.size() - 1 ); } /** * Returns true if the given list is null or empty. * * @param <T> The generic list type. * @param list The list that has a last item. * * @return true The list is empty. */ public static <T> boolean isEmpty( final List<T> list ) { return list == null || list.isEmpty(); } }
Function<ArrayList<T>, T> getLast = a -> a.get(a.size() - 1);
Let ArrayList is myList public void getLastValue(List myList){ if(myList == null || myList.isEmpty()){ return; } int size = myList.size(); System.out.print("last value := "+myList.get(size-1)); }
LinkedList<Object> mLinkedList = new LinkedList<>();
/** * Returns the first element in this list. * * @return the first element in this list * @throws NoSuchElementException if this list is empty */ public E getFirst() { final Node<E> f = first; if (f == null) throw new NoSuchElementException(); return f.item; } /** * Returns the last element in this list. * * @return the last element in this list * @throws NoSuchElementException if this list is empty */ public E getLast() { final Node<E> l = last; if (l == null) throw new NoSuchElementException(); return l.item; } /** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */ public E removeFirst() { final Node<E> f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } /** * Removes and returns the last element from this list. * * @return the last element from this list * @throws NoSuchElementException if this list is empty */ public E removeLast() { final Node<E> l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } /** * Inserts the specified element at the beginning of this list. * * @param e the element to add */ public void addFirst(E e) { linkFirst(e); } /** * Appends the specified element to the end of this list. * * <p>This method is equivalent to {@link * * @param e the element to add */ public void addLast(E e) { linkLast(e); }
List<E> list = new ArrayList<E>(); private int i = -1; public void addObjToList(E elt){ i++; list.add(elt); } public E getObjFromList(){ if(i == -1){ return null; } E object = list.get(i); list.remove(i); i--; return object; }
public class RegularEmployee { private BigDecimal salary; public void setSalary(BigDecimal salary) { this.salary = salary; } public static BigDecimal getBonusMultiplier() { return new BigDecimal(".02"); } public BigDecimal calculateBonus() { return salary.multiply(getBonusMultiplier()); } } public class SpecialEmployee extends RegularEmployee { public static BigDecimal getBonusMultiplier() { return new BigDecimal(".03"); } }
package sp.trial; public class Base { static void printValue() { System.out.println(" Called static Base method."); } void nonStatPrintValue() { System.out.println(" Called non-static Base method."); } void nonLocalIndirectStatMethod() { System.out.println(" Non-static calls overridden(?) static:"); System.out.print(" "); this.printValue(); } }
package sp.trial; public class Child extends Base { static void printValue() { System.out.println(" Called static Child method."); } void nonStatPrintValue() { System.out.println(" Called non-static Child method."); } void localIndirectStatMethod() { System.out.println(" Non-static calls own static:"); System.out.print(" "); printValue(); } public static void main(String[] args) { System.out.println("Object: static type Base; runtime type Child:"); Base base = new Child(); base.printValue(); base.nonStatPrintValue(); System.out.println("Object: static type Child; runtime type Child:"); Child child = new Child(); child.printValue(); child.nonStatPrintValue(); System.out.println("Class: Child static call:"); Child.printValue(); System.out.println("Class: Base static call:"); Base.printValue(); System.out.println("Object: static/runtime type Child -- call static from non-static method of Child:"); child.localIndirectStatMethod(); System.out.println("Object: static/runtime type Child -- call static from non-static method of Base:"); child.nonLocalIndirectStatMethod(); } }
Object: static type Base; runtime type Child. Called static Base method. Called non-static Child method. Object: static type Child; runtime type Child. Called static Child method. Called non-static Child method. Class: Child static call. Called static Child method. Class: Base static call. Called static Base method. Object: static/runtime type Child -- call static from non-static method of Child. Non-static calls own static. Called static Child method. Object: static/runtime type Child -- call static from non-static method of Base. Non-static calls overridden(?) static. Called static Base method.
import java.lang.reflect.InvocationTargetException; import java.math.BigDecimal; class RegularEmployee { private BigDecimal salary = BigDecimal.ONE; public void setSalary(BigDecimal salary) { this.salary = salary; } public static BigDecimal getBonusMultiplier() { return new BigDecimal(".02"); } public BigDecimal calculateBonus() { return salary.multiply(this.getBonusMultiplier()); } public BigDecimal calculateOverridenBonus() { try { try { return salary.multiply((BigDecimal) this.getClass() .getDeclaredMethod("getBonusMultiplier").invoke(this)); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } return null; } } final class SpecialEmployee extends RegularEmployee { public static BigDecimal getBonusMultiplier() { return new BigDecimal(".03"); } } public class StaticTestCoolMain { static public void main(String[] args) { RegularEmployee Alan = new RegularEmployee(); System.out.println(Alan.calculateBonus()); System.out.println(Alan.calculateOverridenBonus()); SpecialEmployee Bob = new SpecialEmployee(); System.out.println(Bob.calculateBonus()); System.out.println(Bob.calculateOverridenBonus()); } }
RegularEmployee Carl = new SpecialEmployee(); System.out.println(Carl.calculateBonus()); System.out.println(Carl.calculateOverridenBonus());
class MyClass { ... } class MySubClass extends MyClass { ... } MyClass obj1 = new MyClass(); MySubClass obj2 = new MySubClass(); ob2 instanceof MyClass --> true Class clazz1 = obj1.getClass(); Class clazz2 = obj2.getClass(); clazz2 instanceof clazz1 --> false
Animal lassie = new Dog(); lassie.speak(); Animal kermit = new Frog(); kermit.speak();
class Animal { public static void eat() { System.out.println("Animal Eating"); } } class Dog extends Animal{ public static void eat() { System.out.println("Dog Eating"); } } class Test { public static void main(String args[]) { Animal obj= new Dog(); obj.eat(); } } Output Animal Eating
class SuperClass { public static void staticMethod() { System.out.println("SuperClass: inside staticMethod"); } } public class SubClass extends SuperClass { public static void staticMethod() { System.out.println("SubClass: inside staticMethod"); } public static void main(String[] args) { SuperClass superClassWithSuperCons = new SuperClass(); SuperClass superClassWithSubCons = new SubClass(); SubClass subClassWithSubCons = new SubClass(); superClassWithSuperCons.staticMethod(); superClassWithSubCons.staticMethod(); subClassWithSubCons.staticMethod(); } }
package rflib.common.utils; import haxe.ds.ObjectMap; class SingletonsRegistry { public static var instances:Map<Class<Dynamic>, Dynamic>; static function __init__() { StaticsInitializer.addCallback(SingletonsRegistry, function() { instances = null; }); } public static function getInstance(cls:Class<Dynamic>, ?args:Array<Dynamic>) { if (instances == null) { instances = untyped new ObjectMap<Dynamic, Dynamic>(); } if (!instances.exists(cls)) { if (args == null) args = []; instances.set(cls, Type.createInstance(cls, args)); } return instances.get(cls); } public static function validate(inst:Dynamic, cls:Class<Dynamic>) { if (instances == null) return; var inst2 = instances[cls]; if (inst2 != null && inst != inst2) throw "Can\ } }
public class Vehicle { static int VIN; public static int getVehileNumber() { return VIN; }} class Car extends Vehicle { static int carNumber; public static int getVehileNumber() { return carNumber; }}
public static final int getVehileNumber() { return VIN; }
public class StaticMethodsHiding { public static void main(String[] args) { SubClass.hello(); } } class SuperClass { static void hello(){ System.out.println("SuperClass saying Hello"); } } class SubClass extends SuperClass { }
class OverridenStaticMeth { static void printValue() { System.out.println("Overriden Meth"); } } public class OverrideStaticMeth extends OverridenStaticMeth { static void printValue() { System.out.println("Overriding Meth"); } public static void main(String[] args) { OverridenStaticMeth osm = new OverrideStaticMeth(); osm.printValue(); System.out.println("now, from main"); printValue(); } }
String str = "abc"; String repeated = str.repeat(3); repeated.equals("abcabcabc");
String str = "abc"; String repeated = str.repeat(3); repeated.equals("abcabcabc");
/** * Returns a string whose value is the concatenation of this * string repeated {@code count} times. * <p> * If this string is empty or count is zero then the empty * string is returned. * * @param count number of times to repeat * * @return A string composed of this string repeated * {@code count} times or the empty string if this * string is empty or count is zero * * @throws IllegalArgumentException if the {@code count} is * negative. * * @since 11 */
repeated = new String(new char[n]).replace("\0", s);
String str = "abc"; String repeated = StringUtils.repeat(str, 3); repeated.equals("abcabcabc");
System.out.println(String.join("", Collections.nCopies(100, "hello")));
repeated = String.format(String.format("%%%ds", n), " ").replace(" ",s);
import static java.util.stream.Collectors.joining; ... String repeated = Stream.generate(() -> "abc").limit(3).collect(joining());
public static String repeat(String str, int times) { return Stream.generate(() -> str).limit(times).collect(joining()); }
public static String repeat(String s, int times) { if (times <= 0) return ""; else return s + repeat(s, times-1); }
public static String repeat(String s, int times) { if (times <= 0) return ""; else if (times % 2 == 0) return repeat(s+s, times/2); else return s + repeat(s+s, times/2); }
public class Repeat { public static void main(String[] args) { int n = Integer.parseInt(args[0]); String s = args[1]; int l = s.length(); long start, end; start = System.currentTimeMillis(); for (int i = 0; i < n; i++) { if(repeatLog2(s,i).length()!=i*l) throw new RuntimeException(); } end = System.currentTimeMillis(); System.out.println("RecLog2Concat: " + (end-start) + "ms"); start = System.currentTimeMillis(); for (int i = 0; i < n; i++) { if(repeatR(s,i).length()!=i*l) throw new RuntimeException(); } end = System.currentTimeMillis(); System.out.println("RecLinConcat: " + (end-start) + "ms"); start = System.currentTimeMillis(); for (int i = 0; i < n; i++) { if(repeatIc(s,i).length()!=i*l) throw new RuntimeException(); } end = System.currentTimeMillis(); System.out.println("IterConcat: " + (end-start) + "ms"); start = System.currentTimeMillis(); for (int i = 0; i < n; i++) { if(repeatSb(s,i).length()!=i*l) throw new RuntimeException(); } end = System.currentTimeMillis(); System.out.println("IterStrB: " + (end-start) + "ms"); } public static String repeatLog2(String s, int times) { if (times <= 0) { return ""; } else if (times % 2 == 0) { return repeatLog2(s+s, times/2); } else { return s + repeatLog2(s+s, times/2); } } public static String repeatR(String s, int times) { if (times <= 0) { return ""; } else { return s + repeatR(s, times-1); } } public static String repeatIc(String s, int times) { String tmp = ""; for (int i = 0; i < times; i++) { tmp += s; } return tmp; } public static String repeatSb(String s, int n) { final StringBuilder sb = new StringBuilder(); for(int i = 0; i < n; i++) { sb.append(s); } return sb.toString(); } }
public static String repeat(String s, int n) { if(s == null) { return null; } final StringBuilder sb = new StringBuilder(s.length() * n); for(int i = 0; i < n; i++) { sb.append(s); } return sb.toString(); }
public static void repeat(StringBuilder stringBuilder, String s, int times) { if (times > 0) { repeat(stringBuilder.append(s), s, times - 1); } } public static String repeat(String s, int times) { StringBuilder stringBuilder = new StringBuilder(s.length() * times); repeat(stringBuilder, s, times); return stringBuilder.toString(); }
@Test public void repeatString() { String string = "abc"; assertThat($(string).repeat(3).toString(), is("abcabcabc")); }
private static String fun1(int size) { StringBuilder sb = new StringBuilder(size * 2); for (int i = 0; i < size; i++) { sb.append(",?"); } return sb.substring(1); } private static String fun2(int size) { return new String(new char[size]).replaceAll("\0", ",?").substring(1); }
public static String repeat(String toRepeat, int times) { if (toRepeat == null) { toRepeat = ""; } if (times < 0) { times = 0; } final int length = toRepeat.length(); final int total = length * times; final char[] src = toRepeat.toCharArray(); char[] dst = new char[total]; for (int i = 0; i < total; i += length) { System.arraycopy(src, 0, dst, i, length); } return String.copyValueOf(dst); }
public static String repeat2(String toRepeat, int times) { if (toRepeat == null) { toRepeat = ""; } if (times < 0) { times = 0; } String[] copies = new String[times]; Arrays.fill(copies, toRepeat); return Arrays.toString(copies). replace("[", ""). replace("]", ""). replaceAll(", ", ""); }
public static String repeat3(String toRepeat, int times) { return Collections.nCopies(times, toRepeat). toString(). replace("[", ""). replace("]", ""). replaceAll(", ", ""); }
/** * Helper-Class for Repeating Strings and other CharSequence-Implementations * @author Maciej Schuttkowski */ public class RepeatingCharSequence implements CharSequence { final int count; CharSequence internalCharSeq = ""; CharSequence separator = ""; /** * CONSTRUCTOR - RepeatingCharSequence * @param input CharSequence to repeat * @param count Repeat-Count */ public RepeatingCharSequence(CharSequence input, int count) { if(count < 0) throw new IllegalArgumentException("Can not repeat String \""+input+"\" less than 0 times! count="+count); if(count > 0) internalCharSeq = input; this.count = count; } /** * CONSTRUCTOR - Strings.RepeatingCharSequence * @param input CharSequence to repeat * @param count Repeat-Count * @param separator Separator-Sequence to use */ public RepeatingCharSequence(CharSequence input, int count, CharSequence separator) { this(input, count); this.separator = separator; } @Override public CharSequence subSequence(int start, int end) { checkBounds(start); checkBounds(end); int subLen = end - start; if (subLen < 0) { throw new IndexOutOfBoundsException("Illegal subSequence-Length: "+subLen); } return (start == 0 && end == length()) ? this : toString().substring(start, subLen); } @Override public int length() { return count < 1 ? 0 : ( (internalCharSeq.length()*count) + (separator.length()*(count-1))); } @Override public char charAt(int index) { final int internalIndex = internalIndex(index); if(internalIndex > internalCharSeq.length()-1) { return separator.charAt(internalIndex-internalCharSeq.length()); } return internalCharSeq.charAt(internalIndex); } @Override public String toString() { return count < 1 ? "" : new StringBuilder(this).toString(); } private void checkBounds(int index) { if(index < 0 || index >= length()) throw new IndexOutOfBoundsException("Index out of Bounds: "+index); } private int internalIndex(int index) { return index % ((length()+separator.length())/count); } }
public static void main(String[] args) { StringBuilder input = new StringBuilder("123"); StringBuilder separator = new StringBuilder("<="); int repeatCount = 2; CharSequence repSeq = new RepeatingCharSequence(input, repeatCount, separator); String repStr = repSeq.toString(); System.out.println("Repeat="+repeatCount+"\tSeparator="+separator+"\tInput="+input+"\tLength="+input.length()); System.out.println("CharSeq:\tLength="+repSeq.length()+"\tVal="+repSeq); System.out.println("String :\tLength="+repStr.length()+"\tVal="+repStr); input.append("ff"); System.out.println(repSeq); separator.append("===").append( System.out.println(repSeq); }
Repeat=2 Separator=<= Input=123 Length=3 CharSeq: Length=8 Val=123<=123 String : Length=8 Val=123<=123 123ff<=123ff 123ff<====>123ff
public String repeat(String str, int count){ if(count <= 0) {return "";} return new String(new char[count]).replace("\0", str); }
public static String repeatString(String what, int howmany) { char[] pattern = what.toCharArray(); char[] res = new char[howmany * pattern.length]; int length = pattern.length; for (int i = 0; i < howmany; i++) System.arraycopy(pattern, 0, res, i * length, length); return new String(res); }
public static String repeatStringSB(String what, int howmany) { StringBuilder out = new StringBuilder(what.length() * howmany); for (int i = 0; i < howmany; i++) out.append(what); return out.toString(); }
public static void main(String... args) { String res; long time; for (int j = 0; j < 1000; j++) { res = repeatString("123", 100000); res = repeatStringSB("123", 100000); } time = System.nanoTime(); res = repeatString("123", 1000000); time = System.nanoTime() - time; System.out.println("elapsed repeatString: " + time); time = System.nanoTime(); res = repeatStringSB("123", 1000000); time = System.nanoTime() - time; System.out.println("elapsed repeatStringSB: " + time); }
elapsed repeatString: 6006571 elapsed repeatStringSB: 9064937
/** * Repeat a String as many times you need. * * @param i - Number of Repeating the String. * @param s - The String wich you want repeated. * @return The string n - times. */ public static String repeate(int i, String s) { StringBuilder sb = new StringBuilder(); for (int j = 0; j < i; j++) sb.append(s); return sb.toString(); }
{ String string = repeat("1234567890", 4); System.out.println(string); System.out.println("======="); repeatWithoutCopySample(string, 100000); System.out.println(string); System.out.println(string.length()); } /** * The core of the task. */ @SuppressWarnings("AssignmentToMethodParameter") public static char[] repeat(char[] sample, int times) { char[] r = new char[sample.length * times]; while (--times > -1) { System.arraycopy(sample, 0, r, times * sample.length, sample.length); } return r; } /** * Java classic style. */ public static String repeat(String sample, int times) { return new String(repeat(sample.toCharArray(), times)); } /** * Java extreme memory style. */ @SuppressWarnings("UseSpecificCatch") public static void repeatWithoutCopySample(String sample, int times) { try { Field valueStringField = String.class.getDeclaredField("value"); valueStringField.setAccessible(true); valueStringField.set(sample, repeat((char[]) valueStringField.get(sample), times)); } catch (Exception ex) { throw new RuntimeException(ex); } }
public static String repeat(String string, int times) { StringBuilder out = new StringBuilder(); while (times-- > 0) { out.append(string); } return out.toString(); }
public static char[] myABCs = { public static int numInput; static Scanner in = new Scanner(System.in); public static void main(String[] args) { System.out.print("Enter Number of Times to repeat: "); numInput = in.nextInt(); repeatArray(numInput); } public static int repeatArray(int y) { for (int a = 0; a < y; a++) { for (int b = 0; b < myABCs.length; b++) { System.out.print(myABCs[b]); } System.out.print(" "); } return y; }
public static final String repeat(String string, long number) { return number == 1 ? string : (number % 2 == 0 ? repeat(string + string, number / 2) : string + repeat(string + string, (number - 1) / 2)); }
String repeatString(String s, int repetitions) { if(repetitions < 0) throw SomeException(); else if(s == null) return null; StringBuilder stringBuilder = new StringBuilder(s.length() * repetitions); for(int i = 0; i < repetitions; i++) stringBuilder.append(s); return stringBuilder.toString(); }
public static String repeat(String str, int times) { int length = str.length(); int size = length * times; char[] c = new char[size]; for (int i = 0; i < size; i++) { c[i] = str.charAt(i % length); } return new String(c); }
public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return repeat(str.charAt(0), repeat); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : return repeat(str.charAt(0), repeat); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } }
public static String repeat(String str, int num) { int len = num * str.length(); StringBuilder sb = new StringBuilder(len); for (int i = 0; i < times; i++) { sb.append(str); } return sb.toString(); }
public String repeat(String str, int count) { return count > 0 ? repeat(str, count -1) + str: ""; }
java.activation java.corba java.transaction java.xml.bind << This one contains the JAXB APIs java.xml.ws java.xml.ws.annotation
<dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.2.11</version> </dependency> <dependency> <groupId>com.sun.xml.bind</groupId> <artifactId>jaxb-core</artifactId> <version>2.2.11</version> </dependency> <dependency> <groupId>com.sun.xml.bind</groupId> <artifactId>jaxb-impl</artifactId> <version>2.2.11</version> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>activation</artifactId> <version>1.1.1</version> </dependency>
<dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency>
<dependencies> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency> <dependency> <groupId>com.sun.xml.bind</groupId> <artifactId>jaxb-impl</artifactId> <version>2.3.0</version> </dependency> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>2.3.0</version> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>activation</artifactId> <version>1.1.1</version> </dependency> </dependencies>
<dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency> <dependency> <groupId>org.eclipse.persistence</groupId> <artifactId>eclipselink</artifactId> <version>2.7.0</version> </dependency>
<dependency> <groupId>org.eclipse.persistence</groupId> <artifactId>org.eclipse.persistence.moxy</artifactId> <version>2.7.3</version> </dependency>
System.setProperty("javax.xml.bind.JAXBContextFactory", "org.eclipse.persistence.jaxb.JAXBContextFactory");
javac --add-modules java.xml.bind <java file name> java --add-modules java.xml.bind <class file>
sourceCompatibility = 10 compile group: compile group: compile group: compile group:
<dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency>
<j2se version="1.6+" java-vm-args="-XX:+IgnoreUnrecognizedVMOptions --add-modules=java.se.ee"/>
<dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>${jaxb-api.version}</version> </dependency> <dependency> <groupId>com.sun.xml.bind</groupId> <artifactId>jaxb-impl</artifactId> <version>${jaxb-api.version}</version> </dependency> <dependency> <groupId>com.sun.xml.bind</groupId> <artifactId>jaxb-core</artifactId> <version>${jaxb-api.version}</version> </dependency>
<profile> <id>java-9</id> <activation> <jdk>9</jdk> </activation> <dependencies> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>2.3.0</version> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>activation</artifactId> <version>1.1.1</version> </dependency> </dependencies> </profile>
[INFO] +- org.glassfish.jaxb:jaxb-runtime:jar:2.3.0:compile [INFO] | +- org.glassfish.jaxb:jaxb-core:jar:2.3.0:compile [INFO] | | +- javax.xml.bind:jaxb-api:jar:2.3.0:compile [INFO] | | +- org.glassfish.jaxb:txw2:jar:2.3.0:compile [INFO] | | \- com.sun.istack:istack-commons-runtime:jar:3.0.5:compile [INFO] | +- org.jvnet.staxex:stax-ex:jar:1.7.8:compile [INFO] | \- com.sun.xml.fastinfoset:FastInfoset:jar:1.2.13:compile [INFO] \- javax.activation:activation:jar:1.1.1:compile
<dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>2.3.1</version> </dependency>
<dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>2.3.0</version> <scope>runtime</scope> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>javax.activation-api</artifactId> <version>1.2.0</version> </dependency>
<dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency>
java.lang.reflect.InvocationTargetException at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:564) at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:107) at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:129) Caused by: java.lang.NoClassDefFoundError: Unable to load class groovy.xml.jaxb.JaxbGroovyMethods due to missing dependency javax/xml/bind/JAXBContext at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:400) at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:277) at org.codehaus.groovy.ast.ClassNode.getMethods(ClassNode.java:397) ... .. . .. ... at org.codehaus.groovy.tools.shell.Groovysh.<init>(Groovysh.groovy:135) at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:232) at org.codehaus.groovy.tools.shell.Main.<init>(Main.groovy:66) at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:232) at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:163) ... 6 more
function extend_qzminynshg { local BASE="/usr/local/java" for LIB in jaxb-api.jar jaxb-core.jar jaxb-impl.jar jaxb-jxc.jar jaxb-xjc.jar; do local FQLIB="$BASE/jaxb-ri/lib/$LIB" if [[ -f $FQLIB ]]; then export CLASSPATH=$FQLIB:$CLASSPATH fi done } extend_qzminynshg; unset extend_qzminynshg
int count = StringUtils.countMatches("a.b.c.d", ".");
int occurance = StringUtils.countOccurrencesOf("a.b.c.d", ".");
int count = line.length() - line.replace(".", "").length();
int apache = StringUtils.countMatches(testString, "."); System.out.println("apache = " + apache);
int spring = org.springframework.util.StringUtils.countOccurrencesOf(testString, "."); System.out.println("spring = " + spring);
int replace = testString.length() - testString.replace(".", "").length(); System.out.println("replace = " + replace);
int replaceAll = testString.replaceAll("[^.]", "").length(); System.out.println("replaceAll = " + replaceAll);
int replaceAllCase2 = testString.length() - testString.replaceAll("\\.", "").length(); System.out.println("replaceAll (second case) = " + replaceAllCase2);
int split = testString.split("\\.",-1).length-1; System.out.println("split = " + split);
long java8 = testString.chars().filter(ch -> ch == System.out.println("java8 = " + java8);
long java8Case2 = testString.codePoints().filter(ch -> ch == System.out.println("java8 (second case) = " + java8Case2);
int stringTokenizer = new StringTokenizer(" " +testString + " ", ".").countTokens()-1; System.out.println("stringTokenizer = " + stringTokenizer);
Benchmark Mode Cnt Score Error Units 1. countMatches avgt 5 0.010  0.001 us/op 2. countOccurrencesOf avgt 5 0.010  0.001 us/op 3. stringTokenizer avgt 5 0.028  0.002 us/op 4. java8_1 avgt 5 0.077  0.005 us/op 5. java8_2 avgt 5 0.078  0.003 us/op 6. split avgt 5 0.137  0.009 us/op 7. replaceAll_2 avgt 5 0.302  0.047 us/op 8. replace avgt 5 0.303  0.034 us/op 9. replaceAll_1 avgt 5 0.351  0.045 us/op
public static int countOccurrences(String haystack, char needle) { int count = 0; for (int i=0; i < haystack.length(); i++) { if (haystack.charAt(i) == needle) { count++; } } return count; }
String s = "a.b.c.d"; int charCount = s.replaceAll("[^.]", "").length(); println(charCount);
String s = "a.b.c.d"; int charCount = s.length() - s.replaceAll("\\.", "").length();
int count = "a.b.c.d".length() - "a.b.c.d".replace(".", "").length();
String s = "a.b.c.d"; long result = s.chars().filter(ch -> ch ==
String text = "a.b.c.d"; int count = text.split("\\.",-1).length-1;
public static int countOccurrences(String haystack, char needle, int i){ return ((i=haystack.indexOf(needle, i)) == -1)?0:1+countOccurrences(haystack, needle, i+1);} System.out.println("num of dots is "+countOccurrences("a.b.c.d",
for(int i=0;i<s.length();num+=(s.charAt(i++)==delim?1:0))
public static int countOccurrences(String haystack, char needle) { return countOccurrences(haystack, needle, 0); } private static int countOccurrences(String haystack, char needle, int index) { if (index >= haystack.length()) { return 0; } int contribution = haystack.charAt(index) == needle ? 1 : 0; return contribution + countOccurrences(haystack, needle, index+1); }
public static int countOccurrences(CharSequeunce haystack, char needle) { return countOccurrences(haystack, needle, 0, haystack.length); } private static int countOccurrences( CharSequence haystack, char needle, int start, int end ) { if (start == end) { return 0; } else if (start+1 == end) { return haystack.charAt(start) == needle ? 1 : 0; } else { int mid = (end+start)>>>1; return countOccurrences(haystack, needle, start, mid) + countOccurrences(haystack, needle, mid, end); } }
public static int countOccurrences(String haystack, char needle) { int count = 0; for (char c : haystack.toCharArray()) { if (c == needle) { ++count; } } return count; }
public static int numberOf(String target, String content) { return (content.split(target).length - 1); }
public static long countOccurences(String s, char c){ return s.chars().filter(ch -> ch == c).count(); } countOccurences("a.b.c.d", countOccurences("hello world",
public class CharacterCounter { public static int countOccurrences(String find, String string) { int count = 0; int indexOf = 0; while (indexOf > -1) { indexOf = string.indexOf(find, indexOf + 1); if (indexOf > -1) count++; } return count; } }
int occurrences = CharacterCounter.countOccurrences("l", "Hello World."); System.out.println(occurrences);
public static void main(String[] args) { String string = "a.b.c.d"; String []splitArray = string.split("\\."); System.out.println("No of . chars is : " + splitArray.length-1); }
int res = "abdsd3$asda$asasdd$sadas".chars().reduce(0, (a, c) -> a + (c == System.out.println(res);
import java.util.Scanner; class apples { public static void main(String args[]) { Scanner bucky = new Scanner(System.in); String hello = bucky.nextLine(); int charCount = hello.length() - hello.replaceAll("e", "").length(); System.out.println(charCount); } }
public static int count( final String s, final char c ) { final char[] chars = s.toCharArray(); int count = 0; for(int i=0; i<chars.length; i++) { if (chars[i] == c) { count++; } } return count; }
public static int countOccurrences(String container, String content){ int lastIndex, currIndex = 0, occurrences = 0; while(true) { lastIndex = container.indexOf(content, currIndex); if(lastIndex == -1) { break; } currIndex = lastIndex + content.length(); occurrences++; } return occurrences; }
int numDots = 0; if (s.charAt(0) == numDots++; } if (s.charAt(1) == numDots++; } if (s.charAt(2) == numDots++; }
create a project position = 0 while (not end of string) { write check for character at position "position" (see above) } write code to output variable "numDots" compile program hand in homework do not think of the loop that your "if"s may have been optimized and compiled to
public static int countOccurrences(String haystack, char needle) { return countOccurrences(haystack, needle, 0); } private static int countOccurrences(String haystack, char needle, int accumulator) { if (haystack.length() == 0) return accumulator; return countOccurrences(haystack.substring(1), needle, haystack.charAt(0) == needle ? accumulator + 1 : accumulator); }
import java.util.Scanner; public class CountingOccurences { public static void main(String[] args) { Scanner inp= new Scanner(System.in); String str; char ch; int count=0; System.out.println("Enter the string:"); str=inp.nextLine(); while(str.length()>0) { ch=str.charAt(0); int i=0; while(str.charAt(i)==ch) { count =count+i; i++; } str.substring(count); System.out.println(ch); System.out.println(count); } } }
int count = (line.length() - line.replace("str", "").length())/"str".length();
int count = CharAdapter.adapt("a.b.c.d").count(c -> c ==
CharBag bag = CharAdapter.adapt("a.b.c.d").toBag(); int count = bag.occurrencesOf(
public enum Weekday { MON, TUE, WED, THU, FRI; public DayOfWeek toDayOfWeek() { ... } } public enum WeekendDay { SAT, SUN; public DayOfWeek toDayOfWeek() { ... } } public enum DayOfWeek { MON, TUE, WED, THU, FRI, SAT, SUN; }
interface Day { ... } public enum Weekday implements Day { MON, TUE, WED, THU, FRI; } public enum WeekendDay implements Day { SAT, SUN; }
interface Day { ... } public enum Weekday implements Day { MON, TUE, WED, THU, FRI; public DayOfWeek toDayOfWeek() { ... } } public enum WeekendDay implements Day { SAT, SUN; public DayOfWeek toDayOfWeek() { ... } } public enum DayOfWeek { MON, TUE, WED, THU, FRI, SAT, SUN; public Day toDay() { ... } }
public final class TEST extends java.lang.Enum<TEST> { public static final TEST ONE; public static final TEST TWO; public static final TEST THREE; static {}; public static TEST[] values(); public static TEST valueOf(java.lang.String); }
public enum All { a (ClassGroup.A,ClassGroup.B), b (ClassGroup.A,ClassGroup.B), c (ClassGroup.A,ClassGroup.B), d (ClassGroup.B) ...
if(myEvent.is(State_StatusGroup.START)) makeNewOperationObject().. if(myEnum.is(State_StatusGroup.STEP)) makeSomeSeriousChanges().. if(myEnum.is(State_StatusGroup.FINISH)) closeTransactionOrSomething()..
public enum AtmOperationStatus { STARTED_BY_SERVER (State_StatusGroup.START), SUCCESS (State_StatusGroup.FINISH), FAIL_TOKEN_TIMEOUT (State_StatusGroup.FAIL, State_StatusGroup.FINISH), FAIL_NOT_COMPLETE (State_StatusGroup.FAIL, State_StatusGroup.STEP), FAIL_UNKNOWN (State_StatusGroup.FAIL, State_StatusGroup.FINISH), (...) private AtmOperationStatus(StatusGroupInterface ... pList){ for (StatusGroupInterface group : pList){ group.addMember(this); } } public boolean is(StatusGroupInterface with){ for (AtmOperationStatus eT : with.getMembers()){ if( eT .equals(this)) return true; } return false; } private interface StatusGroupInterface{ EnumSet<AtmOperationStatus> getMembers(); void addMember(AtmOperationStatus pE); } public enum State_StatusGroup implements StatusGroupInterface{ START, STEP, FAIL, FINISH; private List<AtmOperationStatus> members = new LinkedList<AtmOperationStatus>(); @Override public EnumSet<AtmOperationStatus> getMembers() { return EnumSet.copyOf(members); } @Override public void addMember(AtmOperationStatus pE) { members.add(pE); } static { try { Class.forName(AtmOperationStatus.class.getName()); } catch (ClassNotFoundException ex) { throw new RuntimeException("Class AtmEventType not found", ex); } } } } if (p.getStatus().is(AtmOperationStatus.State_StatusGroup.FINISH)) { }else if (p.getStatus().is(AtmOperationStatus.State_StatusGroup.START)) { }
public enum AtmEventType { USER_DEPOSIT (Status_EventsGroup.WITH_STATUS, Authorization_EventsGroup.USER_AUTHORIZED, ChangedMoneyAccountState_EventsGroup.CHANGED, OperationType_EventsGroup.DEPOSIT, ApplyTo_EventsGroup.CHANNEL), SERVICE_DEPOSIT (Status_EventsGroup.WITH_STATUS, Authorization_EventsGroup.TERMINAL_AUTHORIZATION, ChangedMoneyAccountState_EventsGroup.CHANGED, OperationType_EventsGroup.DEPOSIT, ApplyTo_EventsGroup.CHANNEL), DEVICE_MALFUNCTION (Status_EventsGroup.WITHOUT_STATUS, Authorization_EventsGroup.TERMINAL_AUTHORIZATION, ChangedMoneyAccountState_EventsGroup.DID_NOT_CHANGED, ApplyTo_EventsGroup.DEVICE), CONFIGURATION_4_C_CHANGED(Status_EventsGroup.WITHOUT_STATUS, ApplyTo_EventsGroup.TERMINAL, ChangedMoneyAccountState_EventsGroup.DID_NOT_CHANGED), (...)
if(myEvent2.is(ChangedMoneyAccountState_EventsGroup.CHANGED)) rollBack()..
public interface ICommonInterface { String getName(); } public enum CommonEnum implements ICommonInterface { P_EDITABLE("editable"), P_ACTIVE("active"), P_ID("id"); private final String name; EnumCriteriaComun(String name) { name= name; } @Override public String getName() { return this.name; } }
public enum SubEnum implements ICommonInterface { P_EDITABLE(CommonEnum.P_EDITABLE ), P_ACTIVE(CommonEnum.P_ACTIVE), P_ID(CommonEnum.P_ID), P_NEW_CONSTANT("new_constant"); private final String name; EnumCriteriaComun(CommonEnum commonEnum) { name= commonEnum.name; } EnumCriteriaComun(String name) { name= name; } @Override public String getName() { return this.name; } }
public class A { public static final A a = new A(); public static final A b = new A(); public static final A c = new A(); /* * In case you need to identify your constant * in different JVMs, you need an id. This is the case if * your object is transfered between * different JVM instances (eg. save/load, or network). * Also, switch statements don * Objects, but work with int. */ public static int maxId=0; public int id = maxId++; public int getId() { return id; } } public class B extends A { /* * good: you can do like * A x = getYourEnumFromSomeWhere(); * if(x instanceof B) ...; * to identify which enum x * is of. */ public static final A d = new A(); } public class C extends A { /* Good: e.getId() != d.getId() * Bad: in different JVMs, C and B * might be initialized in different order, * resulting in different IDs. * Workaround: use a fixed int, or hash code. */ public static final A e = new A(); public int getId() { return -32489132; }; }
public interface Kind { /** * Let */ String description() ; /** * Standard {@code Enum} method. */ String name() ; /** * Standard {@code Enum} method. */ int ordinal() ; }
public enum BaseKind implements Kind { FIRST( "First" ), SECOND( "Second" ), ; private final String description ; public String description() { return description ; } private BaseKind( final String description ) { this.description = description ; } public static void checkEnumExtender( final Kind[] baseValues, final Kind[] extendingValues ) { if( extendingValues.length < baseValues.length ) { throw new IncorrectExtensionError( "Only " + extendingValues.length + " values against " + baseValues.length + " base values" ) ; } for( int i = 0 ; i < baseValues.length ; i ++ ) { final Kind baseValue = baseValues[ i ] ; final Kind extendingValue = extendingValues[ i ] ; if( baseValue.ordinal() != extendingValue.ordinal() ) { throw new IncorrectExtensionError( "Base ordinal " + baseValue.ordinal() + " doesn } if( ! baseValue.name().equals( extendingValue.name() ) ) { throw new IncorrectExtensionError( "Base name[ " + i + "] " + baseValue.name() + " doesn } if( ! baseValue.description().equals( extendingValue.description() ) ) { throw new IncorrectExtensionError( "Description[ " + i + "] " + baseValue.description() + " doesn } } } public static class IncorrectExtensionError extends Error { public IncorrectExtensionError( final String s ) { super( s ) ; } } }
public enum ExtendingKind implements Kind { FIRST( BaseKind.FIRST ), SECOND( BaseKind.SECOND ), THIRD( "Third" ), ; private final String description ; public String description() { return description ; } ExtendingKind( final BaseKind baseKind ) { this.description = baseKind.description() ; } ExtendingKind( final String description ) { this.description = description ; } }
interface Day<T> { ... T valueOf(); } public enum Weekday implements Day<Weekday> { MON, TUE, WED, THU, FRI; Weekday valueOf(){ return valueOf(name()); } } public enum WeekendDay implements Day<WeekendDay> { SAT, SUN; WeekendDay valueOf(){ return valueOf(name()); } } Day<Weekday> wds = Weekday.MON; Day<WeekendDay> wends = WeekendDay.SUN; switch(wds.valueOf()){ case MON: case TUE: case WED: case THU: case FRI: } switch(wends.valueOf()){ case SAT: case SUN: }
public enum ANIMAL { WOLF,CAT, DOG } EnumSet<ANIMAL> pets = EnumSet.of(ANIMAL.CAT, ANIMAL.DOG);
public interface Parameter { /** * Retrieve the parameters name. * * @return the name of the parameter */ String getName(); /** * Retrieve the parameters type. * * @return the {@link Class} according to the type of the parameter */ Class<?> getType(); /** * Matches the given string with this parameters value pattern (if applicable). This helps to find * out if the given string is a syntactically valid candidate for this parameters value. * * @param valueStr <i>optional</i> - the string to check for * @return <code>true</code> in case this parameter has no pattern defined or the given string * matches the defined one, <code>false</code> in case <code>valueStr</code> is * <code>null</code> or an existing pattern is not matched */ boolean match(final String valueStr); /** * This method works as {@link * * @param valueStr <i>optional</i> - the string to check for * @throws ArgumentException with code * <dl> * <dt>PARAM_MISSED</dt> * <dd>if <code>valueStr</code> is <code>null</code></dd> * <dt>PARAM_BAD</dt> * <dd>if pattern is not matched</dd> * </dl> */ void matchEx(final String valueStr) throws ArgumentException; /** * Parses a value for this parameter from the given string. This method honors the parameters data * type and potentially other criteria defining a valid value (e.g. a pattern). * * @param valueStr <i>optional</i> - the string to parse the parameter value from * @return the parameter value according to the parameters type (see {@link * <code>null</code> in case <code>valueStr</code> was <code>null</code>. * @throws ArgumentException in case <code>valueStr</code> is not parsable as a value for this * parameter. */ Object parse(final String valueStr) throws ArgumentException; /** * Converts the given value to its external form as it is accepted by {@link * most (ordinary) parameters this is simply a call to {@link String * parameter types {@link Object * enumerations), this method has to be implemented accordingly. * * @param value <i>mandatory</i> - the parameters value * @return the external form of the parameters value, never <code>null</code> * @throws InternalServiceException in case the given <code>value</code> does not match * {@link */ String toString(final Object value) throws InternalServiceException; }
public enum Parameters implements Parameter { /** * ANY ENUM VALUE */ VALUE(new ParameterImpl<String>("VALUE", String.class, "[A-Za-z]{3,10}")); /** * The parameter wrapped by this enum constant. */ private Parameter param; /** * Constructor. * * @param param <i>mandatory</i> - the value for {@link */ private Parameters(final Parameter param) { this.param = param; } /** * {@inheritDoc} */ @Override public String getName() { return this.param.getName(); } /** * {@inheritDoc} */ @Override public Class<?> getType() { return this.param.getType(); } /** * {@inheritDoc} */ @Override public boolean match(final String valueStr) { return this.param.match(valueStr); } /** * {@inheritDoc} */ @Override public void matchEx(final String valueStr) { this.param.matchEx(valueStr); } /** * {@inheritDoc} */ @Override public Object parse(final String valueStr) throws ArgumentException { return this.param.parse(valueStr); } /** * {@inheritDoc} */ @Override public String toString(final Object value) throws InternalServiceException { return this.param.toString(value); } }
public enum ExtendedParameters implements Parameter { /** * ANY ENUM VALUE */ VALUE(my.package.name.VALUE); /** * EXTENDED ENUM VALUE */ EXTENDED_VALUE(new ParameterImpl<String>("EXTENDED_VALUE", String.class, "[0-9A-Za-z_.-]{1,20}")); /** * The parameter wrapped by this enum constant. */ private Parameter param; /** * Constructor. * * @param param <i>mandatory</i> - the value for {@link */ private Parameters(final Parameter param) { this.param = param; } /** * {@inheritDoc} */ @Override public String getName() { return this.param.getName(); } /** * {@inheritDoc} */ @Override public Class<?> getType() { return this.param.getType(); } /** * {@inheritDoc} */ @Override public boolean match(final String valueStr) { return this.param.match(valueStr); } /** * {@inheritDoc} */ @Override public void matchEx(final String valueStr) { this.param.matchEx(valueStr); } /** * {@inheritDoc} */ @Override public Object parse(final String valueStr) throws ArgumentException { return this.param.parse(valueStr); } /** * {@inheritDoc} */ @Override public String toString(final Object value) throws InternalServiceException { return this.param.toString(value); } }
public class ParameterImpl<T> implements Parameter { /** * The default pattern for numeric (integer, long) parameters. */ private static final Pattern NUMBER_PATTERN = Pattern.compile("[0-9]+"); /** * The default pattern for parameters of type boolean. */ private static final Pattern BOOLEAN_PATTERN = Pattern.compile("0|1|true|false"); /** * The name of the parameter, never <code>null</code>. */ private final String name; /** * The data type of the parameter. */ private final Class<T> type; /** * The validation pattern for the parameters values. This may be <code>null</code>. */ private final Pattern validator; /** * Shortcut constructor without <code>validatorPattern</code>. * * @param name <i>mandatory</i> - the value for {@link * @param type <i>mandatory</i> - the value for {@link */ public ParameterImpl(final String name, final Class<T> type) { this(name, type, null); } /** * Constructor. * * @param name <i>mandatory</i> - the value for {@link * @param type <i>mandatory</i> - the value for {@link * @param validatorPattern - <i>optional</i> - the pattern for {@link * <dl> * <dt style="margin-top:0.25cm;"><i>Note:</i> * <dd>The default validation patterns {@link * {@link * </dl> */ public ParameterImpl(final String name, final Class<T> type, final String validatorPattern) { this.name = name; this.type = type; if (null != validatorPattern) { this.validator = Pattern.compile(validatorPattern); } else if (Integer.class == this.type || Long.class == this.type) { this.validator = NUMBER_PATTERN; } else if (Boolean.class == this.type) { this.validator = BOOLEAN_PATTERN; } else { this.validator = null; } } /** * {@inheritDoc} */ @Override public boolean match(final String valueStr) { if (null == valueStr) { return false; } if (null != this.validator) { final Matcher matcher = this.validator.matcher(valueStr); return matcher.matches(); } return true; } /** * {@inheritDoc} */ @Override public void matchEx(final String valueStr) throws ArgumentException { if (false == this.match(valueStr)) { if (null == valueStr) { throw ArgumentException.createEx(ErrorCode.PARAM_MISSED, "The value must not be null", this.name); } throw ArgumentException.createEx(ErrorCode.PARAM_BAD, "The value must match the pattern: " + this.validator.pattern(), this.name); } } /** * Parse the parameters value from the given string value according to {@link * the value is checked by {@link * * @param valueStr <i>optional</i> - the string value to parse the value from * @return the parsed value, may be <code>null</code> * @throws ArgumentException in case the parameter: * <ul> * <li>does not {@link * <li>cannot be parsed according to {@link * </ul> * @throws InternalServiceException in case the type {@link * programming error. */ @Override public T parse(final String valueStr) throws ArgumentException, InternalServiceException { if (null == valueStr) { return null; } this.matchEx(valueStr); if (String.class == this.type) { return this.type.cast(valueStr); } if (Boolean.class == this.type) { return this.type.cast(Boolean.valueOf(("1".equals(valueStr)) || Boolean.valueOf(valueStr))); } try { if (Integer.class == this.type) { return this.type.cast(Integer.valueOf(valueStr)); } if (Long.class == this.type) { return this.type.cast(Long.valueOf(valueStr)); } } catch (final NumberFormatException e) { throw ArgumentException.createEx(ErrorCode.PARAM_BAD, "The value cannot be parsed as " + this.type.getSimpleName().toLowerCase() + ".", this.name); } return this.parseOther(valueStr); } /** * Field access for {@link * * @return the value of {@link */ @Override public String getName() { return this.name; } /** * Field access for {@link * * @return the value of {@link */ @Override public Class<T> getType() { return this.type; } /** * {@inheritDoc} */ @Override public final String toString(final Object value) throws InternalServiceException { if (false == this.type.isAssignableFrom(value.getClass())) { throw new InternalServiceException(ErrorCode.PANIC, "Parameter.toString(): Bad type of value. Expected {0} but is {1}.", this.type.getName(), value.getClass().getName()); } if (String.class == this.type || Integer.class == this.type || Long.class == this.type) { return String.valueOf(value); } if (Boolean.class == this.type) { return Boolean.TRUE.equals(value) ? "1" : "0"; } return this.toStringOther(value); } /** * Parse parameter values of other (non standard types). This method is called by * {@link * String, Boolean, Integer and Long). It is intended for extensions. * <dl> * <dt style="margin-top:0.25cm;"><i>Note:</i> * <dd>This default implementation always throws an InternalServiceException. * </dl> * * @param valueStr <i>mandatory</i> - the string value to parse the value from * @return the parsed value, may be <code>null</code> * @throws ArgumentException in case the parameter cannot be parsed according to {@link * @throws InternalServiceException in case the type {@link * programming error. */ protected T parseOther(final String valueStr) throws ArgumentException, InternalServiceException { throw new InternalServiceException(ErrorCode.PANIC, "ParameterImpl.parseOther(): Unsupported parameter type: " + this.type.getName()); } /** * Convert the values of other (non standard types) to their external form. This method is called * by {@link * (currently String, Boolean, Integer and Long). It is intended for extensions. * <dl> * <dt style="margin-top:0.25cm;"><i>Note:</i> * <dd>This default implementation always throws an InternalServiceException. * </dl> * * @param value <i>mandatory</i> - the parameters value * @return the external form of the parameters value, never <code>null</code> * @throws InternalServiceException in case the given <code>value</code> does not match * {@link */ protected String toStringOther(final Object value) throws InternalServiceException { throw new InternalServiceException(ErrorCode.PANIC, "ParameterImpl.toStringOther(): Unsupported parameter type: " + this.type.getName()); } }
static final Set<Short> enumA = new LinkedHashSet<>(Arrays.asList(new Short[]{ static final Set<Short> enumB = new LinkedHashSet<>(enumA); static { enumB.add((short) }
for (A a : B.values()) { switch (a) { case a: case b: case c: System.out.println("Value is: " + a.toString()); break; default: throw new IllegalStateException("This should never happen."); } }
for (Short a : enumB) { switch (a) { case case case System.out.println("Value is: " + new String(Character.toChars(a))); break; default: throw new IllegalStateException("This should never happen."); } }
static final Set<String> enumA = new LinkedHashSet<>(Arrays.asList(new String[] { "BACKWARDS", "FOREWARDS", "STANDING" })); static final Set<String> enumB = new LinkedHashSet<>(enumA); static { enumB.add("JUMP"); }
for (String a : enumB) { switch (a) { case "BACKWARDS": case "FOREWARDS": case "STANDING": System.out.println("Value is: " + a); break; default: throw new IllegalStateException("This should never happen."); } }
apply plugin: sourceSets { main { java { srcDir } } } dependencies { runtime files( runtime fileTree(dir: }
error: package com.google.gson does not exist import com.google.gson.Gson;
repositories { flatDir { dirs } } dependencies { compile name: }
repositories { mavenCentral() } dependencies { compile }
allprojects { ... repositories { flatDir { dirs "$rootProject.projectDir/libs" } mavenCentral() } ... }
repositories { mavenCentral() mavenLocal() } dependencies { compile ("com.company:utility:0.0.1") }
repositories { mavenCentral() flatDir { dirs } } ... compile name:
Reflections reflections = new Reflections("my.project.prefix"); Set<Class<? extends Object>> allClasses = reflections.getSubTypesOf(Object.class);
List<ClassLoader> classLoadersList = new LinkedList<ClassLoader>(); classLoadersList.add(ClasspathHelper.contextClassLoader()); classLoadersList.add(ClasspathHelper.staticClassLoader()); Reflections reflections = new Reflections(new ConfigurationBuilder() .setScanners(new SubTypesScanner(false ), new ResourcesScanner()) .setUrls(ClasspathHelper.forClassLoader(classLoadersList.toArray(new ClassLoader[0]))) .filterInputsBy(new FilterBuilder().include(FilterBuilder.prefix("org.your.package"))));
Set<Class<?>> classes = reflections.getSubTypesOf(Object.class);
/** * Scans all classes accessible from the context class loader which belong to the given package and subpackages. * * @param packageName The base package * @return The classes * @throws ClassNotFoundException * @throws IOException */ private static Class[] getClasses(String packageName) throws ClassNotFoundException, IOException { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); assert classLoader != null; String path = packageName.replace( Enumeration<URL> resources = classLoader.getResources(path); List<File> dirs = new ArrayList<File>(); while (resources.hasMoreElements()) { URL resource = resources.nextElement(); dirs.add(new File(resource.getFile())); } ArrayList<Class> classes = new ArrayList<Class>(); for (File directory : dirs) { classes.addAll(findClasses(directory, packageName)); } return classes.toArray(new Class[classes.size()]); } /** * Recursive method used to find all classes in a given directory and subdirs. * * @param directory The base directory * @param packageName The package name for classes found inside the base directory * @return The classes * @throws ClassNotFoundException */ private static List<Class> findClasses(File directory, String packageName) throws ClassNotFoundException { List<Class> classes = new ArrayList<Class>(); if (!directory.exists()) { return classes; } File[] files = directory.listFiles(); for (File file : files) { if (file.isDirectory()) { assert !file.getName().contains("."); classes.addAll(findClasses(file, packageName + "." + file.getName())); } else if (file.getName().endsWith(".class")) { classes.add(Class.forName(packageName + } } return classes; }
final ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false); provider.addIncludeFilter(new RegexPatternTypeFilter(Pattern.compile(".*"))); final Set<BeanDefinition> classes = provider.findCandidateComponents("my.package.name"); for (BeanDefinition bean: classes) { Class<?> clazz = Class.forName(bean.getBeanClassName()); }
final ClassLoader loader = Thread.currentThread().getContextClassLoader(); for (final ClassPath.ClassInfo info : ClassPath.from(loader).getTopLevelClasses()) { if (info.getName().startsWith("my.package.")) { final Class<?> clazz = info.load(); } }
/** * Private helper method * * @param directory * The directory to start with * @param pckgname * The package name to search for. Will be needed for getting the * Class object. * @param classes * if a file isn * @throws ClassNotFoundException */ private static void checkDirectory(File directory, String pckgname, ArrayList<Class<?>> classes) throws ClassNotFoundException { File tmpDirectory; if (directory.exists() && directory.isDirectory()) { final String[] files = directory.list(); for (final String file : files) { if (file.endsWith(".class")) { try { classes.add(Class.forName(pckgname + + file.substring(0, file.length() - 6))); } catch (final NoClassDefFoundError e) { } } else if ((tmpDirectory = new File(directory, file)) .isDirectory()) { checkDirectory(tmpDirectory, pckgname + "." + file, classes); } } } } /** * Private helper method. * * @param connection * the connection to the jar * @param pckgname * the package name to search for * @param classes * the current ArrayList of all classes. This method will simply * add new classes. * @throws ClassNotFoundException * if a file isn * @throws IOException * if it can */ private static void checkJarFile(JarURLConnection connection, String pckgname, ArrayList<Class<?>> classes) throws ClassNotFoundException, IOException { final JarFile jarFile = connection.getJarFile(); final Enumeration<JarEntry> entries = jarFile.entries(); String name; for (JarEntry jarEntry = null; entries.hasMoreElements() && ((jarEntry = entries.nextElement()) != null);) { name = jarEntry.getName(); if (name.contains(".class")) { name = name.substring(0, name.length() - 6).replace( if (name.contains(pckgname)) { classes.add(Class.forName(name)); } } } } /** * Attempts to list all the classes in the specified package as determined * by the context class loader * * @param pckgname * the package name to search * @return a list of classes that exist within that package * @throws ClassNotFoundException * if something went wrong */ public static ArrayList<Class<?>> getClassesForPackage(String pckgname) throws ClassNotFoundException { final ArrayList<Class<?>> classes = new ArrayList<Class<?>>(); try { final ClassLoader cld = Thread.currentThread() .getContextClassLoader(); if (cld == null) throw new ClassNotFoundException("Can final Enumeration<URL> resources = cld.getResources(pckgname .replace( URLConnection connection; for (URL url = null; resources.hasMoreElements() && ((url = resources.nextElement()) != null);) { try { connection = url.openConnection(); if (connection instanceof JarURLConnection) { checkJarFile((JarURLConnection) connection, pckgname, classes); } else if (connection instanceof FileURLConnection) { try { checkDirectory( new File(URLDecoder.decode(url.getPath(), "UTF-8")), pckgname, classes); } catch (final UnsupportedEncodingException ex) { throw new ClassNotFoundException( pckgname + " does not appear to be a valid package (Unsupported encoding)", ex); } } else throw new ClassNotFoundException(pckgname + " (" + url.getPath() + ") does not appear to be a valid package"); } catch (final IOException ioex) { throw new ClassNotFoundException( "IOException was thrown when trying to get all resources for " + pckgname, ioex); } } } catch (final NullPointerException ex) { throw new ClassNotFoundException( pckgname + " does not appear to be a valid package (Null pointer exception)", ex); } catch (final IOException ioex) { throw new ClassNotFoundException( "IOException was thrown when trying to get all resources for " + pckgname, ioex); } return classes; }
getClassesForPackage("package.your.classes.are.in");
package test; import java.io.DataInputStream; import java.io.InputStream; import java.net.URL; import java.util.ArrayList; import java.util.List; public class Test { public static void main(String[] args) throws Exception{ List<Class> classes = getClasses(Test.class.getClassLoader(),"test"); for(Class c:classes){ System.out.println("Class: "+c); } } public static List<Class> getClasses(ClassLoader cl,String pack) throws Exception{ String dottedPackage = pack.replaceAll("[/]", "."); List<Class> classes = new ArrayList<Class>(); URL upackage = cl.getResource(pack); DataInputStream dis = new DataInputStream((InputStream) upackage.getContent()); String line = null; while ((line = dis.readLine()) != null) { if(line.endsWith(".class")) { classes.add(Class.forName(dottedPackage+"."+line.substring(0,line.lastIndexOf( } } return classes; } }
Reflections reflections = new Reflections("my.package"); Set<Class<? extends Object>> classes = reflections.getSubTypesOf(Object.class);
@IndexSubclasses package my.package; Iterable<Class> classes = ClassIndex.getPackageClasses("my.package");
List<String> classNames = new FastClasspathScanner("com.mypackage").scan() .getNamesOfAllClasses();
/** * Attempts to list all the classes in the specified package as determined * by the context class loader, recursively, avoiding anonymous classes * * @param pckgname * the package name to search * @return a list of classes that exist within that package * @throws ClassNotFoundException * if something went wrong */ private static List<Class> getClassesForPackage(String pckgname) throws ClassNotFoundException { ArrayList<File> directories = new ArrayList<File>(); String packageToPath = pckgname.replace( try { ClassLoader cld = Thread.currentThread().getContextClassLoader(); if (cld == null) { throw new ClassNotFoundException("Can } Enumeration<URL> resources = cld.getResources(packageToPath); while (resources.hasMoreElements()) { directories.add(new File(URLDecoder.decode(resources.nextElement().getPath(), "UTF-8"))); } } catch (NullPointerException x) { throw new ClassNotFoundException(pckgname + " does not appear to be a valid package (Null pointer exception)"); } catch (UnsupportedEncodingException encex) { throw new ClassNotFoundException(pckgname + " does not appear to be a valid package (Unsupported encoding)"); } catch (IOException ioex) { throw new ClassNotFoundException("IOException was thrown when trying to get all resources for " + pckgname); } ArrayList<Class> classes = new ArrayList<Class>(); while (!directories.isEmpty()){ File directoryFile = directories.remove(0); if (directoryFile.exists()) { File[] files = directoryFile.listFiles(); for (File file : files) { if ((file.getName().endsWith(".class")) && (!file.getName().contains("$"))) { int index = directoryFile.getPath().indexOf(packageToPath); String packagePrefix = directoryFile.getPath().substring(index).replace( try { String className = packagePrefix + classes.add(Class.forName(className)); } catch (NoClassDefFoundError e) { } } else if (file.isDirectory()){ directories.add(new File(file.getPath())); } } } else { throw new ClassNotFoundException(pckgname + " (" + directoryFile.getPath() + ") does not appear to be a valid package"); } } return classes; }
Cleaning... rm -rf build/ Building... javac -d build/classes src/pro/ddopson/ClassEnumerator.java src/test/ClassIShouldFindOne.java src/test/ClassIShouldFindTwo.java src/test/subpkg/ClassIShouldFindThree.java src/test/TestClassEnumeration.java Making JAR Files... jar cf build/ClassEnumerator_test.jar -C build/classes/ . jar cf build/ClassEnumerator.jar -C build/classes/ pro Running Filesystem Classpath Test... java -classpath build/classes test.TestClassEnumeration ClassDiscovery: Package: ClassDiscovery: Reading Directory ClassDiscovery: FileName ClassDiscovery: FileName ClassDiscovery: FileName ClassDiscovery: Reading Directory ClassDiscovery: FileName ClassDiscovery: FileName Running JAR Classpath Test... java -classpath build/ClassEnumerator_test.jar test.TestClassEnumeration ClassDiscovery: Package: ClassDiscovery: Reading JAR file: ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry ClassDiscovery: JarEntry Tests Passed.
import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface EntityToBeScanned { }
public class ClassScanner { public static Set<Class<?>> allFoundClassesAnnotatedWithEntityToBeScanned(){ Reflections reflections = new Reflections(".*"); Set<Class<?>> annotated = reflections.getTypesAnnotatedWith(EntityToBeScanned.class); return annotated; } }
<!-- https: <dependency> <groupId>com.google.guava</groupId> <artifactId>guava</artifactId> <version>21.0</version> </dependency> <!-- https: <dependency> <groupId>org.javassist</groupId> <artifactId>javassist</artifactId> <version>3.22.0-CR1</version> </dependency> <!-- https: <dependency> <groupId>org.reflections</groupId> <artifactId>reflections</artifactId> <version>0.9.10</version> </dependency>
String pkg = "org/apache/commons/lang"; ClassLoader cl = ClassLoader.getSystemClassLoader(); URL[] urls = ((URLClassLoader) cl).getURLs(); for (URL url : urls) { System.out.println(url.getFile()); File jar = new File(url.getFile()); }
if (jar.isDirectory()) { File subdir = new File(jar, pkg); if (!subdir.exists()) continue; File[] files = subdir.listFiles(); for (File file : files) { if (!file.isFile()) continue; if (file.getName().endsWith(".class")) System.out.println("Found class: " + file.getName().substring(0, file.getName().length() - 6)); } }
else { try { ZipFile zip = new ZipFile(jar); for (Enumeration<? extends ZipEntry> entries = zip .entries(); entries.hasMoreElements();) { ZipEntry entry = entries.nextElement(); String name = entry.getName(); if (!name.startsWith(pkg)) continue; name = name.substring(pkg.length() + 1); if (name.indexOf( System.out.println("Found class: " + name.substring(0, name.length() - 6)); } } catch (ZipException e) { System.out.println("Not a ZIP: " + e.getMessage()); } catch (IOException e) { System.err.println(e.getMessage()); } }
import java.io.File; import java.io.IOException; import java.net.URL; import java.util.Enumeration; import java.util.LinkedList; import java.util.List; public final class ClassFinder { private final static char DOT = private final static char SLASH = private final static String CLASS_SUFFIX = ".class"; private final static String BAD_PACKAGE_ERROR = "Unable to get resources from path public final static List<Class<?>> find(final String scannedPackage) { final ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); final String scannedPath = scannedPackage.replace(DOT, SLASH); final Enumeration<URL> resources; try { resources = classLoader.getResources(scannedPath); } catch (IOException e) { throw new IllegalArgumentException(String.format(BAD_PACKAGE_ERROR, scannedPath, scannedPackage), e); } final List<Class<?>> classes = new LinkedList<Class<?>>(); while (resources.hasMoreElements()) { final File file = new File(resources.nextElement().getFile()); classes.addAll(find(file, scannedPackage)); } return classes; } private final static List<Class<?>> find(final File file, final String scannedPackage) { final List<Class<?>> classes = new LinkedList<Class<?>>(); if (file.isDirectory()) { for (File nestedFile : file.listFiles()) { classes.addAll(find(nestedFile, scannedPackage)); } } else if (file.getName().endsWith(CLASS_SUFFIX) && !file.getName().contains("$")) { final int beginIndex = 0; final int endIndex = file.getName().length() - CLASS_SUFFIX.length(); final String className = file.getName().substring(beginIndex, endIndex); try { final String resource = scannedPackage + DOT + className; classes.add(Class.forName(resource)); } catch (ClassNotFoundException ignore) { } } return classes; } }
List<Class<?>> classes = ClassFinder.find("com.package"); ExcelReporting excelReporting; for (Class<?> aClass : classes) { Constructor constructor = aClass.getConstructor(); constructor.newInstance(); }
import javax.tools.JavaFileObject; import javax.tools.StandardJavaFileManager; import javax.tools.StandardLocation; import javax.tools.ToolProvider; import java.io.File; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.regex.Pattern; import java.util.stream.Collectors; import java.util.stream.StreamSupport; public class PackageUtil { public static Collection<Class> getClasses(final String pack) throws Exception { final StandardJavaFileManager fileManager = ToolProvider.getSystemJavaCompiler().getStandardFileManager(null, null, null); return StreamSupport.stream(fileManager.list(StandardLocation.CLASS_PATH, pack, Collections.singleton(JavaFileObject.Kind.CLASS), false).spliterator(), false) .map(javaFileObject -> { try { final String[] split = javaFileObject.getName() .replace(".class", "") .replace(")", "") .split(Pattern.quote(File.separator)); final String fullClassName = pack + "." + split[split.length - 1]; return Class.forName(fullClassName); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } }) .collect(Collectors.toCollection(ArrayList::new)); } }
public static void main(String[] args) throws Exception { final String pack = "java.nio.file"; PackageUtil.getClasses(pack).stream().forEach(System.out::println); }
List<Class> myTypes = new ArrayList<>(); Reflections reflections = new Reflections("com.package"); for (String s : reflections.getStore().get(SubTypesScanner.class).values()) { myTypes.add(Class.forName(s)); }
------------------------------------------------------- T E S T S ------------------------------------------------------- Running some.properly.named.test.run.with.maven.SomeTest Tests run: 0, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.123 sec
Reflections reflections = new Reflections(new ConfigurationBuilder() .setScanners(new SubTypesScanner(false ), new ResourcesScanner()) .addUrls(ClasspathHelper.forJavaClassPath()) .filterInputsBy(new FilterBuilder() .include(FilterBuilder.prefix(basePackage)))); Set<Class<?>> subTypesOf = reflections.getSubTypesOf(Object.class);
package eric.j2se.reflect; import java.util.Set; import org.reflections.Reflections; import org.reflections.scanners.ResourcesScanner; import org.reflections.scanners.SubTypesScanner; import org.reflections.util.ClasspathHelper; import org.reflections.util.ConfigurationBuilder; import org.reflections.util.FilterBuilder; /** * an util to iterate class in a package, * * @author eric * @date Dec 10, 2013 12:36:46 AM */ public class IteratePackageUtil { /** * <p> * Get set of all class in a specified package recursively. this only support lib * </p> * <p> * class of sub package will be included, inner class will be included, * </p> * <p> * could load class that use the same classloader of current class, can * </p> * * @param pkg * path of a package * @return */ public static Set<Class<? extends Object>> getClazzSet(String pkg) { Reflections reflections = new Reflections(new ConfigurationBuilder().setScanners(new SubTypesScanner(false), new ResourcesScanner()) .setUrls(ClasspathHelper.forClassLoader(ClasspathHelper.classLoaders(new ClassLoader[0]))) .filterInputsBy(new FilterBuilder().includePackage(pkg))); return reflections.getSubTypesOf(Object.class); } public static void test() { String pkg = "org.apache.tomcat.util"; Set<Class<? extends Object>> clazzSet = getClazzSet(pkg); for (Class<? extends Object> clazz : clazzSet) { System.out.println(clazz.getName()); } } public static void main(String[] args) { test(); } }
package play.util; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.Enumeration; import java.util.List; import java.util.jar.JarEntry; import java.util.jar.JarFile; /** * Created by LINKOR on 26.05.2017 in 15:12. * Date: 2017.05.26 */ public class FileClassFinder { private JarFile file; private boolean trouble; public FileClassFinder(String filePath) { try { file = new JarFile(filePath); } catch (IOException e) { trouble = true; } } public List<String> findClasses(String pkg) { ArrayList<String> classes = new ArrayList<>(); Enumeration<JarEntry> entries = file.entries(); while (entries.hasMoreElements()) { JarEntry cls = entries.nextElement(); if (!cls.isDirectory()) { String fileName = cls.getName(); String className = fileName.replaceAll("/", ".").replaceAll(File.pathSeparator, ".").substring(0, fileName.lastIndexOf( if (className.startsWith(pkg)) classes.add(className.substring(pkg.length() + 1)); } } return classes; } }
import java.io.File; import java.io.FileFilter; import java.util.ArrayList; ... Class<?>[] foundClasses = new Class<?>[0]; final ArrayList<Class<?>> foundClassesDyn = new ArrayList<Class<?>>(); new java.io.File( klass.getResource( "/" + curPackage.replace( "." , "/") ).getFile() ).listFiles( new java.io.FileFilter() { public boolean accept(java.io.File file) { final String classExtension = ".class"; if ( file.isFile() && file.getName().endsWith(classExtension) && ! file.getName().contains("$") ) { try { String className = file.getName(); className = className.substring(0, className.length() - classExtension.length()); foundClassesDyn.add( Class.forName( curPackage + "." + className ) ); } catch (ClassNotFoundException e) { e.printStackTrace(System.out); } } return false; } } ); foundClasses = foundClassesDyn.toArray(foundClasses);
public class JavaClass{ protected JavaClass(int x){} public void main(String[] args){ } }
/* * Get the application * ... ... */ if (jarfile != 0) { mainClassName = GetMainClassName(env, jarfile); ... ... mainClass = LoadClass(env, classname); if(mainClass == NULL) { ... ... mainID = (*env)->GetStaticMethodID(env, mainClass, "main", "([Ljava/lang/String;)V"); ... ... { jint mods; jmethodID mid; jobject obj = (*env)->ToReflectedMethod(env, mainClass, mainID, JNI_TRUE); ... ... mainArgs = NewPlatformStringArray(env, argv, argc); if (mainArgs == NULL) { ReportExceptionDescription(env); goto leave; } (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs); ... ...
class MyApplication { public MyApplication(){ } public void main(String[] args){ } }
class demo { private int length; private static int breadth; void output(){ length=5; System.out.println(length); } static void staticOutput(){ breadth=10; System.out.println(breadth); } public static void main(String args[]){ demo d1=new demo(); d1.output(); staticOutput(); /* Although: demo.staticOutput(); Works fine d1.staticOutput(); Works fine */ } }
public static String humanReadableByteCount(long bytes, boolean si) { int unit = si ? 1000 : 1024; if (bytes < unit) return bytes + " B"; int exp = (int) (Math.log(bytes) / Math.log(unit)); String pre = (si ? "kMGTPE" : "KMGTPE").charAt(exp-1) + (si ? "" : "i"); return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre); }
SI BINARY 0: 0 B 0 B 27: 27 B 27 B 999: 999 B 999 B 1000: 1.0 kB 1000 B 1023: 1.0 kB 1023 B 1024: 1.0 kB 1.0 KiB 1728: 1.7 kB 1.7 KiB 110592: 110.6 kB 108.0 KiB 7077888: 7.1 MB 6.8 MiB 452984832: 453.0 MB 432.0 MiB 28991029248: 29.0 GB 27.0 GiB 1855425871872: 1.9 TB 1.7 TiB 9223372036854775807: 9.2 EB 8.0 EiB (Long.MAX_VALUE)
android.text.format.Formatter.formatShortFileSize(activityContext, bytes);
android.text.format.Formatter.formatFileSize(activityContext, bytes);
------------------------------- >53 B (Bytes) >43 KB >33 MB >23 GB >13 TB >3 PB <=2 EB
public static String formatSize(long v) { if (v < 1024) return v + " B"; int z = (63 - Long.numberOfLeadingZeros(v)) / 10; return String.format("%.1f %sB", (double)v / (1L << (z*10)), " KMGTPE".charAt(z)); }
private static final long K = 1024; private static final long M = K * K; private static final long G = M * K; private static final long T = G * K; public static String convertToStringRepresentation(final long value){ final long[] dividers = new long[] { T, G, M, K, 1 }; final String[] units = new String[] { "TB", "GB", "MB", "KB", "B" }; if(value < 1) throw new IllegalArgumentException("Invalid file size: " + value); String result = null; for(int i = 0; i < dividers.length; i++){ final long divider = dividers[i]; if(value >= divider){ result = format(value, divider, units[i]); break; } } return result; } private static String format(final long value, final long divider, final String unit){ final double result = divider > 1 ? (double) value / (double) divider : (double) value; return new DecimalFormat(" }
public static void main(final String[] args){ final long[] l = new long[] { 1l, 4343l, 43434334l, 3563543743l }; for(final long ll : l){ System.out.println(convertToStringRepresentation(ll)); } }
private static final String[] SI_UNITS = { "B", "kB", "MB", "GB", "TB", "PB", "EB" }; private static final String[] BINARY_UNITS = { "B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB" }; public static String humanReadableByteCount(final long bytes, final boolean useSIUnits, final Locale locale) { final String[] units = useSIUnits ? SI_UNITS : BINARY_UNITS; final int base = useSIUnits ? 1000 : 1024; if (bytes < base) { return bytes + " " + units[0]; } final int exponent = (int) (Math.log(bytes) / Math.log(base)); final String unit = units[exponent]; return String.format(locale, "%.1f %s", bytes / Math.pow(base, exponent), unit); }
/** * formats the bytes to a human readable format * * @param si true if each kilo==1000, false if kilo==1024 */ @SuppressLint("DefaultLocale") public static String humanReadableByteCount(final long bytes,final boolean si) { final int unit=si ? 1000 : 1024; if(bytes<unit) return bytes+" B"; double result=bytes; final String unitsToUse=(si ? "k" : "K")+"MGTPE"; int i=0; final int unitsCount=unitsToUse.length(); while(true) { result/=unit; if(result<unit) break; if(i==unitsCount-1) break; ++i; } final StringBuilder sb=new StringBuilder(9); sb.append(String.format("%.1f ",result)); sb.append(unitsToUse.charAt(i)); if(si) sb.append( else sb.append( final String resultStr=sb.toString(); return resultStr; }
private static final String[] Q = new String[]{"", "K", "M", "G", "T", "P", "E"}; public String getAsString(long bytes) { for (int i = 6; i > 0; i--) { double step = Math.pow(1024, i); if (bytes > step) return String.format("%3.1f %s", bytes / step, Q[i]); } return Long.toString(bytes); }
public static String floatForm (double d) { return new DecimalFormat(" } public static String bytesToHuman (long size) { long Kb = 1 * 1024; long Mb = Kb * 1024; long Gb = Mb * 1024; long Tb = Gb * 1024; long Pb = Tb * 1024; long Eb = Pb * 1024; if (size < Kb) return floatForm( size ) + " byte"; if (size >= Kb && size < Mb) return floatForm((double)size / Kb) + " Kb"; if (size >= Mb && size < Gb) return floatForm((double)size / Mb) + " Mb"; if (size >= Gb && size < Tb) return floatForm((double)size / Gb) + " Gb"; if (size >= Tb && size < Pb) return floatForm((double)size / Tb) + " Tb"; if (size >= Pb && size < Eb) return floatForm((double)size / Pb) + " Pb"; if (size >= Eb) return floatForm((double)size / Eb) + " Eb"; return "???"; }
private String bytesIntoHumanReadable(long bytes) { long kilobyte = 1024; long megabyte = kilobyte * 1024; long gigabyte = megabyte * 1024; long terabyte = gigabyte * 1024; if ((bytes >= 0) && (bytes < kilobyte)) { return bytes + " B"; } else if ((bytes >= kilobyte) && (bytes < megabyte)) { return (bytes / kilobyte) + " KB"; } else if ((bytes >= megabyte) && (bytes < gigabyte)) { return (bytes / megabyte) + " MB"; } else if ((bytes >= gigabyte) && (bytes < terabyte)) { return (bytes / gigabyte) + " GB"; } else if (bytes >= terabyte) { return (bytes / terabyte) + " TB"; } else { return bytes + " Bytes"; } }
UnitFormatter.formatAsUnit(1126, UnitSystem.SI, "B"); UnitFormatter.formatAsUnit(2094, UnitSystem.IEC, "B");
UnitFormatter.formatAsUnits(12_000_678, UnitSystem.SI, "W", ", ");
UnitFormatter.formatAsUnit(2085, UnitSystem.IEC, "B", new DecimalFormat("0.0000"));
UnitComponent uc = new UnitComponent(123_345_567_789L, UnitSystem.SI); int kilos = uc.kilo(); int gigas = uc.giga();
long input1 = 1024; long input2 = 1024 * 1024; Assert.assertEquals("1 KiB", BinaryByteUnit.format(input1)); Assert.assertEquals("1 MiB", BinaryByteUnit.format(input2)); Assert.assertEquals("1.024 KB", DecimalByteUnit.format(input1, " Assert.assertEquals("1.049 MB", DecimalByteUnit.format(input2, " NumberFormat format = new DecimalFormat(" Assert.assertEquals("1 KiB", BinaryByteUnit.format(input1, format)); Assert.assertEquals("1 MiB", BinaryByteUnit.format(input2, format));
String formattedUnit1 = StorageUnits.formatAsCommonUnit(input1, " String formattedUnit2 = StorageUnits.formatAsCommonUnit(input2, " String formattedUnit3 = StorageUnits.formatAsBinaryUnit(input1); String formattedUnit4 = StorageUnits.formatAsBinaryUnit(input2); String formattedUnit5 = StorageUnits.formatAsDecimalUnit(input1, " String formattedUnit6 = StorageUnits.formatAsDecimalUnit(input2, " String formattedUnit7 = StorageUnits.formatAsBinaryUnit(input1, format); String formattedUnit8 = StorageUnits.formatAsBinaryUnit(input2, format); Assert.assertEquals("1 kB", formattedUnit1); Assert.assertEquals("1 MB", formattedUnit2); Assert.assertEquals("1.00 KiB", formattedUnit3); Assert.assertEquals("1.00 MiB", formattedUnit4); Assert.assertEquals("1,02 kB", formattedUnit5); Assert.assertEquals("1,05 MB", formattedUnit6); Assert.assertEquals("1 KiB", formattedUnit7); Assert.assertEquals("1 MiB", formattedUnit8);
String formattedUnit9 = StorageUnits.formatAsKibibyte(input2); String formattedUnit10 = StorageUnits.formatAsCommonMegabyte(input2); Assert.assertEquals("1024.00 KiB", formattedUnit9); Assert.assertEquals("1.00 MB", formattedUnit10);
public interface IUnits { public String format(long size, String pattern); public long getUnitSize(); }
import java.text.DecimalFormat; public class StorageUnits { private static final long K = 1024; private static final long M = K * K; private static final long G = M * K; private static final long T = G * K; enum Unit implements IUnits { TERA_BYTE { @Override public String format(long size, String pattern) { return format(size, getUnitSize(), "TB", pattern); } @Override public long getUnitSize() { return T; } @Override public String toString() { return "Terabytes"; } }, GIGA_BYTE { @Override public String format(long size, String pattern) { return format(size, getUnitSize(), "GB", pattern); } @Override public long getUnitSize() { return G; } @Override public String toString() { return "Gigabytes"; } }, MEGA_BYTE { @Override public String format(long size, String pattern) { return format(size, getUnitSize(), "MB", pattern); } @Override public long getUnitSize() { return M; } @Override public String toString() { return "Megabytes"; } }, KILO_BYTE { @Override public String format(long size, String pattern) { return format(size, getUnitSize(), "kB", pattern); } @Override public long getUnitSize() { return K; } @Override public String toString() { return "Kilobytes"; } }; String format(long size, long base, String unit, String pattern) { return new DecimalFormat(pattern).format( Long.valueOf(size).doubleValue() / Long.valueOf(base).doubleValue() ) + unit; } } public static String format(long size, String pattern) { for(Unit unit : Unit.values()) { if(size >= unit.getUnitSize()) { return unit.format(size, pattern); } } return ("???(" + size + ")???"); } public static String format(long size) { return format(size, " } }
class Main { public static void main(String... args) { System.out.println(StorageUnits.format(21885)); System.out.println(StorageUnits.format(2188121545L)); } }
String[] fileSizeUnits = {"bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"}; public String calculateProperFileSize(double bytes){ String sizeToReturn = ""; int index = 0; for(index = 0; index < fileSizeUnits.length; index++){ if(bytes < 1024){ break; } bytes = bytes / 1024; }
public static String BytesNumberToHumanReadableString(long bytes, bool SI1000orBinary1024) { int unit = SI1000orBinary1024 ? 1000 : 1024; if (bytes < unit) return bytes + " B"; int exp = (int)(Math.Log(bytes) / Math.Log(unit)); String pre = (SI1000orBinary1024 ? "kMGTPE" : "KMGTPE")[(exp - 1)] + (SI1000orBinary1024 ? "" : "i"); return String.Format("{0:F1} {1}B", bytes / Math.Pow(unit, exp), pre); }
func sizeOf(bytes int64) string { const unit = 1024 if bytes < unit { return fmt.Sprintf("%d B", bytes) } fb := float64(bytes) exp := int(math.Log(fb) / math.Log(unit)) pre := "KMGTPE"[exp-1] div := math.Pow(unit, float64(exp)) return fmt.Sprintf("%.1f %ciB", fb / div, pre) }
filename=filedilg.getSelectedFile().getAbsolutePath(); File file=new File(filename); String disp=FileUtils.byteCountToDisplaySize(file.length()); System.out.println("THE FILE PATH IS "+file+"THIS File SIZE IS IN MB "+disp);
public static String humanReadableInt(long number) { return TraditionalBinaryPrefix.long2String(number,,1); }
long Kb = 1024; long Mb = Kb * 1024; long Gb = Mb * 1024; long Tb = Gb * 1024; long Pb = Tb * 1024; long Eb = Pb * 1024; if (size < Kb) return size.ToString() + " byte"; if (size < Mb) return (size / Kb).ToString(" if (size < Gb) return (size / Mb).ToString(" if (size < Tb) return (size / Gb).ToString(" if (size < Pb) return (size / Tb).ToString(" if (size < Eb) return (size / Pb).ToString(" if (size >= Eb) return (size / Eb).ToString(" return "invalid size";
@Transactional(readOnly = false, rollbackFor = Exception.class)
@Transactional(rollbackFor={MyApplicationException.class}) public void myMethod(){ try { } catch(Throwable e) { log.error(e) throw new MyApplicationException(..); } }
@OneToMany(fetch = FetchType.LAZY, mappedBy="country") private Set<City> cities;
public Country getCountry(){ Country country = countryRepository.getCountry(); }
@Transactional public Country getCountry(){ Country country = countryRepository.getCountry(); Object object = country.getCities().size(); }
@Transactional public class DefaultFooService implements FooService { Foo getFoo(String fooName); Foo getFoo(String fooName, String barName); void insertFoo(Foo foo); void updateFoo(Foo foo); }
public class SomeClass { public final static SOME_INSTANCE = new SomeClass(5); private SomeClass(final int value) { }
public class Test{ private Test(Class beanClass, Class stopClass, int flags) throws Exception{ } }
class Derived extends Base { public int method() { return 1; } }
class Base { public String method() { return null; } }
public class Employee { void greet() { System.out.println("Hello everyone!"); } }
public class GrumpyEmployee extends Employee { @Override void greet() { System.out.println("Get lost!"); } }
public class TestFinal { static Employee grumpyEmployee = new GrumpyEmployee(); public static void main(String[] args) { TestFinal testFinal = new TestFinal(); testFinal.sayHello(grumpyEmployee); } private void sayHello(Employee employee) { employee.greet(); } }
import java.awt.Component; import java.awt.Dimension; import java.awt.EventQueue; import java.awt.GridLayout; import java.awt.KeyboardFocusManager; import java.beans.PropertyChangeEvent; import java.beans.PropertyChangeListener; import java.util.ArrayList; import java.util.List; import javax.swing.JComponent; import javax.swing.JDesktopPane; import javax.swing.JFrame; import javax.swing.JInternalFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTextField; import javax.swing.SwingUtilities; /** * @see https: * @see https: */ public class DesignTest { private List<JTextField> list = new ArrayList<JTextField>(); private JPanel panel = new JPanel(); private JScrollPane sp = new JScrollPane(panel); public static void main(String args[]) { EventQueue.invokeLater(new Runnable() { @Override public void run() { DesignTest id = new DesignTest(); id.create("My Project"); } }); } private void addField(String name) { JTextField jtf = new JTextField(16); panel.add(new JLabel(name, JLabel.LEFT)); panel.add(jtf); list.add(jtf); } private void create(String strProjectName) { panel.setLayout(new GridLayout(0, 1)); addField("First Name:"); addField("Last Name:"); addField("Address:"); addField("City:"); addField("Zip Code:"); addField("Phone:"); addField("Email Id:"); KeyboardFocusManager.getCurrentKeyboardFocusManager() .addPropertyChangeListener("permanentFocusOwner", new FocusDrivenScroller(panel)); sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS); sp.validate(); Dimension d = sp.getPreferredSize(); d.setSize(d.width, d.height / 2); sp.setPreferredSize(d); JInternalFrame internaFrame = new JInternalFrame(); internaFrame.add(sp); internaFrame.pack(); internaFrame.setVisible(true); JDesktopPane desktopPane = new JDesktopPane(); desktopPane.add(internaFrame); JFrame frmtest = new JFrame(); frmtest.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frmtest.add(desktopPane); frmtest.pack(); frmtest.setSize(400, 300); frmtest.setLocationRelativeTo(null); frmtest.setVisible(true); list.get(0).requestFocusInWindow(); } private static class FocusDrivenScroller implements PropertyChangeListener { private JComponent parent; public FocusDrivenScroller(JComponent parent) { this.parent = parent; } @Override public void propertyChange(PropertyChangeEvent evt) { Component focused = (Component) evt.getNewValue(); if (focused != null && SwingUtilities.isDescendingFrom(focused, parent)) { parent.scrollRectToVisible(focused.getBounds()); } } } }
<pre> +--------------+--------+ | | ...data... |[Remove]| | ...data... | | | ...data... | | +--------------+--------+ </pre>
TreeSet<String> ts = new TreeSet<String>(); ts.add(null); HashSet<String> hs = new HashSet<String>(); hs.add(null);
  Property  HashSet  TreeSet  LinkedHashSet     no guarantee order  sorted according    Order  will remain constant to the natural  insertion-order    over time  ordering     Add/remove  O(1)  O(log(n))  O(1)      NavigableSet    Interfaces  Set  Set  Set     SortedSet       not allowed    Null values  allowed  1st element only  allowed     in Java 7      Fail-fast behavior of an iterator cannot be guaranteed   Fail-fast  impossible to make any hard guarantees in the presence of   behavior  unsynchronized concurrent modification    Is    synchronized  implementation is not synchronized  
import java.util.HashSet; import java.util.Set; import java.util.TreeSet; public class HashTreeSetCompare { O(Hash + tree set) > O(tree set) ?? Really???? Why? public static void main(String args[]) { int size = 80000; useHashThenTreeSet(size); useTreeSetOnly(size); } private static void useTreeSetOnly(int size) { System.out.println("useTreeSetOnly: "); long start = System.currentTimeMillis(); Set<String> sortedSet = new TreeSet<String>(); for (int i = 0; i < size; i++) { sortedSet.add(i + ""); } long end = System.currentTimeMillis(); System.out.println("useTreeSetOnly: " + (end - start)); } private static void useHashThenTreeSet(int size) { System.out.println("useHashThenTreeSet: "); long start = System.currentTimeMillis(); Set<String> set = new HashSet<String>(); for (int i = 0; i < size; i++) { set.add(i + ""); } Set<String> sortedSet = new TreeSet<String>(set); long end = System.currentTimeMillis(); System.out.println("useHashThenTreeSet: " + (end - start)); } }
object references an unsaved transient instance - save the transient instance before flushing
@OneToOne(cascade = {CascadeType.ALL}) @JoinColumn(name = "performancelog_id") public PerformanceLog getPerformanceLog() { return performanceLog; }
import org.hibernate.annotations.Cascade; import org.hibernate.annotations.CascadeType; ... @Cascade({CascadeType.SAVE_UPDATE}) private Set<Child> children;
@OneToMany(cascade = CascadeType.ALL, mappedBy="globalConfig", orphanRemoval = true) private Set<GlobalConfigScope>gcScopeSet;
@ManyToOne @JoinColumn(name="global_config_id") private GlobalConfig globalConfig;
@ManyToOne(cascade = CascadeType.PERSIST) @JoinColumn(name="global_config_id") private GlobalConfig globalConfig;
{ code block that performed the operation } catch (Exception e) { e.printStackTrace(); return ERROR; }
Permission p = new Permission(); p.setName("help"); Permission p2 = new Permission(); p2.setName("self_info"); p = (Permission)crudRepository.save(p); p2 = (Permission)crudRepository.save(p2); Role role = new Role(); role.setAvailable(true); role.setDescription("a test role"); role.setRole("admin"); List<Permission> pList = new ArrayList<Permission>(); pList.add(p); pList.add(p2); role.setPermissions(pList); crudRepository.save(role);
Employee emp = new Employee(); emp.setDept(new Dept(deptId)); em.persist(emp);
this.lastName = lastName; this.isAdmin = isAdmin; this.accountStatus = "Active"; this.setNewPassword(password); this.timeJoin = new Date(); create();
this.lastName = lastName; this.isAdmin = isAdmin; this.accountStatus = "Active"; this.timeJoin = new Date(); create(); this.setNewPassword(password);
object references an unsaved transient instance - save the transient instance before flushing
Exception in thread "main" java.lang.IllegalStateException: org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: com.model.Car_OneToMany
@OneToMany(cascade = {CascadeType.ALL}) @Column(name = "ListOfCarsDrivenByDriver") private List<Car_OneToMany> listOfCarsBeingDriven = new ArrayList<Car_OneToMany>();
insert into Department (name, numOfemp, Depno) values (?, ?, ?) Hibernate: insert into Employee (SSN, dep_Depno, firstName, lastName, middleName, empno) values (?, ?, ?, ?, ?, ?) Session session=sf.openSession(); session.beginTransaction(); session.save(dep); session.save(emp);
Department dept = (Department)session.load(Department.class, dept_code); employee.setDepartment(dept);
@Entity(name = "ic_advance_salary") @Table(name = "ic_advance_salary") public class AdvanceSalary extends BaseDO{ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "id") private Integer id; @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = "employee_id", nullable = false) private Employee employee; @Column(name = "employee_id", insertable=false, updatable=false) @NotNull(message="Please enter employee Id") private Long employee_id; @Column(name = "advance_date") @DateTimeFormat(pattern = "dd-MMM-yyyy") @NotNull(message="Please enter advance date") private Date advance_date; @Column(name = "amount") @NotNull(message="Please enter Paid Amount") private Double amount; @Column(name = "cheque_date") @DateTimeFormat(pattern = "dd-MMM-yyyy") private Date cheque_date; @Column(name = "cheque_no") private String cheque_no; @Column(name = "remarks") private String remarks; public AdvanceSalary() { } public AdvanceSalary(Integer advance_salary_id) { this.id = advance_salary_id; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Employee getEmployee() { return employee; } public void setEmployee(Employee employee) { this.employee = employee; } public Long getEmployee_id() { return employee_id; } public void setEmployee_id(Long employee_id) { this.employee_id = employee_id; } }
public class Reference implements Serializable { @Id @Column(precision=20, scale=0) private BigInteger id; @Temporal(TemporalType.TIMESTAMP) private Date modifiedOn; @OneToOne(mappedBy="reference") private ReferenceAdditionalDetails refAddDetails; . . . }
public class ReferenceAdditionalDetails implements Serializable{ private static final long serialVersionUID = 1L; @Id @OneToOne @JoinColumn(name="reference",referencedColumnName="id") private Reference reference; private String preferedSector1; private String preferedSector2; . . }
. . reference.setRefAddDetails(null); reference = referenceDao.create(reference); entityManager.flush(); . .
if (obj instanceof C) ; if (C.class.isInstance(obj)) ; if (C.class.isAssignableFrom(obj.getClass())) ; try { C c = (C) obj; } catch (ClassCastException e) { } try { C c = C.class.cast(obj); } catch (ClassCastException e) { }
Object instance = new SomeClass(); instance.getClass().getName(); instance.getClass();
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String name = request.getClass().getName(); }
ArrayList<Tienda> tiendas; List<Tienda> tiendasList; tiendas = new ArrayList<Tienda>(); Resources res = this.getBaseContext().getResources(); XMLParser saxparser = new XMLParser(marca,res); tiendasList = saxparser.parse(marca,res); tiendas = tiendasList.toArray(); this.adaptador = new adaptadorMarca(this, R.layout.filamarca, tiendas); setListAdapter(this.adaptador);
Foo[] array = new Foo[list.size()]; list.toArray(array);
List<Integer> list = ...; int[] array = new int[list.size()]; for(int i = 0; i < list.size(); i++) array[i] = list.get(i);
String[] strings = list.stream().toArray(String[]::new);
List<Long> list = new ArrayList<Long>(); list.add(100l); list.add(200l); list.add(300l); Long[] array = (Long[]) list.toArray(new Long[list.size()]); System.out.println(array[0] + " " + array[1] + " " + array[2]);
ArrayList<Foo> list = new ArrayList<Foo>(); Foo[] resultArray = new Foo[list.size()]; resultArray = list.toArray(resultArray);
import java.util.ArrayList; public class CopyElementsOfArrayListToArrayExample { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); arrayList.add("1"); arrayList.add("2"); arrayList.add("3"); arrayList.add("4"); arrayList.add("5"); /* To copy all elements of java ArrayList object into array use Object[] toArray() method. */ Object[] objArray = arrayList.toArray(); System.out.println("ArrayList elements are copied into an Array. Now Array Contains.."); for(int index=0; index < objArray.length ; index++) System.out.println(objArray[index]); } } /* Output would be ArrayList elements are copied into an Array. Now Array Contains.. 1 2 3 4 5
public static Object[] toArray(List<?> a) { Object[] arr = new Object[a.size()]; for (int i = 0; i < a.size(); i++) arr[i] = a.get(i); return arr; }
public static void main(String[] args) { List<String> list = new ArrayList<String>() {{ add("hello"); add("world"); }}; Object[] arr = toArray(list); System.out.println(arr[0]); }
public static <T> T[] toArray(List<T> list, Class<T> objectClass) { if (list == null) { return null; } T[] listAsArray = (T[]) Array.newInstance(objectClass, list.size()); list.toArray(listAsArray); return listAsArray; }
ArrayList<String> stringList = new ArrayList<String>(); stringList.add("ListItem1"); stringList.add("ListItem2"); String[] stringArray = new String[stringList.size()]; stringArray = stringList.toArray(stringList);
for(String value : stringList) { System.out.println(value); }
List list = new ArrayList(); list.add("Apple"); list.add("Banana"); Object[] ol = list.toArray();
System.out.println(response.split("\r\n\r\n")[1]); System.out.println("******"); System.out.println(response.split("\r\n\r\n")[1].getBytes().toString());
String decompressGZIP(byte[] gzip) throws IOException { java.util.zip.Inflater inf = new java.util.zip.Inflater(); java.io.ByteArrayInputStream bytein = new java.io.ByteArrayInputStream(gzip); java.util.zip.GZIPInputStream gzin = new java.util.zip.GZIPInputStream(bytein); java.io.ByteArrayOutputStream byteout = new java.io.ByteArrayOutputStream(); int res = 0; byte buf[] = new byte[1024]; while (res >= 0) { res = gzin.read(buf, 0, buf.length); if (res > 0) { byteout.write(buf, 0, res); } } byte uncompressed[] = byteout.toByteArray(); return (uncompressed.toString()); }
byte[] b = string.getBytes(); byte[] b = string.getBytes(Charset.forName("UTF-8")); byte[] b = string.getBytes(StandardCharsets.UTF_8);
String string = new String(byte[] bytes, Charset charset);
String example = "Convert Java String"; byte[] bytes = example.getBytes();
String data = "sample data"; byte[] byteData = data.getBytes();
String abc="abcdefghight"; byte[] b = abc.getBytes();
Bool DmgrGetVersion (String szVersion); Char NewszVersion [200]; Strcpy (NewszVersion, szVersion.t_str ()); .t_str () applies to builder c ++ 2010
public static byte[] asBytes (String s) { String tmp; byte[] b = new byte[s.length() / 2]; int i; for (i = 0; i < s.length() / 2; i++) { tmp = s.substring(i * 2, i * 2 + 2); b[i] = (byte)(Integer.parseInt(tmp, 16) & 0xff); } return b; }
Matching Java Virtual Machines (3): 1.8.0_05, x86_64: "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home 1.6.0_65-b14-462, x86_64: "Java SE 6" /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 1.6.0_65-b14-462, i386: "Java SE 6" /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home
export JAVA_HOME=`/usr/libexec/java_home -v 1.6.0_65-b14-462`
java version "1.6.0_65" Java(TM) SE Runtime Environment (build 1.6.0_65-b14-462-11M4609) Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-462, mixed mode)
alias j12="export JAVA_HOME=`/usr/libexec/java_home -v 12`; java -version" alias j11="export JAVA_HOME=`/usr/libexec/java_home -v 11`; java -version" alias j10="export JAVA_HOME=`/usr/libexec/java_home -v 10`; java -version" alias j9="export JAVA_HOME=`/usr/libexec/java_home -v 9`; java -version" alias j8="export JAVA_HOME=`/usr/libexec/java_home -v 1.8`; java -version" alias j7="export JAVA_HOME=`/usr/libexec/java_home -v 1.7`; java -version"
$ j8 java version "1.8.0_102" Java(TM) SE Runtime Environment (build 1.8.0_102-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)
function jhome set JAVA_HOME (/usr/libexec/java_home $argv) echo "JAVA_HOME:" $JAVA_HOME echo "java -version:" java -version end
jhome () { export JAVA_HOME=`/usr/libexec/java_home $@` echo "JAVA_HOME:" $JAVA_HOME echo "java -version:" java -version }
sudo ln -nsf /Library/Java/JavaVirtualMachines/jdk1.7.0_51.jdk/Contents \ /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK
export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_51.jdk/Contents/Home"
/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home
touch .bash_profile open -a TextEdit.app .bash_profile
export JAVA_HOME="$(/usr/libexec/java_home -v 1.8)"
function setjdk() { if [ $ removeFromPath if [ -n "${JAVA_HOME+x}" ]; then removeFromPath $JAVA_HOME fi export JAVA_HOME=`/usr/libexec/java_home -v $@` export PATH=$JAVA_HOME/bin:$PATH fi }
**USAGE** /usr/libexec/java_home helps users set a $JAVA_HOME in their login rc files, or provides a way for command-line Java tools to use the most appropriate JVM which can satisfy a minimum version or archi- tecture requirement. The --exec argument can invoke tools in the selected $JAVA_HOME/bin directory, which is useful for starting Java command-line tools from launchd plists without hardcoding the full path to the Java command-line tool. Usage for bash-style shells: $ export JAVA_HOME=`/usr/libexec/java_home` Usage for csh-style shells: % setenv JAVA_HOME `/usr/libexec/java_home`
jenv add /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
$ cat ~/.jdk alias jdks="/usr/libexec/java_home -V" function jdk() { echo "Switching java version $1"; requestedVersion=$1 oldStyleVersion=8 if [ $requestedVersion -gt $oldStyleVersion ]; then export JAVA_HOME=$(/usr/libexec/java_home -v $1); else export JAVA_HOME=`/usr/libexec/java_home -v 1.$1`; fi echo "Setting JAVA_HOME=$JAVA_HOME" which java java -version; }
$ jdk 8 Switching java version 8 Setting JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home /usr/bin/java java version "1.8.0_131" Java(TM) SE Runtime Environment (build 1.8.0_131-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
$ jdk 9 Switching java version 9 Setting JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home /usr/bin/java java version "9.0.1" Java(TM) SE Runtime Environment (build 9.0.1+11) Java HotSpot(TM) 64-Bit Server VM (build 9.0.1+11, mixed mode)
alias j8="jhome -v 1.8.0_162" alias j9="jhome -v 9.0.1" function jhome set -g -x JAVA_HOME (/usr/libexec/java_home $argv) echo "JAVA_HOME:" $JAVA_HOME echo "java -version:" java -version end funcsave jhome
/usr/libexec/java_home -V 579ms  Wed 14 Feb 11:44:01 2018 Matching Java Virtual Machines (3): 9.0.1, x86_64: "Java SE 9.0.1" /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home 1.8.0_162, x86_64: "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home 1.8.0_121, x86_64: "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home
alias jdks="/usr/libexec/java_home -V" function jdk() { echo "Switching java version"; export JAVA_HOME=`/usr/libexec/java_home -v 1.$1`; java -version; }
1. export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home 2. source ~/.zshrc - Restart zshrc to reflect the changes. 3. echo $JAVA_HOME - make sure path is set up properly ----> /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home 4. java -version --> java version "1.8.0_112" Java(TM) SE Runtime Environment (build 1.8.0_112-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)
/usr/libexec/java_home -v 1.7.0_75 --exec java -jar you-file.jar
eric@eric-pc:~$ jv java version "1.8.0_191" Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) eric@eric-pc:~$ jv11 eric@eric-pc:~$ jv java version "11.0.1" 2018-10-16 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.1+13-LTS) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.1+13-LTS, mixed mode) eric@eric-pc:~$ jvd eric@eric-pc:~$ jv java version "1.8.0_191" Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) eric@eric-pc:~$
sudo ln -s path/to/jdk /Library/Java/JavaVirtualMachines/jdk-[some-identifier].jdk
sudo ln -s /Applications/Android\ Studio.app/Contents/jre/jdk /Library/Java/JavaVirtualMachines/jdk-android-studio.jdk
String commaSeparated = "item1 , item2 , item3"; ArrayList<String> items =
List<String> items = Arrays.asList(str.split("\\s*,\\s*"));
List<String> list = new ArrayList<String>(Arrays.asList(string.split(" , ")));
List<String> list = Lists.newArrayList(Splitter.on(" , ").split(string));
String str="string,with,comma"; ArrayList aList= new ArrayList(Arrays.asList(str.split(","))); for(int i=0;i<aList.size();i++) { System.out.println(" -->"+aList.get(i)); }
List<String> list = Stream.of("a,b,c".split(",")) .collect(Collectors.toList());
ArrayList<String> list = Stream.of("a,b,c".split(",")) .collect(Collectors.toCollection(ArrayList<String>::new));
ArrayList<String> list = Pattern.compile(",") .splitAsStream("a,b,c") .collect(Collectors.toCollection(ArrayList<String>::new));
String commaSeparated = "item1 , item2 , item3"; ArrayList<String> items = new ArrayList<String>(Arrays.asList(commaSeparated.split(",")));
List<String> items = Arrays.asList(commaSeparated.split(","));
List<String> items= Stream.of(commaSeparated.split(",")) .map(String::trim) .collect(toList());
import java.util.Collections; ... String commaSeparated = "item1 , item2 , item3"; ArrayList<String> items = new ArrayList<>(); Collections.addAll(items, commaSeparated.split("\\s*,\\s*")); ...
import com.google.common.base.Splitter; import com.google.common.collect.Lists; String commaSeparated = "item1 , item2 , item3"; ArrayList<String> list = Lists.newArrayList(Splitter.on( System.out.println(list); list.add("another item"); System.out.println(list);
[item1, item2, item3] [item1, item2, item3, another item]
String myStr = "item1,item2,item3"; List myList = Arrays.asList(myStr.split(","));
String commaSeparated = "item1 , item2 , item3"; List<String> result1 = Arrays.stream(commaSeparated.split(" , ")) .collect(Collectors.toList()); List<String> result2 = Stream.of(commaSeparated.split(" , ")) .collect(Collectors.toList());
List commaseperated = new ArrayList(); String mylist = "item1 , item2 , item3"; mylist = Arrays.asList(myStr.trim().split(" , "));
private static final Pattern listAsString = Pattern.compile("^\\[?([^\\[\\]]*)\\]?$"); private List<String> getList(String value) { Matcher matcher = listAsString.matcher((String) value); if (matcher.matches()) { String[] split = matcher.group(matcher.groupCount()).split("\\s*,\\s*"); return new ArrayList<>(Arrays.asList(split)); } return Collections.emptyList();
List<String> items = Arrays.asList(s.split("[,\\s]+"));
String myString= "A, B, C, D"; List<String> finalString= Arrays.asList(myString.split("\\s*,\\s*")); System.out.println(finalString);
var list = Splitter.on(",").splitToList(YourStringVariable)
String str = "aa,bb,cc,dd,aa,ss,bb,ee,aa,zz,dd,ff,hh"; Collection<String> col = new HashSet<>(Stream.of(str.split(",")).collect(Collectors.toList()));
String string[] ={"A","B","C","D"}; List<String> listOfString = Stream.of(string).collect(Collectors.toList());
ArrayList<HashMap<String, String>> mListmain = new ArrayList<HashMap<String, String>>(); String marray[]= mListmain.split(",");
String query = "SELECT FOO, BAR, BAZ FROM ABC WHERE BAR > 4";
String query = "SELECT FOO, BAR, BAZ" + " FROM ABC " + " WHERE BAR > 4 ";
String query = "SELECT FOO, BAR, BAZ" + " FROM ABC " + " WHERE BAR > 4 ";
String query = // "SELECT FOO, BAR, BAZ" + // " FROM ABC" + // " WHERE BAR > 4";
/*- * Here is a block comment with some very special * formatting that I want indent(1) to ignore. * * one * two * three */
String query = "SELECT FOO, BAR, BAZ" + " FROM ABC" + " WHERE BAR > 4";
final String sql = "SELECT v.value FROM properties p " + "JOIN property_values v ON p.property_id = v.property_id " + "WHERE p.product_id = ? " + "AND v.value IS NOT NULL ";
Preferences->Java->Editor->Save Actions->Format Source Code->Format Edited Lines
public interface Dependency { void someMethod(); } public class Foo { public bar(final Dependency d) { ... } }
public class FooTest { @Test public void dependencyIsNotCalled() { final Foo foo = new Foo(...); final Dependency dependency = mock(Dependency.class); foo.bar(dependency); ** } }
import static org.mockito.Mockito.never; import static org.mockito.Mockito.verify; verify(dependency, never()).someMethod();
@After public void after() { verifyNoMoreInteractions(<your mock1>, <your mock2>...); }
public static transient void verifyNoMoreInteractions(Object mocks[]) { MOCKITO_CORE.verifyNoMoreInteractions(mocks); } public static transient void verifyZeroInteractions(Object mocks[]) { MOCKITO_CORE.verifyNoMoreInteractions(mocks); }
public class Tree<T> { private Node<T> root; public Tree(T rootData) { root = new Node<T>(); root.data = rootData; root.children = new ArrayList<Node<T>>(); } public static class Node<T> { private T data; private Node<T> parent; private List<Node<T>> children; } }
public class TreeNode<T> implements Iterable<TreeNode<T>> { T data; TreeNode<T> parent; List<TreeNode<T>> children; public TreeNode(T data) { this.data = data; this.children = new LinkedList<TreeNode<T>>(); } public TreeNode<T> addChild(T child) { TreeNode<T> childNode = new TreeNode<T>(child); childNode.parent = this; this.children.add(childNode); return childNode; } }
TreeNode<String> root = new TreeNode<String>("root"); { TreeNode<String> node0 = root.addChild("node0"); TreeNode<String> node1 = root.addChild("node1"); TreeNode<String> node2 = root.addChild("node2"); { TreeNode<String> node20 = node2.addChild(null); TreeNode<String> node21 = node2.addChild("node21"); { TreeNode<String> node210 = node20.addChild("node210"); } } }
import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; /** * @author ycoppel@google.com (Yohann Coppel) * * @param <T> * Object */ public class Tree<T> { private T head; private ArrayList<Tree<T>> leafs = new ArrayList<Tree<T>>(); private Tree<T> parent = null; private HashMap<T, Tree<T>> locate = new HashMap<T, Tree<T>>(); public Tree(T head) { this.head = head; locate.put(head, this); } public void addLeaf(T root, T leaf) { if (locate.containsKey(root)) { locate.get(root).addLeaf(leaf); } else { addLeaf(root).addLeaf(leaf); } } public Tree<T> addLeaf(T leaf) { Tree<T> t = new Tree<T>(leaf); leafs.add(t); t.parent = this; t.locate = this.locate; locate.put(leaf, t); return t; } public Tree<T> setAsParent(T parentRoot) { Tree<T> t = new Tree<T>(parentRoot); t.leafs.add(this); this.parent = t; t.locate = this.locate; t.locate.put(head, this); t.locate.put(parentRoot, t); return t; } public T getHead() { return head; } public Tree<T> getTree(T element) { return locate.get(element); } public Tree<T> getParent() { return parent; } public Collection<T> getSuccessors(T root) { Collection<T> successors = new ArrayList<T>(); Tree<T> tree = getTree(root); if (null != tree) { for (Tree<T> leaf : tree.leafs) { successors.add(leaf.head); } } return successors; } public Collection<Tree<T>> getSubTrees() { return leafs; } public static <T> Collection<T> getSuccessors(T of, Collection<Tree<T>> in) { for (Tree<T> tree : in) { if (tree.locate.containsKey(of)) { return tree.getSuccessors(of); } } return new ArrayList<T>(); } @Override public String toString() { return printTree(0); } private static final int indent = 2; private String printTree(int increment) { String s = ""; String inc = ""; for (int i = 0; i < increment; ++i) { inc = inc + " "; } s = inc + head; for (Tree<T> child : leafs) { s += "\n" + child.printTree(increment + indent); } return s; } }
public class Tree { private List<Tree> leaves = new LinkedList<Tree>(); private Tree parent = null; private String data; public Tree(String data, Tree parent) { this.data = data; this.parent = parent; } }
public interface Tree <N extends Serializable> extends Serializable { List<N> getRoots (); N getParent (N node); List<N> getChildren (N node); }
public interface MutableTree <N extends Serializable> extends Tree<N> { boolean add (N parent, N node); boolean remove (N node, boolean cascade); }
public class FileTree implements Tree<File> { @Override public List<File> getRoots() { return Arrays.stream(File.listRoots()).collect(Collectors.toList()); } @Override public File getParent(File node) { return node.getParentFile(); } @Override public List<File> getChildren(File node) { if (node.isDirectory()) { File[] children = node.listFiles(); if (children != null) { return Arrays.stream(children).collect(Collectors.toList()); } } return Collections.emptyList(); } }
public class MappedTreeStructure<N extends Serializable> implements MutableTree<N> { public static void main(String[] args) { MutableTree<String> tree = new MappedTreeStructure<>(); tree.add("A", "B"); tree.add("A", "C"); tree.add("C", "D"); tree.add("E", "A"); System.out.println(tree); } private final Map<N, N> nodeParent = new HashMap<>(); private final LinkedHashSet<N> nodeList = new LinkedHashSet<>(); private void checkNotNull(N node, String parameterName) { if (node == null) throw new IllegalArgumentException(parameterName + " must not be null"); } @Override public boolean add(N parent, N node) { checkNotNull(parent, "parent"); checkNotNull(node, "node"); N current = parent; do { if (node.equals(current)) { throw new IllegalArgumentException(" node must not be the same or an ancestor of the parent"); } } while ((current = getParent(current)) != null); boolean added = nodeList.add(node); nodeList.add(parent); nodeParent.put(node, parent); return added; } @Override public boolean remove(N node, boolean cascade) { checkNotNull(node, "node"); if (!nodeList.contains(node)) { return false; } if (cascade) { for (N child : getChildren(node)) { remove(child, true); } } else { for (N child : getChildren(node)) { nodeParent.remove(child); } } nodeList.remove(node); return true; } @Override public List<N> getRoots() { return getChildren(null); } @Override public N getParent(N node) { checkNotNull(node, "node"); return nodeParent.get(node); } @Override public List<N> getChildren(N node) { List<N> children = new LinkedList<>(); for (N n : nodeList) { N parent = nodeParent.get(n); if (node == null && parent == null) { children.add(n); } else if (node != null && parent != null && parent.equals(node)) { children.add(n); } } return children; } @Override public String toString() { StringBuilder builder = new StringBuilder(); dumpNodeStructure(builder, null, "- "); return builder.toString(); } private void dumpNodeStructure(StringBuilder builder, N node, String prefix) { if (node != null) { builder.append(prefix); builder.append(node.toString()); builder.append( prefix = " " + prefix; } for (N child : getChildren(node)) { dumpNodeStructure(builder, child, prefix); } } }
public class TreeNodeArray<T> { public T value; public final java.util.List<TreeNodeArray<T>> kids = new java.util.ArrayList<TreeNodeArray<T>>(); }
/*** /* Within the class that private class Node { public String value; public Node[] nodes; }
private class Node { String value; Node left; Node right; }
private class Node { String value; Map<char, Node> nodes; }
import java.util.Arrays; import java.util.ArrayList; import java.util.List; public class kidsOfMatchTheseDays { static private class Node { String value; Node[] nodes; } static public List<String> list(Node node, String find) { return list(node, find, new ArrayList<String>(), false); } static private ArrayList<String> list( Node node, String find, ArrayList<String> list, boolean add) { if (node == null) { return list; } if (node.value.equals(find)) { add = true; } if (add) { list.add(node.value); } if (node.nodes != null) { for (Node child: node.nodes) { list(child, find, list, add); } } return list; } public static final void main(String... args) { Node tree = new Node(); tree.value = "root"; Node[] n = {new Node(), new Node()}; tree.nodes = n; tree.nodes[0].value = "leftish"; tree.nodes[1].value = "rightish-leafy"; Node[] nn = {new Node()}; tree.nodes[0].nodes = nn; tree.nodes[0].nodes[0].value = "off-leftish-leaf"; System.out.println(Arrays.toString(list(tree, args[0]).toArray())); } }
$ java kidsOfMatchTheseDays leftish [leftish, off-leftish-leaf] $ java kidsOfMatchTheseDays root [root, leftish, off-leftish-leaf, rightish-leafy] $ java kidsOfMatchTheseDays rightish-leafy [rightish-leafy] $ java kidsOfMatchTheseDays a []
Object[] tree = new Object[2]; tree[0] = "Hello"; { Object[] subtree = new Object[2]; subtree[0] = "Goodbye"; subtree[1] = ""; tree[1] = subtree; }
public abstract class Node { List<Node> children; public List<Node> getChidren() { if (children == null) { children = new ArrayList<>(); } return chidren; } }
public class MenuItem extends Node { String label; String href; ... }
import java.util.ArrayList; import java.util.List; /** * * @author X2 * * @param <T> */ public class HisTree<T> { private Node<T> root; public HisTree(T rootData) { root = new Node<T>(); root.setData(rootData); root.setChildren(new ArrayList<Node<T>>()); } } class Node<T> { private T data; private Node<T> parent; private List<Node<T>> children; public T getData() { return data; } public void setData(T data) { this.data = data; } public Node<T> getParent() { return parent; } public void setParent(Node<T> parent) { this.parent = parent; } public List<Node<T>> getChildren() { return children; } public void setChildren(List<Node<T>> children) { this.children = children; } }
import java.util.HashMap; import java.util.LinkedList; public class TreeMap<T> extends LinkedHashMap<T, TreeMap<T>> { public void put(T[] path) { LinkedList<T> list = new LinkedList<>(); for (T key : path) { list.add(key); } return put(list); } public void put(LinkedList<T> path) { if (path.isEmpty()) { return; } T key = path.removeFirst(); TreeMap<T> val = get(key); if (val == null) { val = new TreeMap<>(); put(key, val); } val.put(path); } }
root, child 1 root, child 1, child 1a root, child 1, child 1b root, child 2 root, child 3, child 3a
TreeMap<String> root = new TreeMap<>(); Scanner scanner = new Scanner(new File("input.txt")); while (scanner.hasNextLine()) { root.put(scanner.nextLine().split(", ")); }
import com.fasterxml.jackson.annotation.JsonValue; import com.fasterxml.jackson.databind.ObjectMapper; import java.util.HashMap; import java.util.Map; import java.util.TreeMap; /** * Created by kic on 16.07.15. */ public class NestedMap<K, V> { private final Map root = new HashMap<>(); public NestedMap<K, V> put(K key) { Object nested = root.get(key); if (nested == null || !(nested instanceof NestedMap)) root.put(key, nested = new NestedMap<>()); return (NestedMap<K, V>) nested; } public Map.Entry<K,V > put(K key, V value) { root.put(key, value); return (Map.Entry<K, V>) root.entrySet().stream().filter(e -> ((Map.Entry) e).getKey().equals(key)).findFirst().get(); } public NestedMap<K, V> get(K key) { return (NestedMap<K, V>) root.get(key); } public V getValue(K key) { return (V) root.get(key); } @JsonValue public Map getRoot() { return root; } public static void main(String[] args) throws Exception { NestedMap<String, Integer> test = new NestedMap<>(); test.put("a").put("b").put("c", 12); Map.Entry<String, Integer> foo = test.put("a").put("b").put("d", 12); test.put("b", 14); ObjectMapper mapper = new ObjectMapper(); System.out.println(mapper.writeValueAsString(test)); foo.setValue(99); System.out.println(mapper.writeValueAsString(test)); System.out.println(test.get("a").get("b").getValue("d")); } }
// import java.awt.*; import java.awt.event.*; import javax.swing.*; import javax.swing.tree.*; public class TestTree extends JFrame { JTree tree; DefaultTreeModel treeModel; public TestTree( ) { super("Tree Test Example"); setSize(400, 300); setDefaultCloseOperation(EXIT_ON_CLOSE); } public void init( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode("Root"); DefaultMutableTreeNode subroot = new DefaultMutableTreeNode("SubRoot"); DefaultMutableTreeNode leaf1 = new DefaultMutableTreeNode("Leaf 1"); DefaultMutableTreeNode leaf2 = new DefaultMutableTreeNode("Leaf 2"); treeModel = new DefaultTreeModel(root); tree = new JTree(treeModel); treeModel.insertNodeInto(subroot, root, 0); subroot.add(leaf1); root.add(leaf2); getContentPane( ).add(tree, BorderLayout.CENTER); } public static void main(String args[]) { TestTree tt = new TestTree( ); tt.init( ); tt.setVisible(true); } }
package com.datastructure.tree; public class BinaryTreeWithoutRecursion <T> { private TreeNode<T> root; public BinaryTreeWithoutRecursion (){ root = null; } public void insert(T data){ root =insert(root, data); } public TreeNode<T> insert(TreeNode<T> node, T data ){ TreeNode<T> newNode = new TreeNode<>(); newNode.data = data; newNode.right = newNode.left = null; if(node==null){ node = newNode; return node; } Queue<TreeNode<T>> queue = new Queue<TreeNode<T>>(); queue.enque(node); while(!queue.isEmpty()){ TreeNode<T> temp= queue.deque(); if(temp.left!=null){ queue.enque(temp.left); }else { temp.left = newNode; queue =null; return node; } if(temp.right!=null){ queue.enque(temp.right); }else { temp.right = newNode; queue =null; return node; } } queue=null; return node; } public void inOrderPrint(TreeNode<T> root){ if(root!=null){ inOrderPrint(root.left); System.out.println(root.data); inOrderPrint(root.right); } } public void postOrderPrint(TreeNode<T> root){ if(root!=null){ postOrderPrint(root.left); postOrderPrint(root.right); System.out.println(root.data); } } public void preOrderPrint(){ preOrderPrint(root); } public void inOrderPrint(){ inOrderPrint(root); } public void postOrderPrint(){ inOrderPrint(root); } public void preOrderPrint(TreeNode<T> root){ if(root!=null){ System.out.println(root.data); preOrderPrint(root.left); preOrderPrint(root.right); } } /** * @param args */ public static void main(String[] args) { BinaryTreeWithoutRecursion <Integer> ls= new BinaryTreeWithoutRecursion <>(); ls.insert(1); ls.insert(2); ls.insert(3); ls.insert(4); ls.insert(5); ls.insert(6); ls.insert(7); ls.inOrderPrint(); } }
TreeSet<String> treeSet = new TreeSet<String>(); Iterator<String> it = treeSet.Iterator(); while(it.hasNext()){ ... }
class Node { int data; Node left; Node right; public Node(int ddata, Node left, Node right) { this.data = ddata; this.left = null; this.right = null; } public void displayNode(Node n) { System.out.print(n.data + " "); } } class BinaryTree { Node root; public BinaryTree() { this.root = null; } public void insertLeft(int parent, int leftvalue ) { Node n = find(root, parent); Node leftchild = new Node(leftvalue, null, null); n.left = leftchild; } public void insertRight(int parent, int rightvalue) { Node n = find(root, parent); Node rightchild = new Node(rightvalue, null, null); n.right = rightchild; } public void insertRoot(int data) { root = new Node(data, null, null); } public Node getRoot() { return root; } public Node find(Node n, int key) { Node result = null; if (n == null) return null; if (n.data == key) return n; if (n.left != null) result = find(n.left, key); if (result == null) result = find(n.right, key); return result; } public int getheight(Node root){ if (root == null) return 0; return Math.max(getheight(root.left), getheight(root.right)) + 1; } public void printTree(Node n) { if (n == null) return; printTree(n.left); n.displayNode(n); printTree(n.right); } }
class ShowProperties { public static void main(String[] args) { System.getProperties().list(System.out); } }
public static final class OsUtils { private static String OS = null; public static String getOsName() { if(OS == null) { OS = System.getProperty("os.name"); } return OS; } public static boolean isWindows() { return getOsName().startsWith("Windows"); } public static boolean isUnix() }
OsCheck.OSType ostype=OsCheck.getOperatingSystemType(); switch (ostype) { case Windows: break; case MacOS: break; case Linux: break; case Other: break; }
/** * helper class to check the operating system this Java VM runs in * * please keep the notes below as a pseudo-license * * http: * compare to http: * http: */ import java.util.Locale; public static final class OsCheck { /** * types of Operating Systems */ public enum OSType { Windows, MacOS, Linux, Other }; protected static OSType detectedOS; /** * detect the operating system from the os.name System property and cache * the result * * @returns - the operating system detected */ public static OSType getOperatingSystemType() { if (detectedOS == null) { String OS = System.getProperty("os.name", "generic").toLowerCase(Locale.ENGLISH); if ((OS.indexOf("mac") >= 0) || (OS.indexOf("darwin") >= 0)) { detectedOS = OSType.MacOS; } else if (OS.indexOf("win") >= 0) { detectedOS = OSType.Windows; } else if (OS.indexOf("nux") >= 0) { detectedOS = OSType.Linux; } else { detectedOS = OSType.Other; } } return detectedOS; } }
private static String OS = System.getProperty("os.name").toLowerCase(); public static void detectOS() { if (isWindows()) { } else if (isMac()) { } else if (isUnix()) { } else { } } private static boolean isWindows() { return (OS.indexOf("win") >= 0); } private static boolean isMac() { return (OS.indexOf("mac") >= 0); } private static boolean isUnix() { return (OS.indexOf("nux") >= 0); }
public class Util { public enum OS { WINDOWS, LINUX, MAC, SOLARIS }; private static OS os = null; public static OS getOS() { if (os == null) { String operSys = System.getProperty("os.name").toLowerCase(); if (operSys.contains("win")) { os = OS.WINDOWS; } else if (operSys.contains("nix") || operSys.contains("nux") || operSys.contains("aix")) { os = OS.LINUX; } else if (operSys.contains("mac")) { os = OS.MAC; } else if (operSys.contains("sunos")) { os = OS.SOLARIS; } } return os; } }
switch (Util.getOS()) { case WINDOWS: break; case LINUX:
String osName = System.getProperty("os.name"); String osNameMatch = osName.toLowerCase(); if(osNameMatch.contains("linux")) { osType = OS_LINUX; }else if(osNameMatch.contains("windows")) { osType = OS_WINDOWS; }else if(osNameMatch.contains("solaris") || osNameMatch.contains("sunos")) { osType = OS_SOLARIS; }else if(osNameMatch.contains("mac os") || osNameMatch.contains("macos") || osNameMatch.contains("darwin")) { osType = OS_MAC_OS_X; }else { }
System.getProperty("os.name"); System.getProperty("os.version"); System.getProperty("os.arch");
public class App { public static void main( String[] args ) { System.out.println(System.getProperty("os.name")); System.out.println(System.getProperty("os.version")); System.out.println(System.getProperty("path.separator")); System.out.println(System.getProperty("user.dir")); System.out.println(System.getProperty("user.home")); System.out.println(System.getProperty("user.name")); System.out.println(System.getProperty("os.arch")); System.out.println(System.getProperty("line.separator")); System.out.println(System.getProperty("java.version")); System.out.println(System.getProperty("java.vendor.url")); System.out.println(System.getProperty("java.vendor")); System.out.println(System.getProperty("java.home")); System.out.println(System.getProperty("java.class.path")); System.out.println(System.getProperty("file.separator")); } }
Windows 7 6.1 ; C:\Users\user\Documents\workspace-eclipse\JavaExample C:\Users\user user amd64 1.7.0_71 http: Oracle Corporation C:\Program Files\Java\jre7 C:\Users\user\Documents\workspace-Eclipse\JavaExample\target\classes \
String osName = System.getProperty("os.name"); System.out.println("Operating system " + osName);
/** * types of Operating Systems * * please keep the note below as a pseudo-license * * helper class to check the operating system this Java VM runs in * http: * compare to http: * http: */ public enum OSType { MacOS("mac", "darwin"), Windows("win"), Linux("nux"), Other("generic"); private static OSType detectedOS; private final String[] keys; private OSType(String... keys) { this.keys = keys; } private boolean match(String osKey) { for (int i = 0; i < keys.length; i++) { if (osKey.indexOf(keys[i]) != -1) return true; } return false; } public static OSType getOS_Type() { if (detectedOS == null) detectedOS = getOperatingSystemType(System.getProperty("os.name", Other.keys[0]).toLowerCase()); return detectedOS; } private static OSType getOperatingSystemType(String osKey) { for (OSType osType : values()) { if (osType.match(osKey)) return osType; } return Other; } }
public class MyFirstJavaProgram { public static void main(String []args) { System.getProperties().list(System.out); } }
public static void main(String[] args) { Properties pro = System.getProperties(); for(Object obj : pro.keySet()){ System.out.println(" System "+(String)obj+" : "+System.getProperty((String)obj)); } }
import org.apache.commons.exec.OS; if (OS.isFamilyWindows()){ } else if (OS.isFamilyUnix()){ }
Set<String> set = new HashSet<>(yourList); yourList.clear(); yourList.addAll(set);
List<String> deduped = list.stream().distinct().collect(Collectors.toList());
List<String> deDupStringList = new ArrayList<>(new HashSet<>(strList));
List<String> deDupStringList2 = Lists.newArrayList(Sets.newHashSet(strList));
List<String> deDupStringList3 = strList.stream().distinct().collect(Collectors.toList());
List<String> deDupStringList3 = strList.stream().distinct() .collect(Collectors.toCollection(LinkedList::new));
ArrayList l1 = new ArrayList(); ArrayList l2 = new ArrayList(); Iterator iterator = l1.iterator(); while (iterator.hasNext()) { YourClass o = (YourClass) iterator.next(); if(!l2.contains(o)) l2.add(o); }
myArrayList = new ArrayList<String>(new LinkedHashSet<String>(myArrayList));
List<String> cityList = new ArrayList<>(); cityList.add("Delhi"); cityList.add("Mumbai"); cityList.add("Bangalore"); cityList.add("Chennai"); cityList.add("Kolkata"); cityList.add("Mumbai"); cityList = cityList.stream().distinct().collect(Collectors.toList());
ArrayList<String> lst = new ArrayList<String>(); lst.add("ABC"); lst.add("ABC"); lst.add("ABCD"); lst.add("ABCD"); lst.add("ABCE"); System.out.println("Duplicates List "+lst); Object[] st = lst.toArray(); for (Object s : st) { if (lst.indexOf(s) != lst.lastIndexOf(s)) { lst.remove(lst.lastIndexOf(s)); } } System.out.println("Distinct List "+lst);
Duplicates List [ABC, ABC, ABCD, ABCD, ABCE] Distinct List [ABC, ABCD, ABCE]
public static <T> void removeDuplicates(ArrayList<T> list) { int size = list.size(); int out = 0; { final Set<T> encountered = new HashSet<T>(); for (int in = 0; in < size; in++) { final T t = list.get(in); final boolean first = encountered.add(t); if (first) { list.set(out++, t); } } } while (out < size) { list.remove(--size); } }
public static <T> void removeDuplicates(LinkedList<T> list) { final Set<T> encountered = new HashSet<T>(); for (Iterator<T> iter = list.iterator(); iter.hasNext(); ) { final T t = iter.next(); final boolean first = encountered.add(t); if (!first) { iter.remove(); } } }
public static <T> void removeDuplicates(List<T> list) { if (list instanceof RandomAccess) { } else { } }
private List<SomeClass> clearListFromDuplicateFirstName(List<SomeClass> list1) { Map<String, SomeClass> cleanMap = new LinkedHashMap<String, SomeClass>(); for (int i = 0; i < list1.size(); i++) { cleanMap.put(list1.get(i).getFirstName(), list1.get(i)); } List<SomeClass> list = new ArrayList<SomeClass>(cleanMap.values()); return list; }
public static void main(String[] args){ ArrayList<Object> al = new ArrayList<Object>(); al.add("abc"); al.add( al.add( al.add( al.add("abc"); al.add(10.3); al.add( al.add(10); al.add("abc"); al.add(10); System.out.println("Before Duplicate Remove:"+al); for(int i=0;i<al.size();i++){ for(int j=i+1;j<al.size();j++){ if(al.get(i).equals(al.get(j))){ al.remove(j); j--; } } } System.out.println("After Removing duplicate:"+al); }
ListIterable<Integer> integers = FastList.newListWith(1, 3, 1, 2, 2, 1); Assert.assertEquals( FastList.newListWith(1, 3, 2), integers.distinct());
MutableSet<T> seenSoFar = UnifiedSet.newSet(); int size = list.size(); for (int i = 0; i < size; i++) { T item = list.get(i); if (seenSoFar.add(item)) { targetCollection.add(item); } } return targetCollection;
MutableList<Integer> distinct = ListAdapter.adapt(integers).distinct();
List<Entity> entities = repository.findByUserId(userId); Set<Entity> s = new LinkedHashSet<Entity>(entities); entities.clear(); entities.addAll(s);
ArrayList< Integer > al = new ArrayList< Integer >(); for ( int i = 0; i <= 5; i++ ) if ( !al.contains( i ) ) al.add( i ); for (int i = 0; i <= 10; i++ ) if ( !al.contains( i ) ) al.add( i ); for( Integer i: al ) { System.out.print( i + " "); }
LinkedHashSet link=new LinkedHashSet(); List listOfValues=new ArrayList(); listOfValues.add(link);
List<String> duplicatList = new ArrayList<String>(); duplicatList = Arrays.asList("AA","BB","CC","DD","DD","EE","AA","FF"); Set<String> uniqueList = new HashSet<String>(duplicatList); duplicatList = new ArrayList<String>(uniqueList); System.out.println("Removed Duplicate : "+duplicatList);
ArrayList<String> city=new ArrayList<String>(); city.add("rajkot"); city.add("gondal"); city.add("rajkot"); city.add("gova"); city.add("baroda"); city.add("morbi"); city.add("gova"); HashSet<String> hashSet = new HashSet<String>(); hashSet.addAll(city); city.clear(); city.addAll(hashSet); Toast.makeText(getActivity(),"" + city.toString(),Toast.LENGTH_SHORT).show();
String[] arr2 = {"5","1","2","3","3","4","1","2"}; Set<String> set = new LinkedHashSet<String>(Arrays.asList(arr2)); for(String s1 : set) System.out.println(s1); System.out.println( "------------------------" ); String[] arr3 = set.toArray(new String[0]); for(int i = 0; i < arr3.length; i++) System.out.println(arr3[i].toString());
List<String> result = new ArrayList<String>(); Set<String> set = new LinkedHashSet<String>(); String s = "ravi is a good!boy. But ravi is very nasty fellow."; StringTokenizer st = new StringTokenizer(s, " ,. ,!"); while (st.hasMoreTokens()) { result.add(st.nextToken()); } System.out.println(result); set.addAll(result); result.clear(); result.addAll(set); System.out.println(result); output: [ravi, is, a, good, boy, But, ravi, is, very, nasty, fellow] [ravi, is, a, good, boy, But, very, nasty, fellow]
public List<Contact> removeDuplicates(List<Contact> list) { Set set = new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) { if (((Contact) o1).getId().equalsIgnoreCase(((Contact) o2).getId()) /*&& ((Contact)o1).getName().equalsIgnoreCase(((Contact)o2).getName())*/) { return 0; } return 1; } }); set.addAll(list); final List newList = new ArrayList(set); return newList; }
ArrayList<Class1> l1 = new ArrayList<Class1>(); ArrayList<Class1> l2 = new ArrayList<Class1>(); Iterator iterator1 = l1.iterator(); boolean repeated = false; while (iterator1.hasNext()) { Class1 c1 = (Class1) iterator1.next(); for (Class1 _c: l2) { if(_c.getId() == c1.getId()) repeated = true; } if(!repeated) l2.add(c1); }
for(int i = 0; i < Models.size(); i++) { for(int j = i + 1; j < Models.size(); j++) { if(Models.get(i).getName().equals(Models.get(j).getName())){ Models.remove(j); j--; } } }
for(int a=0;a<myArray.size();a++){ for(int b=a+1;b<myArray.size();b++){ if(myArray.get(a).equalsIgnoreCase(myArray.get(b))){ myArray.remove(b); dups++; b--; } } }
import java.util.*; class RemoveDupFrmString { public static void main(String[] args) { String s="appsc"; Set<Character> unique = new LinkedHashSet<Character> (); for(char c : s.toCharArray()) { System.out.println(unique.add(c)); } for(char dis:unique){ System.out.println(dis); } } }
public Set<Object> findDuplicates(List<Object> list) { Set<Object> items = new HashSet<Object>(); Set<Object> duplicates = new HashSet<Object>(); for (Object item : list) { if (items.contains(item)) { duplicates.add(item); } else { items.add(item); } } return duplicates; }
ArrayList<String> list = new ArrayList<String>(); HashSet<String> unique = new LinkedHashSet<String>(); HashSet<String> dup = new LinkedHashSet<String>(); boolean b = false; list.add("Hello"); list.add("Hello"); list.add("how"); list.add("are"); list.add("u"); list.add("u"); for(Iterator iterator= list.iterator();iterator.hasNext();) { String value = (String)iterator.next(); System.out.println(value); if(b==unique.add(value)) dup.add(value); else unique.add(value); } System.out.println(unique); System.out.println(dup);
public static Object[] removeDuplicate(Object[] inputArray) { long startTime = System.nanoTime(); int totalSize = inputArray.length; Object[] resultArray = new Object[totalSize]; int newSize = 0; for(int i=0; i<totalSize; i++) { Object value = inputArray[i]; if(value == null) { continue; } for(int j=i+1; j<totalSize; j++) { if(value.equals(inputArray[j])) { inputArray[j] = null; } } resultArray[newSize++] = value; } long endTime = System.nanoTime()-startTime; System.out.println("Total Time-B:"+endTime); return resultArray; }
public class University { private String id; private String name; private String address; private List<Student> students; }
import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.ManyToOne; import javax.persistence.Table; @Entity @Table(name="Books") public class Books implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="book_id") private int id; @Column(name="book_name") private String name; @Column(name="author_name") private String authorName; @ManyToOne Subject subject; public Subject getSubject() { return subject; } public void setSubject(Subject subject) { this.subject = subject; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthorName() { return authorName; } public void setAuthorName(String authorName) { this.authorName = authorName; } }
import java.io.Serializable; import java.util.ArrayList; import java.util.List; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.OneToMany; import javax.persistence.Table; @Entity @Table(name="Subject") public class Subject implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name="subject_id") private int id; @Column(name="subject_name") private String name; /** Observe carefully i have mentioned fetchType.EAGER. By default its is fetchType.LAZY for @OneToMany i have mentioned it but not required. Check the Output by changing it to fetchType.EAGER */ @OneToMany(mappedBy="subject",cascade=CascadeType.ALL,fetch=FetchType.LAZY, orphanRemoval=true) List<Books> listBooks=new ArrayList<Books>(); public List<Books> getListBooks() { return listBooks; } public void setListBooks(List<Books> listBooks) { this.listBooks = listBooks; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } }
import org.hibernate.SessionFactory; import org.hibernate.boot.registry.StandardServiceRegistryBuilder; import org.hibernate.cfg.Configuration; public class HibernateUtil { private static SessionFactory sessionFactory ; static { Configuration configuration = new Configuration(); configuration.addAnnotatedClass (Com.OneToMany.Books.class); configuration.addAnnotatedClass (Com.OneToMany.Subject.class); configuration.setProperty("connection.driver_class","com.mysql.jdbc.Driver"); configuration.setProperty("hibernate.connection.url", "jdbc:mysql: configuration.setProperty("hibernate.connection.username", "root"); configuration.setProperty("hibernate.connection.password", "root"); configuration.setProperty("dialect", "org.hibernate.dialect.MySQLDialect"); configuration.setProperty("hibernate.hbm2ddl.auto", "update"); configuration.setProperty("hibernate.show_sql", "true"); configuration.setProperty(" hibernate.connection.pool_size", "10"); configuration.setProperty(" hibernate.cache.use_second_level_cache", "true"); configuration.setProperty(" hibernate.cache.use_query_cache", "true"); configuration.setProperty(" cache.provider_class", "org.hibernate.cache.EhCacheProvider"); configuration.setProperty("hibernate.cache.region.factory_class" ,"org.hibernate.cache.ehcache.EhCacheRegionFactory"); StandardServiceRegistryBuilder builder = new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()); sessionFactory = configuration.buildSessionFactory(builder.build()); } public static SessionFactory getSessionFactory() { return sessionFactory; } }
import org.hibernate.Session; import org.hibernate.SessionFactory; public class Main { public static void main(String[] args) { SessionFactory factory=HibernateUtil.getSessionFactory(); save(factory); retrieve(factory); } private static void retrieve(SessionFactory factory) { Session session=factory.openSession(); try{ session.getTransaction().begin(); Subject subject=(Subject)session.get(Subject.class, 1); System.out.println("subject associated collection is loading lazily as @OneToMany is lazy loaded"); Books books=(Books)session.get(Books.class, 1); System.out.println("books associated collection is loading eagerly as by default @ManyToOne is Eagerly loaded"); /*Books b1=(Books)session.get(Books.class, new Integer(1)); Subject sub=session.get(Subject.class, 1); sub.getListBooks().remove(b1); session.save(sub); session.getTransaction().commit();*/ }catch(Exception e){ e.printStackTrace(); }finally{ session.close(); } } private static void save(SessionFactory factory){ Subject subject=new Subject(); subject.setName("C++"); Books books=new Books(); books.setAuthorName("Bala"); books.setName("C++ Book"); books.setSubject(subject); subject.getListBooks().add(books); Session session=factory.openSession(); try{ session.beginTransaction(); session.save(subject); session.getTransaction().commit(); }catch(Exception e){ e.printStackTrace(); }finally{ session.close(); } } }
Public class UniversityDaoImpl extends GenericDaoHibernate<University, Integer> implements UniversityDao { @Override public University get(final Integer id) { Query query = getQuery("from University u where idUniversity=:id").setParameter("id", id).setMaxResults(1).setFetchSize(1); University university = (University) query.uniqueResult(); ***Hibernate.initialize(university.getStudents());*** return university; } }
public interface IXMLizable<T> { static T newInstanceFromXML(Element e); Element toXMLElement(); }
class Foo implements IXMLizable<Foo> { public static Foo newInstanceFromXML(Element e) { ... } } Foo obj = Foo.newInstanceFromXML(e);
MyInterface var = new MyImplementingClass(); var.staticMethod();
public interface IXMLizableFactory<T extends IXMLizable> { public T newInstanceFromXML(Element e); } public interface IXMLizable { public Element toXMLElement(); }
public interface Arithmetic { public int add(int a, int b); public static int multiply(int a, int b) { return a * b; } }
public class ArithmaticImplementation implements Arithmetic { @Override public int add(int a, int b) { return a + b; } public static void main(String[] args) { int result = Arithmetic.multiply(2, 3); System.out.println(result); } }
public interface TimeClient { static public ZoneId getZoneId (String zoneString) { try { return ZoneId.of(zoneString); } catch (DateTimeException e) { System.err.println("Invalid time zone: " + zoneString + "; using default time zone instead."); return ZoneId.systemDefault(); } } default public ZonedDateTime getZonedDateTime(String zoneString) { return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString)); } }
public interface Test { static class Inner { public static Object get() { return 0; } } }
cmd = createCmd(Person.getCreateCmdId()); Person p = cmd.execute();
cmd = createCmd(Person.getGetCmdId()); cmd.set(ID, id); Person p = cmd.execute();
public class A { public static void methodX() { } } public class B extends A { public static void methodX() { } }
interface Iface { public static void thisIsTheMethod(); } class A implements Iface { public static void thisIsTheMethod(){ system.out.print("I } } class B extends Class A { public static void thisIsTheMethod(){ System.out.print("I } } SomeClass { void doStuff(Iface face) { IFace.thisIsTheMethod(); } }
SI si = clazz.getStatic(SI.class); SI si = Someclass.static.SI;
public interface IGenericEnum <T extends Enum<T>> { String getId(); String getDisplayName(); }
public enum ExecutionModeType implements IGenericEnum<ExecutionModeType> { STANDARD ("Standard", "Standard Mode"), DEBUG ("Debug", "Debug Mode"); String id; String displayName; public String getId() { return id; } public String getDisplayName() { return displayName; } private ExecutionModeType(String id, String displayName) { this.id = id; this.displayName = displayName; } public static boolean isValidId(String id) { return GenericEnumUtility.isValidId(ExecutionModeType.class, id); } public static String printIdOptions(String delimiter){ return GenericEnumUtility.printIdOptions(ExecutionModeType.class, delimiter); } public static String[] getIdArray(){ return GenericEnumUtility.getIdArray(ExecutionModeType.class); } public static ExecutionModeType getById(String id) throws NoSuchObjectException { return GenericEnumUtility.getById(ExecutionModeType.class, id); } }
public class GenericEnumUtility { public static <T extends Enum<T> & IGenericEnum<T>> boolean isValidId(Class<T> enumType, String id) { for(IGenericEnum<T> enumOption : enumType.getEnumConstants()) { if(enumOption.getId().equals(id)) { return true; } } return false; } public static <T extends Enum<T> & IGenericEnum<T>> String printIdOptions(Class<T> enumType, String delimiter){ String ret = ""; delimiter = delimiter == null ? " " : delimiter; int i = 0; for(IGenericEnum<T> enumOption : enumType.getEnumConstants()) { if(i == 0) { ret = enumOption.getId(); } else { ret += delimiter + enumOption.getId(); } i++; } return ret; } public static <T extends Enum<T> & IGenericEnum<T>> String[] getIdArray(Class<T> enumType){ List<String> idValues = new ArrayList<String>(); for(IGenericEnum<T> enumOption : enumType.getEnumConstants()) { idValues.add(enumOption.getId()); } return idValues.toArray(new String[idValues.size()]); } @SuppressWarnings("unchecked") public static <T extends Enum<T> & IGenericEnum<T>> T getById(Class<T> enumType, String id) throws NoSuchObjectException { id = id == null ? "" : id; for(IGenericEnum<T> enumOption : enumType.getEnumConstants()) { if(id.equals(enumOption.getId())) { return (T)enumOption; } } throw new NoSuchObjectException(String.format("ERROR: \"%s\" is not a valid ID. Valid IDs are: %s.", id, printIdOptions(enumType, " , "))); } }
interface I { int x=20; void getValue(); static void main(String[] args){}; } class InterDemo implements I { public void getValue() { System.out.println(x); } public static void main(String[] args) { InterDemo i=new InterDemo(); i.getValue(); } }
MessageDigest md = MessageDigest.getInstance("MD5"); try (InputStream is = Files.newInputStream(Paths.get("file.txt")); DigestInputStream dis = new DigestInputStream(is, md)) { /* Read decorated stream (dis) to EOF as normal... */ } byte[] digest = md.digest();
try (InputStream is = Files.newInputStream(Paths.get("file.txt"))) { String md5 = org.apache.commons.codec.digest.DigestUtils.md5Hex(is); }
import java.io.*; import java.security.MessageDigest; public class MD5Checksum { public static byte[] createChecksum(String filename) throws Exception { InputStream fis = new FileInputStream(filename); byte[] buffer = new byte[1024]; MessageDigest complete = MessageDigest.getInstance("MD5"); int numRead; do { numRead = fis.read(buffer); if (numRead > 0) { complete.update(buffer, 0, numRead); } } while (numRead != -1); fis.close(); return complete.digest(); } public static String getMD5Checksum(String filename) throws Exception { byte[] b = createChecksum(filename); String result = ""; for (int i=0; i < b.length; i++) { result += Integer.toString( ( b[i] & 0xff ) + 0x100, 16).substring( 1 ); } return result; } public static void main(String args[]) { try { System.out.println(getMD5Checksum("apache-tomcat-5.5.17.exe")); } catch (Exception e) { e.printStackTrace(); } } }
HashCode hc = Files.asByteSource(file).hash(Hashing.sha1()); "SHA-1: " + hc.toString();
byte[] b = Files.readAllBytes(Paths.get("/path/to/file")); byte[] hash = MessageDigest.getInstance("MD5").digest(b);
String expected = "2252290BC44BEAD16AA1BF89948472E8"; String actual = DatatypeConverter.printHexBinary(hash); System.out.println(expected.equalsIgnoreCase(actual) ? "MATCH" : "NO MATCH");
HashCode md5 = Files.hash(file, Hashing.md5()); byte[] md5Bytes = md5.asBytes(); String md5Hex = md5.toString(); HashCode crc32 = Files.hash(file, Hashing.crc32()); int crc32Int = crc32.asInt(); long checksumResult = crc32.padToLong();
DigestUtils.md5DigestAsHex(FileUtils.readFileToByteArray(file))
DigestUtils.md5Hex(FileUtils.readFileToByteArray(file))
String path = "your complete file path"; MessageDigest md = MessageDigest.getInstance("MD5"); md.update(Files.readAllBytes(Paths.get(path))); byte[] digest = md.digest();
String digestInHex = DatatypeConverter.printHexBinary(digest).toUpperCase(); System.out.println(digestInHex);
try { String s = "TEST STRING"; MessageDigest md5 = MessageDigest.getInstance("MD5"); md5.update(s.getBytes(),0,s.length()); String signature = new BigInteger(1,md5.digest()).toString(16); System.out.println("Signature: "+signature); } catch (final NoSuchAlgorithmException e) { e.printStackTrace(); }
public static void main(String[] args) throws Exception { MessageDigest md = MessageDigest.getInstance("MD5"); FileInputStream fis = new FileInputStream("c:\\apache\\cxf.jar"); byte[] dataBytes = new byte[1024]; int nread = 0; while ((nread = fis.read(dataBytes)) != -1) { md.update(dataBytes, 0, nread); }; byte[] mdbytes = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < mdbytes.length; i++) { sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1)); } System.out.println("Digest(in hex format):: " + sb.toString()); }
public String calcMD5() throws Exception{ byte[] buffer = new byte[8192]; MessageDigest md = MessageDigest.getInstance("MD5"); DigestInputStream dis = new DigestInputStream(new FileInputStream(new File("Path to file")), md); try { while (dis.read(buffer) != -1); }finally{ dis.close(); } byte[] bytes = md.digest(); char[] hexChars = new char[bytes.length * 2]; for ( int j = 0; j < bytes.length; j++ ) { int v = bytes[j] & 0xFF; hexChars[j * 2] = hexArray[v >>> 4]; hexChars[j * 2 + 1] = hexArray[v & 0x0F]; } return new String(hexChars); }
... String signature = new BigInteger(1,md5.digest()).toString(16); ...
public static String MD5Hash(String toHash) throws RuntimeException { try{ return String.format("%032x", new BigInteger(1, MessageDigest.getInstance("MD5").digest(toHash.getBytes()))); } catch (NoSuchAlgorithmException e) { } }
String hash = MD5.asHex(MD5.getHash(new File(filename)));
public String checksum(File file) { try { InputStream fin = new FileInputStream(file); java.security.MessageDigest md5er = MessageDigest.getInstance("MD5"); byte[] buffer = new byte[1024]; int read; do { read = fin.read(buffer); if (read > 0) md5er.update(buffer, 0, read); } while (read != -1); fin.close(); byte[] digest = md5er.digest(); if (digest == null) return null; String strDigest = "0x"; for (int i = 0; i < digest.length; i++) { strDigest += Integer.toString((digest[i] & 0xff) + 0x100, 16).substring(1).toUpperCase(); } return strDigest; } catch (Exception e) { return null; } }
String checksum = DigestUtils.md5Hex(new FileInputStream(filePath));
import java.io.File; import java.io.IOException; import java.nio.file.Files; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import javax.xml.bind.DatatypeConverter; public class Checksum { /** * Generates an MD5 checksum as a String. * @param file The file that is being checksummed. * @return Hex string of the checksum value. * @throws NoSuchAlgorithmException * @throws IOException */ public static String generate(File file) throws NoSuchAlgorithmException,IOException { MessageDigest messageDigest = MessageDigest.getInstance("MD5"); messageDigest.update(Files.readAllBytes(file.toPath())); byte[] hash = messageDigest.digest(); return DatatypeConverter.printHexBinary(hash).toUpperCase(); } public static void main(String argv[]) throws NoSuchAlgorithmException, IOException { File file = new File("/Users/foo.bar/Documents/file.jar"); String hex = Checksum.generate(file); System.out.printf("hex=%s\n", hex); } }
public static HashCode hash(File file, HashFunction hashFunction) throws IOException Computes the hash code of the file using hashFunction. Parameters: file - the file to read hashFunction - the hash function to use to hash the data Returns: the HashCode of all of the bytes in the file Throws: IOException - if an I/O error occurs Since: 12.0
public static String getMd5OfFile(String filePath) { String returnVal = ""; try { InputStream input = new FileInputStream(filePath); byte[] buffer = new byte[1024]; MessageDigest md5Hash = MessageDigest.getInstance("MD5"); int numRead = 0; while (numRead != -1) { numRead = input.read(buffer); if (numRead > 0) { md5Hash.update(buffer, 0, numRead); } } input.close(); byte [] md5Bytes = md5Hash.digest(); for (int i=0; i < md5Bytes.length; i++) { returnVal += Integer.toString( ( md5Bytes[i] & 0xff ) + 0x100, 16).substring( 1 ); } } catch(Throwable t) {t.printStackTrace();} return returnVal.toUpperCase(); }
public static String hashFile(String algorithm, File f) throws IOException, NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(algorithm); try(BufferedInputStream in = new BufferedInputStream((new FileInputStream(f))); DigestOutputStream out = new DigestOutputStream(OutputStream.nullOutputStream(), md)) { in.transferTo(out); } String fx = "%0" + (md.getDigestLength()*2) + "x"; return String.format(fx, new BigInteger(1, md.digest())); }
hashFile("SHA-512", Path.of("src", "test", "resources", "some.txt").toFile());
"e30fa2784ba15be37833d569280e2163c6f106506dfb9b07dde67a24bfb90da65c661110cf2c5c6f71185754ee5ae3fd83a5465c92f72abd888b03187229da29"
BigDecimal a = new BigDecimal("1.6"); BigDecimal b = new BigDecimal("9.2"); a.divide(b)
java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.
a.divide(b, 2, RoundingMode.HALF_UP) where 2 is precision and RoundingMode.HALF_UP is rounding mode
txtTotalInvoice.setText(var1.divide(var2).doubleValue() + "");
txtTotalInvoice.setText(var1.divide(var2,4, RoundingMode.HALF_UP).doubleValue() + "");
public static void main(String[] args) { int age = 30; BigDecimal retireMentFund = new BigDecimal("10000.00"); retireMentFund.setScale(2,BigDecimal.ROUND_HALF_UP); BigDecimal yearsInRetirement = new BigDecimal("20.00"); String name = " Dennis"; for ( int i = age; i <=65; i++){ recalculate(retireMentFund,new BigDecimal("0.10")); } BigDecimal monthlyPension = retireMentFund.divide( yearsInRetirement.divide(new BigDecimal("12"), new MathContext(2, RoundingMode.CEILING)), new MathContext(2, RoundingMode.CEILING)); System.out.println(name+ " will have " + monthlyPension +" per month for retirement"); } public static void recalculate (BigDecimal fundAmount, BigDecimal rate){ fundAmount.multiply(rate.add(new BigDecimal("1.00"))); }
try { result = n1.divide(n2); } catch (ArithmeticException e){ Log.d("Error bigdecimal", e.toString()); result = (n1.doubleValue() / n2.doubleValue()); };
java.lang.ArithmeticException: Non-terminating decimal expansion
MathContext precision = new MathContext(int setPrecisionYouWant); BigDecimal a = new BigDecimal("1.6",precision); BigDecimal b = new BigDecimal("9.2",precision); a.divide(b)
String date_s = " 2011-01-18 00:00:00.0"; SimpleDateFormat dt = new SimpleDateFormat("yyyyy-mm-dd hh:mm:ss"); Date date = dt.parse(date_s); SimpleDateFormat dt1 = new SimpleDateFormat("yyyyy-mm-dd"); System.out.println(dt1.format(date));
String oldstring = "2011-01-18 00:00:00.0"; LocalDateTime datetime = LocalDateTime.parse(oldstring, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.S"));
String newstring = datetime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd")); System.out.println(newstring);
String oldstring = "2011-01-18 00:00:00.0"; Date date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S").parse(oldstring);
String newstring = new SimpleDateFormat("yyyy-MM-dd").format(date); System.out.println(newstring);
G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, ..., 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00
"yyyy.MM.dd G "EEE, MMM d, "h:mm a" 12:08 PM "hh "K:mm a, z" 0:08 PM, PDT "yyyyy.MMMMM.dd GGG hh:mm aaa" 02001.July.04 AD 12:08 PM "EEE, d MMM yyyy HH:mm:ss Z" Wed, 4 Jul 2001 12:08:56 -0700 "yyMMddHHmmssZ" 010704120856-0700 "yyyy-MM-dd "yyyy-MM-dd "YYYY-
import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class FormateDate { public static void main(String[] args) throws ParseException { String date_s = "2011-01-18 00:00:00.0"; SimpleDateFormat dt = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); Date date = dt.parse(date_s); SimpleDateFormat dt1 = new SimpleDateFormat("yyyy-MM-dd"); System.out.println(dt1.format(date)); } }
Date convertToDate(String receivedDate) throws ParseException{ SimpleDateFormat formatter = new SimpleDateFormat("dd-MM-yyyy"); Date date = formatter.parse(receivedDate); return date; }
DateFormat df = new SimpleDateFormat("dd/MM/yyyy"); String requiredDate = df.format(new Date()).toString();
String date = "2011-01-18 00:00:00.0"; TemporalAccessor temporal = DateTimeFormatter .ofPattern("yyyy-MM-dd HH:mm:ss.S") .parse(date); String output = DateTimeFormatter.ofPattern("yyyy-MM-dd").format(temporal);
String pattern = "yyyy-MM-dd HH:mm:ss.S"; SimpleDateFormat format = new SimpleDateFormat(pattern); try { Date date = format.parse("2011-01-18 00:00:00.0"); System.out.println(date); } catch (ParseException e) { e.printStackTrace(); }
import java.text.SimpleDateFormat; import java.util.Date; import java.text.ParseException; public class DateConversionExample{ public static void main(String arg[]){ try{ SimpleDateFormat sourceDateFormat = new SimpleDateFormat("yyyy-MM-DD HH:mm:ss"); Date date = sourceDateFormat.parse("2011-01-18 00:00:00.0"); SimpleDateFormat targetDateFormat = new SimpleDateFormat("yyyy-MM-dd"); System.out.println(targetDateFormat.format(date)); }catch(ParseException e){ e.printStackTrace(); } } }
try { String date_s = "2011-01-18 00:00:00.0"; SimpleDateFormat simpledateformat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S"); Date tempDate=simpledateformat.parse(date_s); SimpleDateFormat outputDateFormat = new SimpleDateFormat("yyyy-MM-dd"); System.out.println("Output date is = "+outputDateFormat.format(tempDate)); } catch (ParseException ex) { System.out.println("Parse Exception"); }
String date_s = "2011-01-18 00:00:00.0"; org.joda.time.format.DateTimeFormatter formatter = org.joda.time.format.DateTimeFormat.forPattern( "yyyy-MM-dd org.joda.time.DateTime dateTimeInUTC = formatter.withZoneUTC().parseDateTime( date_s ); System.out.println( "dateTimeInUTC: " + dateTimeInUTC ); System.out.println( "dateTimeInUTC (date only): " + org.joda.time.format.ISODateTimeFormat.date().print( dateTimeInUTC ) ); System.out.println( "" ); org.joda.time.DateTimeZone kolkataTimeZone = org.joda.time.DateTimeZone.forID( "Asia/Kolkata" ); org.joda.time.DateTime dateTimeInKolkata = formatter.withZone( kolkataTimeZone ).parseDateTime( date_s ); System.out.println( "dateTimeInKolkata: " + dateTimeInKolkata ); System.out.println( "dateTimeInKolkata (date only): " + org.joda.time.format.ISODateTimeFormat.date().print( dateTimeInKolkata ) ); System.out.println( "dateTimeInKolkata adjusted to UTC: " + dateTimeInKolkata.toDateTime( org.joda.time.DateTimeZone.UTC ) );
public class SystemDateTest { String stringDate; public static void main(String[] args) { SystemDateTest systemDateTest = new SystemDateTest(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd-mm-yyyy hh:mm:ss"); systemDateTest.setStringDate(simpleDateFormat.format(systemDateTest.getDate())); System.out.println(systemDateTest.getStringDate()); } public Date getDate() { return new Date(); } public String getStringDate() { return stringDate; } public void setStringDate(String stringDate) { this.stringDate = stringDate; } }
String str = "2000-12-12"; Date dt = null; SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd"); try { dt = formatter.parse(str); } catch (Exception e) { } JOptionPane.showMessageDialog(null, formatter.format(dt));
String date_s = "2011-01-18 00:00:00.0"; date_s.substring(0,10);
String date_s = " 2011-01-18 00:00:00.0"; date_s.substring(1,11);
Date yourDate = new Date(); SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd"); String date = DATE_FORMAT.format(yourDate);
private SimpleDateFormat dataFormat = new SimpleDateFormat("dd/MM/yyyy"); @Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { if(value instanceof Date) { value = dataFormat.format(value); } return super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column); };
public static Date getDateFromString(String format, String dateStr) { DateFormat formatter = new SimpleDateFormat(format); Date date = null; try { date = (Date) formatter.parse(dateStr); } catch (ParseException e) { e.printStackTrace(); } return date; } public static String getDate(Date date, String dateFormat) { DateFormat formatter = new SimpleDateFormat(dateFormat); return formatter.format(date); }
public String concat(String s) { int i = s.length(); if (i == 0) { return this; } else { char ac[] = new char[count + i]; getChars(0, count, ac, 0); s.getChars(0, i, ac, count); return new String(0, count + i, ac); } }
public class Concat { String cat(String a, String b) { a += b; return a; } }
java.lang.String cat(java.lang.String, java.lang.String); Code: 0: new 3: dup 4: invokespecial 7: aload_1 8: invokevirtual 11: aload_2 12: invokevirtual 15: invokevirtual 18: astore_1 19: aload_1 20: areturn
a = new StringBuilder() .append(a) .append(b) .toString();
String a = new StringBuilder(b).append(c).append(d).toString();
String c = a; for (long i = 0; i < 100000L; i++) { c = c.concat(b); }
long start = System.currentTimeMillis(); String a = "a"; String b = "b"; for (int i = 0; i < 10000000; i++) { String c = a.concat(b); } long end = System.currentTimeMillis(); System.out.println(end - start);
@Warmup(iterations = 5, time = 200, timeUnit = TimeUnit.MILLISECONDS) @Measurement(iterations = 5, time = 200, timeUnit = TimeUnit.MILLISECONDS) public class StringConcatenation { @org.openjdk.jmh.annotations.State(Scope.Thread) public static class State2 { public String a = "abc"; public String b = "xyz"; } @org.openjdk.jmh.annotations.State(Scope.Thread) public static class State3 { public String a = "abc"; public String b = "xyz"; public String c = "123"; } @org.openjdk.jmh.annotations.State(Scope.Thread) public static class State4 { public String a = "abc"; public String b = "xyz"; public String c = "123"; public String d = "!@ } @Benchmark public void plus_2(State2 state, Blackhole blackhole) { blackhole.consume(state.a+state.b); } @Benchmark public void plus_3(State3 state, Blackhole blackhole) { blackhole.consume(state.a+state.b+state.c); } @Benchmark public void plus_4(State4 state, Blackhole blackhole) { blackhole.consume(state.a+state.b+state.c+state.d); } @Benchmark public void stringbuilder_2(State2 state, Blackhole blackhole) { blackhole.consume(new StringBuilder().append(state.a).append(state.b).toString()); } @Benchmark public void stringbuilder_3(State3 state, Blackhole blackhole) { blackhole.consume(new StringBuilder().append(state.a).append(state.b).append(state.c).toString()); } @Benchmark public void stringbuilder_4(State4 state, Blackhole blackhole) { blackhole.consume(new StringBuilder().append(state.a).append(state.b).append(state.c).append(state.d).toString()); } @Benchmark public void concat_2(State2 state, Blackhole blackhole) { blackhole.consume(state.a.concat(state.b)); } @Benchmark public void concat_3(State3 state, Blackhole blackhole) { blackhole.consume(state.a.concat(state.b.concat(state.c))); } @Benchmark public void concat_4(State4 state, Blackhole blackhole) { blackhole.consume(state.a.concat(state.b.concat(state.c.concat(state.d)))); } }
Benchmark Mode Cnt Score Error Units StringConcatenation.concat_2 thrpt 50 24908871.258  1011269.986 ops/s StringConcatenation.concat_3 thrpt 50 14228193.918  466892.616 ops/s StringConcatenation.concat_4 thrpt 50 9845069.776  350532.591 ops/s StringConcatenation.plus_2 thrpt 50 38999662.292  8107397.316 ops/s StringConcatenation.plus_3 thrpt 50 34985722.222  5442660.250 ops/s StringConcatenation.plus_4 thrpt 50 31910376.337  2861001.162 ops/s StringConcatenation.stringbuilder_2 thrpt 50 40472888.230  9011210.632 ops/s StringConcatenation.stringbuilder_3 thrpt 50 33902151.616  5449026.680 ops/s StringConcatenation.stringbuilder_4 thrpt 50 29220479.267  3435315.681 ops/s
String s = "I"; String s1 = s.concat("am").concat("good").concat("boy"); System.out.println(s1);
String s="I"; String s1=s.concat("am").concat("good").concat("boy"); System.out.println(s1);
String s="I"+"am"+"good"+"boy"; System.out.println(s);
StringBuffer sb = new StringBuffer("I"); sb.append("am"); sb.append("good"); sb.append("boy"); System.out.println(sb);
public class NoClassDefFoundErrorDemo { public static void main(String[] args) { try { SimpleCalculator calculator1 = new SimpleCalculator(); } catch (Throwable t) { System.out.println(t); } SimpleCalculator calculator2 = new SimpleCalculator(); } }
public class SimpleCalculator { static int undefined = 1 / 0; }
import java.lang.instrument.*; import java.security.*; public class ClassLoadTracer { public static void premain(String agentArgs, Instrumentation inst) { final java.io.PrintStream out = System.out; inst.addTransformer(new ClassFileTransformer() { public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { String pd = (null == protectionDomain) ? "null" : protectionDomain.getCodeSource().toString(); out.println(className + " loaded by " + loader + " at " + new java.util.Date() + " in " + pd); Thread.dumpStack(); return null; } }); } }
System.out.println(TheNoDefFoundClass.class.getProtectionDomain().getCodeSource().getLocation());
static class Example { static { thisThrowsRuntimeException(); } } static class Simulation { Simulation() { try { new Example(); } catch (Throwable ignored) { } new Example(); } }
sdk list java sdk install java 8u152-zulu sdk use java 8u152-zulu
private static HttpHost proxy = new HttpHost(proxyHost, Integer.valueOf(proxyPort), "http");
try { } catch (Throwable t) { Logger.getLogger("<logger-name>").info("Loading my class went wrong", t); }
android { compileSdkVersion 23 buildToolsVersion packagingOptions { } defaultConfig { minSdkVersion 17 targetSdkVersion 23 versionCode 11 versionName "2.1" }
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder". SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http:
<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-api</artifactId> <version>1.7.5</version> </dependency> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>1.7.5</version> </dependency>
<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-api</artifactId> <version>1.7.5</version> </dependency> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-simple</artifactId> <version>1.6.4</version> </dependency>
<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-simple</artifactId> <version>1.7.21</version> </dependency>
<!-- https: <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-simple</artifactId> <version>1.8.0-beta2</version> </dependency>
<!-- https: <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-simple</artifactId> <version>1.7.25</version> </dependency>
<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>1.5.6</version> </dependency>
<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>1.7.21</version> </dependency>
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder". SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http:
<dependency> <groupId>com.googlecode.slf4j-maven-plugin-log</groupId> <artifactId>slf4j-maven-plugin-log</artifactId> <version>1.0.0</version> </dependency>
<?xml version="1.0" encoding="UTF-8"?> <configuration> <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"> <!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --> <encoder> <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> </encoder> </appender> <appender name="FILE" class="ch.qos.logback.core.FileAppender"> <file>logs/logs.log</file> <encoder> <pattern>%date %level [%thread] %logger{10} - %msg%n</pattern> </encoder> </appender> <root level="debug"> <appender-ref ref="STDOUT" /> <appender-ref ref="FILE" /> </root> <logger level="DEBUG" name="com.myapp"/> </configuration>
<dependency> <groupId>ch.qos.logback</groupId> <artifactId>logback-classic</artifactId> <version>1.0.13</version> </dependency>
class OuterClass{ public static class StaticNestedClass{ } public class InnerClass{ } public InnerClass getAnInnerClass(){ return new InnerClass(); } public static InnerClass getAnInnerClassStatically(){ return new InnerClass(); } } class OtherClass{ private OuterClass.StaticNestedClass staticNestedClass = new OuterClass.StaticNestedClass(); private OuterClass.InnerClass innerClass = new OuterClass.InnerClass(); private OuterClass outerclass= new OuterClass(); private OuterClass.InnerClass innerClass2 = outerclass.getAnInnerClass(); private OuterClass.InnerClass innerClass3 = outerclass.new InnerClass(); }
public class eOAuth { private eOAuth(){} public final static int ECodeOauthInvalidGrant = 0x1; public final static int ECodeOauthUnknown = 0x10; public static GetSomeStuff(){} }
if (value == eOAuth.ECodeOauthInvalidGrant) eOAuth.GetSomeStuff(); ...
public enum MyUtilities {; public static void myMethod(); }
public class Outer { public static class Inner {} }
public enum StaticClass2 { ; public static boolean isEmpty(final String s) { return s == null || s.isEmpty(); } }
public class whatever { static class innerclass { } }
public class StaticClass { static private int me = 3; public static void printHelloWorld() { System.out.println("Hello World"); } public static void main(String[] args) { StaticClass.printHelloWorld(); System.out.println(StaticClass.me); } }
class StaticClass1 { public static int yum = 4; static void printHowAreYou() { System.out.println("How are you?"); } } public class StaticClass { static int me = 3; public static void printHelloWorld() { System.out.println("Hello World"); StaticClass1.printHowAreYou(); System.out.println(StaticClass1.yum); } public static void main(String[] args) { StaticClass.printHelloWorld(); System.out.println(StaticClass.me); } }
String s = "It was the best of times, it was the worst of times,\n" + "it was the age of wisdom, it was the age of foolishness,\n" + "it was the epoch of belief, it was the epoch of incredulity,\n" + "it was the season of Light, it was the season of Darkness,\n" + "it was the spring of hope, it was the winter of despair,\n" + "we had everything before us, we had nothing before us";
String s = new StringBuilder() .append("It was the best of times, it was the worst of times,\n") .append("it was the age of wisdom, it was the age of foolishness,\n") .append("it was the epoch of belief, it was the epoch of incredulity,\n") .append("it was the season of Light, it was the season of Darkness,\n") .append("it was the spring of hope, it was the winter of despair,\n") .append("we had everything before us, we had nothing before us") .toString();
String s = String.format("%s\n%s\n%s\n%s\n%s\n%s" , "It was the best of times, it was the worst of times," , "it was the age of wisdom, it was the age of foolishness," , "it was the epoch of belief, it was the epoch of incredulity," , "it was the season of Light, it was the season of Darkness," , "it was the spring of hope, it was the winter of despair," , "we had everything before us, we had nothing before us" );
String s = String.join("\n" , "It was the best of times, it was the worst of times," , "it was the age of wisdom, it was the age of foolishness," , "it was the epoch of belief, it was the epoch of incredulity," , "it was the season of Light, it was the season of Darkness," , "it was the spring of hope, it was the winter of despair," , "we had everything before us, we had nothing before us" );
import org.adrianwalker.multilinestring.Multiline; ... public final class MultilineStringUsage { /** <html> <head/> <body> <p> Hello<br/> Multiline<br/> World<br/> </p> </body> </html> */ @Multiline private static String html; public static void main(final String[] args) { System.out.println(html); } }
public static String S() { StackTraceElement element = new RuntimeException().getStackTrace()[1]; String name = element.getClassName().replace( StringBuilder sb = new StringBuilder(); String line = null; InputStream in = classLoader.getResourceAsStream(name); String s = convertStreamToString(in, element.getLineNumber()); return s.substring(s.indexOf("/*")+2, s.indexOf("*/")); } private static String convertStreamToString(InputStream is, int lineNum) { /* * To convert the InputStream to String we use the BufferedReader.readLine() * method. We iterate until the BufferedReader return null which means * there * and returned as String. */ BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuilder sb = new StringBuilder(); String line = null; int i = 1; try { while ((line = reader.readLine()) != null) { if (i++ >= lineNum) { sb.append(line + "\n"); } } } catch (IOException e) { e.printStackTrace(); } finally { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } return sb.toString(); }
String s = String.join( System.getProperty("line.separator"), "First line.", "Second line.", "The rest.", "And the last!" );
final String text = join("\r\n" ,"text" ,"text" ,"text" );
String a="Hello"; String b="Goodbye"; String c=a+b;
String a="Hello"; String b="Goodbye": StringBuilder temp=new StringBuilder(); temp.append(a).append(b); String c=temp.toString();
String newline = System.getProperty ("line.separator"); string1 + newline + string2 + newline + string3
String multilineString = String.format("%s\n%s\n%s\n",line1,line2,line3);
Reader r = new InputStreamReader(Foo.class.getResourceAsStream("filename"), "UTF-8"); String s = Utils.readAll(r);
public static String readAll(Reader input) { StringBuilder sb = new StringBuilder(); char[] buffer = new char[4096]; int charsRead; while ((charsRead = input.read(buffer)) >= 0) { sb.append(buffer, 0, charsRead); } input.close(); return sb.toString(); }
import sys import string import os print for line in sys.stdin: one = string.replace(line, print print
/** <html> <head/> <body> <p> Hello<br/> Multiline<br/> World<br/> </p> </body> </html> */ @Multiline private static String html;
StringWriter stringWriter = new StringWriter(); PrintWriter writer = new PrintWriter(stringWriter); writer.println("It was the best of times, it was the worst of times"); writer.println("it was the age of wisdom, it was the age of foolishness,"); writer.println("it was the epoch of belief, it was the epoch of incredulity,"); writer.println("it was the season of Light, it was the season of Darkness,"); writer.println("it was the spring of hope, it was the winter of despair,"); writer.println("we had everything before us, we had nothing before us"); String string = stringWriter.toString();
import org.apache.commons.lang3.StringUtils; String multiline = StringUtils.join(new String[] { "It was the best of times, it was the worst of times ", "it was the age of wisdom, it was the age of foolishness", "it was the epoch of belief, it was the epoch of incredulity", "it was the season of Light, it was the season of Darkness", "it was the spring of hope, it was the winter of despair", "we had everything before us, we had nothing before us" }, "\n");
public static String multilineString(String... lines){ StringBuilder sb = new StringBuilder(); for(String s : lines){ sb.append(s); sb.append ( } return sb.toStirng(); }
String out = Joiner.on(newline).join(ImmutableList.of( "line1", "line2", "line3"));
String separator = System.getProperty("line.separator"); String[] lines = {"Line 1", "Line 2" }; StringBuilder builder = new StringBuilder(lines[0]); for (int i = 1; i < lines.length(); i++) { builder.append(separator).append(lines[i]); } String multiLine = builder.toString();
import static some.Util.*; public class Java { public static void main(String[] args) { String sql = $( "Select * from java", "join some on ", "group by" ); System.out.println(sql); } } public class Util { public static String $(String ...sql){ return String.join(System.getProperty("line.separator"),sql); } }
String a = "a\n"; String b = "b\n"; String c = "c\n"; String d = "d\n"; String abcd = a + b + c + d; System.out.println(abcd); String abcd2 = "a\n" + "b\n" + "c\n" + "d\n"; System.out.println(abcd2);
Code: 0: ldc 2: astore_1 3: ldc 5: astore_2 6: ldc 8: astore_3 9: ldc 11: astore 4 13: new 16: dup 17: invokespecial 20: aload_1 21: invokevirtual 24: aload_2 25: invokevirtual 28: aload_3 29: invokevirtual 32: aload 4 34: invokevirtual 37: invokevirtual 40: astore 5 42: getstatic 45: aload 5 47: invokevirtual 50: ldc 52: astore 6 54: getstatic 57: aload 6 59: invokevirtual 62: return
StringBuilder builder = new StringBuilder(); public String getString() { return builder.toString(); } private DropdownContent _(String a) { builder.append(a); return this; } public String funct_showhide() { return _("function slidedown_showHide(boxId)"). _("{"). _("if(!slidedown_direction[boxId])slidedown_direction[boxId] = 1;"). _("if(!slideDownInitHeight[boxId])slideDownInitHeight[boxId] = 0;"). _("if(slideDownInitHeight[boxId]==0)slidedown_direction[boxId]=slidedownSpeed; "). _("else slidedown_direction[boxId] = slidedownSpeed*-1;"). _("slidedownContentBox = document.getElementById(boxId);"). _("var subDivs = slidedownContentBox.getElementsByTagName( _("for(var no=0;no<subDivs.length;no++){"). _(" if(subDivs[no].className== _("}"). _("contentHeight = slidedownContent.offsetHeight;"). _("slidedownContentBox.style.visibility= _("slidedownActive = true;"). _("slidedown_showHide_start(slidedownContentBox,slidedownContent);"). _("}").getString(); }
const char usage = "\n" "Usage: xxxx <options>\n" "\n" "Removes your options as designated by the required parameter <options>,\n" "which must be one of the following strings:\n" " love\n" " sex\n" " drugs\n" " rockandroll\n" "\n" ;
String Query = " SELECT some_column, another column FROM one_table a JOIN another_table b ON a.id = b.id AND a.role_code = b.role_code WHERE a.dept = AND b.sales_quote > 1000 Order BY 1, 2 " ;
InputStream fileIS = YourClass.class.getResourceAsStream("MultiLine.xml"); Properties prop = new Properies(); prop.loadFromXML(fileIS);
static final String UNIQUE_MEANINGFUL_KEY = "Super Duper UNIQUE Key"; prop.getProperty(UNIQUE_MEANINGFUL_KEY)
<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE properties SYSTEM "http: <properties> <entry key="Super Duper UNIQUE Key"> MEGA LONG MULTILINE </entry> </properties>
@Controller @RequestMapping("/users") public class SomeController { @Autowired private UserService userService; @RequestMapping("/login") public void login(@RequestParam("username") String username, @RequestParam("password") String password) { userService.login(username, password); } }
<beans ...> <bean id="userService" class="com.foo.UserServiceImpl"/> <bean id="fooController" class="com.foo.FooController"/> </beans>
public class FooController { @Autowired private UserService userService; }
class A { private int id; } class B { private String name; @Autowired A a; public void showDetail() { System.out.println("Value of id form A class" + a.getId();); } }
class EnglishGreeting { private Greeting greeting; } class Greeting { private String message; }
<bean id="englishGreeting" class="com.bean.EnglishGreeting"> <property name="greeting" ref="greeting"/> </bean> <bean id="greeting" class="com.bean.Greeting"> <property name="message" value="Hello World"/> </bean>
class EnglishGreeting { @Autowired private Greeting greeting; }
<bean id="englishGreeting" class="com.bean.EnglishGreeting"></bean> <bean id="greeting" class="com.bean.Greeting"> <property name="message" value="Hello World"/> </bean>
public class AccController { @Autowired private UserService userService; }
public class YourController{ @Autowired private UserService userService; }
public static int safeLongToInt(long l) { int i = (int)l; if ((long)i != l) { throw new IllegalArgumentException(l + " cannot be cast to int without changing its value."); } return i; }
import static java.lang.Math.toIntExact; long foo = 10L; int bar = toIntExact(foo);
public static int safeLongToInt(long l) { if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { throw new IllegalArgumentException (l + " cannot be cast to int without changing its value."); } return (int) l; }
public static int safeLongToInt(long l) { return Ints.checkedCast(l); }
long aLong = ...; int anInt = new BigDecimal(aLong).intValueExact();
public static int safeLongToInt(long l) { return (int) Math.max(Math.min(Integer.MAX_VALUE, l), Integer.MIN_VALUE); }
public int longToInt(long theLongOne) { return Long.valueOf(theLongOne).intValue(); }
public static int intValue(long value) { int valueInt = (int)value; if (valueInt != value) { throw new IllegalArgumentException( "The long value "+value+" is not within range of the int type" ); } return valueInt; }
public static final long LONG_HIGH_BITS = 0xFFFFFFFF80000000L; public static int safeLongToInt(long l) { if ((l & LONG_HIGH_BITS) == 0 || (l & LONG_HIGH_BITS) == LONG_HIGH_BITS) { return (int) l; } else { throw new IllegalArgumentException("..."); } }
public int longToInt(Long longVariable) { try { return Integer.valueOf(longVariable.toString()); } catch(IllegalArgumentException e) { Log.e(e.printstackstrace()); } }
<project> [...] <build> [...] <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> </plugins> [...] </build> [...] </project>
<project> [...] <properties> <maven.compiler.source>1.8</maven.compiler.source> <maven.compiler.target>1.8</maven.compiler.target> </properties> [...] </project>
<build> <finalName>SpringApp</finalName> <plugins> <plugin> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>1.7</source> <target>1.7</target> </configuration> </plugin> ... </plugins> ... </build>
<bytecodeTargetLevel> <module name="project-name" target="1.7" /> </bytecodeTargetLevel>
sourceCompatibility = "xx" targetCompatibility = "xx"
subprojects { project -> sourceCompatibility = "1.7" targetCompatibility = "1.7" }
public static String fmt(double d) { if(d == (long) d) return String.format("%d",(long)d); else return String.format("%s",d); }
double myValue = 0.00000021d; DecimalFormat df = new DecimalFormat("0", DecimalFormatSymbols.getInstance(Locale.ENGLISH)); df.setMaximumFractionDigits(340); System.out.println(df.format(myValue));
double myValue = 0.00000021d; String.format("%s", myvalue);
double myValue = 0.00000021d; String.format("%.12f", myvalue);
double myValue = 0.00000021d; System.out.println(String.format("%.0f", myvalue)); DecimalFormat df = new DecimalFormat("0"); System.out.println(df.format(myValue));
double myValue = 0.00000021d; DecimalFormat df = new DecimalFormat("0"); df.setMaximumFractionDigits(340); System.out.println(df.format(myvalue));
if (d % 1.0 != 0) return String.format("%s", d); else return String.format("%.0f",d);
public static String prettyPrint(double d) { int i = (int) d; return d == i ? String.valueOf(i) : String.valueOf(d); }
if(n % 1 == 0) { return String.format(Locale.US, "%.0f", n)); } else { return String.format(Locale.US, "%.1f", n)); }
private static String trimTrailingZeros(String number) { if(!number.contains(".")) { return number; } return number.replaceAll("\\.?0*$", ""); }
double f = 123456.789d; System.out.println(String.format(Locale.FRANCE,"%f",f)); System.out.println(String.format(Locale.GERMANY,"%f",f)); System.out.println(String.format(Locale.US,"%f",f));
res += stripFpZeroes(String.format((Locale) null, (nDigits!=0 ? "%."+nDigits+"f" : "%f"), value)); ... protected static String stripFpZeroes(String fpnumber) { int n = fpnumber.indexOf( if (n == -1) { return fpnumber; } if (n < 2) { n = 2; } String s = fpnumber; while (s.length() > n && s.endsWith("0")) { s = s.substring(0, s.length()-1); } return s; }
double horribleNumber = 3598945.141658554548844; DoubleFormatter df = new DoubleFormatter(4,6); String beautyDisplay = df.format(horribleNumber);
import java.math.RoundingMode; import java.text.DecimalFormat; import java.text.DecimalFormatSymbols; import java.text.NumberFormat; import java.util.Locale; import com.google.common.base.Preconditions; import com.google.common.base.Strings; /** * Convert a double to a beautiful String (US-local): * * double horribleNumber = 3598945.141658554548844; * DoubleFormatter df = new DoubleFormatter(4,6); * String beautyDisplay = df.format(horribleNumber); * String beautyLabel = df.formatHtml(horribleNumber); * * Manipulate 3 instances of NumberFormat to efficiently format a great number of double values. * (avoid to create an object NumberFormat each call of format()). * * 3 instances of NumberFormat will be reused to format a value v: * * if v < EXP_DOWN, uses nfBelow * if EXP_DOWN <= v <= EXP_UP, uses nfNormal * if EXP_UP < v, uses nfAbove * * nfBelow, nfNormal and nfAbove will be generated base on the precision_ parameter. * * @author: DUONG Phu-Hiep */ public class DoubleFormatter { private static final double EXP_DOWN = 1.e-3; private double EXP_UP; private int maxInteger_; private int maxFraction_; private NumberFormat nfBelow_; private NumberFormat nfNormal_; private NumberFormat nfAbove_; private enum NumberFormatKind {Below, Normal, Above} public DoubleFormatter(int maxInteger, int maxFraction){ setPrecision(maxInteger, maxFraction); } public void setPrecision(int maxInteger, int maxFraction){ Preconditions.checkArgument(maxFraction>=0); Preconditions.checkArgument(maxInteger>0 && maxInteger<17); if (maxFraction == maxFraction_ && maxInteger_ == maxInteger) { return; } maxFraction_ = maxFraction; maxInteger_ = maxInteger; EXP_UP = Math.pow(10, maxInteger); nfBelow_ = createNumberFormat(NumberFormatKind.Below); nfNormal_ = createNumberFormat(NumberFormatKind.Normal); nfAbove_ = createNumberFormat(NumberFormatKind.Above); } private NumberFormat createNumberFormat(NumberFormatKind kind) { final String sharpByPrecision = Strings.repeat(" NumberFormat f = NumberFormat.getInstance(Locale.US); f.setRoundingMode(RoundingMode.HALF_EVEN); if (f instanceof DecimalFormat) { DecimalFormat df = (DecimalFormat) f; DecimalFormatSymbols dfs = df.getDecimalFormatSymbols(); if (kind == NumberFormatKind.Above) { dfs.setExponentSeparator("e+"); } else { dfs.setExponentSeparator("e"); } df.setDecimalFormatSymbols(dfs); if (kind == NumberFormatKind.Normal) { if (maxFraction_ == 0) { df.applyPattern(" } else { df.applyPattern(" } } else { if (maxFraction_ == 0) { df.applyPattern("0E0"); } else { df.applyPattern("0."+sharpByPrecision+"E0"); } } } return f; } public String format(double v) { if (Double.isNaN(v)) { return "-"; } if (v==0) { return "0"; } final double absv = Math.abs(v); if (absv<EXP_DOWN) { return nfBelow_.format(v); } if (absv>EXP_UP) { return nfAbove_.format(v); } return nfNormal_.format(v); } /** * format and higlight the important part (integer part & exponent part) */ public String formatHtml(double v) { if (Double.isNaN(v)) { return "-"; } return htmlize(format(v)); } /** * This is the base alogrithm: create a instance of NumberFormat for the value, then format it. It should * not be used to format a great numbers of value * * We will never use this methode, it is here only to understanding the Algo principal: * * format v to string. precision_ is numbers of digits after decimal. * if EXP_DOWN <= abs(v) <= EXP_UP, display the normal format: 124.45678 * otherwise display scientist format with: 1.2345e+30 * * pre-condition: precision >= 1 */ @Deprecated public String formatInefficient(double v) { final String sharpByPrecision = Strings.repeat(" final double absv = Math.abs(v); NumberFormat f = NumberFormat.getInstance(Locale.US); f.setRoundingMode(RoundingMode.HALF_EVEN); if (f instanceof DecimalFormat) { DecimalFormat df = (DecimalFormat) f; DecimalFormatSymbols dfs = df.getDecimalFormatSymbols(); dfs.setGroupingSeparator( if (absv>EXP_UP) { dfs.setExponentSeparator("e+"); } else { dfs.setExponentSeparator("e"); } df.setDecimalFormatSymbols(dfs); if (absv<EXP_DOWN || absv>EXP_UP) { df.applyPattern("0."+sharpByPrecision+"E0"); } else { df.applyPattern(" } } return f.format(v); } /** * Convert "3.1416e+12" to "<b>3</b>.1416e<b>+12</b>" * It is a html format of a number which highlight the integer and exponent part */ private static String htmlize(String s) { StringBuilder resu = new StringBuilder("<b>"); int p1 = s.indexOf( if (p1>0) { resu.append(s.substring(0, p1)); resu.append("</b>"); } else { p1 = 0; } int p2 = s.lastIndexOf( if (p2>0) { resu.append(s.substring(p1, p2)); resu.append("<b>"); resu.append(s.substring(p2, s.length())); resu.append("</b>"); } else { resu.append(s.substring(p1, s.length())); if (p1==0){ resu.append("</b>"); } } return resu.toString(); } }
/** * Equivalent to Strings.repeat(" */ private static String createSharp(int n) { StringBuilder sb = new StringBuilder(); for (int i=0;i<n;i++) { sb.append( } return sb.toString(); }
if (d == Math.floor(d)) { return String.format("%.0f", d); } else { return Double.toString(d); }
public static String removeZero(double number) { DecimalFormat format = new DecimalFormat(" return format.format(number); }
String s = String.valueof("your int variable"); while (g.endsWith("0") && g.contains(".")) { g = g.substring(0, g.length() - 1); if (g.endsWith(".")) { g = g.substring(0, g.length() - 1); } }
import java.util.ArrayList; import java.util.List; public class UseMixedNumbers { public static void main(String[] args) { List<Number> listNumbers = new ArrayList<Number>(); listNumbers.add(232); listNumbers.add(0.18); listNumbers.add(1237875192); listNumbers.add(4.58); listNumbers.add(0); listNumbers.add(1.2345); for (Number number : listNumbers) { System.out.println(number); } } }
public static String formatFloatToString(final float f) { final int i=(int)f; if(f==i) return Integer.toString(i); return Float.toString(f); }
public static String formatFloatToString(final float f) { final String s=Float.toString(f); int dotPos=-1; for(int i=0;i<s.length();++i) if(s.charAt(i)== { dotPos=i; break; } if(dotPos==-1) return s; int end=dotPos; for(int i=dotPos+1;i<s.length();++i) { final char c=s.charAt(i); if(c!= end=i+1; } final String result=s.substring(0,end); return result; }
public static String fmt(double d) { String val = Double.toString(d); String[] valArray = val.split("\\."); long valLong = 0; if(valArray.length == 2){ valLong = Long.parseLong(valArray[1]); } if (valLong == 0) return String.format("%d", (long) d); else return String.format("%s", d); }
private static String format(final double dbl) { return dbl % 1 != 0 ? String.valueOf(dbl) : String.valueOf((int) dbl); }
public static String removeTrailingZeros(double f) { if(f == (int)f) { return String.format("%d", (int)f); } return String.format("%f", f).replaceAll("0*$", ""); }
public class Test { public static void main(String args[]){ System.out.println(String.format("%s something",new Double(3.456))); System.out.println(String.format("%s something",new Double(3.456234523452))); System.out.println(String.format("%s something",new Double(3.45))); System.out.println(String.format("%s something",new Double(3))); } }
3.456 something 3.456234523452 something 3.45 something 3.0 something
String s = "1.210000"; while (s.endsWith("0")){ s = (s.substring(0, s.length() - 1)); }
interface ApplicationRepository<T> extends PagingAndSortingRepository<T, Long> { } interface ReadOnlyRepository<T> extends Repository<T, Long> { }
TreeSet<String> set = new TreeSet<String>(); set.add("lol"); set.add("cat"); for (String s : set) { System.out.println(s); }
List<String> strings = new ArrayList<String>() strings.add("lol"); strings.add("cat"); Collections.sort(strings); for (String s : strings) { System.out.println(s); }
Collator usCollator = Collator.getInstance(Locale.US); usCollator.setStrength(Collator.PRIMARY); Collections.sort(strings, usCollator);
List<string> sorted = Ordering.natural().sortedCopy(strings);
List<String> strings = new ArrayList<String>() strings.add("lol"); strings.add("cat"); PriorityQueue<String> sortedStrings = new PriorityQueue(strings); while(!sortedStrings.isEmpty()) { System.out.println(sortedStrings.poll()); }
public class SortedList<E> extends AbstractList<E> { private ArrayList<E> internalList = new ArrayList<E>(); @Override public void add(int position, E e) { internalList.add(e); Collections.sort(internalList, null); } @Override public E get(int i) { return internalList.get(i); } @Override public int size() { return internalList.size(); } }
public class Test { int value; public int getValue() { return value; } public void reset() { value = 0; } public void method1(int i) { value = ((value + i) / i) << 1; if ((i & 0xFFFFFFF) == 1000000000) { System.out.println("You } } public void method2(int i) throws Exception { value = ((value + i) / i) << 1; if ((i & 0xFFFFFFF) == 1000000000) { throw new Exception(); } } public void method3(int i) throws Exception { value = ((value + i) / i) << 1; if ((i & 0x1) == 1) { throw new Exception(); } } public static void main(String[] args) { int i; long l; Test t = new Test(); l = System.currentTimeMillis(); t.reset(); for (i = 1; i < 100000000; i++) { t.method1(i); } l = System.currentTimeMillis() - l; System.out.println( "method1 took " + l + " ms, result was " + t.getValue() ); l = System.currentTimeMillis(); t.reset(); for (i = 1; i < 100000000; i++) { try { t.method2(i); } catch (Exception e) { System.out.println("You } } l = System.currentTimeMillis() - l; System.out.println( "method2 took " + l + " ms, result was " + t.getValue() ); l = System.currentTimeMillis(); t.reset(); for (i = 1; i < 100000000; i++) { try { t.method3(i); } catch (Exception e) { } } l = System.currentTimeMillis() - l; System.out.println( "method3 took " + l + " ms, result was " + t.getValue() ); } }
method1 took 972 ms, result was 2 method2 took 1003 ms, result was 2 method3 took 66716 ms, result was 2
method1 took 1733 ms, result was 2 method2 took 1248 ms, result was 2 method3 took 83997 ms, result was 2 method4 took 1692 ms, result was 2 method5 took 60946 ms, result was 2 method6 took 25746 ms, result was 2
public void method4(int i) throws NoStackTraceThrowable { value = ((value + i) / i) << 1; if ((i & 0x1) == 1) { throw new NoStackTraceThrowable(); } } public void method5(int i) throws NoStackTraceRuntimeException { value = ((value + i) / i) << 1; if ((i & 0x1) == 1) { throw new NoStackTraceRuntimeException(); } } public static void main(String[] args) { int i; long l; Test t = new Test(); l = System.currentTimeMillis(); t.reset(); for (i = 1; i < 100000000; i++) { try { t.method4(i); } catch (NoStackTraceThrowable e) { } } l = System.currentTimeMillis() - l; System.out.println( "method4 took " + l + " ms, result was " + t.getValue() ); l = System.currentTimeMillis(); t.reset(); for (i = 1; i < 100000000; i++) { try { t.method5(i); } catch (RuntimeException e) { } } l = System.currentTimeMillis() - l; System.out.println( "method5 took " + l + " ms, result was " + t.getValue() ); }
method1 took 883 ms, result was 2 method2 took 882 ms, result was 2 method3 took 32270 ms, result was 2 method4 took 8114 ms, result was 2 method5 took 8086 ms, result was 2
public class NoStackTraceThrowable extends Throwable { public NoStackTraceThrowable() { super("my special throwable", null, false, false); } }
class ControlException extends ControlThrowable class T { var value = 0 def reset = { value = 0 } def method1(i: Int) = { value = ((value + i) / i) << 1 if ((i & 0xfffffff) == 1000000000) { println("You } } def method2(i: Int) = { value = ((value + i) / i) << 1 if ((i & 0xfffffff) == 1000000000) { throw new Exception() } } def method3(i: Int) = { value = ((value + i) / i) << 1 if ((i & 0x1) == 1) { throw new Exception() } } def method4(i: Int) = { value = ((value + i) / i) << 1 if ((i & 0x1) == 1) { throw new ControlException() } } } class Main { var l = System.currentTimeMillis val t = new T for (i <- 1 to 10000000) t.method1(i) l = System.currentTimeMillis - l println("method1 took " + l + " ms, result was " + t.value) t.reset l = System.currentTimeMillis for (i <- 1 to 10000000) try { t.method2(i) } catch { case _ => println("You } l = System.currentTimeMillis - l println("method2 took " + l + " ms, result was " + t.value) t.reset l = System.currentTimeMillis for (i <- 1 to 10000000) try { t.method4(i) } catch { case _ => } l = System.currentTimeMillis - l println("method4 took " + l + " ms, result was " + t.value) t.reset l = System.currentTimeMillis for (i <- 1 to 10000000) try { t.method3(i) } catch { case _ => } l = System.currentTimeMillis - l println("method3 took " + l + " ms, result was " + t.value) }
method1 took 146 ms, result was 2 method2 took 159 ms, result was 2 method4 took 1551 ms, result was 2 method3 took 42492 ms, result was 2
int value; public int getValue() { return value; } public void reset() { value = 0; } public boolean baseline_null(boolean shouldfail, int recurse_depth) { if (recurse_depth <= 0) { return shouldfail; } else { return baseline_null(shouldfail,recurse_depth-1); } } public boolean retval_error(boolean shouldfail, int recurse_depth) { if (recurse_depth <= 0) { if (shouldfail) { return false; } else { return true; } } else { boolean nested_error = retval_error(shouldfail,recurse_depth-1); if (nested_error) { return true; } else { return false; } } } public void exception_error(boolean shouldfail, int recurse_depth) throws Exception { if (recurse_depth <= 0) { if (shouldfail) { throw new Exception(); } } else { exception_error(shouldfail,recurse_depth-1); } } public static void main(String[] args) { int i; long l; TestIt t = new TestIt(); int failures; int ITERATION_COUNT = 100000000; for (int recurse_depth = 2; recurse_depth <= 10; recurse_depth+=3) { for (float exception_freq = 0.0f; exception_freq <= 1.0f; exception_freq += 0.25f) { int EXCEPTION_MOD = (exception_freq == 0.0f) ? ITERATION_COUNT+1 : (int)(1.0f / exception_freq); failures = 0; long start_time = System.currentTimeMillis(); t.reset(); for (i = 1; i < ITERATION_COUNT; i++) { boolean shoulderror = (i % EXCEPTION_MOD) == 0; t.baseline_null(shoulderror,recurse_depth); } long elapsed_time = System.currentTimeMillis() - start_time; System.out.format("baseline: recurse_depth %s, exception_freqeuncy %s (%s), time elapsed %s ms\n", recurse_depth, exception_freq, failures,elapsed_time); } } for (int recurse_depth = 2; recurse_depth <= 10; recurse_depth+=3) { for (float exception_freq = 0.0f; exception_freq <= 1.0f; exception_freq += 0.25f) { int EXCEPTION_MOD = (exception_freq == 0.0f) ? ITERATION_COUNT+1 : (int)(1.0f / exception_freq); failures = 0; long start_time = System.currentTimeMillis(); t.reset(); for (i = 1; i < ITERATION_COUNT; i++) { boolean shoulderror = (i % EXCEPTION_MOD) == 0; if (!t.retval_error(shoulderror,recurse_depth)) { failures++; } } long elapsed_time = System.currentTimeMillis() - start_time; System.out.format("retval_error: recurse_depth %s, exception_freqeuncy %s (%s), time elapsed %s ms\n", recurse_depth, exception_freq, failures,elapsed_time); } } for (int recurse_depth = 2; recurse_depth <= 10; recurse_depth+=3) { for (float exception_freq = 0.0f; exception_freq <= 1.0f; exception_freq += 0.25f) { int EXCEPTION_MOD = (exception_freq == 0.0f) ? ITERATION_COUNT+1 : (int)(1.0f / exception_freq); failures = 0; long start_time = System.currentTimeMillis(); t.reset(); for (i = 1; i < ITERATION_COUNT; i++) { boolean shoulderror = (i % EXCEPTION_MOD) == 0; try { t.exception_error(shoulderror,recurse_depth); } catch (Exception e) { failures++; } } long elapsed_time = System.currentTimeMillis() - start_time; System.out.format("exception_error: recurse_depth %s, exception_freqeuncy %s (%s), time elapsed %s ms\n", recurse_depth, exception_freq, failures,elapsed_time); } } }
baseline: recurse_depth 2, exception_freqeuncy 0.0 (0), time elapsed 683 ms baseline: recurse_depth 2, exception_freqeuncy 0.25 (0), time elapsed 790 ms baseline: recurse_depth 2, exception_freqeuncy 0.5 (0), time elapsed 768 ms baseline: recurse_depth 2, exception_freqeuncy 0.75 (0), time elapsed 749 ms baseline: recurse_depth 2, exception_freqeuncy 1.0 (0), time elapsed 731 ms baseline: recurse_depth 5, exception_freqeuncy 0.0 (0), time elapsed 923 ms baseline: recurse_depth 5, exception_freqeuncy 0.25 (0), time elapsed 971 ms baseline: recurse_depth 5, exception_freqeuncy 0.5 (0), time elapsed 982 ms baseline: recurse_depth 5, exception_freqeuncy 0.75 (0), time elapsed 947 ms baseline: recurse_depth 5, exception_freqeuncy 1.0 (0), time elapsed 937 ms baseline: recurse_depth 8, exception_freqeuncy 0.0 (0), time elapsed 1154 ms baseline: recurse_depth 8, exception_freqeuncy 0.25 (0), time elapsed 1149 ms baseline: recurse_depth 8, exception_freqeuncy 0.5 (0), time elapsed 1133 ms baseline: recurse_depth 8, exception_freqeuncy 0.75 (0), time elapsed 1117 ms baseline: recurse_depth 8, exception_freqeuncy 1.0 (0), time elapsed 1116 ms retval_error: recurse_depth 2, exception_freqeuncy 0.0 (0), time elapsed 742 ms retval_error: recurse_depth 2, exception_freqeuncy 0.25 (24999999), time elapsed 743 ms retval_error: recurse_depth 2, exception_freqeuncy 0.5 (49999999), time elapsed 734 ms retval_error: recurse_depth 2, exception_freqeuncy 0.75 (99999999), time elapsed 723 ms retval_error: recurse_depth 2, exception_freqeuncy 1.0 (99999999), time elapsed 728 ms retval_error: recurse_depth 5, exception_freqeuncy 0.0 (0), time elapsed 920 ms retval_error: recurse_depth 5, exception_freqeuncy 0.25 (24999999), time elapsed 1121 ms retval_error: recurse_depth 5, exception_freqeuncy 0.5 (49999999), time elapsed 1037 ms retval_error: recurse_depth 5, exception_freqeuncy 0.75 (99999999), time elapsed 1141 ms retval_error: recurse_depth 5, exception_freqeuncy 1.0 (99999999), time elapsed 1130 ms retval_error: recurse_depth 8, exception_freqeuncy 0.0 (0), time elapsed 1218 ms retval_error: recurse_depth 8, exception_freqeuncy 0.25 (24999999), time elapsed 1334 ms retval_error: recurse_depth 8, exception_freqeuncy 0.5 (49999999), time elapsed 1478 ms retval_error: recurse_depth 8, exception_freqeuncy 0.75 (99999999), time elapsed 1637 ms retval_error: recurse_depth 8, exception_freqeuncy 1.0 (99999999), time elapsed 1655 ms exception_error: recurse_depth 2, exception_freqeuncy 0.0 (0), time elapsed 726 ms exception_error: recurse_depth 2, exception_freqeuncy 0.25 (24999999), time elapsed 17487 ms exception_error: recurse_depth 2, exception_freqeuncy 0.5 (49999999), time elapsed 33763 ms exception_error: recurse_depth 2, exception_freqeuncy 0.75 (99999999), time elapsed 67367 ms exception_error: recurse_depth 2, exception_freqeuncy 1.0 (99999999), time elapsed 66990 ms exception_error: recurse_depth 5, exception_freqeuncy 0.0 (0), time elapsed 924 ms exception_error: recurse_depth 5, exception_freqeuncy 0.25 (24999999), time elapsed 23775 ms exception_error: recurse_depth 5, exception_freqeuncy 0.5 (49999999), time elapsed 46326 ms exception_error: recurse_depth 5, exception_freqeuncy 0.75 (99999999), time elapsed 91707 ms exception_error: recurse_depth 5, exception_freqeuncy 1.0 (99999999), time elapsed 91580 ms exception_error: recurse_depth 8, exception_freqeuncy 0.0 (0), time elapsed 1144 ms exception_error: recurse_depth 8, exception_freqeuncy 0.25 (24999999), time elapsed 30440 ms exception_error: recurse_depth 8, exception_freqeuncy 0.5 (49999999), time elapsed 59116 ms exception_error: recurse_depth 8, exception_freqeuncy 0.75 (99999999), time elapsed 116678 ms exception_error: recurse_depth 8, exception_freqeuncy 1.0 (99999999), time elapsed 116477 ms
public static int parseUnsignedInt(String s, int defaultValue) { final int strLength = s.length(); if (strLength == 0) return defaultValue; int value = 0; for (int i=strLength-1; i>=0; i--) { int c = s.charAt(i); if (c > 47 && c < 58) { c -= 48; for (int j=strLength-i; j!=1; j--) c *= 10; value += c; } else { return defaultValue; } } return value < 0 ? defaultValue : value; }
public boolean method1(int i) { value = ((value + i) / i) << 1; return ((i & 0xFFFFFFF) == 1000000000); } .... for (i = 1; i < 100000000; i++) { if (t.method1(i)) { System.out.println("Will never be true!"); } }
method1 took 841 ms, result was 2 method2 took 841 ms, result was 2 method3 took 85058 ms, result was 2
method1 took 821 ms, result was 2 method2 took 838 ms, result was 2 method3 took 85929 ms, result was 2
Benchmark Mode Samples Mean Mean error Units dynamicException avgt 25 1901.196 14.572 ns/op dynamicException_NoStack avgt 25 67.029 0.212 ns/op dynamicException_NoStack_UsedData avgt 25 68.952 0.441 ns/op dynamicException_NoStack_UsedStack avgt 25 137.329 1.039 ns/op dynamicException_UsedData avgt 25 1900.770 9.359 ns/op dynamicException_UsedStack avgt 25 20033.658 118.600 ns/op plain avgt 25 1.259 0.002 ns/op staticException avgt 25 1.510 0.001 ns/op staticException_NoStack avgt 25 1.514 0.003 ns/op staticException_NoStack_UsedData avgt 25 4.185 0.015 ns/op staticException_NoStack_UsedStack avgt 25 19.110 0.051 ns/op staticException_UsedData avgt 25 4.159 0.007 ns/op staticException_UsedStack avgt 25 25.144 0.186 ns/op
Benchmark Mode Samples Mean Mean error Units exception_0000 avgt 25 1959.068 30.783 ns/op exception_0001 avgt 25 1945.958 12.104 ns/op exception_0002 avgt 25 2063.575 47.708 ns/op exception_0004 avgt 25 2211.882 29.417 ns/op exception_0008 avgt 25 2472.729 57.336 ns/op exception_0016 avgt 25 2950.847 29.863 ns/op exception_0032 avgt 25 4416.548 50.340 ns/op exception_0064 avgt 25 6845.140 40.114 ns/op exception_0128 avgt 25 11774.758 54.299 ns/op exception_0256 avgt 25 21617.526 101.379 ns/op exception_0512 avgt 25 42780.434 144.594 ns/op exception_1024 avgt 25 82839.358 291.434 ns/op
class Example { public static Example Parse(String input) throws AnyRuntimeParsigException ... }
public static Example Parse(String input, Example defaultValue)
Xxxxx.regex(".....pattern", src); if(ImTotallySure) { Example v = Example.Parse(src); }
public interface Runnable { void run(); } public interface Callable<V> { V call() throws Exception; }
public interface Callable<V> { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception; }
public interface Runnable { /** * When an object implementing interface <code>Runnable</code> is used * to create a thread, starting the thread causes the object * <code>run</code> method to be called in that separately executing * thread. * <p> * The general contract of the method <code>run</code> is that it may * take any action whatsoever. * * @see java.lang.Thread */ public abstract void run(); }
<T> Future<T> submit(Callable<T> task); Future<?> submit(Runnable task); <T> Future<T> submit(Runnable task, T result);
public class HelloRunnable implements Runnable { public void run() { System.out.println("Hello from a thread!"); } public static void main(String args[]) { (new Thread(new HelloRunnable())).start(); } }
+-------------------------------------+--------------------------------------------------------------------------------------------------+ | Runnable | Callable<T> | +-------------------------------------+--------------------------------------------------------------------------------------------------+ | Introduced in Java 1.0 of java.lang | Introduced in Java 1.5 of java.util.concurrent library | | Runnable cannot be parametrized | Callable is a parametrized type whose type parameter indicates the return type of its run method | | Runnable has run() method | Callable has call() method | | Runnable.run() returns void | Callable.call() returns a value of Type T | | Can not throw Checked Exceptions | Can throw Checked Exceptions | +-------------------------------------+--------------------------------------------------------------------------------------------------+
public void doStuff(String str) { if (str != null && str != "**here I want to check the { } }
public static boolean empty( final String s ) { return s == null || s.trim().isEmpty(); }
import org.apache.commons.lang.StringUtils; if (StringUtils.isNotBlank(str)) { ... } if (StringUtils.isBlank(str)) { ... }
import android.text.TextUtils; if (!TextUtils.isEmpty(str)) { ... }
Strings.nullToEmpty(str).isEmpty(); Strings.isNullOrEmpty(str);
import com.google.common.base.Strings; if (!Strings.isNullOrEmpty(myString)) { return myString; }
/** * <p>Checks if a String is whitespace, empty ("") or null.</p> * * <pre> * StringUtils.isBlank(null) = true * StringUtils.isBlank("") = true * StringUtils.isBlank(" ") = true * StringUtils.isBlank("bob") = false * StringUtils.isBlank(" bob ") = false * </pre> * * @param str the String to check, may be null * @return <code>true</code> if the String is null, empty or whitespace * @since 2.0 */ public static boolean isBlank(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(str.charAt(i)) == false)) { return false; } } return true; }
Optional.ofNullable(str) .filter(s -> !(s.trim().isEmpty())) .ifPresent(result -> { });
Predicate<String> p = (s)-> ( s != null && !s.isEmpty()); p.test(string);
jshell> "".isBlank() $7 ==> true jshell> " ".isBlank() $8 ==> true jshell> " ! ".isBlank() $9 ==> false
boolean isNullOrEmpty = Optional.ofNullable(str).map(String::isBlank).orElse(true);
private boolean stringNotEmptyOrNull(String st) { return st != null && !st.isEmpty(); }
public List<Employee> findEmployees(String str, int dep) { Preconditions.checkState(StringUtils.isNotBlank(str), "Invalid input, input is blank or null"); /** code here **/ }
public class StringUtils{ public static boolean areSet(String... strings) { for(String s : strings) if(s == null || s.isEmpty) return false; return true; } }
if(!StringUtils.areSet(firstName,lastName,address) { }
String str1 = ""; String str2 = null; if(StringUtils.isEmpty(str)){ System.out.println("str1 is null or empty"); } if(StringUtils.isEmpty(str2)){ System.out.println("str2 is null or empty"); }
import com.google.common.base.Strings; import org.apache.commons.lang.StringUtils; /** * Created by hu0983 on 2016.01.13.. */ public class StringNotEmptyTesting { public static void main(String[] args){ String a = " "; String b = ""; String c=null; System.out.println("Apache:"); if(!StringUtils.isNotBlank(a)){ System.out.println(" a is blank"); } if(!StringUtils.isNotBlank(b)){ System.out.println(" b is blank"); } if(!StringUtils.isNotBlank(c)){ System.out.println(" c is blank"); } System.out.println("Google:"); if(Strings.isNullOrEmpty(Strings.emptyToNull(a))){ System.out.println(" a is NullOrEmpty"); } if(Strings.isNullOrEmpty(b)){ System.out.println(" b is NullOrEmpty"); } if(Strings.isNullOrEmpty(c)){ System.out.println(" c is NullOrEmpty"); } } }
Function<String, Boolean> isNotEmpty = s -> s != null && !"".equals(s)
String emptyString = ""; isNotEmpty.apply(emptyString); String notEmptyString = "StackOverflow"; isNotEmpty.apply(notEmptyString);
Function<String, Boolean> isEmpty = s -> s == null || "".equals(s)
String emptyString = ""; !isEmpty.apply(emptyString); String notEmptyString = "StackOverflow"; !isEmpty.apply(notEmptyString);
org.springframework.util.StringUtils.hasLength(String str)
org.springframework.util.StringUtils.hasText(String str)
if (str == null || str.trim().length() == 0) { } else { }
org.springframework.util.StringUtils.isEmpty(@Nullable Object str);
public Boolean isStringCorrect(String str) { return Optional.ofNullable(str) .map(String::trim) .map(string -> !str.isEmpty()) .orElse(false); }
str!=null && !str.equalsIgnoreCase("null") && !str.isEmpty()
String path = File.separator + "var"+ File.separator + "temp"
String listOfFiles = ... String[] filePaths = listOfFiles.split(File.pathSeparator);
import java.io.File; public class FileSeparator { public static void main(String[] args) { System.out.println("File.separator = "+File.separator); System.out.println("File.separatorChar = "+File.separatorChar); System.out.println("File.pathSeparator = "+File.pathSeparator); System.out.println("File.pathSeparatorChar = "+File.pathSeparatorChar); } }
File.separator = / File.separatorChar = / File.pathSeparator = : File.pathSeparatorChar = :
File.separator = \ File.separatorChar = \ File.pathSeparator = ; File.pathSeparatorChar = ;
File fileUnsafe = new File("tmp/abc.txt"); File fileSafe = new File("tmp"+File.separator+"abc.txt");
import java.util.Base64; byte[] bytes = "Hello, World!".getBytes("UTF-8"); String encoded = Base64.getEncoder().encodeToString(bytes); byte[] decoded = Base64.getDecoder().decode(encoded);
import org.apache.commons.codec.binary.Base64; import org.apache.commons.codec.binary.StringUtils; public String decode(String s) { return StringUtils.newStringUtf8(Base64.decodeBase64(s)); } public String encode(String s) { return Base64.encodeBase64String(StringUtils.getBytesUtf8(s)); }
BASE64Decoder decoder = new BASE64Decoder(); byte[] decodedBytes = decoder.decodeBuffer(encodedBytes);
public class MyBase64 { private final static char[] ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray(); private static int[] toInt = new int[128]; static { for(int i=0; i< ALPHABET.length; i++){ toInt[ALPHABET[i]]= i; } } /** * Translates the specified byte array into Base64 string. * * @param buf the byte array (not null) * @return the translated Base64 string (not null) */ public static String encode(byte[] buf){ int size = buf.length; char[] ar = new char[((size + 2) / 3) * 4]; int a = 0; int i=0; while(i < size){ byte b0 = buf[i++]; byte b1 = (i < size) ? buf[i++] : 0; byte b2 = (i < size) ? buf[i++] : 0; int mask = 0x3F; ar[a++] = ALPHABET[(b0 >> 2) & mask]; ar[a++] = ALPHABET[((b0 << 4) | ((b1 & 0xFF) >> 4)) & mask]; ar[a++] = ALPHABET[((b1 << 2) | ((b2 & 0xFF) >> 6)) & mask]; ar[a++] = ALPHABET[b2 & mask]; } switch(size % 3){ case 1: ar[--a] = case 2: ar[--a] = } return new String(ar); } /** * Translates the specified Base64 string into a byte array. * * @param s the Base64 string (not null) * @return the byte array (not null) */ public static byte[] decode(String s){ int delta = s.endsWith( "==" ) ? 2 : s.endsWith( "=" ) ? 1 : 0; byte[] buffer = new byte[s.length()*3/4 - delta]; int mask = 0xFF; int index = 0; for(int i=0; i< s.length(); i+=4){ int c0 = toInt[s.charAt( i )]; int c1 = toInt[s.charAt( i + 1)]; buffer[index++]= (byte)(((c0 << 2) | (c1 >> 4)) & mask); if(index >= buffer.length){ return buffer; } int c2 = toInt[s.charAt( i + 2)]; buffer[index++]= (byte)(((c1 << 4) | (c2 >> 2)) & mask); if(index >= buffer.length){ return buffer; } int c3 = toInt[s.charAt( i + 3 )]; buffer[index++]= (byte)(((c2 << 6) | c3) & mask); } return buffer; } }
public class Base64Coder { private static final String systemLineSeparator = System.getProperty("line.separator"); private static final char[] map1 = new char[64]; static { int i=0; for (char c= for (char c= for (char c= map1[i++] = private static final byte[] map2 = new byte[128]; static { for (int i=0; i<map2.length; i++) map2[i] = -1; for (int i=0; i<64; i++) map2[map1[i]] = (byte)i; } /** * Encodes a string into Base64 format. * No blanks or line breaks are inserted. * @param s A String to be encoded. * @return A String containing the Base64 encoded data. */ public static String encodeString (String s) { return new String(encode(s.getBytes())); } /** * Encodes a byte array into Base 64 format and breaks the output into lines of 76 characters. * This method is compatible with <code>sun.misc.BASE64Encoder.encodeBuffer(byte[])</code>. * @param in An array containing the data bytes to be encoded. * @return A String containing the Base64 encoded data, broken into lines. */ public static String encodeLines (byte[] in) { return encodeLines(in, 0, in.length, 76, systemLineSeparator); } /** * Encodes a byte array into Base 64 format and breaks the output into lines. * @param in An array containing the data bytes to be encoded. * @param iOff Offset of the first byte in <code>in</code> to be processed. * @param iLen Number of bytes to be processed in <code>in</code>, starting at <code>iOff</code>. * @param lineLen Line length for the output data. Should be a multiple of 4. * @param lineSeparator The line separator to be used to separate the output lines. * @return A String containing the Base64 encoded data, broken into lines. */ public static String encodeLines (byte[] in, int iOff, int iLen, int lineLen, String lineSeparator) { int blockLen = (lineLen*3) / 4; if (blockLen <= 0) throw new IllegalArgumentException(); int lines = (iLen+blockLen-1) / blockLen; int bufLen = ((iLen+2)/3)*4 + lines*lineSeparator.length(); StringBuilder buf = new StringBuilder(bufLen); int ip = 0; while (ip < iLen) { int l = Math.min(iLen-ip, blockLen); buf.append (encode(in, iOff+ip, l)); buf.append (lineSeparator); ip += l; } return buf.toString(); } /** * Encodes a byte array into Base64 format. * No blanks or line breaks are inserted in the output. * @param in An array containing the data bytes to be encoded. * @return A character array containing the Base64 encoded data. */ public static char[] encode (byte[] in) { return encode(in, 0, in.length); } /** * Encodes a byte array into Base64 format. * No blanks or line breaks are inserted in the output. * @param in An array containing the data bytes to be encoded. * @param iLen Number of bytes to process in <code>in</code>. * @return A character array containing the Base64 encoded data. */ public static char[] encode (byte[] in, int iLen) { return encode(in, 0, iLen); } /** * Encodes a byte array into Base64 format. * No blanks or line breaks are inserted in the output. * @param in An array containing the data bytes to be encoded. * @param iOff Offset of the first byte in <code>in</code> to be processed. * @param iLen Number of bytes to process in <code>in</code>, starting at <code>iOff</code>. * @return A character array containing the Base64 encoded data. */ public static char[] encode (byte[] in, int iOff, int iLen) { int oDataLen = (iLen*4+2)/3; int oLen = ((iLen+2)/3)*4; char[] out = new char[oLen]; int ip = iOff; int iEnd = iOff + iLen; int op = 0; while (ip < iEnd) { int i0 = in[ip++] & 0xff; int i1 = ip < iEnd ? in[ip++] & 0xff : 0; int i2 = ip < iEnd ? in[ip++] & 0xff : 0; int o0 = i0 >>> 2; int o1 = ((i0 & 3) << 4) | (i1 >>> 4); int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6); int o3 = i2 & 0x3F; out[op++] = map1[o0]; out[op++] = map1[o1]; out[op] = op < oDataLen ? map1[o2] : out[op] = op < oDataLen ? map1[o3] : return out; } /** * Decodes a string from Base64 format. * No blanks or line breaks are allowed within the Base64 encoded input data. * @param s A Base64 String to be decoded. * @return A String containing the decoded data. * @throws IllegalArgumentException If the input is not valid Base64 encoded data. */ public static String decodeString (String s) { return new String(decode(s)); } /** * Decodes a byte array from Base64 format and ignores line separators, tabs and blanks. * CR, LF, Tab and Space characters are ignored in the input data. * This method is compatible with <code>sun.misc.BASE64Decoder.decodeBuffer(String)</code>. * @param s A Base64 String to be decoded. * @return An array containing the decoded data bytes. * @throws IllegalArgumentException If the input is not valid Base64 encoded data. */ public static byte[] decodeLines (String s) { char[] buf = new char[s.length()]; int p = 0; for (int ip = 0; ip < s.length(); ip++) { char c = s.charAt(ip); if (c != buf[p++] = c; } return decode(buf, 0, p); } /** * Decodes a byte array from Base64 format. * No blanks or line breaks are allowed within the Base64 encoded input data. * @param s A Base64 String to be decoded. * @return An array containing the decoded data bytes. * @throws IllegalArgumentException If the input is not valid Base64 encoded data. */ public static byte[] decode (String s) { return decode(s.toCharArray()); } /** * Decodes a byte array from Base64 format. * No blanks or line breaks are allowed within the Base64 encoded input data. * @param in A character array containing the Base64 encoded data. * @return An array containing the decoded data bytes. * @throws IllegalArgumentException If the input is not valid Base64 encoded data. */ public static byte[] decode (char[] in) { return decode(in, 0, in.length); } /** * Decodes a byte array from Base64 format. * No blanks or line breaks are allowed within the Base64 encoded input data. * @param in A character array containing the Base64 encoded data. * @param iOff Offset of the first character in <code>in</code> to be processed. * @param iLen Number of characters to process in <code>in</code>, starting at <code>iOff</code>. * @return An array containing the decoded data bytes. * @throws IllegalArgumentException If the input is not valid Base64 encoded data. */ public static byte[] decode (char[] in, int iOff, int iLen) { if (iLen%4 != 0) throw new IllegalArgumentException ("Length of Base64 encoded input string is not a multiple of 4."); while (iLen > 0 && in[iOff+iLen-1] == int oLen = (iLen*3) / 4; byte[] out = new byte[oLen]; int ip = iOff; int iEnd = iOff + iLen; int op = 0; while (ip < iEnd) { int i0 = in[ip++]; int i1 = in[ip++]; int i2 = ip < iEnd ? in[ip++] : int i3 = ip < iEnd ? in[ip++] : if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127) throw new IllegalArgumentException ("Illegal character in Base64 encoded data."); int b0 = map2[i0]; int b1 = map2[i1]; int b2 = map2[i2]; int b3 = map2[i3]; if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0) throw new IllegalArgumentException ("Illegal character in Base64 encoded data."); int o0 = ( b0 <<2) | (b1>>>4); int o1 = ((b1 & 0xf)<<4) | (b2>>>2); int o2 = ((b2 & 3)<<6) | b3; out[op++] = (byte)o0; if (op<oLen) out[op++] = (byte)o1; if (op<oLen) out[op++] = (byte)o2; } return out; } private Base64Coder() {} }
public static byte[] encode(byte[] b) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(); OutputStream b64os = MimeUtility.encode(baos, "base64"); b64os.write(b); b64os.close(); return baos.toByteArray(); } public static byte[] decode(byte[] b) throws Exception { ByteArrayInputStream bais = new ByteArrayInputStream(b); InputStream b64is = MimeUtility.decode(bais, "base64"); byte[] tmp = new byte[b.length]; int n = b64is.read(tmp); byte[] res = new byte[n]; System.arraycopy(tmp, 0, res, 0, n); return res; }
import org.eclipse.jetty.util.B64Code; final String decoded = B64Code.decode(encoded, "UTF-8");
library | encode | decode ------------------+--------------+-------------
@Test public void EncodeDecode() { String hello = "Hello World"; byte[] helloBytes = hello.getBytes(StandardCharsets.UTF_8); String encodedHello = DatatypeConverter.printBase64Binary(helloBytes); LOGGER.info(hello + " encoded=> " + encodedHello); byte[] encodedHelloBytes = DatatypeConverter.parseBase64Binary(encodedHello); String helloAgain = new String(encodedHelloBytes, StandardCharsets.UTF_8) ; LOGGER.info(encodedHello + " decoded=> " + helloAgain); Assert.assertEquals(hello, helloAgain); }
INFO - Hello World encoded=> SGVsbG8gV29ybGQ= INFO - SGVsbG8gV29ybGQ= decoded=> Hello World
public class Base64Test { public static void main(String[] args) { String encodeToString = Base64.encodeToString("JavaTips.net".getBytes(), true); System.out.println("encodeToString " + encodeToString); byte[] decodedBytes = Base64.decode(encodeToString.getBytes()); System.out.println("decodedBytes " + new String(decodedBytes)); } }
import com.sun.org.apache.xml.internal.security.utils.Base64; String str="Hello World"; String base64_str=Base64.encode(str.getBytes("UTF-8"));
String str="Hello World"; String base64_str=""; try {base64_str=(String)Class.forName("java.util.prefs.Base64").getDeclaredMethod("byteArrayToBase64", new Class[]{byte[].class}).invoke(null, new Object[]{str.getBytes("UTF-8")}); } catch (Exception ee) {}
String currentString = "Hello World"; String base64String = java.util.prefs.Base64.byteArrayToBase64(currentString.getBytes("UTF-8"));
Base64 base64 = new Base64(); String encodedFile="JVBERi0xLjUKJeLjz9MKMSAwIG9iago8PCAKICAgL1R5cGUgL0NhdGFsb2cKICAgL1BhZ2VzIDIgMCBSCiAgIC9QYWdlTGF5b3V0IC9TaW5"; byte[] dd=encodedFile.getBytes(); byte[] bytes = Base64.decodeBase64(dd); response.setHeader("Content-disposition", "attachment; filename=\""+filename+"\""); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Expires", "-1"); response.getOutputStream().write(bytes);
byte[] decodedKey = Base64.decode(encodedPublicKey, Base64.DEFAULT);
import java.io.UnsupportedEncodingException; /** * Utilities for encoding and decoding the Base64 representation of * binary data. See RFCs <a * href="http: * href="http: */ public class Base64 { public static final int DEFAULT = 0; public static final int NO_PADDING = 1; public static final int NO_WRAP = 2; public static final int CRLF = 4; public static final int URL_SAFE = 8; public static final int NO_CLOSE = 16; static abstract class Coder { public byte[] output; public int op; public abstract boolean process(byte[] input, int offset, int len, boolean finish); public abstract int maxOutputSize(int len); } public static byte[] decode(String str, int flags) { return decode(str.getBytes(), flags); } public static byte[] decode(byte[] input, int flags) { return decode(input, 0, input.length, flags); } public static byte[] decode(byte[] input, int offset, int len, int flags) { Decoder decoder = new Decoder(flags, new byte[len*3/4]); if (!decoder.process(input, offset, len, true)) { throw new IllegalArgumentException("bad base-64"); } if (decoder.op == decoder.output.length) { return decoder.output; } byte[] temp = new byte[decoder.op]; System.arraycopy(decoder.output, 0, temp, 0, decoder.op); return temp; } static class Decoder extends Coder { private static final int DECODE[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, }; /** * Decode lookup table for the "web safe" variant (RFC 3548 * sec. 4) where - and _ replace + and /. */ private static final int DECODE_WEBSAFE[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, }; /** Non-data values in the DECODE arrays. */ private static final int SKIP = -1; private static final int EQUALS = -2; private int state; private int value; final private int[] alphabet; public Decoder(int flags, byte[] output) { this.output = output; alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE; state = 0; value = 0; } public int maxOutputSize(int len) { return len * 3/4 + 10; } /** * Decode another block of input data. * * @return true if the state machine is still healthy. false if * bad base-64 data has been detected in the input stream. */ public boolean process(byte[] input, int offset, int len, boolean finish) { if (this.state == 6) return false; int p = offset; len += offset; int state = this.state; int value = this.value; int op = 0; final byte[] output = this.output; final int[] alphabet = this.alphabet; while (p < len) { if (state == 0) { while (p+4 <= len && (value = ((alphabet[input[p] & 0xff] << 18) | (alphabet[input[p+1] & 0xff] << 12) | (alphabet[input[p+2] & 0xff] << 6) | (alphabet[input[p+3] & 0xff]))) >= 0) { output[op+2] = (byte) value; output[op+1] = (byte) (value >> 8); output[op] = (byte) (value >> 16); op += 3; p += 4; } if (p >= len) break; } int d = alphabet[input[p++] & 0xff]; switch (state) { case 0: if (d >= 0) { value = d; ++state; } else if (d != SKIP) { this.state = 6; return false; } break; case 1: if (d >= 0) { value = (value << 6) | d; ++state; } else if (d != SKIP) { this.state = 6; return false; } break; case 2: if (d >= 0) { value = (value << 6) | d; ++state; } else if (d == EQUALS) { output[op++] = (byte) (value >> 4); state = 4; } else if (d != SKIP) { this.state = 6; return false; } break; case 3: if (d >= 0) { value = (value << 6) | d; output[op+2] = (byte) value; output[op+1] = (byte) (value >> 8); output[op] = (byte) (value >> 16); op += 3; state = 0; } else if (d == EQUALS) { output[op+1] = (byte) (value >> 2); output[op] = (byte) (value >> 10); op += 2; state = 5; } else if (d != SKIP) { this.state = 6; return false; } break; case 4: if (d == EQUALS) { ++state; } else if (d != SKIP) { this.state = 6; return false; } break; case 5: if (d != SKIP) { this.state = 6; return false; } break; } } if (!finish) { this.state = state; this.value = value; this.op = op; return true; } switch (state) { case 0: break; case 1: this.state = 6; return false; case 2: output[op++] = (byte) (value >> 4); break; case 3: output[op++] = (byte) (value >> 10); output[op++] = (byte) (value >> 2); break; case 4: this.state = 6; return false; case 5: break; } this.state = state; this.op = op; return true; } } public static String encodeToString(byte[] input, int flags) { try { return new String(encode(input, flags), "US-ASCII"); } catch (UnsupportedEncodingException e) { throw new AssertionError(e); } } public static String encodeToString(byte[] input, int offset, int len, int flags) { try { return new String(encode(input, offset, len, flags), "US-ASCII"); } catch (UnsupportedEncodingException e) { throw new AssertionError(e); } } public static byte[] encode(byte[] input, int flags) { return encode(input, 0, input.length, flags); } public static byte[] encode(byte[] input, int offset, int len, int flags) { Encoder encoder = new Encoder(flags, null); int output_len = len / 3 * 4; if (encoder.do_padding) { if (len % 3 > 0) { output_len += 4; } } else { switch (len % 3) { case 0: break; case 1: output_len += 2; break; case 2: output_len += 3; break; } } if (encoder.do_newline && len > 0) { output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) * (encoder.do_cr ? 2 : 1); } encoder.output = new byte[output_len]; encoder.process(input, offset, len, true); assert encoder.op == output_len; return encoder.output; } static class Encoder extends Coder { /** * Emit a new line every this many output tuples. Corresponds to * a 76-character line length (the maximum allowable according to * <a href="http: */ public static final int LINE_GROUPS = 19; /** * Lookup table for turning Base64 alphabet positions (6 bits) * into output bytes. */ private static final byte ENCODE[] = { }; /** * Lookup table for turning Base64 alphabet positions (6 bits) * into output bytes. */ private static final byte ENCODE_WEBSAFE[] = { }; final private byte[] tail; int tailLen; private int count; final public boolean do_padding; final public boolean do_newline; final public boolean do_cr; final private byte[] alphabet; public Encoder(int flags, byte[] output) { this.output = output; do_padding = (flags & NO_PADDING) == 0; do_newline = (flags & NO_WRAP) == 0; do_cr = (flags & CRLF) != 0; alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE; tail = new byte[2]; tailLen = 0; count = do_newline ? LINE_GROUPS : -1; } /** * @return an overestimate for the number of bytes {@code * len} bytes could encode to. */ public int maxOutputSize(int len) { return len * 8/5 + 10; } public boolean process(byte[] input, int offset, int len, boolean finish) { final byte[] alphabet = this.alphabet; final byte[] output = this.output; int op = 0; int count = this.count; int p = offset; len += offset; int v = -1; switch (tailLen) { case 0: break; case 1: if (p+2 <= len) { v = ((tail[0] & 0xff) << 16) | ((input[p++] & 0xff) << 8) | (input[p++] & 0xff); tailLen = 0; }; break; case 2: if (p+1 <= len) { v = ((tail[0] & 0xff) << 16) | ((tail[1] & 0xff) << 8) | (input[p++] & 0xff); tailLen = 0; } break; } if (v != -1) { output[op++] = alphabet[(v >> 18) & 0x3f]; output[op++] = alphabet[(v >> 12) & 0x3f]; output[op++] = alphabet[(v >> 6) & 0x3f]; output[op++] = alphabet[v & 0x3f]; if (--count == 0) { if (do_cr) output[op++] = output[op++] = count = LINE_GROUPS; } } while (p+3 <= len) { v = ((input[p] & 0xff) << 16) | ((input[p+1] & 0xff) << 8) | (input[p+2] & 0xff); output[op] = alphabet[(v >> 18) & 0x3f]; output[op+1] = alphabet[(v >> 12) & 0x3f]; output[op+2] = alphabet[(v >> 6) & 0x3f]; output[op+3] = alphabet[v & 0x3f]; p += 3; op += 4; if (--count == 0) { if (do_cr) output[op++] = output[op++] = count = LINE_GROUPS; } } if (finish) { if (p-tailLen == len-1) { int t = 0; v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4; tailLen -= t; output[op++] = alphabet[(v >> 6) & 0x3f]; output[op++] = alphabet[v & 0x3f]; if (do_padding) { output[op++] = output[op++] = } if (do_newline) { if (do_cr) output[op++] = output[op++] = } } else if (p-tailLen == len-2) { int t = 0; v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) | (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2); tailLen -= t; output[op++] = alphabet[(v >> 12) & 0x3f]; output[op++] = alphabet[(v >> 6) & 0x3f]; output[op++] = alphabet[v & 0x3f]; if (do_padding) { output[op++] = } if (do_newline) { if (do_cr) output[op++] = output[op++] = } } else if (do_newline && op > 0 && count != LINE_GROUPS) { if (do_cr) output[op++] = output[op++] = } assert tailLen == 0; assert p == len; } else { if (p == len-1) { tail[tailLen++] = input[p]; } else if (p == len-2) { tail[tailLen++] = input[p]; tail[tailLen++] = input[p+1]; } } this.op = op; this.count = count; return true; } } private Base64() { } }
private static final Method JAVA_UTIL_BASE64_GETENCODER; static { Method getEncoderMethod; try { final Class<?> base64Class = Class.forName("java.util.Base64"); getEncoderMethod = base64Class.getMethod("getEncoder"); } catch (ClassNotFoundException | NoSuchMethodException e) { getEncoderMethod = null; } JAVA_UTIL_BASE64_GETENCODER = getEncoderMethod; } static String base64EncodeToString(String s) { final byte[] bytes = s.getBytes(StandardCharsets.ISO_8859_1); if (JAVA_UTIL_BASE64_GETENCODER == null) { return DatatypeConverter.printBase64Binary(bytes); } else { try { final Object encoder = JAVA_UTIL_BASE64_GETENCODER.invoke(null); final Class<?> encoderClass = encoder.getClass(); final Method encodeMethod = encoderClass.getMethod("encode", byte[].class); final byte[] encodedBytes = (byte[]) encodeMethod.invoke(encoder, bytes); return new String(encodedBytes); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { throw new IllegalStateException(e); } } }
/** Counts number of foobangs. * @param type Type of foobangs to count. Can be 1=green foobangs, * 2=wrinkled foobangs, 3=sweet foobangs, 0=all types. * @return number of foobangs of type */ public int countFoobangs(int type)
/** Types of foobangs. */ public enum FB_TYPE { GREEN, WRINKLED, SWEET, /** special type for all types combined */ ALL; } /** Counts number of foobangs. * @param type Type of foobangs to count * @return number of foobangs of type */ public int countFoobangs(FB_TYPE type)
int sweetFoobangCount = countFoobangs(FB_TYPE.SWEET);
public class Color { private Color() {} public static final Color RED = new Color(); public static final Color AMBER = new Color(); public static final Color GREEN = new Color(); }
Color color = ... ; switch (color) { case RED: ... break; }
public Class Color { public static final int RED = 0; public static final int AMBER = 1; public static final int GREEN = 2; }
public class Color { public static final int RED_TAG = 1; public static final int AMBER_TAG = 2; public static final int GREEN_TAG = 3; public final int tag; private Color(int tag) { this.tag = tag; } public static final Color RED = new Color(RED_TAG); public static final Color AMBER = new Color(AMBER_TAG); public static final Color GREEN = new Color(GREEN_TAG); }
Color color = ... ; switch (color.tag) { case Color.RED_TAG: ... break; }
public class SingletonClass { public static final void INSTANCE = new SingletonClass(); private SingletonClass() {} }
public class SingletonClass { private static SingletonClass INSTANCE; private SingletonClass() {} public SingletonClass getInstance() { if (INSTANCE == null) INSTANCE = new SingletonClass(); return INSTANCE; } }
enum StringComparator implements Comparator<String> { NATURAL { @Override public int compare(String s1, String s2) { return s1.compareTo(s2); } }, REVERSE { @Override public int compare(String s1, String s2) { return NATURAL.compare(s2, s1); } }, LENGTH { @Override public int compare(String s1, String s2) { return new Integer(s1.length()).compareTo(s2.length()); } }; }
public enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }
class Weekday extends Enum { public static final Weekday MONDAY = new Weekday( "MONDAY", 0 ); public static final Weekday TUESDAY = new Weekday( "TUESDAY ", 1 ); public static final Weekday WEDNESDAY= new Weekday( "WEDNESDAY", 2 ); public static final Weekday THURSDAY= new Weekday( "THURSDAY", 3 ); public static final Weekday FRIDAY= new Weekday( "FRIDAY", 4 ); public static final Weekday SATURDAY= new Weekday( "SATURDAY", 5 ); public static final Weekday SUNDAY= new Weekday( "SUNDAY", 6 ); private Weekday( String s, int i ) { super( s, i ); } }
public class EnumExample { interface SeasonInt { String seasonDuration(); } private enum Season implements SeasonInt { WINTER(88, "DEC - FEB"), SPRING(92, "MAR - JUN"), SUMMER(91, "JUN - AUG"), FALL(90, "SEP - NOV"); private int days; private String months; Season(int days, String months) { this.days = days; this.months = months; } @Override public String seasonDuration() { return this+" -> "+this.days + "days, " + this.months+" months"; } } public static void main(String[] args) { System.out.println(Season.SPRING.seasonDuration()); for (Season season : Season.values()){ System.out.println(season.seasonDuration()); } } }
enum ProtocolType { TCP_IP (1, "Transmission Control Protocol"), IP (2, "Internet Protocol"), UDP (3, "User Datagram Protocol"); public int code; public String name; private ProtocolType(int code, String name) { this.code = code; this.name = name; } public static ProtocolType fromInt(int code) { switch(code) { case 1: return TCP_IP; case 2: return IP; case 3: return UDP; } return null; } }
public enum State { Start("1"), Wait("1"), Notify("2"), NotifyAll("3"), Run("4"), SystemInatilize("5"), VendorInatilize("6"), test, FrameworkInatilize("7"); public static State getState(String value) { return State.Wait; } private String value; State test; private State(String value) { this.value = value; } private State() { } public String getValue() { return value; } public void setCurrentState(State currentState) { test = currentState; } public boolean isNotify() { return this.equals(Notify); } } public class EnumTest { State test; public void setCurrentState(State currentState) { test = currentState; } public State getCurrentState() { return test; } public static void main(String[] args) { System.out.println(State.test); System.out.println(State.FrameworkInatilize); EnumTest test=new EnumTest(); test.setCurrentState(State.Notify); test. stateSwitch(); } public void stateSwitch() { switch (getCurrentState()) { case Notify: System.out.println("Notify"); System.out.println(test.isNotify()); break; default: break; } } }
public enum operation { create("1") delete("2") edit("3") read("4") public boolean isCreate() { return this.equals(create); } }
private operation currentOperation; currentOperation = operation.create
enum RGB { RED("Red"), GREEN("Green"), BLUE("Blue"); public static final String PREFIX = "color "; public String getRGBString() { return PREFIX + color; } String color; RGB(String color) { this.color = color; } } public class HelloWorld { public static void main(String[] args) { String c = RGB.RED.getRGBString(); System.out.print("Hello " + c); } }
public enum Items { MESSAGES, CHATS, CITY_ONLINE, FRIENDS, PROFILE, SETTINGS, PEOPLE_SEARCH, CREATE_CHAT } @Override public boolean onCreateOptionsMenu(Menu menuPrm) { getMenuInflater().inflate(R.menu.main, menuPrm); View itemChooserLcl; for (int i = 0; i < menuPrm.size(); i++) { MenuItem itemLcl = menuPrm.getItem(i); itemChooserLcl = itemLcl.getActionView(); if (itemChooserLcl != null) { itemChooserLcl.setTag(Items.values()[i]); itemChooserLcl.setOnClickListener(drawerMenuListener); } } return true; } private View.OnClickListener drawerMenuListener=new View.OnClickListener() { @Override public void onClick(View v) { Items tagLcl= (Items) v.getTag(); switch (tagLcl){ case MESSAGES: ; break; case CHATS : ; break; case CITY_ONLINE : ; break; case FRIENDS : ; break; case PROFILE: ; break; case SETTINGS: ; break; case PEOPLE_SEARCH: ; break; case CREATE_CHAT: ; break; } } };
public enum Mapping { ONE("1"), TWO("2"); private String label; private Mapping(String label){ this.label = label; } public static Mapping by(String label) { for(Mapping m: values() { if(m.label.equals(label)) return m; } return null; } }
Set<String> mySet = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
Set<String> myConcurrentSet = ConcurrentHashMap.newKeySet();
Set s = Collections.synchronizedSet(new HashSet(...));
import java.util.AbstractSet; import java.util.Iterator; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; public class ConcurrentHashSet<E> extends AbstractSet<E> implements Set<E>{ private final ConcurrentMap<E, Object> theMap; private static final Object dummy = new Object(); public ConcurrentHashSet(){ theMap = new ConcurrentHashMap<E, Object>(); } @Override public int size() { return theMap.size(); } @Override public Iterator<E> iterator(){ return theMap.keySet().iterator(); } @Override public boolean isEmpty(){ return theMap.isEmpty(); } @Override public boolean add(final E o){ return theMap.put(o, ConcurrentHashSet.dummy) == null; } @Override public boolean contains(final Object o){ return theMap.containsKey(o); } @Override public void clear(){ theMap.clear(); } @Override public boolean remove(final Object o){ return theMap.remove(o) == ConcurrentHashSet.dummy; } public boolean addIfAbsent(final E o){ Object obj = theMap.putIfAbsent(o, ConcurrentHashSet.dummy); return obj == null; } }
package com.animation; import android.app.Activity; import android.os.Bundle; import android.view.animation.Animation; import android.view.animation.LinearInterpolator; import android.view.animation.RotateAnimation; import android.widget.Button; import android.widget.LinearLayout; public class AnimateScreen extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); LinearLayout ll = new LinearLayout(this); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); layoutParams.setMargins(30, 20, 30, 0); Button bt = new Button(this); bt.setText(String.valueOf(bt.getWidth())); RotateAnimation ra = new RotateAnimation(0,360,bt.getWidth() / 2,bt.getHeight() / 2); ra.setDuration(3000L); ra.setRepeatMode(Animation.RESTART); ra.setRepeatCount(Animation.INFINITE); ra.setInterpolator(new LinearInterpolator()); bt.startAnimation(ra); ll.addView(bt,layoutParams); setContentView(ll); }
view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { view.getViewTreeObserver().removeOnGlobalLayoutListener(this); view.getHeight(); } });
final View view= ... view.post(new Runnable() { @Override public void run() { view.getHeight(); } });
view = new View(this) { @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { super.onLayout(changed, l, t, r, b); view.getHeight(); } };
View viewYouNeedHeightFrom = ... ... if(ViewCompat.isLaidOut(viewYouNeedHeightFrom)) { viewYouNeedHeightFrom.getHeight(); }
@Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); }
yourView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { yourView.getViewTreeObserver().removeGlobalOnLayoutListener(this); } });
@SuppressLint("NewApi") @SuppressWarnings("deprecation") @Override public void onGlobalLayout() { if(android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN) { yourView.getViewTreeObserver().removeOnGlobalLayoutListener(this); } else { yourView.getViewTreeObserver().removeGlobalOnLayoutListener(this); } }
myImage.measure(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT); int width = myImage.getMeasuredWidth(); int height = myImage.getMeasuredHeight();
view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() { @Override public boolean onPreDraw() { if (view.getViewTreeObserver().isAlive()) view.getViewTreeObserver().removeOnPreDrawListener(this); return false; } });
view.height { Log.i("Info", "Here is your height:" + it) }
fun <T : View> T.height(function: (Int) -> Unit) { if (height == 0) viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener { override fun onGlobalLayout() { viewTreeObserver.removeOnGlobalLayoutListener(this) function(height) } }) else function(height) }
RxView.layoutChanges(yourView).take(1) .subscribe(aVoid -> { });
fun View.postWithTreeObserver(postJob: (View, Int, Int) -> Unit) { viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener { override fun onGlobalLayout() { val widthSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED) val heightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED) measure(widthSpec, heightSpec) postJob(this@postWithTreeObserver, measuredWidth, measuredHeight) if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) { @Suppress("DEPRECATION") viewTreeObserver.removeGlobalOnLayoutListener(this) } else { viewTreeObserver.removeOnGlobalLayoutListener(this) } } }) }
import java.util.ArrayList; import java.util.List; class Test { private final List foo; public Test() { foo = new ArrayList(); foo.add("foo"); } public static void main(String[] args) { Test t = new Test(); t.foo.add("bar"); System.out.println("print - " + t.foo); } }
import java.util.ArrayList; import java.util.List; class Test { private final List foo; public Test() { foo = new ArrayList(); foo.add("foo"); } public void setFoo(List foo) { } }
private static final List foo; static { foo = new ArrayList(); }
public class ClassDemo { private final int var1 = 3; public ClassDemo() { ... } }
class Bike9{ final int speedlimit=90; void run(){ speedlimit=400; } public static void main(String args[]){ Bike9 obj=new Bike9(); obj.run(); } }
final class Bike{} class Honda1 extends Bike{ void run(){ System.out.println("running safely with 100kmph"); } public static void main(String args[]){ Honda1 honda= new Honda(); honda.run(); } }
class Bike{ final void run(){System.out.println("running");} } class Honda extends Bike{ void run(){System.out.println("running safely with 100kmph");} public static void main(String args[]){ Honda honda= new Honda(); honda.run(); } }
private static final List foo; static { foo = new ArrayList(); } public Test() { foo.add("foo"); }
public void showCaseFinalArgumentVariable(final int someFinalInt){ someFinalInt = 9; }
final FinalClass fc = someFC; final FinalClass fc; final FinalClass fc = new FinalClass(); fc = someOtherFC; fc.someMethod(); someOtherFC.someMethod();
void someMethod(final String s){ s = someOtherString; }
class Main { public static void main(String args[]){ final int i = 20; i = 30; } }
final class Base { } class Derived extends Base { } public class Main { public static void main(String args[]) { } }
class Base { public final void show() { System.out.println("Base::show() called"); } } class Derived extends Base { public void show() { System.out.println("Derived::show() called"); } } public class Main { public static void main(String[] args) { Base b = new Derived();; b.show(); } }
Webster --------- ------------ ---- Current Java Fn. 1.2509 1.2738 13.2560 P(37) [Java] 1.2508 1.2481 1.2454 P(65599) [Aho et al] 1.2490 1.2510 1.2450 P(31) [K+R] 1.2500 1.2488 1.2425 P(33) [Torek] 1.2500 1.2500 1.2453 Vo WAIS Fn 1.2497 1.2519 1.2452 Weinberger Weinberger Weinberger
@Entity public class Company { @OneToMany(cascade = CascadeType.ALL , fetch = FetchType.LAZY) @JoinColumn(name = "companyIdRef", referencedColumnName = "companyId") private List<Branch> branches; ... }
@Entity public class Company { @OneToMany(cascade = CascadeType.ALL , fetch = FetchType.LAZY, mappedBy = "companyIdRef") private List<Branch> branches; ... }
@Entity public class Company { @OneToMany(fetch = FetchType.LAZY, mappedBy = "company") private List<Branch> branches; } @Entity public class Branch { @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = "companyId") private Company company; }
@Entity public class Troop { @OneToMany(mappedBy="troop") public Set<Soldier> getSoldiers() { ... } @Entity public class Soldier { @ManyToOne @JoinColumn(name="troop_fk") public Troop getTroop() { ... }
@Entity public class Troop { @OneToMany @JoinColumn(name="troop_fk") public Set<Soldier> getSoldiers() { ... } @Entity public class Soldier { @ManyToOne @JoinColumn(name="troop_fk", insertable=false, updatable=false) public Troop getTroop() { ... }
@Entity public class Company { private int companyId; private String companyName; private List<Branch> branches; @Id @GeneratedValue @Column(name="COMPANY_ID") public int getCompanyId() { return companyId; } public void setCompanyId(int companyId) { this.companyId = companyId; } @Column(name="COMPANY_NAME") public String getCompanyName() { return companyName; } public void setCompanyName(String companyName) { this.companyName = companyName; } @OneToMany(fetch=FetchType.LAZY,cascade=CascadeType.ALL,mappedBy="company") public List<Branch> getBranches() { return branches; } public void setBranches(List<Branch> branches) { this.branches = branches; } }
@Entity public class Branch { private int branchId; private String branchName; private Company company; @Id @GeneratedValue @Column(name="BRANCH_ID") public int getBranchId() { return branchId; } public void setBranchId(int branchId) { this.branchId = branchId; } @Column(name="BRANCH_NAME") public String getBranchName() { return branchName; } public void setBranchName(String branchName) { this.branchName = branchName; } @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="COMPANY_ID") public Company getCompany() { return company; } public void setCompany(Company company) { this.company = company; } }
@Entity public class Driver { @ManyToMany(mappedBy = "drivers") private List<Cars> cars; } @Entity public class Cars { @ManyToMany private List<Drivers> drivers; }
@Entity public class Driver { @ManyToMany(mappedBy = "drivers") private List<Cars> cars; } @Entity public class Cars { @ManyToMany @JoinColumn(name = "driverID") private List<Drivers> drivers; }
HashMap<String, HashMap> selects = new HashMap<String, HashMap>();
for (int i=0; i < selects.size(); i++) { HashMap h = selects[i].getValue(); ComboBox cb = new ComboBox(); for (int y=0; y < h.size(); i++) { cb.items.add(h[y].getValue); } }
HashMap<String, HashMap> selects = new HashMap<String, HashMap>(); for(Map.Entry<String, HashMap> entry : selects.entrySet()) { String key = entry.getKey(); HashMap value = entry.getValue(); }
HashMap<Integer,Integer> hm = new HashMap<Integer, Integer>(); /* * Logic to put the Key,Value pair in your HashMap hm */ hm.forEach((k,v) -> System.out.println("key: "+k+" value:"+v));
HashMap<Integer,Integer> hm = new HashMap<Integer, Integer>(); Random rand = new Random(47); int i=0; while(i<5){ i++; int key = rand.nextInt(20); int value = rand.nextInt(50); System.out.println("Inserting key: "+key+" Value: "+value); Integer imap =hm.put(key,value); if( imap == null){ System.out.println("Inserted"); } else{ System.out.println("Replaced with "+imap); } } hm.forEach((k,v) -> System.out.println("key: "+k+" value:"+v)); Output: Inserting key: 18 Value: 5 Inserted Inserting key: 13 Value: 11 Inserted Inserting key: 1 Value: 29 Inserted Inserting key: 8 Value: 0 Inserted Inserting key: 2 Value: 7 Inserted key: 1 value:29 key: 18 value:5 key: 2 value:7 key: 8 value:0 key: 13 value:11
HashMap<String, HashMap<SomeInnerKeyType, String>> selects = new HashMap<String, HashMap<SomeInnerKeyType, String>>(); ... for(HashMap<SomeInnerKeyType, String> h : selects.values()) { ComboBox cb = new ComboBox(); for(String s : h.values()) { cb.items.add(s); } }
HashMap<T,U> map = new HashMap<T,U>(); ... Iterator it = map.values().iterator(); while (it.hasNext()) { System.out.println(it.next()); }
HashMap<String, HashMap> selects = new HashMap<String, HashMap>(); for (String key : selects.keySet()) { HashMap<innerKey, String> boxHolder = selects.get(key); ComboBox cb = new ComboBox(); for (InnerKey innerKey : boxHolder.keySet()) { cb.items.add(boxHolder.get(innerKey)); } }
sample.forEach((k,v) -> System.out.println(k + "=" + v)); sample.entrySet().stream().forEachOrdered((entry) -> { Object currentKey = entry.getKey(); Object currentValue = entry.getValue(); System.out.println(currentKey + "=" + currentValue); }); sample.entrySet().parallelStream().forEach((entry) -> { Object currentKey = entry.getKey(); Object currentValue = entry.getValue(); System.out.println(currentKey + "=" + currentValue); });
/** *Output: D: 99.22 A: 3434.34 C: 1378.0 B: 123.22 E: -19.08 B */ import java.util.HashMap; import java.util.Map; import java.util.Set; public class MainClass { public static void main(String args[]) { HashMap<String, Double> hm = new HashMap<String, Double>(); hm.put("A", new Double(3434.34)); hm.put("B", new Double(123.22)); hm.put("C", new Double(1378.00)); hm.put("D", new Double(99.22)); hm.put("E", new Double(-19.08)); Set<Map.Entry<String, Double>> set = hm.entrySet(); for (Map.Entry<String, Double> me : set) { System.out.print(me.getKey() + ": "); System.out.println(me.getValue()); } System.out.println(); double balance = hm.get("B"); hm.put("B", balance + 1000); System.out.println("B } }
a instanceof int 3 instanceof Foo int.class.isAssignableFrom(int.class)
package foo; public class Benchmark { public static final Object a = new A(); public static final Object b = new B(); ... }
getstatic foo/Benchmark.b:java.lang.Object instanceof foo/A
ldc Lfoo/A; (org.objectweb.asm.Type) getstatic foo/Benchmark.b:java.lang.Object invokevirtual java/lang/Class isInstance((Ljava/lang/Object;)Z);
ldc Lfoo/A; (org.objectweb.asm.Type) getstatic foo/Benchmark.b:java.lang.Object invokevirtual java/lang/Object getClass(()Ljava/lang/Class;); invokevirtual java/lang/Class isAssignableFrom((Ljava/lang/Class;)Z);
class A {} class B extends A {} public class Benchmark { public static final Object a = new A(); public static final Object b = new B(); @Benchmark @BenchmarkMode(Mode.Throughput) @OutputTimeUnit(TimeUnit.MICROSECONDS) public boolean testInstanceOf() { return b instanceof A; } @Benchmark @BenchmarkMode(Mode.Throughput) @OutputTimeUnit(TimeUnit.MICROSECONDS) public boolean testIsInstance() { return A.class.isInstance(b); } @Benchmark @BenchmarkMode(Mode.Throughput) @OutputTimeUnit(TimeUnit.MICROSECONDS) public boolean testIsAssignableFrom() { return A.class.isAssignableFrom(b.getClass()); } public static void main(String[] args) throws RunnerException { Options opt = new OptionsBuilder() .include(TestPerf2.class.getSimpleName()) .warmupIterations(20) .measurementIterations(2000) .forks(1) .build(); new Runner(opt).run(); } }
Benchmark Mode Cnt Score Error Units Benchmark.testIsInstance thrpt 2000 373,061  0,115 ops/us Benchmark.testInstanceOf thrpt 2000 371,047  0,131 ops/us Benchmark.testIsAssignableFrom thrpt 2000 363,648  0,289 ops/us
class A{} class B extends A{} A b = new B(); boolean execute(){ return A.class.isAssignableFrom(b.getClass()); } for (int i = 0; i < 100; ++i) execute(); int count = 100000; final long start = System.nanoTime(); for(int i=0; i<count; i++){ execute(); } final long elapsed = System.nanoTime() - start;
B b = new C(); System.out.println(b instanceof A); System.out.println(b instanceof B); System.out.println(b instanceof C); System.out.println(b.getClass().isAssignableFrom(A.class)); System.out.println(b.getClass().isAssignableFrom(B.class)); System.out.println(b.getClass().isAssignableFrom(C.class));
boolean test(Class clazz) { return (this instanceof clazz); }
boolean test(Class clazz) { return (clazz.isAssignableFrom(this.getClass())); }
isAssignableFrom(A, B) = if (A == B) return true else if (B == java.lang.Object) return false else return isAssignableFrom(A, getSuperClass(B))
class A{} class B extends A{} public class InstanceOfTest { public static final Object a = new A(); public static final Object b = new B(); @Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public boolean testInstanceOf() { return b instanceof A; } @Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public boolean testIsInstance() { return A.class.isInstance(b); } @Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public boolean testIsAssignableFrom() { return A.class.isAssignableFrom(b.getClass()); } public static void main(String[] args) throws RunnerException { Options opt = new OptionsBuilder() .include(InstanceOfTest.class.getSimpleName()) .warmupIterations(5) .measurementIterations(5) .forks(1) .build(); new Runner(opt).run(); } }
Benchmark Mode Cnt Score Error Units InstanceOfTest.testInstanceOf avgt 5 1,972 ? 0,002 ns/op InstanceOfTest.testIsAssignableFrom avgt 5 1,991 ? 0,004 ns/op InstanceOfTest.testIsInstance avgt 5 1,972 ? 0,003 ns/op
List<String> strings = ... List<Integer> integers = new LinkedList(strings);
List<Integer> integers = new LinkedList<>(strings);
import static com.google.common.collect.Lists.*; ... List<String> names = newArrayList(); List<String> names = newArrayList("one", "two", "three");
Map<String, List> mainMap = new HashMap<String, List>(); for(int i=0; i<something.size(); i++){ Set set = getSet(...); List listOfNames = new ArrayList(set); mainMap.put(differentKeyName,listOfNames); }
List<String> mainList = new ArrayList<String>(); mainList.addAll(set);
List<String> list = set.stream().collect(Collectors.toList());
public static void main(String[] args) { Set<String> set = new TreeSet<>(); set.add("A"); set.add("B"); set.add("C"); List<String> list = set.stream().collect(Collectors.toList()); }
Map<String, List> mainMap = new HashMap<String, List>(); for(int i=0; i<something.size(); i++){ Set set = getSet(...); mainMap.put(differentKeyName, Arrays.asList(set.toArray(new Object[set.size()]))); }
Map<String, Collection> mainMap = new HashMap<String, Collection>(); for(int i=0; i<something.size(); i++){ Set set = getSet(...); mainMap.put(differentKeyName,set); }
public static <U> List<U> convertSetToList(Set<U> set) { return new ArrayList<U>(set); }
public static <U, L extends List<U>> List<U> convertSetToList(Set<U> set, Class<L> clazz) throws InstantiationException, IllegalAccessException { L list = clazz.newInstance(); list.addAll(set); return list; }
List<String> stringList = setString.stream().collect(Collectors.toList());
public static <T> Collector<T, ?, List<T>> toList() { return new CollectorImpl<>((Supplier<List<T>>) ArrayList::new, List::add, (left, right) -> { left.addAll(right); return left; }, CH_ID); }
List<String> stringArrayList = setString.stream() .collect(Collectors.toCollection(ArrayList::new));
ArrayList<T> yourList = Collections.list(Collections.enumeration(yourSet<T>));
ArrayList < String > L1 = new ArrayList < String > (); L1.addAll(ActualMap.keySet()); for (String x: L1) { System.out.println(x.toString()); }
Map<String, List> mainMap = new HashMap<String, List>(); for(int i=0; i<something.size(); i++){ Set set = getSet(...); mainMap.put(differentKeyName, new ArrayList(set)); }
<android.support.design.widget.FloatingActionButton android:id="@+id/profile_edit_fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="end|bottom" android:layout_margin="16dp" android:clickable="true" android:src="@drawable/ic_mode_edit_white_24dp" />
FloatingActionButton fab = (FloatingActionButton) rootView.findViewById(R.id.profile_edit_fab); fab.setBackgroundColor(Color.parseColor("
fab.setBackgroundDrawable(new ColorDrawable(Color.parseColor("
mFab.setBackgroundTintList(ColorStateList.valueOf(your color in int));
<android.support.design.widget.FloatingActionButton android:id="@+id/profile_edit_fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="end|bottom" android:layout_margin="16dp" android:clickable="true" android:src="@drawable/ic_mode_edit_white_24dp" app:backgroundTint="@android:color/white"/>
actionButton.setBackgroundTintList(ColorStateList.valueOf(getResources().getColor(R.color.white)));
<style name="AppTheme" parent="Base.Theme.AppCompat.Light"> <item name="colorAccent">@color/accent</item> </style>
mFab.setBackgroundTintList(ColorStateList.valueOf(ContextCompat.getColor(mContext,R.color.mColor)));
<style name="AppTheme.FloatingAccentButtonOverlay" > <item name="colorAccent">@color/colorFloatingActionBarAccent</item> </style>
<android.support.design.widget.FloatingActionButton android:theme="AppTheme.FloatingAccentButtonOverlay" ... </android.support.design.widget.FloatingActionButton>
xmlns:card_view="http: card_view:backgroundTint="@color/whicheverColorYouLike"
xmlns:app="http: app:backgroundTint="@color/whicheverColorYouLike"
<android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" app:elevation="6dp" app:backgroundTint="@color/colorAccent" app:pressedTranslationZ="12dp" android:layout_margin="@dimen/fab_margin" android:src="@drawable/add"/>
favourite_fab.setImageDrawable(ContextCompat.getDrawable(getBaseContext(), R.drawable.favourite_selected));
android:backgroundTint="@{item.selected ? @color/selected : @color/unselected}"
<?xml version="1.0" encoding="utf-8"?> <resources> <color name="colorPrimary"> <color name="colorPrimaryDark"> <color name="colorAccent"> <color name="corBotaoFoto"> <color name="corPar"> <color name="corImpar"> </resources>
<android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="@dimen/fab_margin" android:src="@android:drawable/ic_input_add" android:tint=" app:backgroundTint="@color/corPar"/>
import android.os.Vibrator; ... Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { v.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE)); } else { v.vibrate(500); }
<uses-permission android:name="android.permission.VIBRATE"/>
<uses-permission android:name="android.permission.VIBRATE"/>
Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); v.vibrate(400);
Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); long[] pattern = {0, 100, 1000}; v.vibrate(pattern, 0);
Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); long[] pattern = {0, 100, 1000, 300, 200, 100, 500, 200, 100}; v.vibrate(pattern, -1);
Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); if (v.hasVibrator()) { Log.v("Can Vibrate", "YES"); } else { Log.v("Can Vibrate", "NO"); }
private void shakeItBaby() { if (Build.VERSION.SDK_INT >= 26) { ((Vibrator) getSystemService(VIBRATOR_SERVICE)).vibrate(VibrationEffect.createOneShot(150, VibrationEffect.DEFAULT_AMPLITUDE)); } else { ((Vibrator) getSystemService(VIBRATOR_SERVICE)).vibrate(150); } }
private fun shakeItBaby(context: Context) { if (Build.VERSION.SDK_INT >= 26) { (context.getSystemService(VIBRATOR_SERVICE) as Vibrator).vibrate(VibrationEffect.createOneShot(150, VibrationEffect.DEFAULT_AMPLITUDE)) } else { (context.getSystemService(VIBRATOR_SERVICE) as Vibrator).vibrate(150) } }
public void vibrate(int duration) { Vibrator vibs = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); vibs.vibrate(duration); }
long[] pattern = {0, 100, 1000, 300}; v.vibrate(pattern, -1);
<uses-permission android:name="android.permission.VIBRATE"/>
private static final long[] THREE_CYCLES = new long[] { 100, 1000, 1000, 1000, 1000, 1000 }; public void longVibrate(View v) { vibrateMulti(THREE_CYCLES); } private void vibrateMulti(long[] cycles) { NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new Notification(); notification.vibrate = cycles; notificationManager.notify(0, notification); }
<button android:layout_height="wrap_content" android:layout_width ="wrap_content" android:onclick ="longVibrate" android:text ="VibrateThrice"> </button>
public static final void vibratePhone(Context context, short vibrateMilliSeconds) { Vibrator vibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE); vibrator.vibrate(vibrateMilliSeconds); }
<uses-permission android:name="android.permission.VIBRATE"/>
import android.os.Vibrator; ... Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { v.vibrate(VibrationEffect.createOneShot(1000,VibrationEffect.DEFAULT_AMPLITUDE)); }else{ v.vibrate(1000); }
<uses-permission android:name="android.permission.VIBRATE"/>
public class Main { public native int square(int i); public static void main(String[] args) { System.loadLibrary("Main"); System.out.println(new Main().square(2)); } }
JNIEXPORT jint JNICALL Java_Main_square( JNIEnv *env, jobject obj, jint i) { return i * i; }
sudo apt-get install build-essential openjdk-7-jdk export JAVA_HOME= javac Main.java javah -jni Main gcc -shared -fpic -o libMain.so -I${JAVA_HOME}/include \ -I${JAVA_HOME}/include/linux Main.c java -Djava.library.path=. Main
protected native Object clone() throws CloneNotSupportedException;
static JNINativeMethod methods[] = { ... {"clone", "()Ljava/lang/Object;", (void *)&JVM_Clone}, }; JNIEXPORT void JNICALL Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls) { (*env)->RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0])); }
JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle)) JVMWrapper("JVM_Clone");
public interface LoginAuth{ public String encryptPassword(String pass); public void checkDBforUser(); }
public class DBMySQL implements LoginAuth{ } public class DBOracle implements LoginAuth{ } public class DBAbc implements LoginAuth{ }
public abstract class LoginAuth{ public String encryptPassword(String pass){ } public abstract void checkDBforUser(); }
public interface SomeInterfaceOne { void usualAbstractMethod(String inputString); default void defaultMethod(String inputString){ System.out.println("Inside SomeInterfaceOne defaultMethod::"+inputString); } }
public interface SomeInterfaceTwo { void usualAbstractMethod(String inputString); default void defaultMethod(String inputString){ System.out.println("Inside SomeInterfaceTwo defaultMethod::"+inputString); } }
public interface Payment { void makePayment(); } public class PayPal implements Payment { public void makePayment() { } } public class CreditCard implements Payment { public void makePayment() { } }
public abstract class Burger { public void packing() { } public abstract void price(); } public class VegBerger extends Burger { public void price() { } } public class NonVegBerger extends Burger { public void price() { } }
public interface OldInterface { public void existingMethod(); default public void newDefaultMethod() { System.out.println("New default method" + " is added in interface"); } }
public class OldInterfaceImpl implements OldInterface { public void existingMethod() { } }
OldInterfaceImpl obj = new OldInterfaceImpl (); obj.newDefaultMethod();
public interface Iterable<T> { public void forEach(Consumer<? super T> consumer); }
public interface Iterable<T> { public default void forEach(Consumer <? super T> consumer) { for (T t : this) { consumer.accept(t); } } }
public interface InterfaceA { default void defaultMethod(){ System.out.println("Interface A default method"); } } public interface InterfaceB { default void defaultMethod(){ System.out.println("Interface B default method"); } } public class Impl implements InterfaceA, InterfaceB { }
public class Impl implements InterfaceA, InterfaceB { public void defaultMethod(){ } }
public class Impl implements InterfaceA, InterfaceB { public void defaultMethod(){ InterfaceA.super.defaultMethod(); } }
public interface MyData { default void print(String str) { if (!isNull(str)) System.out.println("MyData Print::" + str); } static boolean isNull(String str) { System.out.println("Interface Null Check"); return str == null ? true : "".equals(str) ? true : false; } }
public class MyDataImpl implements MyData { public boolean isNull(String str) { System.out.println("Impl Null Check"); return str == null ? true : false; } public static void main(String args[]){ MyDataImpl obj = new MyDataImpl(); obj.print(""); obj.isNull("abc"); } }
import java.time.*; public interface TimeClient { void setTime(int hour, int minute, int second); void setDate(int day, int month, int year); void setDateAndTime(int day, int month, int year, int hour, int minute, int second); LocalDateTime getLocalDateTime(); static ZoneId getZoneId (String zoneString) { try { return ZoneId.of(zoneString); } catch (DateTimeException e) { System.err.println("Invalid time zone: " + zoneString + "; using default time zone instead."); return ZoneId.systemDefault(); } } default ZonedDateTime getZonedDateTime(String zoneString) { return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString)); } }
package adventure; import java.awt.*; public interface Playable { public void playSound(String s); public Image loadPicture(String s); }
public abstract class World... public Playable owner; public Playable getOwner() { return owner; } public void setOwner(Playable owner) { this.owner = owner; }
interface Forgiver { void forgive(); } abstract class GodLike implements Forgiver { abstract void forget(); final void forgive() { forget(); } }
class HumanLike implements Forgiver { void forgive() { } }
class AngelLike extends GodLike { void forget() { } }
public abstract class CTC { public int salary(int hra, int da, int extra) { int total; total = hra+da+extra; return total; } } class Manger extends CTC { } class CEO extends CTC { } class Developer extends CTC { }
public interface EmployeType { public String typeOfEmployee(); } class ContarctOne implements EmployeType { @Override public String typeOfEmployee() { return "contract"; } } class PermanentOne implements EmployeType { @Override public String typeOfEmployee() { return "permanent"; } }
class IWasDesignedPoorly { private Hashtable stuffIWant; } IWasDesignedPoorly obj = ...;
Field f = obj.getClass().getDeclaredField("stuffIWant"); f.setAccessible(true); Hashtable iWantThis = (Hashtable) f.get(obj);
def obj = new IWasDesignedPoorly() def hashTable = obj.getStuffIWant()
public class Reflection1{ private int i = 10; public void methoda() { System.out.println("method1"); } public void methodb() { System.out.println("method2"); } public void methodc() { System.out.println("method3"); } }
import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Reflection2{ public static void main(String ar[]) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { Method[] mthd = Reflection1.class.getMethods(); Field[] fld = Reflection1.class.getDeclaredFields(); for(Method mthd1:mthd) { System.out.println("method :"+mthd1.getName()); System.out.println("parametes :"+mthd1.getReturnType()); } for(Field fld1:fld) { fld1.setAccessible(true); System.out.println("field :"+fld1.getName()); System.out.println("type :"+fld1.getType()); System.out.println("value :"+fld1.getInt(new Reflaction1())); } } }
private static Field getField(Class<?> cls, String fieldName) { for (Class<?> c = cls; c != null; c = c.getSuperclass()) { try { final Field field = c.getDeclaredField(fieldName); field.setAccessible(true); return field; } catch (final NoSuchFieldException e) { } catch (Exception e) { throw new IllegalArgumentException( "Cannot access field " + cls.getName() + "." + fieldName, e); } } throw new IllegalArgumentException( "Cannot find field " + cls.getName() + "." + fieldName); }
org.deeplearning4j.nn.layers.BaseOutputLayer ll = (org.deeplearning4j.nn.layers.BaseOutputLayer) model.getLayer(0); Field f = Class.forName("org.deeplearning4j.nn.layers.BaseOutputLayer").getDeclaredField("solver"); f.setAccessible(true); Solver s = (Solver) f.get(ll);
Hashtable iWantThis = (Hashtable)ReflectionTestUtils.getField(obj, "stuffIWant");
@JailBreak Foo foo = new Foo(); foo.stuffIWant = "123; public class Foo { private String stuffIWant; }
public static void main(String args[]) { int MAX_ITERATION = 10000000; long starttime = System.currentTimeMillis(); for (int i = 0; i < MAX_ITERATION; ++i) { String s = Integer.toString(10); } long endtime = System.currentTimeMillis(); System.out.println("diff1: " + (endtime-starttime)); starttime = System.currentTimeMillis(); for (int i = 0; i < MAX_ITERATION; ++i) { String s1 = new Integer(10).toString(); } endtime = System.currentTimeMillis(); System.out.println("diff2: " + (endtime-starttime)); }
Integer i = new Integer(8); String retval = i.toString(516, 8); System.out.println("Value = " + retval);
int i = 506; String str = new Integer(i).toString(); System.out.println(str + " : " + new Integer(i).toString().getClass());
public static void copyFile(File sourceFile, File destFile) throws IOException { if(!destFile.exists()) { destFile.createNewFile(); } FileChannel source = null; FileChannel destination = null; try { source = new FileInputStream(sourceFile).getChannel(); destination = new FileOutputStream(destFile).getChannel(); destination.transferFrom(source, 0, source.size()); } finally { if(source != null) { source.close(); } if(destination != null) { destination.close(); } } }
public static void copyFile( File from, File to ) throws IOException { if ( !to.exists() ) { to.createNewFile(); } try ( FileChannel in = new FileInputStream( from ).getChannel(); FileChannel out = new FileOutputStream( to ).getChannel() ) { out.transferFrom( in, 0, in.size() ); } }
public static void copyFile( File from, File to ) throws IOException { Files.copy( from.toPath(), to.toPath() ); }
package com.yourcompany.nio; class Files { static int copyRecursive(Path source, Path target, boolean prompt, CopyOptions options...) { CopyVisitor copyVisitor = new CopyVisitor(source, target, options).copy(); EnumSet<FileVisitOption> fileVisitOpts; if (Arrays.toList(options).contains(java.nio.file.LinkOption.NOFOLLOW_LINKS) { fileVisitOpts = EnumSet.noneOf(FileVisitOption.class) } else { fileVisitOpts = EnumSet.of(FileVisitOption.FOLLOW_LINKS); } Files.walkFileTree(source[i], fileVisitOpts, Integer.MAX_VALUE, copyVisitor); } private class CopyVisitor implements FileVisitor<Path> { final Path source; final Path target; final CopyOptions[] options; CopyVisitor(Path source, Path target, CopyOptions options...) { this.source = source; this.target = target; this.options = options; }; @Override FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) { Path newdir = target.resolve(source.relativize(dir)); try { Files.copy(dir, newdir, options); } catch (FileAlreadyExistsException x) { } catch (IOException x) { System.err.format("Unable to create: %s: %s%n", newdir, x); return SKIP_SUBTREE; } return CONTINUE; } @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) { Path newfile= target.resolve(source.relativize(file)); try { Files.copy(file, newfile, options); } catch (IOException x) { System.err.format("Unable to copy: %s: %s%n", source, x); } return CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) { if (exc == null && Arrays.toList(options).contains(COPY_ATTRIBUTES)) { Path newdir = target.resolve(source.relativize(dir)); try { FileTime time = Files.getLastModifiedTime(dir); Files.setLastModifiedTime(newdir, time); } catch (IOException x) { System.err.format("Unable to copy all attributes to: %s: %s%n", newdir, x); } } return CONTINUE; } @Override public FileVisitResult visitFileFailed(Path file, IOException exc) { if (exc instanceof FileSystemLoopException) { System.err.println("cycle detected: " + file); } else { System.err.format("Unable to copy: %s: %s%n", file, exc); } return CONTINUE; } }
long bytes = java.nio.file.Files.copy( new java.io.File("<filepath1>").toPath(), new java.io.File("<filepath2>").toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING, java.nio.file.StandardCopyOption.COPY_ATTRIBUTES, java.nio.file.LinkOption.NOFOLLOW_LINKS);
long bytes = java.nio.file.Files.move( new java.io.File("<filepath1>").toPath(), new java.io.File("<filepath2>").toPath(), java.nio.file.StandardCopyOption.ATOMIC_MOVE, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
long bytes = com.yourcompany.nio.Files.copyRecursive( new java.io.File("<filepath1>").toPath(), new java.io.File("<filepath2>").toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING, java.nio.file.StandardCopyOption.COPY_ATTRIBUTES java.nio.file.LinkOption.NOFOLLOW_LINKS );
File src = new File("original.txt"); File target = new File("copy.txt"); Files.copy(src.toPath(), target.toPath(), StandardCopyOption.REPLACE_EXISTING);
public void copy(File src, File dst) throws IOException { InputStream in = new FileInputStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[1024]; int len; while ((len = in.read(buf)) > 0) { out.write(buf, 0, len); } } finally { out.close(); } } finally { in.close(); } }
private static void copyFileUsingJava7Files(File source, File dest) throws IOException { Files.copy(source.toPath(), dest.toPath()); }
private static void copyFileUsingApacheCommonsIO(File source, File dest) throws IOException { FileUtils.copyFile(source, dest); }
private static void copyFileUsingGuava(File source,File dest) throws IOException{ Files.copy(source,dest); }
public static void copyFile(File src, File dst) throws IOException { long p = 0, dp, size; FileChannel in = null, out = null; try { if (!dst.exists()) dst.createNewFile(); in = new FileInputStream(src).getChannel(); out = new FileOutputStream(dst).getChannel(); size = in.size(); while ((dp = out.transferFrom(in, p, size)) > 0) { p += dp; } } finally { try { if (out != null) out.close(); } finally { if (in != null) in.close(); } } }
import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; import java.text.DecimalFormat; public class test { private static final int BUFFER = 4096*16; static final DecimalFormat df = new DecimalFormat(" public static void nioBufferCopy(final File source, final File target ) { FileChannel in = null; FileChannel out = null; double size=0; long overallT1 = System.currentTimeMillis(); try { in = new FileInputStream(source).getChannel(); out = new FileOutputStream(target).getChannel(); size = in.size(); double size2InKB = size / 1024 ; ByteBuffer buffer = ByteBuffer.allocateDirect(BUFFER); while (in.read(buffer) != -1) { buffer.flip(); while(buffer.hasRemaining()){ out.write(buffer); } buffer.clear(); } long overallT2 = System.currentTimeMillis(); System.out.println(String.format("Copied %s KB in %s millisecs", df.format(size2InKB), (overallT2 - overallT1))); } catch (IOException e) { e.printStackTrace(); } finally { close(in); close(out); } } private static void close(Closeable closable) { if (closable != null) { try { closable.close(); } catch (IOException e) { if (FastCopy.debug) e.printStackTrace(); } } }
private void copy(final File f1, final File f2) throws IOException { f2.createNewFile(); final RandomAccessFile file1 = new RandomAccessFile(f1, "r"); final RandomAccessFile file2 = new RandomAccessFile(f2, "rw"); file2.getChannel().write(file1.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f1.length())); file1.close(); file2.close(); }
private static long fileCopyUsingFileStreams(File fileToCopy, File newFile) throws IOException { FileInputStream input = new FileInputStream(fileToCopy); FileOutputStream output = new FileOutputStream(newFile); byte[] buf = new byte[1024]; int bytesRead; long start = System.currentTimeMillis(); while ((bytesRead = input.read(buf)) > 0) { output.write(buf, 0, bytesRead); } long end = System.currentTimeMillis(); input.close(); output.close(); return (end-start); } private static long fileCopyUsingNIOChannelClass(File fileToCopy, File newFile) throws IOException { FileInputStream inputStream = new FileInputStream(fileToCopy); FileChannel inChannel = inputStream.getChannel(); FileOutputStream outputStream = new FileOutputStream(newFile); FileChannel outChannel = outputStream.getChannel(); long start = System.currentTimeMillis(); inChannel.transferTo(0, fileToCopy.length(), outChannel); long end = System.currentTimeMillis(); inputStream.close(); outputStream.close(); return (end-start); } private static long fileCopyUsingApacheCommons(File fileToCopy, File newFile) throws IOException { long start = System.currentTimeMillis(); FileUtils.copyFile(fileToCopy, newFile); long end = System.currentTimeMillis(); return (end-start); } private static long fileCopyUsingNIOFilesClass(File fileToCopy, File newFile) throws IOException { Path source = Paths.get(fileToCopy.getPath()); Path destination = Paths.get(newFile.getPath()); long start = System.currentTimeMillis(); Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING); long end = System.currentTimeMillis(); return (end-start); }
String name = new Object(){}.getClass().getEnclosingMethod().getName();
/** * Get the method name for a depth in call stack. <br /> * Utility function * @param depth depth in the call stack (0 means current method, 1 means call method, ...) * @return method name */ public static String getMethodName(final int depth) { final StackTraceElement[] ste = Thread.currentThread().getStackTrace(); return ste[ste.length - 1 - depth].getMethodName(); }
public class MethodNameTest { private static final int CLIENT_CODE_STACK_INDEX; static { int i = 0; for (StackTraceElement ste : Thread.currentThread().getStackTrace()) { i++; if (ste.getClassName().equals(MethodNameTest.class.getName())) { break; } } CLIENT_CODE_STACK_INDEX = i; } public static void main(String[] args) { System.out.println("methodName() = " + methodName()); System.out.println("CLIENT_CODE_STACK_INDEX = " + CLIENT_CODE_STACK_INDEX); } public static String methodName() { return Thread.currentThread().getStackTrace()[CLIENT_CODE_STACK_INDEX].getMethodName(); } }
public class SomeClass { public void foo(){ class Local {}; String name = Local.class.getEnclosingMethod().getName(); } }
import java.lang.reflect.Method; public class TraceHelper { private static Method m; static { try { m = Throwable.class.getDeclaredMethod("getStackTraceElement", int.class); m.setAccessible(true); } catch (Exception e) { e.printStackTrace(); } } public static String getMethodName(final int depth) { try { StackTraceElement element = (StackTraceElement) m.invoke( new Throwable(), depth + 1); return element.getMethodName(); } catch (Exception e) { e.printStackTrace(); return null; } } }
StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace(); StackTraceElement e = stacktrace[1]; String methodName = e.getMethodName(); System.out.println(methodName);
new Object(){}.getClass().getEnclosingMethod().getName()
Thread.currentThread().getStackTrace()[1].getMethodName()
public static String getCurrentMethodName() { return Thread.currentThread().getStackTrace()[2].getClassName() + "." + Thread.currentThread().getStackTrace()[2].getMethodName(); }
/* Utility class: Getting the name of the current executing method * https: * * Provides: * * getCurrentClassName() * getCurrentMethodName() * getCurrentFileName() * * getInvokingClassName() * getInvokingMethodName() * getInvokingFileName() * * Nb. Using StackTrace * method names. See other stackoverflow posts eg. https: * * 29/09/2012 (lem) - added methods to return (1) fully qualified names and (2) invoking class/method names */ package com.stackoverflow.util; public class StackTraceInfo { /* (Lifted from virgo47 private static final int CLIENT_CODE_STACK_INDEX; static { int i = 0; for (StackTraceElement ste: Thread.currentThread().getStackTrace()) { i++; if (ste.getClassName().equals(StackTraceInfo.class.getName())) { break; } } CLIENT_CODE_STACK_INDEX = i; } public static String getCurrentMethodName() { return getCurrentMethodName(1); } private static String getCurrentMethodName(int offset) { return Thread.currentThread().getStackTrace()[CLIENT_CODE_STACK_INDEX + offset].getMethodName(); } public static String getCurrentClassName() { return getCurrentClassName(1); } private static String getCurrentClassName(int offset) { return Thread.currentThread().getStackTrace()[CLIENT_CODE_STACK_INDEX + offset].getClassName(); } public static String getCurrentFileName() { return getCurrentFileName(1); } private static String getCurrentFileName(int offset) { String filename = Thread.currentThread().getStackTrace()[CLIENT_CODE_STACK_INDEX + offset].getFileName(); int lineNumber = Thread.currentThread().getStackTrace()[CLIENT_CODE_STACK_INDEX + offset].getLineNumber(); return filename + ":" + lineNumber; } public static String getInvokingMethodName() { return getInvokingMethodName(2); } private static String getInvokingMethodName(int offset) { return getCurrentMethodName(offset + 1); } public static String getInvokingClassName() { return getInvokingClassName(2); } private static String getInvokingClassName(int offset) { return getCurrentClassName(offset + 1); } public static String getInvokingFileName() { return getInvokingFileName(2); } private static String getInvokingFileName(int offset) { return getCurrentFileName(offset + 1); } public static String getCurrentMethodNameFqn() { return getCurrentMethodNameFqn(1); } private static String getCurrentMethodNameFqn(int offset) { String currentClassName = getCurrentClassName(offset + 1); String currentMethodName = getCurrentMethodName(offset + 1); return currentClassName + "." + currentMethodName ; } public static String getCurrentFileNameFqn() { String CurrentMethodNameFqn = getCurrentMethodNameFqn(1); String currentFileName = getCurrentFileName(1); return CurrentMethodNameFqn + "(" + currentFileName + ")"; } public static String getInvokingMethodNameFqn() { return getInvokingMethodNameFqn(2); } private static String getInvokingMethodNameFqn(int offset) { String invokingClassName = getInvokingClassName(offset + 1); String invokingMethodName = getInvokingMethodName(offset + 1); return invokingClassName + "." + invokingMethodName; } public static String getInvokingFileNameFqn() { String invokingMethodNameFqn = getInvokingMethodNameFqn(2); String invokingFileName = getInvokingFileName(2); return invokingMethodNameFqn + "(" + invokingFileName + ")"; } }
new Exception("is not thrown").getStackTrace()[1].getMethodName()
public static String getCurrentClassAndMethodNames() { final StackTraceElement e = Thread.currentThread().getStackTrace()[2]; final String s = e.getClassName(); return s.substring(s.lastIndexOf( }
public class SomeClass { public static void main(String[] args) { System.out.println(Util.getCurrentClassAndMethodNames()); } }
String methodName =Thread.currentThread().getStackTrace()[1].getMethodName(); System.out.println("methodName = " + methodName);
System.out.printf("Class %s.%s\n", getClass().getName(), new Exception("is not thrown").getStackTrace()[0].getMethodName());
/** * @param className fully qualified className * <br/> * <code>YourClassName.class.getName();</code> * <br/><br/> * @param classSimpleName simpleClassName * <br/> * <code>YourClassName.class.getSimpleName();</code> * <br/><br/> */ public static void getStackTrace(final String className, final String classSimpleName) { final StackTraceElement[] steArray = Thread.currentThread().getStackTrace(); int index = 0; for (StackTraceElement ste : steArray) { if (ste.getClassName().equals(className)) { break; } index++; } if (index >= steArray.length) { Log.w(classSimpleName, Arrays.toString(new String[]{steArray[3].getMethodName(), String.valueOf(steArray[3].getLineNumber())})); } else { Log.w(classSimpleName, Arrays.toString(new String[]{steArray[index].getMethodName(), String.valueOf(steArray[index].getLineNumber())})); } }
MethodHandles.lookup().lookupClass().getEnclosingMethod().getName();
public static String getCurrentMethodName() { return StackWalker.getInstance() .walk(s -> s.skip(1).findFirst()) .get() .getMethodName(); } public static String getCallerMethodName() { return StackWalker.getInstance() .walk(s -> s.skip(2).findFirst()) .get() .getMethodName(); }
class Example { FileOutputStream fileOutputStream; public Example() { debug("Example.Example()",false); try { fileOutputStream = new FileOutputStream("debug.txt"); } catch (Exception exception) { debug(exception + Calendar.getInstance().getTime()); } } private boolean was911AnInsideJob() { System.out.println("Example.was911AnInsideJob()"); return true; } public boolean shouldGWBushBeImpeached(){ System.out.println("Example.shouldGWBushBeImpeached()"); return true; } public void setPunishment(int yearsInJail){ debug("Server.setPunishment(int yearsInJail=" + yearsInJail + ")",true); } }
private void debug (Object object) { debug(object,true); } private void dedub(Object object, boolean debug) { if (debug) { System.out.println(object); fileOutputStream.write(object.toString().getBytes()); } }
public class GenericClass<T> { public Type getMyType() { } }
public class GenericClass<T> { private final Class<T> type; public GenericClass(Class<T> type) { this.type = type; } public Class<T> getMyType() { return this.type; } }
private Class<T> persistentClass; public Constructor() { this.persistentClass = (Class<T>) ((ParameterizedType) getClass() .getGenericSuperclass()).getActualTypeArguments()[0]; }
import com.google.common.reflect.TypeToken; import java.lang.reflect.Type; public abstract class GenericClass<T> { private final TypeToken<T> typeToken = new TypeToken<T>(getClass()) { }; private final Type type = typeToken.getType(); public Type getType() { return type; } public static void main(String[] args) { GenericClass<String> example = new GenericClass<String>() { }; System.out.println(example.getType()); } }
class GenericCls<T> { private Class<T> type; public GenericCls(Class<T> cls) { type= cls; } Class<T> getType(){return type;} }
GenericCls<?> instance = new GenericCls<String>(String.class); assert instance.getType() == String.class;
public class A<T> { protected Class<T> clazz; public A() { this.clazz = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]; } public Class<T> getClazz() { return clazz; } } public class B extends A<C> { public void anything() { } }
public abstract class AbstractDAO<T extends EntityInterface, U extends QueryCriteria, V> { /** * Method returns class implementing EntityInterface which was used in class * extending AbstractDAO * * @return Class<T extends EntityInterface> */ public Class<T> returnedClass() { return (Class<T>) getTypeArguments(AbstractDAO.class, getClass()).get(0); } /** * Get the underlying class for a type, or null if the type is a variable * type. * * @param type the type * @return the underlying class */ public static Class<?> getClass(Type type) { if (type instanceof Class) { return (Class) type; } else if (type instanceof ParameterizedType) { return getClass(((ParameterizedType) type).getRawType()); } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType) type).getGenericComponentType(); Class<?> componentClass = getClass(componentType); if (componentClass != null) { return Array.newInstance(componentClass, 0).getClass(); } else { return null; } } else { return null; } } /** * Get the actual type arguments a child class has used to extend a generic * base class. * * @param baseClass the base class * @param childClass the child class * @return a list of the raw classes for the actual type arguments. */ public static <T> List<Class<?>> getTypeArguments( Class<T> baseClass, Class<? extends T> childClass) { Map<Type, Type> resolvedTypes = new HashMap<Type, Type>(); Type type = childClass; while (!getClass(type).equals(baseClass)) { if (type instanceof Class) { type = ((Class) type).getGenericSuperclass(); } else { ParameterizedType parameterizedType = (ParameterizedType) type; Class<?> rawType = (Class) parameterizedType.getRawType(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); TypeVariable<?>[] typeParameters = rawType.getTypeParameters(); for (int i = 0; i < actualTypeArguments.length; i++) { resolvedTypes.put(typeParameters[i], actualTypeArguments[i]); } if (!rawType.equals(baseClass)) { type = rawType.getGenericSuperclass(); } } } Type[] actualTypeArguments; if (type instanceof Class) { actualTypeArguments = ((Class) type).getTypeParameters(); } else { actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments(); } List<Class<?>> typeArgumentsAsClasses = new ArrayList<Class<?>>(); for (Type baseType : actualTypeArguments) { while (resolvedTypes.containsKey(baseType)) { baseType = resolvedTypes.get(baseType); } typeArgumentsAsClasses.add(getClass(baseType)); } return typeArgumentsAsClasses; } }
import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; public class GenericClass<T extends String> { public static void main(String[] args) { for (TypeVariable typeParam : GenericClass.class.getTypeParameters()) { System.out.println(typeParam.getName()); for (Type bound : typeParam.getBounds()) { System.out.println(bound); } } } }
import java.lang.annotation.*; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface EntityAnnotation { Class entityClass(); }
@EntityAnnotation(entityClass = PassedGenericType.class) public class Subclass<PassedGenericType> {...}
import org.springframework.core.annotation.AnnotationUtils; . . . private Class getGenericParameterType() { final Class aClass = this.getClass(); EntityAnnotation ne = AnnotationUtils.findAnnotation(aClass, EntityAnnotation.class); return ne.entityClass(); }
public abstract class AbstractDao<T> { private final Class<T> persistentClass; public AbstractDao() { this.persistentClass = (Class<T>) ((ParameterizedType) this.getClass().getGenericSuperclass()) .getActualTypeArguments()[0]; } }
@SuppressWarnings("unchecked") private Class<T> getGenericTypeClass() { try { String className = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0].getTypeName(); Class<?> clazz = Class.forName(className); return (Class<T>) clazz; } catch (Exception e) { throw new IllegalStateException("Class is not parametrized with generic type!!! Please use extends <> "); } }
public abstract class GenericClass<T>{ public abstract Class<T> getMyType(); }
public class SpecificClass extends GenericClass<String>{ @Override public Class<String> getMyType(){ return String.class; } }
public class Constant<T> { private T value; @SuppressWarnings("unchecked") public Class<T> getClassType () { return ((Class<T>) value.getClass()); } }
Constant<?> constant = ...; if (constant.getClassType().equals(Integer.class)) { Constant<Integer> integerConstant = (Constant<Integer>)constant; Integer value = integerConstant.getValue(); }
private Class<T> getGenericTypeClass() { return (Class<T>) (getParametrizedType(getClass())).getActualTypeArguments()[0]; } private static ParameterizedType getParametrizedType(Class clazz){ if(clazz.getSuperclass().equals(MyGenericClass.class)){ return (ParameterizedType) clazz.getGenericSuperclass(); } else { return getParametrizedType(clazz.getSuperclass()); } }
public class GenericDemo<T>{ private T type; GenericDemo(T t) { this.type = t; } public String getType() { return this.type.getClass().getName(); } public static void main(String[] args) { GenericDemo<Integer> obj = new GenericDemo<Integer>(5); System.out.println("Type: "+ obj.getType()); } }
public class Main { public static void main(String[] args) throws Exception { System.out.println(Main.<String> getClazz()); } static <T> Class getClazz(T... param) { return param.getClass().getComponentType(); } }
public class GenericClass<T> { private Class<T> realType; public GenericClass() { findTypeArguments(getClass()); } private void findTypeArguments(Type t) { if (t instanceof ParameterizedType) { Type[] typeArgs = ((ParameterizedType) t).getActualTypeArguments(); realType = (Class<T>) typeArgs[0]; } else { Class c = (Class) t; findTypeArguments(c.getGenericSuperclass()); } } public Type getMyType() { return realType; } }
public class FirstLevelChild<T> extends GenericClass<T> { } public class SecondLevelChild extends FirstLevelChild<String> { }
public static final Class<?> getGenericArgument(final Class<?> clazz) { return (Class<?>) ((ParameterizedType) clazz.getGenericSuperclass()).getActualTypeArguments()[0]; }
class SomeClass<N>{ WeakReference<N> variableToGetTypeFrom; N getType(){ return variableToGetTypeFrom.get(); } }
public class GenericClass<T> { private Class classForT(T...t) { return t.getClass().getComponentType(); } public static void main(String[] args) { GenericClass<String> g = new GenericClass<String>(); System.out.println(g.classForT()); System.out.println(String.class); } }
/Library/Java/Home /System/Library/Frameworks/JavaVM.framework/Home /System/Library/Frameworks/JavaVM.framework/Versions/Current
sudo ln -s /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java_home /usr/libexec/java_home
/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
launchctl setenv JAVA_HOME $(/usr/libexec/java_home -v 1.8)
echo "export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)" > ~/.mavenrc
Field hack = WarpTransform2D.class.getDeclaredField("USE_HACK"); hack.setAccessible(true); hack.set(null, true);
import java.lang.reflect.*; public class EverythingIsTrue { static void setFinalStatic(Field field, Object newValue) throws Exception { field.setAccessible(true); Field modifiersField = Field.class.getDeclaredField("modifiers"); modifiersField.setAccessible(true); modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL); field.set(null, newValue); } public static void main(String args[]) throws Exception { setFinalStatic(Boolean.class.getField("FALSE"), true); System.out.format("Everything is %s", false); } }
public class A { private final String myVar = "Some Value"; }
public class A { private final String myVar; private A() { myVar = "Some Value"; } }
class Flag { static final boolean FLAG = true; } class Checker { public static void main(String... argv) { System.out.println(Flag.FLAG); } }
0: getstatic 3: iconst_1 4: invokevirtual 7: return
Reflect.on(yourObject).set("finalFieldName", finalFieldValue);
import java.lang.reflect.*; public class EverythingIsTrue { static void setFinalStatic(Field field, Object newValue) throws Exception { field.setAccessible(true); Field modifiersField = Field.class.getDeclaredField("modifiers"); AccessController.doPrivileged(new PrivilegedAction() { @Override public Object run() { modifiersField.setAccessible(true); return null; } }); modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL); field.set(null, newValue); } public static void main(String args[]) throws Exception { setFinalStatic(Boolean.class.getField("FALSE"), true); System.out.format("Everything is %s", false); } }
AccessController.doPrivileged((PrivilegedAction) () -> { modifiersField.setAccessible(true); return null; });
public static <T> T assignFinalField(Object object, Class<?> clazz, String fieldName, UnaryOperator<T> newValueFunction) { Field f = null, ff = null; try { f = clazz.getDeclaredField(fieldName); final int oldM = f.getModifiers(); final int newM = oldM & ~Modifier.FINAL; ff = Field.class.getDeclaredField("modifiers"); ff.setAccessible(true); ff.setInt(f,newM); f.setAccessible(true); T result = (T)f.get(object); T newValue = newValueFunction.apply(result); f.set(object,newValue); ff.setInt(f,oldM); return result; } ...
/** * @author Dmitrijs Lobanovskis * @since 03/03/2016. */ public class SomeClass { private final String str; SomeClass(){ this.str = "This is the string that never changes!"; } public String getStr() { return str; } @Override public String toString() { return "Class name: " + getClass() + " Value: " + getStr(); } }
/** * @author Dmitrijs Lobanovskis * @since 03/03/2016. */ public class Main { public static void main(String[] args) throws Exception{ SomeClass someClass = new SomeClass(); System.out.println(someClass); Field field = someClass.getClass().getDeclaredField("str"); field.setAccessible(true); field.set(someClass, "There you are"); System.out.println(someClass); } }
Class name: class SomeClass Value: This is the string that never changes! Class name: class SomeClass Value: There you are Process finished with exit code 0
assertThat(objectUnderTest, is(not(someOtherObject))); assertThat(objectUnderTest, not(someOtherObject)); assertThat(objectUnderTest, not(equalTo(someOtherObject)));
import static org.junit.Assert.*; import static org.hamcrest.CoreMatchers.*;
String msg = "Expected <" + foo + "> to be unequal to <" + bar +">"; assertFalse(msg, foo.equals(bar));
static void assertTrue(java.lang.String message, boolean condition)
int status = doSomething() ; assertTrue("doSomething() returned unexpected status", status != 123 ) ;
.... assertThat(1, not(equalTo(Integer.valueOf(winningBidderId)))); ....
public class Animal { private String name; private int age; private String favoriteFood; public Animal(String name, int age, String favoriteFood) { this.name = name; this.age = age; this.favoriteFood = favoriteFood; } public Animal createWithNewNameAndAge(String name, int age) { return new Animal(this.name, this.age, this.favoriteFood); } public String getName() { return name; } public int getAge() { return age; } public String getFavoriteFood() { return favoriteFood; } @Override public String toString() { return "Animal [name=" + name + ", age=" + age + ", favoriteFood=" + favoriteFood + "]"; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((favoriteFood == null) ? 0 : favoriteFood.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (!(obj instanceof Animal)) return false; Animal other = (Animal) obj; return age == other.age && favoriteFood.equals(other.favoriteFood) && name.equals(other.name); } }
@Test void assertListNotEquals_JUnit_way() { Animal scoubi = new Animal("scoubi", 10, "hay"); Animal littleScoubi = scoubi.createWithNewNameAndAge("little scoubi", 1); Assert.assertNotEquals(scoubi, littleScoubi); }
import org.assertj.core.api.Assertions; @Test void assertListNotEquals_AssertJ() { Animal scoubi = new Animal("scoubi", 10, "hay"); Animal littleScoubi = scoubi.createWithNewNameAndAge("little scoubi", 1); Assertions.assertThat(littleScoubi) .extracting(Animal::getName, Animal::getAge, Animal::getFavoriteFood) .containsExactly("little scoubi", 1, "hay"); }
SimpleDateFormat dateFormatGmt = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss"); dateFormatGmt.setTimeZone(TimeZone.getTimeZone("GMT")); SimpleDateFormat dateFormatLocal = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss"); return dateFormatLocal.parse( dateFormatGmt.format(new Date()) );
OffsetDateTime now = OffsetDateTime.now( ZoneOffset.UTC );
System.out.println( "UTC/GMT date-time in ISO 8601 format: " + new org.joda.time.DateTime( org.joda.time.DateTimeZone.UTC ) );
org.joda.time.DateTime now = new org.joda.time.DateTime(); org.joda.time.DateTime zulu = now.toDateTime( org.joda.time.DateTimeZone.UTC );
System.out.println( "Local time in ISO 8601 format: " + now ); System.out.println( "Same moment in UTC (Zulu): " + zulu );
DateTimeZone zoneMontral = DateTimeZone.forID( "America/Montreal" ); DateTime now = DateTime.now( zoneMontral );
DateTimeZone zoneDefault = DateTimeZone.getDefault();
static final String DATEFORMAT = "yyyy-MM-dd HH:mm:ss" public static Date GetUTCdatetimeAsDate() { return StringDateToDate(GetUTCdatetimeAsString()); } public static String GetUTCdatetimeAsString() { final SimpleDateFormat sdf = new SimpleDateFormat(DATEFORMAT); sdf.setTimeZone(TimeZone.getTimeZone("UTC")); final String utcTime = sdf.format(new Date()); return utcTime; } public static Date StringDateToDate(String StrDate) { Date dateToReturn = null; SimpleDateFormat dateFormat = new SimpleDateFormat(DATEFORMAT); try { dateToReturn = (Date)dateFormat.parse(StrDate); } catch (ParseException e) { e.printStackTrace(); } return dateToReturn; }
Calendar c = Calendar.getInstance(); System.out.println("current: "+c.getTime()); TimeZone z = c.getTimeZone(); int offset = z.getRawOffset(); if(z.inDaylightTime(new Date())){ offset = offset + z.getDSTSavings(); } int offsetHrs = offset / 1000 / 60 / 60; int offsetMins = offset / 1000 / 60 % 60; System.out.println("offset: " + offsetHrs); System.out.println("offset: " + offsetMins); c.add(Calendar.HOUR_OF_DAY, (-offsetHrs)); c.add(Calendar.MINUTE, (-offsetMins)); System.out.println("GMT Time: "+c.getTime());
SimpleDateFormat f = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss"); f.setTimeZone(TimeZone.getTimeZone("UTC")); System.out.println(f.format(new Date()));
Calendar aGMTCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT")); aGMTCalendar.getTime();
Calendar aNotGMTCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT-2"));aNotGMTCalendar.getTime();
import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.TimeZone; public class Test { public static void main(final String[] args) throws ParseException { final SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z"); f.setTimeZone(TimeZone.getTimeZone("UTC")); System.out.println(f.format(new Date())); } }
Calendar c = Calendar.getInstance(); int utcOffset = c.get(Calendar.ZONE_OFFSET) + c.get(Calendar.DST_OFFSET); Long utcMilliseconds = c.getTimeInMillis() + utcOffset;
System.out.println(new java.util.Date().getHours() + " hours");
System.out.println(Calendar.getInstance(TimeZone.getTimeZone("GMT")) .get(Calendar.HOUR_OF_DAY) + " Hours");
import org.joda.time.DateTimeZone; import java.util.Date; ... Date local = new Date(); System.out.println("Local: " + local); DateTimeZone zone = DateTimeZone.getDefault(); long utc = zone.convertLocalToUTC(local.getTime(), false); System.out.println("UTC: " + new Date(utc));
Calendar aGMTCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
SimpleDateFormat dateFormatGmt = new SimpleDateFormat("yyyy-MM-dd"); dateFormatGmt.setTimeZone(TimeZone.getTimeZone("GMT")); System.out.println(dateFormatGmt.format(date));
SimpleDateFormat dateFormatGmt = new SimpleDateFormat("dd:MM:yyyy HH:mm:ss"); dateFormatGmt.setTimeZone(TimeZone.getTimeZone("GMT")); System.out.println(dateFormatGmt.format(new Date())+"");
Calendar cal2 = Calendar.getInstance(TimeZone.getTimeZone("GMT-2"));
import java.sql.Timestamp; import java.util.Calendar; ... private static Timestamp getGMT() { Calendar cal = Calendar.getInstance(); return new Timestamp(cal.getTimeInMillis() -cal.get(Calendar.ZONE_OFFSET) -cal.get(Calendar.DST_OFFSET)); }
String DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss z" ; final SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); String dateTimeString = sdf.format(new Date());
import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.TimeZone; public class TimZoneTest { public static void main (String[] args){ System.out.println(my_time_in("GMT-5:00", "MM/dd/yyyy HH:mm:ss") ); System.out.println(my_time_in("GMT+5:30", " System.out.println("---------------------------------------------"); System.out.println(my_time_in("America/Los_Angeles", " System.out.println(my_time_in("America/Buenos_Aires", " } public static String my_time_in(String target_time_zone, String format){ TimeZone tz = TimeZone.getTimeZone(target_time_zone); Date date = Calendar.getInstance().getTime(); SimpleDateFormat date_format_gmt = new SimpleDateFormat(format); date_format_gmt.setTimeZone(tz); return date_format_gmt.format(date); } }
10/08/2011 21:07:21 at 07:37 AM GMT+05:30 on 10/09/2011 at 19:07 PM PDT on 10/08/2011 at 23:07 PM ART on 10/08/2011
DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd DateTimeZone dateTimeZone = DateTimeZone.getDefault(); DateTime currDateTime = new DateTime(); long utcTime = dateTimeZone.convertLocalToUTC(currDateTime .getMillis(), false); String currTime = formatter.print(utcTime); currDateTime = formatter.parseDateTime(currTime);
Date currDate; SimpleDateFormat dateFormatGmt = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss"); dateFormatGmt.setTimeZone(TimeZone.getTimeZone("GMT")); SimpleDateFormat dateFormatLocal = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss"); long currTime = 0; try { currDate = dateFormatLocal.parse( dateFormatGmt.format(new Date()) ); currTime = currDate.getTime(); } catch (ParseException e) { e.printStackTrace(); }
public static Date toUTC(Date date){ long datems = date.getTime(); long timezoneoffset = TimeZone.getDefault().getOffset(datems); datems -= timezoneoffset; return new Date(datems); }
public static void main(String args[]){ LocalDate date=LocalDate.now(); System.out.println("Current date = "+date); }
public static String GetCurrentTimeStamp() { Calendar cal=Calendar.getInstance(); long offset = cal.getTimeZone().getOffset(System.currentTimeMillis()); return new java.sql.Timestamp(System.currentTimeMillis()+offset).toString(); }
import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; class NTP_UTC_Time { private static final String TAG = "SntpClient"; private static final int RECEIVE_TIME_OFFSET = 32; private static final int TRANSMIT_TIME_OFFSET = 40; private static final int NTP_PACKET_SIZE = 48; private static final int NTP_PORT = 123; private static final int NTP_MODE_CLIENT = 3; private static final int NTP_VERSION = 3; private static final long OFFSET_1900_TO_1970 = ((365L * 70L) + 17L) * 24L * 60L * 60L; private long mNtpTime; public boolean requestTime(String host, int timeout) { try { DatagramSocket socket = new DatagramSocket(); socket.setSoTimeout(timeout); InetAddress address = InetAddress.getByName(host); byte[] buffer = new byte[NTP_PACKET_SIZE]; DatagramPacket request = new DatagramPacket(buffer, buffer.length, address, NTP_PORT); buffer[0] = NTP_MODE_CLIENT | (NTP_VERSION << 3); writeTimeStamp(buffer, TRANSMIT_TIME_OFFSET); socket.send(request); DatagramPacket response = new DatagramPacket(buffer, buffer.length); socket.receive(response); socket.close(); mNtpTime = readTimeStamp(buffer, RECEIVE_TIME_OFFSET); } catch (Exception e) { return false; } return true; } public long getNtpTime() { return mNtpTime; } /** * Reads an unsigned 32 bit big endian number from the given offset in the buffer. */ private long read32(byte[] buffer, int offset) { byte b0 = buffer[offset]; byte b1 = buffer[offset+1]; byte b2 = buffer[offset+2]; byte b3 = buffer[offset+3]; int i0 = ((b0 & 0x80) == 0x80 ? (b0 & 0x7F) + 0x80 : b0); int i1 = ((b1 & 0x80) == 0x80 ? (b1 & 0x7F) + 0x80 : b1); int i2 = ((b2 & 0x80) == 0x80 ? (b2 & 0x7F) + 0x80 : b2); int i3 = ((b3 & 0x80) == 0x80 ? (b3 & 0x7F) + 0x80 : b3); return ((long)i0 << 24) + ((long)i1 << 16) + ((long)i2 << 8) + (long)i3; } /** * Reads the NTP time stamp at the given offset in the buffer and returns * it as a system time (milliseconds since January 1, 1970). */ private long readTimeStamp(byte[] buffer, int offset) { long seconds = read32(buffer, offset); long fraction = read32(buffer, offset + 4); return ((seconds - OFFSET_1900_TO_1970) * 1000) + ((fraction * 1000L) / 0x100000000L); } /** * Writes 0 as NTP starttime stamp in the buffer. --> Then NTP returns Time OFFSET since 1900 */ private void writeTimeStamp(byte[] buffer, int offset) { int ofs = offset++; for (int i=ofs;i<(ofs+8);i++) buffer[i] = (byte)(0); } }
long now = 0; NTP_UTC_Time client = new NTP_UTC_Time(); if (client.requestTime("pool.ntp.org", 2000)) { now = client.getNtpTime(); }
private String get_UTC_Datetime_from_timestamp(long timeStamp){ try{ Calendar cal = Calendar.getInstance(); TimeZone tz = cal.getTimeZone(); int tzt = tz.getOffset(System.currentTimeMillis()); timeStamp -= tzt; DateFormat sdf = new SimpleDateFormat(); Date netDate = (new Date(timeStamp)); return sdf.format(netDate); } catch(Exception ex){ return ""; } }
String UTC_DateTime = get_UTC_Datetime_from_timestamp(now);
final Date gmt = new Timestamp(System.currentTimeMillis() - Calendar.getInstance().getTimeZone() .getOffset(System.currentTimeMillis()));
long instant = DateTimeZone.UTC.getMillisKeepLocal(DateTimeZone.getDefault(), System.currentTimeMillis());
public class CurrentUtcDate { public static void main(String[] args) { Date date = new Date(); SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss"); dateFormat.setTimeZone(TimeZone.getTimeZone("UTC")); System.out.println("UTC Time is: " + dateFormat.format(date)); } }
import java.io.StringReader; import org.jdom2.input.SAXBuilder; import org.jdom2.output.Format; import org.jdom2.output.XMLOutputter; String prettyXml = new XMLOutputter(Format.getPrettyFormat()). outputString(new SAXBuilder().build(new StringReader(uglyXml)));
for (String join : joins) { mIrc.join(mSession, join); }
joins.parallelStream().forEach(join -> mIrc.join(mSession, join));
Object prev = null; for(Object curr : list) { if( prev != null ) foo(prev, curr); prev = curr; }
for (String join : joins) { mIrc.join(mSession, join); }
joins.forEach(new Consumer<T>() { @Override public void accept(T join) { mIrc.join(mSession, join); } });
final Consumer<T> c = new Consumer<T>() { @Override public void accept(T join) { mIrc.join(mSession, join); } }; for (T t : joins) { c.accept(t); }
@VmOptions("-server") public class Java8IterationBenchmarks { public static class TestObject { public int result; } public @Param({"100", "10000"}) int elementCount; ArrayList<TestObject> list; TestObject[] array; @BeforeExperiment public void setup(){ list = new ArrayList<>(elementCount); for (int i = 0; i < elementCount; i++) { list.add(new TestObject()); } array = list.toArray(new TestObject[list.size()]); } @Benchmark public void timeTraditionalForEach(int reps){ for (int i = 0; i < reps; i++) { for (TestObject t : list) { t.result++; } } return; } @Benchmark public void timeForEachAnonymousClass(int reps){ for (int i = 0; i < reps; i++) { list.forEach(new Consumer<TestObject>() { @Override public void accept(TestObject t) { t.result++; } }); } return; } @Benchmark public void timeForEachLambda(int reps){ for (int i = 0; i < reps; i++) { list.forEach(t -> t.result++); } return; } @Benchmark public void timeForEachOverArray(int reps){ for (int i = 0; i < reps; i++) { for (TestObject t : array) { t.result++; } } } }
public abstract class MyOptimizedCollection<E> implements Collection<E>{ private enum OperatingSystem{ LINUX, WINDOWS, ANDROID } private OperatingSystem operatingSystem = OperatingSystem.WINDOWS; private int numberOfCores = Runtime.getRuntime().availableProcessors(); private Collection<E> delegate; @Override public Stream<E> parallelStream() { if (!System.getProperty("parallelSupport").equals("true")) { return this.delegate.stream(); } switch (operatingSystem) { case WINDOWS: if (numberOfCores > 3 && delegate.size() > 10000) { return this.delegate.parallelStream(); }else{ return this.delegate.stream(); } case LINUX: return SomeVerySpecialStreamImplementation.stream(this.delegate.spliterator()); case ANDROID: default: return this.delegate.stream(); } } }
for(int i=0; i<size; i++) action.accept(elements[i])
Iterator iter = list.iterator(); while(iter.hasNext()) Object next = iter.next(); do something with `next`
private List<Integer> list; private final int size = 1_000_000; public MyClass(){ list = new ArrayList<>(); Random rand = new Random(); for (int i = 0; i < size; ++i) { list.add(rand.nextInt(size * 50)); } } private void doIt(Integer i) { i *= 2; }
myClass.fored(); myClass.fored(); myClass.fored(); for (int i = 0; i < reps; ++i) { begin = System.nanoTime(); myClass.fored(); end = System.nanoTime(); nanoSum += end - begin; } System.out.println(nanoSum / reps);
for(int i = 0, l = list.size(); i < l; ++i) { doIt(list.get(i)); }
Stream<String> stream = Stream.of("", "1", "2", "3").filter(s -> !s.isEmpty()); Iterable<String> iterable = stream::iterator; for (String s : iterable) { fileWriter.append(s); }
class MyConsumer implements Consumer<Integer>{ @Override public void accept(Integer o) { System.out.println("Here you can also add your business logic that will work with Iteration and you can reuse it."+o); } } public class ForEachConsumer { public static void main(String[] args) { ArrayList<Integer> aList = new ArrayList<>(); for(int i=1;i<=10;i++) aList.add(i); MyConsumer consumer = new MyConsumer(); aList.forEach(consumer); Consumer<Integer> lambda = (Integer o) ->{ System.out.println("Using Lambda Expression to iterate and do something else(BI).. "+o); }; aList.forEach(lambda); aList.forEach(new Consumer<Integer>(){ @Override public void accept(Integer o) { System.out.println("Calling with Anonymous Inner Class "+o); } }); } }
BUILD FAILED C:\Users\Derek\Desktop\eclipse\eclipse\glassfish\setup.xml:161: The following error occurred while executing this line: C:\Users\Derek\Desktop\eclipse\eclipse\glassfish\setup.xml:141: The following error occurred while executing this line: C:\Users\Derek\Desktop\eclipse\eclipse\glassfish\setup.xml:137: Please set java.home to a JDK installation Total time: 1 second C:\Users\Derek\Desktop\eclipse\eclipse\glassfish>lib\ant\bin\ant -f setup.xml Unable to locate tools.jar. Expected to find it in C:\Program Files\Java\jre6\lib\tools.jar Buildfile: setup.xml
set JAVA_HOME="C:\\....\java\jdk1.x.y_zz" echo %JAVA_HOME% set PATH=%PATH%;%JAVA_HOME%\bin echo %PATH%
set Java_Home=C:\Program Files\Java\jdk1.8.0_11 set PATH=%PATH%;C:\Program Files\Java\jdk1.8.0_11\bin
if (f = fopen("goodluckfindingthisfile")) { ... } else {
try { f = new FileInputStream("goodluckfindingthisfile"); } catch (FileNotFoundException e) { ... }
public FileInputStream(String name) throws FileNotFoundException
public RowData getRowData(int row) throws CheckedInvalidRowNumberException
"Internal error occured: IllegalArgumentException in ...."
try { overzealousAPI(thisArgumentWontWork); } catch (OverzealousCheckedException exception) { throw new RuntimeException(exception); }
catch (Exception e) { /* TODO deal with this at some point (yeah right) */}
public [int or IOException] writeToStream(OutputStream stream) { [void or IOException] a= stream.write(mybytes); if (a instanceof IOException) return a; return mybytes.length; }
try { httpconn.setRequestMethod("POST"); } catch (ProtocolException e) { throw new CanNeverHappenException("oh dear!"); }
try { } catch (AnnoyingcheckedException e) { throw new RuntimeException(e); }
class WidgetList extends AbstractList<Widget> { private static final int SIZE_OF_WIDGET = 100; private final RandomAccessFile file; public WidgetList(RandomAccessFile file) { this.file = file; } @Override public int size() { return (int)(file.length() / SIZE_OF_WIDGET); } @Override public Widget get(int index) { file.seek((long)index * SIZE_OF_WIDGET); byte[] data = new byte[SIZE_OF_WIDGET]; file.read(data); return new Widget(data); } }
@Override public int size() { try { return (int)(file.length() / SIZE_OF_WIDGET); } catch (IOException e) { throw new WidgetListException(e); } } public static class WidgetListException extends RuntimeException { public WidgetListException(Throwable cause) { super(cause); } }
class Util { /** * Throws any {@link Throwable} without needing to declare it in the * method * * <p>When calling, it is suggested to prepend this method by the * {@code throw} keyword. This tells the compiler about the control flow, * about reachable and unreachable code. (For example, you don * specify a method return value when throwing an exception.) To support * this, this method has a return type of {@link RuntimeException}, * although it never returns anything. * * @param t the {@code Throwable} to throw * @return nothing; this method never returns normally * @throws Throwable that was provided to the method * @throws NullPointerException if {@code t} is {@code null} */ public static RuntimeException sneakyThrow(Throwable t) { return Util.<RuntimeException>sneakyThrow1(t); } @SuppressWarnings("unchecked") private static <T extends Throwable> RuntimeException sneakyThrow1( Throwable t) throws T { throw (T)t; } }
@Override public int size() { try { return (int)(file.length() / SIZE_OF_WIDGET); } catch (IOException e) { throw sneakyThrow(e); } }
try { ... } catch (Throwable t) { if (t instanceof IOException) { ... } else { throw t; } }
public void writeTo(OutputStream out) throws IOException;
ByteArrayOutputStream out = new ByteArrayOutputStream(); try { someWidget.writeTo(out); } catch (IOException e) { throw new RuntimeException(e); }
try { ... } catch (SomeStupidExceptionOmgWhoCares e) { e.printStackTrace(); }
try { ... } catch (SomethingWeird e) { logger.log(e); }
try { SwingUtilities.invokeAndWait(() -> { try { FileUtility f = new FileUtility(); uiComponent.setValue(f.readSomething()); } catch (IOException e) { throw new UncheckedIOException(e); } }); } catch (InterruptedException ex) { throw new IllegalStateException("Interrupted updating UI", ex); } catch (InvocationTargetException ex) { throw new IllegalStateException("Invocation target exception updating UI", ex); }
private void UpdateValue() { if (InvokeRequired) { Invoke(new MethodInvoker(UpdateValue)); } else { FileUtility f = new FileUtility(); uiComponent.Value = f.ReadSomething(); } }
@Override public void clear() { try { backingImplementation.clear(); } catch (CheckedBackingImplException ex) { throw new IllegalStateException("Error clearing underlying list.", ex); } }
try { thirdPartyMethod(); } catch(TPException e) { }
try{ methodDeclaringCheckedException(); }catch(CheckedException e){ logger.error(e); }
try{ methodDeclaringCheckedException(); }catch(CheckedException e){ exceptionHandler.handleError(e); }
try { ... do something ... } catch (Throwable throwable) { ApplicationContext.getExceptionService().handleException("Handle this exception", throwable); }
java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
$ sudo update-java-alternatives -a update-alternatives: error: no alternatives for mozilla-javaplugin.so
$ java --version openjdk 10.0.1 2018-04-17 OpenJDK Runtime Environment (build 10.0.1+10-Ubuntu-3ubuntu1) OpenJDK 64-Bit Server VM (build 10.0.1+10-Ubuntu-3ubuntu1, mixed mode)
/etc/java-9-openjdk/management/management.properties /etc/java-11-openjdk/management/management.properties
/etc/java-9-openjdk/security/java.security /etc/java-11-openjdk/security/java.security
sudo /var/lib/dpkg/info/ca-certificates-java.postinst configure
sudo apt-get remove --purge openjdk* java-common default-jdk sudo apt-get autoremove --purge
sudo /var/lib/dpkg/info/ca-certificates-java.postinst configure
sudo gedit $(path to your architecture specific ini i.e. TOS_DI...ini) Djavax.net.ssl.trustStore=/etc/ssl/certs/java/cacerts
-Djavax.net.ssl.trustStore=cacerts -Djavax.net.ssl.trustStorePassword=changeit -Djavax.net.ssl.trustStoreType=JKS
keytool -list -keystore cacerts Keystore type: JKS Keystore provider: SUN
sudo dpkg --purge --force-depends ca-certificates-java sudo apt-get install ca-certificates-java
-Djavax.net.ssl.trustStore=/etc/ssl/certs/java/cacerts
(as root) umask 022 mkdir -p /System/Library/Java/Support/CoreDeploy.bundle/Contents/Home/lib/security cp $(/usr/libexec/java_home -v 1.7)/jre/lib/security/cacerts \ /System/Library/Java/Support/CoreDeploy.bundle/Contents/Home/lib/security
server.ssl.key-store=classpath:server.jks server.ssl.trust-store=classpath:server.jks
sudo apt install ca-certificates-java cp /etc/ssl/certs/java/cacerts /path/to/jdk-9.0.1/lib/security/cacerts
sudo yum install ca-certificates cp /etc/pki/java/cacerts /path/to/jdk-9.0.1/lib/security/cacerts
System.setProperty("javax.net.ssl.trustStore",path_to_your_cacerts_file);
System.setProperty("javax.net.ssl.trustStore", "C:\\Users\\user-id\\Desktop\\tomcat\\cacerts"); System.setProperty("javax.net.ssl.trustStorePassword", "passwd");
sudo update-ca-certificates -f sudo /var/lib/dpkg/info/ca-certificates-java.postinst configure
Date input = new Date(); LocalDate date = input.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
Date input = new Date(); Instant instant = input.toInstant();
Date input = new Date(); Instant instant = input.toInstant(); ZonedDateTime zdt = instant.atZone(ZoneId.systemDefault());
Date input = new Date(); Instant instant = input.toInstant(); ZonedDateTime zdt = instant.atZone(ZoneId.systemDefault()); LocalDate date = zdt.toLocalDate();
Date input = new Date(); LocalDate date = LocalDate.ofInstant(input.toInstant(), ZoneId.systemDefault());
Date date = ...; Instant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault()).toLocalDate()
/** * Utilities for conversion between the old and new JDK date types * (between {@code java.util.Date} and {@code java.time.*}). * * <p> * All methods are null-safe. */ public class DateConvertUtils { /** * Calls {@link */ public static LocalDate asLocalDate(java.util.Date date) { return asLocalDate(date, ZoneId.systemDefault()); } /** * Creates {@link LocalDate} from {@code java.util.Date} or it */ public static LocalDate asLocalDate(java.util.Date date, ZoneId zone) { if (date == null) return null; if (date instanceof java.sql.Date) return ((java.sql.Date) date).toLocalDate(); else return Instant.ofEpochMilli(date.getTime()).atZone(zone).toLocalDate(); } /** * Calls {@link */ public static LocalDateTime asLocalDateTime(java.util.Date date) { return asLocalDateTime(date, ZoneId.systemDefault()); } /** * Creates {@link LocalDateTime} from {@code java.util.Date} or it */ public static LocalDateTime asLocalDateTime(java.util.Date date, ZoneId zone) { if (date == null) return null; if (date instanceof java.sql.Timestamp) return ((java.sql.Timestamp) date).toLocalDateTime(); else return Instant.ofEpochMilli(date.getTime()).atZone(zone).toLocalDateTime(); } /** * Calls {@link */ public static java.util.Date asUtilDate(Object date) { return asUtilDate(date, ZoneId.systemDefault()); } /** * Creates a {@link java.util.Date} from various date objects. Is null-safe. Currently supports:<ul> * <li>{@link java.util.Date} * <li>{@link java.sql.Date} * <li>{@link java.sql.Timestamp} * <li>{@link java.time.LocalDate} * <li>{@link java.time.LocalDateTime} * <li>{@link java.time.ZonedDateTime} * <li>{@link java.time.Instant} * </ul> * * @param zone Time zone, used only if the input object is LocalDate or LocalDateTime. * * @return {@link java.util.Date} (exactly this class, not a subclass, such as java.sql.Date) */ public static java.util.Date asUtilDate(Object date, ZoneId zone) { if (date == null) return null; if (date instanceof java.sql.Date || date instanceof java.sql.Timestamp) return new java.util.Date(((java.util.Date) date).getTime()); if (date instanceof java.util.Date) return (java.util.Date) date; if (date instanceof LocalDate) return java.util.Date.from(((LocalDate) date).atStartOfDay(zone).toInstant()); if (date instanceof LocalDateTime) return java.util.Date.from(((LocalDateTime) date).atZone(zone).toInstant()); if (date instanceof ZonedDateTime) return java.util.Date.from(((ZonedDateTime) date).toInstant()); if (date instanceof Instant) return java.util.Date.from((Instant) date); throw new UnsupportedOperationException("Don } /** * Creates an {@link Instant} from {@code java.util.Date} or it */ public static Instant asInstant(Date date) { if (date == null) return null; else return Instant.ofEpochMilli(date.getTime()); } /** * Calls {@link */ public static ZonedDateTime asZonedDateTime(Date date) { return asZonedDateTime(date, ZoneId.systemDefault()); } /** * Creates {@link ZonedDateTime} from {@code java.util.Date} or it */ public static ZonedDateTime asZonedDateTime(Date date, ZoneId zone) { if (date == null) return null; else return asInstant(date).atZone(zone); } }
Date input = new Date(); Calendar cal = Calendar.getInstance(); cal.setTime(input); LocalDate date = LocalDate.of(cal.get(Calendar.YEAR), cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH));
LocalDate localDate = LocalDate.parse( new SimpleDateFormat("yyyy-MM-dd").format(date) );
LocalDate ld = new java.sql.Date( new java.util.Date().getTime() ).toLocalDate();
public static LocalDate getLocalDateFromDate(Date date){ return LocalDate.from(Instant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault())); }
LocalDateTime date = LocalDateTime.ofInstant(timestamp, ZoneId.systemDefault());
public static LocalDate Date2LocalDate(Date date) { return LocalDate.parse(date.toString(), DateTimeFormatter.ofPattern("EEE MMM dd HH:mm:ss zzz yyyy"))
public String toString() { BaseCalendar.Date date = normalize(); StringBuilder sb = new StringBuilder(28); int index = date.getDayOfWeek(); if (index == BaseCalendar.SUNDAY) { index = 8; } convertToAbbr(sb, wtb[index]).append( convertToAbbr(sb, wtb[date.getMonth() - 1 + 2 + 7]).append( CalendarUtils.sprintf0d(sb, date.getDayOfMonth(), 2).append( CalendarUtils.sprintf0d(sb, date.getHours(), 2).append( CalendarUtils.sprintf0d(sb, date.getMinutes(), 2).append( CalendarUtils.sprintf0d(sb, date.getSeconds(), 2).append( TimeZone zi = date.getZone(); if (zi != null) { sb.append(zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US)); } else { sb.append("GMT"); } sb.append( return sb.toString(); }
Date input = new Date(); GregorianCalendar gregorianCalendar = (GregorianCalendar) Calendar.getInstance(); gregorianCalendar.setTime(input); ZonedDateTime zonedDateTime = gregorianCalendar.toZonedDateTime(); zonedDateTime.toLocalDate();
new LocalDateTime(new Date().getTime()).toLocalDate();
java.util.Date date = (java.util.Date) java.sql.Date.valueOf(localDate);
LocalDate localDate = ((java.sql.Date)java.util.Date).toLocalDate();
import org.joda.time.LocalDate; Date myDate = new Date(); LocalDate localDate = LocalDate.fromDateFields(myDate); System.out.println("My date using Date" Nov 18 11:23:33 BRST 2016); System.out.println("My date using joda.time LocalTime" 2016-11-18);
static String intToString(int num, int digits) { StringBuffer s = new StringBuffer(digits); int zeroes = digits - (int) (Math.log(num) / Math.log(10)) - 1; for (int i = 0; i < zeroes; i++) { s.append(0); } return s.append(num).toString(); }
String format = String.format("%%0%dd", digits); String result = String.format(format, num); return result;
static String intToString(int num, int digits) { assert digits > 0 : "Invalid number of digits"; char[] zeros = new char[digits]; Arrays.fill(zeros, DecimalFormat df = new DecimalFormat(String.valueOf(zeros)); return df.format(num); }
public static String intToString(int num, int digits) { String output = Integer.toString(num); while (output.length() < digits) output = "0" + output; return output; }
int iTest = 2; StringBuffer sTest = new StringBuffer("000000"); sTest.append(String.valueOf(iTest)); System.out.println(sTest.substring(sTest.length()-6, sTest.length()));
new InputStreamReader(new FileInputStream(file), "UTF-8")
import java.nio.charset.StandardCharsets; ... StandardCharsets.UTF_8.name();
import com.squareup.okhttp.internal.Util; Util.UTF_8; Util.UTF_8.name();
package java.nio.charset; Charset utf8 = StandardCharsets.UTF_8;
import java.nio.charset.StandardCharsets ... new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8);
public abstract class MyBase{ public abstract void VoidMethod(object param1); public abstract object MethodWithReturn(object param1); }
public class MyBaseHarness : MyBase{ public Action<object> VoidMethodFunction; public override void VoidMethod(object param1){ VoidMethodFunction(param1); } public Func<object, object> MethodWithReturnFunction; public override object MethodWithReturn(object param1){ return MethodWihtReturnFunction(param1); } }
public abstract class A { public boolean method 1 { } } class B extends class A { @override public boolean method 1 { } } class Test_A { private static B b; @Before public void init() { b = new B (); } @Test public void Test_method 1 { b.method 1; } }
import java.util.ArrayList; import java.util.List; public abstract class ABC { abstract String sayHello(); public List<String> getList() { final List<String> defaultList = new ArrayList<>(); defaultList.add("abstract class"); return defaultList; } }
public class DEF extends ABC { @Override public String sayHello() { return "Hello!"; } }
import org.junit.Before; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.empty; import static org.hamcrest.Matchers.is; import static org.hamcrest.Matchers.not; import static org.hamcrest.Matchers.contains; import java.util.Collection; import java.util.List; import static org.hamcrest.Matchers.equalTo; import org.junit.Test; public class DEFTest { private DEF def; @Before public void setup() { def = new DEF(); } @Test public void add(){ String result = def.sayHello(); assertThat(result, is(equalTo("Hello!"))); } @Test public void getList(){ List<String> result = def.getList(); assertThat((Collection<String>) result, is(not(empty()))); assertThat(result, contains("abstract class")); } }
General  Appearance  Colors and Fonts  Java Editor text font
; Ctrl + mouse wheel zooming in Eclipse. ; Requires Eclipse-Fonts (https: ; Thank you for the unique window class, SWT/Eclipse. ; ^WheelUp:: Send ^{=} ^WheelDown:: Send ^-
import static com.showboy.Myclass; public class Anotherclass{}
import org.apache.commons.lang.StringUtils; . . . if (StringUtils.isBlank(aString)) { . . .
import static org.apache.commons.lang.StringUtils.isBlank; . . . if (isBlank(aString)) { . . .
package test; import org.example.Foo; class A { B b = Foo.B_INSTANCE; }
package test; import static org.example.Foo.B_INSTANCE; class A { B b = B_INSTANCE; }
import java.lang.Math; class WithoutStaticImports { public static void main(String [] args) { System.out.println("round " + Math.round(1032.897)); System.out.println("min " + Math.min(60,102)); } }
import static java.lang.System.out; import static java.lang.Math.*; class WithStaticImports { public static void main(String [] args) { out.println("round " + round(1032.897)); out.println("min " + min(60,102)); } }
import java.lang.System.*; class StaticImportExample{ public static void main(String args[]){ System.out.println("Hello"); System.out.println("Java"); } }
import static java.lang.System.*; class StaticImportExample{ public static void main(String args[]){ out.println("Hello"); out.println("Java"); } }
Date in = new Date(); LocalDateTime ldt = LocalDateTime.ofInstant(in.toInstant(), ZoneId.systemDefault()); Date out = Date.from(ldt.atZone(ZoneId.systemDefault()).toInstant());
Date input = new Date(); Instant instant = input.toInstant(); Date output = Date.from(instant);
Date in = new Date(); LocalDateTime ldt = LocalDateTime.ofInstant(in.toInstant(), ZoneId.systemDefault());
LocalDateTime ldt = ... ZonedDateTime zdt = ldt.atZone(ZoneId.systemDefault()); Date output = Date.from(zdt.toInstant());
Instant instant = Instant.ofEpochMilli(date.getTime()); LocalDateTime ldt = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
Instant instant = ldt.toInstant(ZoneOffset.UTC); Date date = Date.from(instant);
Date date = new Date(); System.out.println(date + " long: " + date.getTime());
Instant instant = Instant.ofEpochMilli(date.getTime()); System.out.println("Instant from Date:\n" + instant);
date = Date.from(instant); System.out.println("Date from Instant:\n" + date + " long: " + date.getTime());
LocalDateTime ldt = LocalDateTime.ofInstant(instant, ZoneOffset.UTC); System.out.println("LocalDateTime from Instant:\n" + ldt);
instant = ldt.toInstant(ZoneOffset.UTC); System.out.println("Instant from LocalDateTime:\n" + instant);
date = Date.from(instant); System.out.println("Date from Instant:\n" + date + " long: " + date.getTime());
Fri Nov 01 07:13:04 PDT 2013 long: 1383315184574 Instant from Date: 2013-11-01T14:13:04.574Z Date from Instant: Fri Nov 01 07:13:04 PDT 2013 long: 1383315184574 LocalDateTime from Instant: 2013-11-01T14:13:04.574 Instant from LocalDateTime: 2013-11-01T14:13:04.574Z Date from Instant: Fri Nov 01 07:13:04 PDT 2013 long: 1383315184574
Date d = java.sql.Timestamp.valueOf( myLocalDateTime );
Date.from(ZonedDateTime.of({time as LocalDateTime}, ZoneId.systemDefault()).toInstant());
static public LocalDateTime toLdt(Date date) { GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); ZonedDateTime zdt = cal.toZonedDateTime(); return zdt.toLocalDateTime(); } static public Date fromLdt(LocalDateTime ldt) { ZonedDateTime zdt = ZonedDateTime.of(ldt, ZoneId.systemDefault()); GregorianCalendar cal = GregorianCalendar.from(zdt); return cal.getTime(); }
LocalDateTime ldt = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
Date date = DateTimeUtils.toDate(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
boolean hasLoop(Node first) { if(first == null) return false; Node slow, fast; slow = fast = first; while(true) { slow = slow.next; if(fast.next != null) fast = fast.next.next; else return false; if(slow == null || fast == null) return false; if(slow == fast) return true; } }
boolean hasLoop(Node first) { Node slow = first; Node fast = first; while(fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if(slow == fast) return true; } return false; }
Node prev = null; Node cur = first; while (cur != null) { Node next = cur.next; cur.next = prev; prev = cur; cur = next; } boolean hasCycle = prev == first && first != null && first.next != null; cur = prev; prev = null; while (cur != null) { Node next = cur.next; cur.next = prev; prev = cur; cur = next; } return hasCycle;
static void assertSameOrder(Node[] nodes) { for (int i = 0; i < nodes.length - 1; i++) { assert nodes[i].next == nodes[i + 1]; } } public static void main(String[] args) { Node[] nodes = new Node[100]; for (int i = 0; i < nodes.length; i++) { nodes[i] = new Node(); } for (int i = 0; i < nodes.length - 1; i++) { nodes[i].next = nodes[i + 1]; } Node first = nodes[0]; Node max = nodes[nodes.length - 1]; max.next = null; assert !hasCycle(first); assertSameOrder(nodes); max.next = first; assert hasCycle(first); assertSameOrder(nodes); max.next = max; assert hasCycle(first); assertSameOrder(nodes); max.next = nodes[50]; assert hasCycle(first); assertSameOrder(nodes); }
public static boolean hasLoop(Node root){ if(root == null) return false; Node slow = root, fast = root; int taken = 0, limit = 2; while (fast.next != null) { fast = fast.next; taken++; if(slow == fast) return true; if(taken == limit){ taken = 0; limit <<= 1; slow = fast; } } return false; }
boolean hasLoop( Node first ) { if ( first == null ) return false; Node turtle = first; Node hare = first; while ( hare.next != null && hare.next.next != null ) { turtle = turtle.next; hare = hare.next.next; if ( turtle == hare ) return true; } return false; }
static boolean hasLoop(Node first) { if(first == null) return false; Node slow, fast; slow = fast = first; while(true) { slow = slow.next; if(fast.next == null) fast = null; else fast = fast.next.next; if(fast == null) return false; if(slow == fast) return true; } }
public static boolean hasCycle (LinkedList<Node> list) { HashSet<Node> visited = new HashSet<Node>(); for (Node n : list) { visited.add(n); if (visited.contains(n.next)) { return true; } } return false; }
count_of_elements_so_far = 0; for (each element in linked list) { search for current element in first <count_of_elements_so_far> if found, then you have a loop else,count_of_elements_so_far++; }
public boolean hasLoop(Node start){ TreeSet<Node> set = new TreeSet<Node>(); Node lookingAt = start; while (lookingAt.peek() != null){ lookingAt = lookingAt.next; if (set.contains(lookingAt){ return false; } else { set.put(lookingAt); } return true; } public Node peek(){ return this.next; }
public class LinkedNodeList { Node first; Int count; LinkedNodeList(){ first = null; count = 0; } LinkedNodeList(Node n){ if (n.next != null){ throw new error("must start with single node!"); } else { first = n; count = 1; } } public void addNode(Node n){ Node lookingAt = first; while(lookingAt.next != null){ lookingAt = lookingAt.next; } lookingAt.next = n; count++; } public boolean hasLoop(){ int counter = 0; Node lookingAt = first; while(lookingAt.next != null){ counter++; if (count < counter){ return false; } else { lookingAt = lookingAt.next; } } return true; } private class Node{ Node next; .... } }
public boolean findCircularLoop() { Node slower, faster; slower = head; faster = head.next; while (true) { if (faster == null || faster.next == null) return false; else if (slower == faster || slower == faster.next) return true; else { slower = slower.next; faster = faster.next.next; } } }
node present: (present node addr) (next node address) node 1: addr1: 0x100 addr2: 0x200 ( no present node address till this point had 0x200) node 2: addr2: 0x200 addr3: 0x300 ( no present node address till this point had 0x300) node 3: addr3: 0x300 addr4: 0x400 ( no present node address till this point had 0x400) node 4: addr4: 0x400 addr5: 0x500 ( no present node address till this point had 0x500) node 5: addr5: 0x500 addr6: 0x600 ( no present node address till this point had 0x600) node 6: addr6: 0x600 addr4: 0x400 ( ONE present node address till this point had 0x400)
public static boolean checkLoopInLinkedList(LinkedNode root){ if (root == null || root.next == null) return false; LinkedNode current1 = root, current2 = root.next, current3 = root.next.next; root.next = null; current2.next = current1; while(current3 != null){ if(current3 == root) return true; current1 = current2; current2 = current3; current3 = current3.next; current2.next = current1; } return false; }
public class questions{ public static void main(String [] args){ LinkedNode n1 = new LinkedNode(); LinkedNode n2 = new LinkedNode(); LinkedNode n3 = new LinkedNode(); n1.next = n2; n2.next = n3; n3.next = n2; System.out.print(checkLoopInLinkedList(n1)); } }
boolean loop(node *head) { node *back=head; node *front=head; while(front && front->next) { front=front->next->next; if(back==front) return true; else back=back->next; } return false }
boolean hasCycle(Node head) { boolean dec = false; Node first = head; Node sec = head; while(first != null && sec != null) { first = first.next; sec = sec.next.next; if(first == sec ) { dec = true; break; } } return dec; }
public boolean hasCycle(ListNode head) { ListNode slow =head; ListNode fast =head; while(fast!=null && fast.next!=null){ slow = slow.next; fast = fast.next.next; if(slow == fast) return true; } return false; }
public boolean loopDetector(Node<E> first) { Node<E> t = first; Map<Node<E>, Node<E>> map = new IdentityHashMap<Node<E>, Node<E>>(); while (t != null) { if (map.containsKey(t)) { System.out.println(" duplicate Node is --" + t + " having value :" + t.data); return true; } else { map.put(t, t); } t = t.next; } return false; }
boolean detectLoop(Node head){ Node fastRunner = head; Node slowRunner = head; while(fastRunner != null && slowRunner !=null && fastRunner.next != null){ fastRunner = fastRunner.next.next; slowRunner = slowRunner.next; if(fastRunner == slowRunner){ return true; } } return false; }
public boolean isCircular() { if (head == null) return false; Node temp1 = head; Node temp2 = head; try { while (temp2.next != null) { temp2 = temp2.next.next.next; temp1 = temp1.next; if (temp1 == temp2 || temp1 == temp2.next) return true; } } catch (NullPointerException ex) { return false; } return false; }
URL website = new URL("http: ReadableByteChannel rbc = Channels.newChannel(website.openStream()); FileOutputStream fos = new FileOutputStream("information.html"); fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
URL website = new URL("http: try (InputStream in = website.openStream()) { Files.copy(in, target, StandardCopyOption.REPLACE_EXISTING); }
public void saveUrl(final String filename, final String urlString) throws MalformedURLException, IOException { BufferedInputStream in = null; FileOutputStream fout = null; try { in = new BufferedInputStream(new URL(urlString).openStream()); fout = new FileOutputStream(filename); final byte data[] = new byte[1024]; int count; while ((count = in.read(data, 0, 1024)) != -1) { fout.write(data, 0, count); } } finally { if (in != null) { in.close(); } if (fout != null) { fout.close(); } } }
BufferedInputStream in = new BufferedInputStream(new URL("http: byte data[] = new byte[1024]; int count; while((count = in.read(data,0,1024)) != -1) { out.write(data, 0, count); }
private static Path download(String sourceURL, String targetDirectory) throws IOException { URL url = new URL(sourceURL); String fileName = sourceURL.substring(sourceURL.lastIndexOf( Path targetPath = new File(targetDirectory + File.separator + fileName).toPath(); Files.copy(url.openStream(), targetPath, StandardCopyOption.REPLACE_EXISTING); return targetPath; }
public static void download(String url, String fileName) throws Exception { try (InputStream in = URI.create(url).toURL().openStream()) { Files.copy(in, Paths.get(fileName)); } }
public static void downloadFileFromURL(String urlString, File destination) { try { URL website = new URL(urlString); ReadableByteChannel rbc; rbc = Channels.newChannel(website.openStream()); FileOutputStream fos = new FileOutputStream(destination); fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE); fos.close(); rbc.close(); } catch (IOException e) { e.printStackTrace(); } }
import java.io.*; import java.net.*; public class filedown { public static void download(String address, String localFileName) { OutputStream out = null; URLConnection conn = null; InputStream in = null; try { URL url = new URL(address); out = new BufferedOutputStream(new FileOutputStream(localFileName)); conn = url.openConnection(); in = conn.getInputStream(); byte[] buffer = new byte[1024]; int numRead; long numWritten = 0; while ((numRead = in.read(buffer)) != -1) { out.write(buffer, 0, numRead); numWritten += numRead; } System.out.println(localFileName + "\t" + numWritten); } catch (Exception exception) { exception.printStackTrace(); } finally { try { if (in != null) { in.close(); } if (out != null) { out.close(); } } catch (IOException ioe) { } } } public static void download(String address) { int lastSlashIndex = address.lastIndexOf( if (lastSlashIndex >= 0 && lastSlashIndex < address.length() - 1) { download(address, (new URL(address)).getFile()); } else { System.err.println("Could not figure out local file name for "+address); } } public static void main(String[] args) { for (int i = 0; i < args.length; i++) { download(args[i]); } } }
public static void downloadFileFromURL(String urlString, File destination) throws Throwable { URL website = new URL(urlString); try( ReadableByteChannel rbc = Channels.newChannel(website.openStream()); FileOutputStream fos = new FileOutputStream(destination); ){ fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE); } }
/** * Downloads from a (http/https) URL and saves to a file. * Does not consider a connection error an Exception. Instead it returns: * * 0=ok * 1=connection interrupted, timeout (but something was read) * 2=not found (FileNotFoundException) (404) * 3=server error (500...) * 4=could not connect: connection timeout (no internet?) java.net.SocketTimeoutException * 5=could not connect: (server down?) java.net.ConnectException * 6=could not resolve host (bad host, or no internet - no dns) * * @param file File to write. Parent directory will be created if necessary * @param url http/https url to connect * @param secsConnectTimeout Seconds to wait for connection establishment * @param secsReadTimeout Read timeout in seconds - trasmission will abort if it freezes more than this * @return See above * @throws IOException Only if URL is malformed or if could not create the file */ public static int saveUrl(final Path file, final URL url, int secsConnectTimeout, int secsReadTimeout) throws IOException { Files.createDirectories(file.getParent()); URLConnection conn = url.openConnection(); if( secsConnectTimeout > 0 ) conn.setConnectTimeout(secsConnectTimeout * 1000); if( secsReadTimeout > 0 ) conn.setReadTimeout(secsReadTimeout * 1000); int ret = 0; boolean somethingRead = false; try (InputStream is = conn.getInputStream()) { try (BufferedInputStream in = new BufferedInputStream(is); OutputStream fout = Files .newOutputStream(file)) { final byte data[] = new byte[8192]; int count; while((count = in.read(data)) > 0) { somethingRead = true; fout.write(data, 0, count); } } } catch(java.io.IOException e) { int httpcode = 999; try { httpcode = ((HttpURLConnection) conn).getResponseCode(); } catch(Exception ee) {} if( somethingRead && e instanceof java.net.SocketTimeoutException ) ret = 1; else if( e instanceof FileNotFoundException && httpcode >= 400 && httpcode < 500 ) ret = 2; else if( httpcode >= 400 && httpcode < 600 ) ret = 3; else if( e instanceof java.net.SocketTimeoutException ) ret = 4; else if( e instanceof java.net.ConnectException ) ret = 5; else if( e instanceof java.net.UnknownHostException ) ret = 6; else throw e; } return ret; }
org.apache.commons.io.FileUtils.copyURLToFile(URL, File)
GetMethod method = new GetMethod(resource_url); try { int statusCode = client.executeMethod(method); if (statusCode != HttpStatus.SC_OK) { logger.error("Get method failed: " + method.getStatusLine()); } org.apache.commons.io.FileUtils.copyInputStreamToFile( method.getResponseBodyAsStream(), new File(resource_file)); } catch (HttpException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { method.releaseConnection(); }
public static boolean saveFile(URL fileURL, String fileSavePath) { boolean isSucceed = true; CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet(fileURL.toString()); httpGet.addHeader("User-Agent", "Mozilla/5.0 (Windows NT 6.3; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0"); httpGet.addHeader("Referer", "https: try { CloseableHttpResponse httpResponse = httpClient.execute(httpGet); HttpEntity fileEntity = httpResponse.getEntity(); if (fileEntity != null) { FileUtils.copyInputStreamToFile(fileEntity.getContent(), new File(fileSavePath)); } } catch (IOException e) { isSucceed = false; } httpGet.releaseConnection(); return isSucceed; }
FileUtils.copyURLToFile(fileURL, new File(fileSavePath), URLS_FETCH_TIMEOUT, URLS_FETCH_TIMEOUT);
public static void saveUrl1(final Path file, final URL url, int secsConnectTimeout, int secsReadTimeout)) throws MalformedURLException, IOException { try (BufferedInputStream in = new BufferedInputStream( streamFromUrl(url, secsConnectTimeout,secsReadTimeout) ); OutputStream fout = Files.newOutputStream(file)) { final byte data[] = new byte[8192]; int count; while((count = in.read(data)) > 0) fout.write(data, 0, count); } } public static void saveUrl2(final Path file, final URL url, int secsConnectTimeout, int secsReadTimeout)) throws MalformedURLException, IOException { try (ReadableByteChannel rbc = Channels.newChannel( streamFromUrl(url, secsConnectTimeout,secsReadTimeout) ); FileChannel channel = FileChannel.open(file, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE) ) { channel.transferFrom(rbc, 0, Long.MAX_VALUE); } } public static void saveUrl3(final Path file, final URL url, int secsConnectTimeout, int secsReadTimeout)) throws MalformedURLException, IOException { try (InputStream in = streamFromUrl(url, secsConnectTimeout,secsReadTimeout) ) { Files.copy(in, file, StandardCopyOption.REPLACE_EXISTING); } } public static InputStream streamFromUrl(URL url,int secsConnectTimeout,int secsReadTimeout) throws IOException { URLConnection conn = url.openConnection(); if(secsConnectTimeout>0) conn.setConnectTimeout(secsConnectTimeout*1000); if(secsReadTimeout>0) conn.setReadTimeout(secsReadTimeout*1000); return conn.getInputStream(); }
<groupId>com.github.javadev</groupId> <artifactId>underscore</artifactId> <version>1.40</version>
import com.github.underscore.lodash.U; public class Download { public static void main(String ... args) { String text = U.fetch("https: + "/921262/how-to-download-and-save-a-file-from-internet-using-java").text(); } }
public class DownloadManager { static String urls = "[WEBSITE NAME]"; public static void main(String[] args) throws IOException{ URL url = verify(urls); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); InputStream in = null; String filename = url.getFile(); filename = filename.substring(filename.lastIndexOf( FileOutputStream out = new FileOutputStream("C:\\Java2_programiranje/Network/DownloadTest1/Project/Output" + File.separator + filename); in = connection.getInputStream(); int read = -1; byte[] buffer = new byte[4096]; while((read = in.read(buffer)) != -1){ out.write(buffer, 0, read); System.out.println("[SYSTEM/INFO]: Downloading file..."); } in.close(); out.close(); System.out.println("[SYSTEM/INFO]: File Downloaded!"); } private static URL verify(String url){ if(!url.toLowerCase().startsWith("http: return null; } URL verifyUrl = null; try{ verifyUrl = new URL(url); }catch(Exception e){ e.printStackTrace(); } return verifyUrl; } }
Properties systemSettings = System.getProperties(); systemSettings.put("proxySet", "true"); systemSettings.put("https.proxyHost", "https proxy of your org"); systemSettings.put("https.proxyPort", "8080");
public static void main(String[] args) throws IOException { String url="https: OutputStream outStream=null; URLConnection connection=null; InputStream is=null; File targetFile=null; URL server=null; Properties systemSettings = System.getProperties(); systemSettings.put("proxySet", "true"); systemSettings.put("https.proxyHost", "https proxy of my organisation"); systemSettings.put("https.proxyPort", "8080"); System.setProperty("java.net.useSystemProxies", "true"); try { server=new URL(url); connection = server.openConnection(); is = connection.getInputStream(); byte[] buffer = new byte[is.available()]; is.read(buffer); targetFile = new File("src/main/resources/targetFile.java"); outStream = new FileOutputStream(targetFile); outStream.write(buffer); } catch (MalformedURLException e) { System.out.println("THE URL IS NOT CORRECT "); e.printStackTrace(); } catch (IOException e) { System.out.println("Io exception"); e.printStackTrace(); } finally{ if(outStream!=null) outStream.close(); } }
URL url = new URL("http: BufferedInputStream bufferedInputStream = new BufferedInputStream(url.openStream()); FileOutputStream stream = new FileOutputStream("/home/sachin/Desktop/test.mkv"); int count=0; byte[] b1 = new byte[100]; while((count = bufferedInputStream.read(b1)) != -1) { System.out.println("b1:"+b1+">>"+count+ ">> KB downloaded:"+new File("/home/sachin/Desktop/test.mkv").length()/1024); stream.write(b1, 0, count); }
public static <T, E> Set<T> getKeysByValue(Map<T, E> map, E value) { Set<T> keys = new HashSet<T>(); for (Entry<T, E> entry : map.entrySet()) { if (Objects.equals(value, entry.getValue())) { keys.add(entry.getKey()); } } return keys; }
public static <T, E> T getKeyByValue(Map<T, E> map, E value) { for (Entry<T, E> entry : map.entrySet()) { if (Objects.equals(value, entry.getValue())) { return entry.getKey(); } } return null; }
public static <T, E> Set<T> getKeysByValue(Map<T, E> map, E value) { return map.entrySet() .stream() .filter(entry -> Objects.equals(entry.getValue(), value)) .map(Map.Entry::getKey) .collect(Collectors.toSet()); }
BiMap<Token, Character> tokenToChar = ImmutableBiMap.of(Token.LEFT_BRACKET, Token token = tokenToChar.inverse().get( Character c = tokenToChar.get(token);
public class NewClass1 { public static void main(String[] args) { Map<Integer, String> testMap = new HashMap<Integer, String>(); testMap.put(10, "a"); testMap.put(20, "b"); testMap.put(30, "c"); testMap.put(40, "d"); for (Entry<Integer, String> entry : testMap.entrySet()) { if (entry.getValue().equals("c")) { System.out.println(entry.getKey()); } } } }
map.put("theKey", "theValue"); map.put("theValue", "theKey");
class MyMap<K,V> extends HashMap<K, V>{ Map<V,K> reverseMap = new HashMap<V,K>(); @Override public V put(K key, V value) { reverseMap.put(value, key); return super.put(key, value); } public K getKey(V value){ return reverseMap.get(value); } }
import java.util.HashMap; import java.util.Map; public class Main { public static void main(String[] argv) { Map<String, String> map = new HashMap<String, String>(); map.put("1","one"); map.put("2","two"); map.put("3","three"); map.put("4","four"); System.out.println(getKeyFromValue(map,"three")); } public static Object getKeyFromValue(Map hm, Object value) { for (Object o : hm.keySet()) { if (hm.get(o).equals(value)) { return o; } } return null; } }
getKeyFromValue(hashMap, item); System.out.println("getKeyFromValue(hashMap, item): "+getKeyFromValue(hashMap, item));
public class KeyValue { public Object key; public Object value; public KeyValue(Object key, Object value) { ... } } map.put(key, new KeyValue(key, value));
Iterator<Map.Entry<String,String>> iter = map.entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String,String> entry = iter.next(); if (entry.getValue().equals(value_you_look_for)) { String key_you_look_for = entry.getKey(); } }
for(int key: hm.keySet()) { if(hm.get(key).equals(value)) { System.out.println(key); } }
ftw.forEach((key, value) -> { if (value=="foo") { System.out.print(key); } });
public <K, V> K getKeyByValue(Map<K, V> map, V value) { for (Map.Entry<K, V> entry : map.entrySet()) { if (value.equals(entry.getValue())) { return entry.getKey(); } } return null; }
public class HashmapKeyExist { public static void main(String[] args) { HashMap<String, String> hmap = new HashMap<String, String>(); hmap.put("1", "Bala"); hmap.put("2", "Test"); Boolean cantain = hmap.containsValue("Bala"); if(hmap.containsKey("2") && hmap.containsValue("Test")) { System.out.println("Yes"); } if(cantain == true) { System.out.println("Yes"); } Set setkeys = hmap.keySet(); Iterator it = setkeys.iterator(); while(it.hasNext()) { String key = (String) it.next(); if (hmap.get(key).equals("Bala")) { System.out.println(key); } } } }
ArrayList valuesList = new ArrayList(); Set keySet = initalMap.keySet(); ArrayList keyList = new ArrayList(keySet); for(int i = 0 ; i < keyList.size() ; i++ ) { valuesList.add(initalMap.get(keyList.get(i))); } Collections.sort(valuesList); Map finalMap = new TreeMap(); for(int i = 0 ; i < valuesList.size() ; i++ ) { String value = (String) valuesList.get(i); for( int j = 0 ; j < keyList.size() ; j++ ) { if(initalMap.get(keyList.get(j)).equals(value)) { finalMap.put(keyList.get(j),value); } } } System.out.println("fianl map ----------------------> " + finalMap);
public static class SmartHashMap <T1 extends Object, T2 extends Object> { public HashMap<T1, T2> keyValue; public HashMap<T2, T1> valueKey; public SmartHashMap(){ this.keyValue = new HashMap<T1, T2>(); this.valueKey = new HashMap<T2, T1>(); } public void add(T1 key, T2 value){ this.keyValue.put(key, value); this.valueKey.put(value, key); } public T2 getValue(T1 key){ return this.keyValue.get(key); } public T1 getKey(T2 value){ return this.valueKey.get(value); } }
public static String getKey(Map<String, Integer> mapref, String value) { String key = ""; for (Map.Entry<String, Integer> map : mapref.entrySet()) { if (map.getValue().toString().equals(value)) { key = map.getKey(); } } return key; }
import java.util.HashMap; import java.util.HashSet; import java.util.Set; public class ValueKeysMap<K, V> extends HashMap <K,V>{ HashMap<V, Set<K>> ValueKeysMap = new HashMap<V, Set<K>>(); @Override public boolean containsValue(Object value) { return ValueKeysMap.containsKey(value); } @Override public V put(K key, V value) { if (containsValue(value)) { Set<K> keys = ValueKeysMap.get(value); keys.add(key); } else { Set<K> keys = new HashSet<K>(); keys.add(key); ValueKeysMap.put(value, keys); } return super.put(key, value); } @Override public V remove(Object key) { V value = super.remove(key); Set<K> keys = ValueKeysMap.get(value); keys.remove(key); if(keys.size() == 0) { ValueKeysMap.remove(value); } return value; } public Set<K> getKeys4ThisValue(V value){ Set<K> keys = ValueKeysMap.get(value); return keys; } public boolean valueContainsThisKey(K key, V value){ if (containsValue(value)) { Set<K> keys = ValueKeysMap.get(value); return keys.contains(key); } return false; } /* * Take care of argument constructor and other api */ }
/** * This method gets the Key for the given Value * @param paramName * @return */ private String getKeyForValueFromMap(String paramName) { String keyForValue = null; if(paramName!=null)) { Set<Entry<String,String>> entrySet = myMap().entrySet(); if(entrySet!=null && entrySet.size>0) { for(Entry<String,String> entry : entrySet) { if(entry!=null && paramName.equalsIgnoreCase(entry.getValue())) { keyForValue = entry.getKey(); } } } } return keyForValue; }
import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Set; public class M{ public static void main(String[] args) { HashMap<String, List<String>> resultHashMap = new HashMap<String, List<String>>(); Set<String> newKeyList = resultHashMap.keySet(); for (Iterator<String> iterator = originalHashMap.keySet().iterator(); iterator.hasNext();) { String hashKey = (String) iterator.next(); if (!newKeyList.contains(originalHashMap.get(hashKey))) { List<String> loArrayList = new ArrayList<String>(); loArrayList.add(hashKey); resultHashMap.put(originalHashMap.get(hashKey), loArrayList); } else { List<String> loArrayList = resultHashMap.get(originalHashMap .get(hashKey)); loArrayList.add(hashKey); resultHashMap.put(originalHashMap.get(hashKey), loArrayList); } } System.out.println("Original HashMap : " + originalHashMap); System.out.println("Result HashMap : " + resultHashMap); } }
import java.util.Collections; import java.util.HashMap; import java.util.Map; public class HMap<K, V> { private final Map<K, Map<K, V>> map; public HMap() { map = new HashMap<K, Map<K, V>>(); } public HMap(final int initialCapacity) { map = new HashMap<K, Map<K, V>>(initialCapacity); } public boolean containsKey(final Object key) { return map.containsKey(key); } public V get(final Object key) { final Map<K, V> entry = map.get(key); if (entry != null) return entry.values().iterator().next(); return null; } public K getKey(final Object key) { final Map<K, V> entry = map.get(key); if (entry != null) return entry.keySet().iterator().next(); return null; } public V put(final K key, final V value) { final Map<K, V> entry = map .put(key, Collections.singletonMap(key, value)); if (entry != null) return entry.values().iterator().next(); return null; } }
String[] keys = yourMap.keySet().toArray(new String[0]); for(int i = 0 ; i < keys.length ; i++){ String key = keys[i]; yourMap.get(key) }
/** * Both key and value types must define equals() and hashCode() for this to work. * This takes into account that all keys are unique but all values may not be. * * @param map * @param <K> * @param <V> * @return */ public static <K, V> Map<V, List<K>> reverseMap(Map<K,V> map) { if(map == null) return null; Map<V, List<K>> reverseMap = new ArrayMap<>(); for(Map.Entry<K,V> entry : map.entrySet()) { appendValueToMapList(reverseMap, entry.getValue(), entry.getKey()); } return reverseMap; } /** * Takes into account that the list may already have values. * * @param map * @param key * @param value * @param <K> * @param <V> * @return */ public static <K, V> Map<K, List<V>> appendValueToMapList(Map<K, List<V>> map, K key, V value) { if(map == null || key == null || value == null) return map; List<V> list = map.get(key); if(list == null) { List<V> newList = new ArrayList<>(); newList.add(value); map.put(key, newList); } else { list.add(value); } return map; }
map.entrySet().stream().filter(entry -> entry.getValue().equals(value)) .forEach(entry -> System.out.println(entry.getKey()));
for (int key : map.keySet()) { if (map.get(key) == value) { res.add(key); } }
for (Map.Entry s : map.entrySet()) { if ((int)s.getValue() == value) { res.add((int)s.getKey()); } }
package hello; public class Hello { Clock clock = new Clock(); public static void main(String args[]) { clock.sayTime(); } }
public class Example { private static boolean staticField; private boolean instanceField; public static void main(String[] args) { staticField = true; Example instance = new Example(); instance.instanceField = true; }
package hello; public class Hello { public static void main(String args[]) { Clock clock=new Clock(); clock.sayTime(); } }
Thread.currentThread().sleep(5000); someOtherThread.sleep(5000);
public class Hello { public static String staticValue; public String nonStaticValue; } class A { Hello hello = new Hello(); hello.staticValue = "abc"; hello.nonStaticValue = "xyz"; } class B { Hello hello2 = new Hello(); hello2.staticValue; hello2.nonStaticValue; }
Hello hello = new Hello(); hello.staticValue = "abc";
package pkg; class StaticExample { int count = 0; StaticExample() { count++; System.out.println(count); } public static void main(String args[]) { StaticExample c1 = new StaticExample(); StaticExample c2 = new StaticExample(); StaticExample c3 = new StaticExample(); } }
package pkg; class StaticExample { static int count = 0; StaticExample() { count++; System.out.println(count); } public static void main(String args[]) { StaticExample c1 = new StaticExample(); StaticExample c2 = new StaticExample(); StaticExample c3 = new StaticExample(); } }
package hello; public class Hello { private Clock clock = new Clock(); public Clock getClock() { return clock; } public static void main(String args[]) { Hello hello = new Hello(); hello.getClock().sayTime(); } }
public class StaticPractise1 { public static void main(String[] args) { StaticPractise2 staticPractise2 = new StaticPractise2(); staticPractise2.printUddhav(); StaticPractise2.printUddhav(); /* false, because printUddhav() is although inside StaticPractise2, but it is where exactly depends on PC program counter on runtime. */ StaticPractise2.printUddhavsStatic1(); staticPractise2.printUddhavsStatic1(); } }
public class StaticPractise2 { public static void printUddhavsStatic1() { System.out.println("Uddhav"); } public void printUddhav() { System.out.println("Uddhav"); } }
class A { int a = 40; public static void main(String args[]) { System.out.println(a); } }
public class Static { private static String owner; private static int rent; private String car; public String getCar() { return car; } public void setCar(String car) { this.car = car; } public static int getRent() { return rent; } public static void setRent(int rent) { Static.rent = rent; } public static String getOwner() { return owner; } public static void setOwner(String owner) { Static.owner = owner; } }
public class StaticClass { static int version; public void printVersion() { System.out.println(version); } } public class MainClass { public static void main(String args[]) { StaticClass staticVar1 = new StaticClass(); staticVar1.version = 10; staticVar1.printVersion() StaticClass staticVar2 = new StaticClass(); staticVar2.printVersion() staticVar2.version = 20; staticVar2.printVersion() staticVar1.printVersion() } }
Map<String, String> map = new LinkedHashMap<String, String>(); map.put("id", "1"); map.put("name", "rohan"); map.put("age", "26"); for (Map.Entry<String, String> entry : map.entrySet()) { System.out.println(entry.getKey() + " = " + entry.getValue()); }
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>
public static double round(double value, int places) { if (places < 0) throw new IllegalArgumentException(); long factor = (long) Math.pow(10, places); value = value * factor; long tmp = Math.round(value); return (double) tmp / factor; }
public static double round(double value, int places) { if (places < 0) throw new IllegalArgumentException(); BigDecimal bd = new BigDecimal(value); bd = bd.setScale(places, RoundingMode.HALF_UP); return bd.doubleValue(); }
System.out.println(new BigDecimal(1.03).subtract(new BigDecimal(0.41))); System.out.println(new BigDecimal("1.03").subtract(new BigDecimal("0.41")));
double value = 200.3456; System.out.printf("Value: %.2f", value);
DecimalFormat df = new DecimalFormat(" System.out.println("Value: " + df.format(value));
double time = 200.3456; DecimalFormat df = new DecimalFormat(" time = Double.valueOf(df.format(time)); System.out.println(time);
double val = ....; val = val*100; val = Math.round(val); val = val /100;
double val = ....; val = val*100; val = (double)((int) val); val = val /100;
function Double round2(Double val) { return new BigDecimal(val.toString()).setScale(2,RoundingMode.HALF_UP).doubleValue(); }
new BigDecimal(val.toString()).setScale(2,RoundingMode.HALF_UP).doubleValue() Double val = 260.775d; 260.77 - WRONG - new BigDecimal(val).setScale(2,RoundingMode.HALF_UP).doubleValue() Double val = 260.775d; 260.77 - TRY AGAIN - Math.round(val * 100.d) / 100.0d Double val = 256.025d; 256.02 - OOPS - new DecimalFormat("0.00").format(val) Double val = 256.025d; 256.02 - FAIL - (int)(val * 100 + 0.5) / 100.0;
double value= 200.3456; DecimalFormat df = new DecimalFormat("0.00"); System.out.println(df.format(value));
double d = 28786.079999999998; String str = String.format("%1.2f", d); d = Double.valueOf(str);
new BigDecimal(myValue).setScale(2, RoundingMode.HALF_UP).doubleValue();
200.3456 * 100 = 20034.56; (int) 20034.56 = 20034; 20034/100.0 = 200.34;
org.hamcrest.Matchers.* org.hamcrest.CoreMatchers.* org.junit.* org.junit.Assert.* org.junit.Assume.* org.junit.matchers.JUnitMatchers.*
org.springframework.test.web.servlet.request.MockMvcRequestBuilders org.springframework.test.web.servlet.request.MockMvcResponseBuilders org.springframework.test.web.servlet.result.MockMvcResultHandlers org.springframework.test.web.servlet.result.MockMvcResultMatchers org.springframework.test.web.servlet.setup.MockMvcBuilders org.mockito.Mockito
jar { doFirst { from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } } exclude }
<target name="jar" depends="compile" description="Create one big jarfile."> <jar jarfile="${output.dir}/deps.jar"> <zipgroupfileset dir="jars"> <include name="**/*.jar" /> </zipgroupfileset> </jar> <sleep seconds="1" /> <jar jarfile="${output.dir}/myjar.jar" basedir="${classes.dir}"> <zipfileset src="${output.dir}/deps.jar" excludes="META-INF/*.SF" /> <manifest> <attribute name="Main-Class" value="com.mycompany.MyMain" /> </manifest> </jar> </target>
java.security.NoSuchAlgorithmException: PBEWithSHA256And256BitAES-CBC-BC SecretKeyFactory not available
SecretKeyFactory.getInstance("PBEWithSHA256And256BitAES-CBC-BC","BC");
java.security.NoSuchProviderException: JCE cannot authenticate the provider BC
<plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-shade-plugin</artifactId> <version>3.1.0</version> <executions> <execution> <phase>package</phase> <goals> <goal>shade</goal> </goals> <configuration> <filters> <filter> <artifact>org.bouncycastle:*</artifact> <excludes> <exclude>META-INF/*.SF</exclude> <exclude>META-INF/*.DSA</exclude> <exclude>META-INF/*.RSA</exclude> </excludes> </filter> </filters> <transformers> <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"> <mainClass>your.class.here</mainClass> </transformer> </transformers> <shadedArtifactAttached>true</shadedArtifactAttached> </configuration> </execution> </executions> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-jarsigner-plugin</artifactId> <version>1.4</version> <executions> <execution> <id>sign</id> <goals> <goal>sign</goal> </goals> </execution> <execution> <id>verify</id> <goals> <goal>verify</goal> </goals> </execution> </executions> <configuration> <keystore>/path/to/myKeystore</keystore> <alias>myfirstkey</alias> <storepass>111111</storepass> <keypass>111111</keypass> </configuration> </plugin>
<jar destfile="app.jar" basedir="${classes.dir}"> <zipfileset excludes="META-INF/**/*" src="${lib.dir}/bcprov-jdk16-145.jar"></zipfileset> <manifest> <attribute name="Main-Class" value="app.Main"/> </manifest> </jar>
version = task fatJar(type: Jar) { manifest { attributes } baseName = project.name + from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } exclude with jar }
<macrodef name="unsignjar" description="To unsign a specific Jar file"> <attribute name="jarfile" description="The jar file to unsign" /> <sequential> <!-- Copying to the temporary manifest file --> <copy toFile="@{jarFile}_MANIFEST.tmp"> <resources> <zipentry zipfile="@{jarFile}" name="META-INF/MANIFEST.MF"/> </resources> </copy> <!-- Removing the Name and SHA entries from the temporary file --> <replaceregexp file="@{jarFile}_MANIFEST.tmp" match="\nName:(.+?)\nSH" replace="SH" flags="gis" byline="false"/> <replaceregexp file="@{jarFile}_MANIFEST.tmp" match="SHA(.*)" replace="" flags="gis" byline="false"/> <!-- Creating a temporary Jar file with the temporary manifest --> <jar jarfile="@{jarFile}.tmp" manifest="@{jarFile}_MANIFEST.tmp"> <zipfileset src="@{jarFile}"> <include name="**"/> <exclude name="META-INF/*.SF"/> <exclude name="META-INF/*.DSA"/> <exclude name="META-INF/*.RSA"/> </zipfileset> </jar> <!-- Removing the temporary manifest --> <delete file="@{jarFile}_MANIFEST.tmp" /> <!-- Swapping the original Jar file with the temporary one --> <move file="@{jarFile}.tmp" tofile="@{jarFile}" overwrite="true" /> </sequential>
<target name="unsignJar"> <unsignjar jarFile="org.test.myjartounsign.jar" /> </target>
deleting: META-INF/ECLIPSE_.SF deleting: META-INF/ECLIPSE_.RSA
jar { from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } exclude manifest { attributes } }
public List<String> getALegacyListReversed() { @SuppressWarnings("unchecked") List<String> list = (List<String>)legacyLibrary.getStringList(); Collections.reverse(list); return list; }
@SuppressWarnings("unchecked") public List<User> findAllUsers(){ Query query = entitymanager.createQuery("SELECT u FROM User u"); return (List<User>)query.getResultList(); }
@SuppressWarnings("unchecked") public List<ReservationMealPlan> retreiveMealPlan() { List<ReservationMealPlan> list=new ArrayList<ReservationMealPlan>(); TestMenuService testMenuService=new TestMenuService(em, this.selectedInstance); list = testMenuService.getMeal(reservationMealPlan); return list; }
public interface LoadFutures extends Map<UUID, Future<LoadResult>> {}
Object obj = context.getAttribute(FUTURES); if (!(obj instanceof LoadFutures)) { String format = "Servlet context attribute \"%s\" is not of type " + "LoadFutures. Its type is %s."; String msg = String.format(format, FUTURES, obj.getClass()); throw new RuntimeException(msg); } return (LoadFutures) obj;
List<String> hello = List.of("a", "b"); String example = hello.get(0);
List hello = List.of("a", "b"); String example = (String) hello.get(0);
Object list = List.of("a", "b"); List<Integer> actualList = (List<Integer>) list;
java.lang.ClassCastException: java.base/java.lang.String cannot be cast to java.base/java.lang.Integer
private static final Optional<?> EMPTY = new Optional<>(); public static<T> Optional<T> empty() { @SuppressWarnings("unchecked") Optional<T> t = (Optional<T>) EMPTY; return t; }
@Path("/authentication") public class AuthenticationEndpoint { @POST @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_FORM_URLENCODED) public Response authenticateUser(@FormParam("username") String username, @FormParam("password") String password) { try { authenticate(username, password); String token = issueToken(username); return Response.ok(token).build(); } catch (Exception e) { return Response.status(Response.Status.FORBIDDEN).build(); } } private void authenticate(String username, String password) throws Exception { } private String issueToken(String username) { } }
public class Credentials implements Serializable { private String username; private String password; }
@POST @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public Response authenticateUser(Credentials credentials) { String username = credentials.getUsername(); String password = credentials.getPassword(); }
@NameBinding @Retention(RUNTIME) @Target({TYPE, METHOD}) public @interface Secured { }
@Secured @Provider @Priority(Priorities.AUTHENTICATION) public class AuthenticationFilter implements ContainerRequestFilter { private static final String REALM = "example"; private static final String AUTHENTICATION_SCHEME = "Bearer"; @Override public void filter(ContainerRequestContext requestContext) throws IOException { String authorizationHeader = requestContext.getHeaderString(HttpHeaders.AUTHORIZATION); if (!isTokenBasedAuthentication(authorizationHeader)) { abortWithUnauthorized(requestContext); return; } String token = authorizationHeader .substring(AUTHENTICATION_SCHEME.length()).trim(); try { validateToken(token); } catch (Exception e) { abortWithUnauthorized(requestContext); } } private boolean isTokenBasedAuthentication(String authorizationHeader) { return authorizationHeader != null && authorizationHeader.toLowerCase() .startsWith(AUTHENTICATION_SCHEME.toLowerCase() + " "); } private void abortWithUnauthorized(ContainerRequestContext requestContext) { requestContext.abortWith( Response.status(Response.Status.UNAUTHORIZED) .header(HttpHeaders.WWW_AUTHENTICATE, AUTHENTICATION_SCHEME + " realm=\"" + REALM + "\"") .build()); } private void validateToken(String token) throws Exception { } }
@Path("/example") public class ExampleResource { @GET @Path("{id}") @Produces(MediaType.APPLICATION_JSON) public Response myUnsecuredMethod(@PathParam("id") Long id) { ... } @DELETE @Secured @Path("{id}") @Produces(MediaType.APPLICATION_JSON) public Response mySecuredMethod(@PathParam("id") Long id) { ... } }
final SecurityContext currentSecurityContext = requestContext.getSecurityContext(); requestContext.setSecurityContext(new SecurityContext() { @Override public Principal getUserPrincipal() { return () -> username; } @Override public boolean isUserInRole(String role) { return true; } @Override public boolean isSecure() { return currentSecurityContext.isSecure(); } @Override public String getAuthenticationScheme() { return AUTHENTICATION_SCHEME; } });
@GET @Secured @Path("{id}") @Produces(MediaType.APPLICATION_JSON) public Response myMethod(@PathParam("id") Long id, @Context SecurityContext securityContext) { ... }
Principal principal = securityContext.getUserPrincipal(); String username = principal.getName();
@Qualifier @Retention(RUNTIME) @Target({ METHOD, FIELD, PARAMETER }) public @interface AuthenticatedUser { }
@Inject @AuthenticatedUser Event<String> userAuthenticatedEvent;
@RequestScoped public class AuthenticatedUserProducer { @Produces @RequestScoped @AuthenticatedUser private User authenticatedUser; public void handleAuthenticationEvent(@Observes @AuthenticatedUser String username) { this.authenticatedUser = findUser(username); } private User findUser(String username) { } }
Random random = new SecureRandom(); String token = new BigInteger(130, random).toString(32);
@NameBinding @Retention(RUNTIME) @Target({TYPE, METHOD}) public @interface Secured { Role[] value() default {}; }
@Path("/example") @Secured({Role.ROLE_1}) public class ExampleResource { @GET @Path("{id}") @Produces(MediaType.APPLICATION_JSON) public Response myMethod(@PathParam("id") Long id) { ... } @DELETE @Path("{id}") @Produces(MediaType.APPLICATION_JSON) @Secured({Role.ROLE_1, Role.ROLE_2}) public Response myOtherMethod(@PathParam("id") Long id) { ... } }
@Secured @Provider @Priority(Priorities.AUTHORIZATION) public class AuthorizationFilter implements ContainerRequestFilter { @Context private ResourceInfo resourceInfo; @Override public void filter(ContainerRequestContext requestContext) throws IOException { Class<?> resourceClass = resourceInfo.getResourceClass(); List<Role> classRoles = extractRoles(resourceClass); Method resourceMethod = resourceInfo.getResourceMethod(); List<Role> methodRoles = extractRoles(resourceMethod); try { if (methodRoles.isEmpty()) { checkPermissions(classRoles); } else { checkPermissions(methodRoles); } } catch (Exception e) { requestContext.abortWith( Response.status(Response.Status.FORBIDDEN).build()); } } private List<Role> extractRoles(AnnotatedElement annotatedElement) { if (annotatedElement == null) { return new ArrayList<Role>(); } else { Secured secured = annotatedElement.getAnnotation(Secured.class); if (secured == null) { return new ArrayList<Role>(); } else { Role[] allowedRoles = secured.value(); return Arrays.asList(allowedRoles); } } } private void checkPermissions(List<Role> allowedRoles) throws Exception { } }
@Provider @Priority(Priorities.AUTHORIZATION) public class AuthorizationFilter implements ContainerRequestFilter { @Context private ResourceInfo resourceInfo; @Override public void filter(ContainerRequestContext requestContext) throws IOException { Method method = resourceInfo.getResourceMethod(); if (method.isAnnotationPresent(DenyAll.class)) { refuseRequest(); } RolesAllowed rolesAllowed = method.getAnnotation(RolesAllowed.class); if (rolesAllowed != null) { performAuthorization(rolesAllowed.value(), requestContext); return; } if (method.isAnnotationPresent(PermitAll.class)) { return; } rolesAllowed = resourceInfo.getResourceClass().getAnnotation(RolesAllowed.class); if (rolesAllowed != null) { performAuthorization(rolesAllowed.value(), requestContext); } if (resourceInfo.getResourceClass().isAnnotationPresent(PermitAll.class)) { return; } if (!isAuthenticated(requestContext)) { refuseRequest(); } } /** * Perform authorization based on roles. * * @param rolesAllowed * @param requestContext */ private void performAuthorization(String[] rolesAllowed, ContainerRequestContext requestContext) { if (rolesAllowed.length > 0 && !isAuthenticated(requestContext)) { refuseRequest(); } for (final String role : rolesAllowed) { if (requestContext.getSecurityContext().isUserInRole(role)) { return; } } refuseRequest(); } /** * Check if the user is authenticated. * * @param requestContext * @return */ private boolean isAuthenticated(final ContainerRequestContext requestContext) { } /** * Refuse the request. */ private void refuseRequest() { throw new AccessDeniedException( "You don } }
EditText t = (EditText )getView(R.id.myEditText); Boolean isFalse = t.getText().equals("OK");
CharSequence myString = "hello"; CharSequence mySpannableStringBuilder = new SpannableStringBuilder();
public int getLength(CharSequence text) { return text.length(); }
String myString = "hello"; getLength(myString); public int getLength(CharSequence text) { return text.length(); }
CharSequence myString = "hello"; getLength(myString); public int getLength(String text) { return text.length(); }
String ext1 = FilenameUtils.getExtension("/path/to/file/foo.txt"); String ext2 = FilenameUtils.getExtension("bar.exe");
String extension = ""; int i = fileName.lastIndexOf( if (i > 0) { extension = fileName.substring(i+1); }
String extension = ""; int i = fileName.lastIndexOf( int p = Math.max(fileName.lastIndexOf( if (i > p) { extension = fileName.substring(i+1); }
private String getFileExtension(File file) { String name = file.getName(); int lastIndexOf = name.lastIndexOf("."); if (lastIndexOf == -1) { return ""; } return name.substring(lastIndexOf); }
String path = "c:/path/to/file/foo.txt"; String ext = Files.getFileExtension(path); System.out.println(ext);
String filename = Files.getNameWithoutExtension(path); System.out.println(filename);
String ext = android.webkit.MimeTypeMap.getFileExtensionFromUrl(file.getName());
String extension = ""; int i = fileName.lastIndexOf( if (i >= 0) { extension = fileName.substring(i+1); }
"file.doc" => "doc" "file.doc.gz" => "gz" ".doc" => "doc"
public static String getExtension(String fileName) { char ch; int len; if(fileName==null || (len = fileName.length())==0 || (ch = fileName.charAt(len-1))== ch== return ""; int dotInd = fileName.lastIndexOf( sepInd = Math.max(fileName.lastIndexOf( if( dotInd<=sepInd ) return ""; else return fileName.substring(dotInd+1).toLowerCase(); }
@Test public void testGetExtension() { assertEquals("", getExtension("C")); assertEquals("ext", getExtension("C.ext")); assertEquals("ext", getExtension("A/B/C.ext")); assertEquals("", getExtension("A/B/C.ext/")); assertEquals("", getExtension("A/B/C.ext/..")); assertEquals("bin", getExtension("A/B/C.bin")); assertEquals("hidden", getExtension(".hidden")); assertEquals("dsstore", getExtension("/user/home/.dsstore")); assertEquals("", getExtension(".strange.")); assertEquals("3", getExtension("1.2.3")); assertEquals("exe", getExtension("C:\\Program Files (x86)\\java\\bin\\javaw.exe")); }
String getFileExtension(File file) { if (file == null) { return ""; } String name = file.getName(); int i = name.lastIndexOf( String ext = i > 0 ? name.substring(i + 1) : ""; return ext; }
String[] split = fullFileName.split("\\."); String ext = split[split.length - 1];
if(FilenameUtils.isExtension(file.getName(),"java")) { someoperation(); }
JFileChooser filechooser = new JFileChooser(); File file = new File("your.txt"); System.out.println("the extension type:"+filechooser.getTypeDescription(file));
/* * Get the extension of a file. */ public static String getExtension(File f) { String ext = null; String s = f.getName(); int i = s.lastIndexOf( if (i > 0 && i < s.length() - 1) { ext = s.substring(i+1).toLowerCase(); } return ext; }
private static final String getExtension(final String filename) { if (filename == null) return null; final String afterLastSlash = filename.substring(filename.lastIndexOf( final int afterLastBackslash = afterLastSlash.lastIndexOf( final int dotIndex = afterLastSlash.indexOf( return (dotIndex == -1) ? "" : afterLastSlash.substring(dotIndex + 1); }
import java.io.File; import java.util.Optional; public class GetFileExtensionTool { public static Optional<String> getFileExtension(File file) { if (file == null) { throw new NullPointerException("file argument was null"); } if (!file.isFile()) { throw new IllegalArgumentException("getFileExtension(File file)" + " called on File object that wasn + " (perhaps a directory or device?). file had path: " + file.getAbsolutePath()); } String fileName = file.getName(); int i = fileName.lastIndexOf( if (i > 0) { return Optional.of(fileName.substring(i + 1)); } else { return Optional.empty(); } } }
static final Pattern PATTERN = Pattern.compile("(.*)\\.(.*)"); Matcher m = PATTERN.matcher(path); if (m.find()) { System.out.println("File path/name: " + m.group(1)); System.out.println("Extention: " + m.group(2)); }
static final Pattern PATTERN = Pattern.compile("((.*\\" + File.separator + ")?(.*)(\\.(.*)))|(.*\\" + File.separator + ")?(.*)"); class Separated { String path, name, ext; } Separated parsePath(String path) { Separated res = new Separated(); Matcher m = PATTERN.matcher(path); if (m.find()) { if (m.group(1) != null) { res.path = m.group(2); res.name = m.group(3); res.ext = m.group(5); } else { res.path = m.group(6); res.name = m.group(7); } } return res; } Separated sp = parsePath("/root/docs/readme.txt"); System.out.println("path: " + sp.path); System.out.println("name: " + sp.name); System.out.println("Extention: " + sp.ext);
String extension = "/path/to/file/foo.txt".substring("/path/to/file/foo.txt".lastIndexOf(
String extension = com.google.common.io.Files.getFileExtension("fileName.jpg");
public static String getFileType(String path){ String fileType = null; fileType = path.substring(path.indexOf( return fileType; }
/** * The extension separator character. */ private static final char EXTENSION_SEPARATOR = /** * The Unix separator character. */ private static final char UNIX_SEPARATOR = /** * The Windows separator character. */ private static final char WINDOWS_SEPARATOR = /** * The system separator character. */ private static final char SYSTEM_SEPARATOR = File.separatorChar; /** * Gets the extension of a filename. * <p> * This method returns the textual part of the filename after the last dot. * There must be no directory separator after the dot. * <pre> * foo.txt --> "txt" * a/b/c.jpg --> "jpg" * a/b.txt/c --> "" * a/b/c --> "" * </pre> * <p> * The output will be the same irrespective of the machine that the code is running on. * * @param filename the filename to retrieve the extension of. * @return the extension of the file or an empty string if none exists. */ public static String getExtension(String filename) { if (filename == null) { return null; } int index = indexOfExtension(filename); if (index == -1) { return ""; } else { return filename.substring(index + 1); } } /** * Returns the index of the last extension separator character, which is a dot. * <p> * This method also checks that there is no directory separator after the last dot. * To do this it uses {@link * handle a file in either Unix or Windows format. * <p> * The output will be the same irrespective of the machine that the code is running on. * * @param filename the filename to find the last path separator in, null returns -1 * @return the index of the last separator character, or -1 if there * is no such character */ public static int indexOfExtension(String filename) { if (filename == null) { return -1; } int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR); int lastSeparator = indexOfLastSeparator(filename); return (lastSeparator > extensionPos ? -1 : extensionPos); } /** * Returns the index of the last directory separator character. * <p> * This method will handle a file in either Unix or Windows format. * The position of the last forward or backslash is returned. * <p> * The output will be the same irrespective of the machine that the code is running on. * * @param filename the filename to find the last path separator in, null returns -1 * @return the index of the last separator character, or -1 if there * is no such character */ public static int indexOfLastSeparator(String filename) { if (filename == null) { return -1; } int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR); int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR); return Math.max(lastUnixPos, lastWindowsPos); }
String[] splits = fileNames.get(i).split("\\."); String extension = ""; if(splits.length >= 2) { extension = splits[splits.length-1]; }
path = "/Users/test/test.txt" extension = path.substring(path.lastIndexOf("."), path.length());
Pattern pattern = Pattern.compile("\\.([^.]*)$"); Matcher matcher = pattern.matcher(fileName); if (matcher.find()) { String ext = matcher.group(1); }
public static String getFileExtension(String fileLink) { String extension; Uri uri = Uri.parse(fileLink); String scheme = uri.getScheme(); if (scheme != null && scheme.equals(ContentResolver.SCHEME_CONTENT)) { MimeTypeMap mime = MimeTypeMap.getSingleton(); extension = mime.getExtensionFromMimeType(CoreApp.getInstance().getContentResolver().getType(uri)); } else { extension = MimeTypeMap.getFileExtensionFromUrl(fileLink); } return extension; } public static String getMimeType(String fileLink) { String type = CoreApp.getInstance().getContentResolver().getType(Uri.parse(fileLink)); if (!TextUtils.isEmpty(type)) return type; MimeTypeMap mime = MimeTypeMap.getSingleton(); return mime.getMimeTypeFromExtension(FileChooserUtil.getFileExtension(fileLink)); }
private String getFileExtension(File file) { String name = file.getName().substring(Math.max(file.getName().lastIndexOf( file.getName().lastIndexOf( file.getName().lastIndexOf( int lastIndexOf = name.lastIndexOf("."); if (lastIndexOf == -1) { return ""; } return name.substring(lastIndexOf + 1); }
String[] extension = "adadad.adad.adnandad.jpg".split("\\.(?=[^\\.]+$)"); extension[1]
@Test public void getFileExtension(String fileName){ String extension = null; List<String> list = new ArrayList<>(); do{ extension = FilenameUtils.getExtension(fileName); if(extension==null){ break; } if(!extension.isEmpty()){ list.add("."+extension); } fileName = FilenameUtils.getBaseName(fileName); }while (!extension.isEmpty()); Collections.reverse(list); System.out.println(list.toString()); }
File f = new File("/path/to/file/foo.txt"); String ext = Files.probeContentType(f.toPath()); if(ext.equalsIgnoreCase("txt")) do whatever;
List<Integer> list = Arrays.asList(1, 10, 3, 7, 5); int a = list.stream() .peek(num -> System.out.println("will filter " + num)) .filter(x -> x > 5) .findFirst() .get(); System.out.println(a);
return dataSource.getParkingLots().stream().filter(parkingLot -> Objects.equals(parkingLot.getId(), id)).findFirst().orElse(null);
Integer a = list.stream() .peek(num -> System.out.println("will filter " + num)) .filter(x -> x > 5) .findFirst() .orElse(null);
for (MyType walk : lst) if (walk > 5) { do_whatever; break; }
for (int x=0; x<list.size(); x++) if (list.get(x) > 5 { do_whatever; break; }
<build> <plugins> <plugin> <artifactId>maven-assembly-plugin</artifactId> <configuration> <finalName>ServiceCreate</finalName> <appendAssemblyId>false</appendAssemblyId> <archive> <manifest> <mainClass>com.svt.optimoo.App</mainClass> </manifest> </archive> <descriptorRefs> <descriptorRef>jar-with-dependencies</descriptorRef> </descriptorRefs> </configuration> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> </plugins> </build>
<build> <plugins> <plugin> <artifactId>maven-assembly-plugin</artifactId> <configuration> <archive> <manifest> <mainClass>[path you class main]</mainClass> </manifest> </archive> <descriptorRefs> <descriptorRef>jar-with-dependencies</descriptorRef> </descriptorRefs> </configuration> <executions> <execution> <id>make-assembly</id> <phase>package</phase> <goals> <goal>single</goal> </goals> </execution> </executions> </plugin> </plugins> </build>
class C { @Override public boolean equals(SomeClass obj){ } }
public static String reverse(String input){ char[] in = input.toCharArray(); int begin=0; int end=in.length-1; char temp; while(end>begin){ temp = in[begin]; in[begin]=in[end]; in[end] = temp; end--; begin++; } return new String(in); }
public static String reverseIt(String source) { int i, len = source.length(); StringBuilder dest = new StringBuilder(len); for (i = (len - 1); i >= 0; i--){ dest.append(source.charAt(i)); } return dest.toString(); }
String string="whatever"; String reverse = new StringBuffer(string).reverse().toString(); System.out.println(reverse);
public static void main(String[] args) { String result=""; for(int i=string.length()-1; i>=0; i--) { result = result + string.charAt(i); } System.out.println(result); StringBuffer buffer = new StringBuffer(string); System.out.println(buffer.reverse()); }
public static void reverseStringByWords(String string) { StringBuilder stringBuilder = new StringBuilder(); String[] words = string.split(" "); for (int j = words.length-1; j >= 0; j--) { stringBuilder.append(words[j]).append( } System.out.println("Reverse words: " + stringBuilder); }
String s = "sample"; String result = new StringBuffer(s).reverse().toString();
public void reverseString() { String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; String reverseAlphabet = reverse(alphabet, alphabet.length()-1); } String reverse(String stringToReverse, int index){ if(index == 0){ return stringToReverse.charAt(0) + ""; } char letter = stringToReverse.charAt(index); return letter + reverse(stringToReverse, index-1); }
import java.util.Scanner; public class class1 { public static void main(String[] args) { Scanner in = new Scanner(System.in); String inpStr = in.nextLine(); System.out.println("Original String :" + inpStr); char temp; char[] arr = inpStr.toCharArray(); int len = arr.length; for(int i=0; i<(inpStr.length())/2; i++,len--){ temp = arr[i]; arr[i] = arr[len-1]; arr[len-1] = temp; } System.out.println("Reverse String :" + String.valueOf(arr)); } }
public String reverseString(String s) { Stack<Character> stack = new Stack<Character>(); StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) { stack.push(s.charAt(i)); } while (!stack.empty()) { sb.append(stack.pop()); } return sb.toString(); }
public class ReverseUsingXOR { public static void main(String[] args) { String str = "prateek"; reverseUsingXOR(str.toCharArray()); } /*Example: * str= prateek; * str[low]=p; * str[high]=k; * str[low]=p^k; * str[high]=(p^k)^k =p; * str[low]=(p^k)^p=k; * * */ public static void reverseUsingXOR(char[] str) { int low = 0; int high = str.length - 1; while (low < high) { str[low] = (char) (str[low] ^ str[high]); str[high] = (char) (str[low] ^ str[high]); str[low] = (char) (str[low] ^ str[high]); low++; high--; } for (int i = 0; i < str.length; i++) { System.out.print(str[i]); } } }
public static String reverseString(String s) { char[] chars = new char[s.length()]; boolean twoCharCodepoint = false; for (int i = 0; i < s.length(); i++) { chars[s.length() - 1 - i] = s.charAt(i); if (twoCharCodepoint) { swap(chars, s.length() - 1 - i, s.length() - i); } twoCharCodepoint = !Character.isBmpCodePoint(s.codePointAt(i)); } return new String(chars); } private static void swap(char[] array, int i, int j) { char temp = array[i]; array[i] = array[j]; array[j] = temp; } public static void main(String[] args) throws Exception { FileOutputStream fos = new FileOutputStream("C:/temp/reverse-string.txt"); StringBuilder sb = new StringBuilder("Linear B Syllable B008 A: "); sb.appendCodePoint(65536); sb.append("."); fos.write(sb.toString().getBytes("UTF-16")); fos.write("\n".getBytes("UTF-16")); fos.write(reverseString(sb.toString()).getBytes("UTF-16")); }
public static void main(String[] args) { String text = "abcdefghijklmnopqrstuvwxyz"; for (int i = (text.length() - 1); i >= 0; i--) { System.out.print(text.charAt(i)); } }
public String reverse(String s) { String reversedString = ""; for(int i=s.length(); i>0; i--) { reversedString += s.charAt(i-1); } return reversedString; }
public class ReverseString { public static void main(String[] args) { String s1 = "neelendra"; for(int i=s1.length()-1;i>=0;i--) { System.out.print(s1.charAt(i)); } } }
System.out.print("Please enter your name: "); String name = keyboard.nextLine(); String reverse = new StringBuffer(name).reverse().toString(); String rev = reverse.toLowerCase(); System.out.println(rev);
Stack<String> myStack = new Stack<>(); StringTokenizer st = new StringTokenizer(s); while (st.hasMoreTokens()) { myStack.push(st.nextToken()); }
System.out.print( while (!myStack.empty()) { System.out.print(myStack.pop()); System.out.print( } System.out.println(
public class Test { public static void main(String args[]) { StringBuffer buffer = new StringBuffer("Game Plan"); buffer.reverse(); System.out.println(buffer); } }
public class ReversString { public static void main(String args[]) { char s[] = "Dhiral Pandya".toCharArray(); String r = new String(reverse(0, s)); System.out.println(r); } public static char[] reverse(int i, char source[]) { if (source.length / 2 == i) { return source; } char t = source[i]; source[i] = source[source.length - 1 - i]; source[source.length - 1 - i] = t; i++; return reverse(i, source); } }
public void reverString(){ System.out.println("Enter value"); BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); try{ String str=br.readLine(); char[] charArray=str.toCharArray(); for(int i=charArray.length-1; i>=0; i--){ System.out.println(charArray[i]); } } catch(IOException ex){ }
class test { public static void main(String args[]) { String str = "world"; String[] split= str.split(""); String revers = ""; for (int i = split.length-1; i>=0; i--) { revers += split[i]; } System.out.printf("%s", revers); } }
public String reverseString(String inputString) { char[] inputStringArray = inputString.toCharArray(); String reverseString = ""; for (int i = inputStringArray.length - 1; i >= 0; i--) { reverseString += inputStringArray[i]; } return reverseString; }
public String reverseString(String inputString) { StringBuilder stringBuilder = new StringBuilder(inputString); stringBuilder = stringBuilder.reverse(); return stringBuilder.toString(); }
return new StringBuilder(inputString).reverse().toString();
public static String reverse(String s) { return "\u202E" + s; }
Algorithm (str,len) char reversedStr[] =new reversedStr[len]
reversedStr[i]=str[len-1-i] reversedStr[len-1=i]=str[i] return reversedStr;
public class Reverse { static char reversedStr[]; public static void main(String[] args) { System.out.println(reversestr("jatin")); } private static String reversestr(String str) { int strlen = str.length(); reversedStr = new char[strlen]; for (int i = 0; i <= strlen / 2; i++) { reversedStr[i] = str.charAt(strlen - 1 - i); reversedStr[strlen - 1 - i] = str.charAt(i); } return new String(reversedStr); } }
package logicprogram; import java.io.*; public class Strinrevers { public static void main(String args[])throws IOException { BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); System.out.println("enter data"); String data=br.readLine(); System.out.println(data); String str=""; char cha[]=data.toCharArray(); int l=data.length(); int k=l-1; System.out.println(l); for(int i=0;k>=i;k--) { str+=cha[k]; } System.out.println(str); } }
import java.util.Scanner; public class Test { public static void main(String[] args){ Scanner input = new Scanner (System.in); String word = input.next(); String reverse = ""; for(int i=word.length()-1; i>=0; i--) reverse += word.charAt(i); System.out.println(reverse); } }
public static String reverse (String a){ char[] rarray = a.toCharArray(); String finalvalue = ""; for (int i = 0; i < rarray.length; i++) { finalvalue += rarray[rarray.length - 1 - i]; } return finalvalue;
String reversedWords = ""; if(s.length()<=0) { return reversedWords; }else if(s.length() == 1){ if(s == " "){ return ""; } return s; } char arr[] = s.toCharArray(); int j = arr.length-1; while(j >= 0 ){ if( arr[j] == reversedWords+=arr[j]; }else{ String temp=""; while(j>=0 && arr[j] != temp+=arr[j]; j--; } j++; temp = reverseWord(temp); reversedWords+=temp; } j--; } String[] chk = reversedWords.split(" "); if(chk == null || chk.length == 0){ return ""; } return reversedWords; } public String reverseWord(String s){ char[] arr = s.toCharArray(); for(int i=0,j=arr.length-1;i<=j;i++,j--){ char tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } return String.valueOf(arr); }
StringBuilder s = new StringBuilder("racecar"); for (int i = 0, j = s.length() - 1; i < (s.length()/2); i++, j--) { char temp = s.charAt(i); s.setCharAt(i, s.charAt(j)); s.setCharAt(j, temp); } System.out.println(s.toString());
public class StringReverse { public static void main(String[] args) { String str = "Dogs hates cats"; StringBuffer sb = new StringBuffer(str); System.out.println(sb.reverse()); } }
public static void main(String[] args) { String str = "Prashant"; int len = str.length(); char[] c = new char[len]; for (int j = len - 1, i = 0; j >= 0; j--, i++) { c[i] = str.charAt(j); } str = String.copyValueOf(c); System.out.println(str); }
public static String SelectRandomFromTemplate(String template,int count) { String[] split = template.split("|"); List<String> list=Arrays.asList(split); Random r = new Random(); while( list.size() > count ) { list.remove(r.nextInt(list.size())); } return StringUtils.join(list, ", "); }
06-03 15:05:29.614: ERROR/AndroidRuntime(7737): java.lang.UnsupportedOperationException 06-03 15:05:29.614: ERROR/AndroidRuntime(7737): at java.util.AbstractList.remove(AbstractList.java:645)
List<String> list = new LinkedList<String>(Arrays.asList(split));
List<String> list = new LinkedList<>(Arrays.asList(split));
List<String> list = new ArrayList<String>(Arrays.asList(split));
LinkedList<String> elements = ...; int k = elements.size() - count; int remaining = elements.size(); for (Iterator i = elements.iterator(); k > 0 && i.hasNext(); remaining--) { i.next(); if (random.nextInt(remaining) < k) { i.remove(); k--; } }
List<String> list = new ArrayList(Arrays.asList(split));
List<String> list = Arrays.asList(split); List<String> newList = new ArrayList<>(list);
String idList = "123,222,333,444"; List<String> parentRecepeIdList = new ArrayList<String>(); parentRecepeIdList.addAll(Arrays.asList(idList.split(","))); parentRecepeIdList.add("555");
public static <T> List<T> asList(T... a) { return new ArrayList<>(a); } /** * @serial include */ private static class ArrayList<E> extends AbstractList<E> implements RandomAccess, java.io.Serializable { private static final long serialVersionUID = -2764017481108945198L; private final E[] a;
public static String SelectRandomFromTemplate(String template, int count) { String[] split = template.split("\\|"); List<String> list = Arrays.asList(split); Random r = new Random(); while( list.size() > count ) { list = list.subList(0, list.size() - (list.size() - count)); } return StringUtils.join(list, ", "); }
ArrayList<String> al = new ArrayList<String>(Arrays.asList(template));
List<String> list = New ArrayList<>(); list.addAll(Arrays.asList(split));
List<String> list = new ArrayList<>(Arrays.asList(split));
List<String> list = new ArrayList<String>(Arrays.asList(split));
List<String> list = new LinkedList<>(Arrays.asList(split));
@RequestMapping("showApples.do") public String getApples(@RequestBody final AllApplesDO applesRequest){ }
public class AllApplesDO { private List<ApplesDO> applesDO; public List<ApplesDO> getApplesDO() { return applesDO; } public void setApplesDO(List<ApplesDO> applesDO) { this.applesDO = applesDO; } }
public class ApplesDO { private String apple; public String getApple() { return apple; } public void setApple(String appl) { this.apple = apple; } public ApplesDO(CustomType custom){ } }
public class ApplesDO { private String apple; public String getApple() { return apple; } public void setApple(String apple) { this.apple = apple; } public ApplesDO(CustomType custom) { } }
public class ApplesDO { private String apple; public String getApple() { return apple; } public void setApple(String apple) { this.apple = apple; } public ApplesDO(CustomType custom) { } public ApplesDO() { } }
private static class Condition { private Long id; public Condition() { } }
import com.fasterxml.jackson.annotation.JsonProperty; public class ApplesDO { private String apple; public String getApple() { return apple; } public void setApple(String apple) { this.apple = apple; } public ApplesDO(CustomType custom){ } public ApplesDO(@JsonProperty("apple")String apple) { } }
{ "applesRequest": { "applesDO": [ { "apple": "Green Apple" }, { "apple": "Red Apple" } ] } }
String jsonInString="{\"ANOTHER_NAME\":\"John\",\"age\":\"17\"}"; ObjectMapper mapper = new ObjectMapper(); Staff obj = mapper.readValue(jsonInString, Staff.class); public static class Staff { public String name; public Integer age; public Staff() { } public Staff(@JsonProperty("ANOTHER_NAME") String n,@JsonProperty("age") Integer a) { name=n;age=a; } }
package example.counter; import javax.validation.constraints.NotNull; import lombok.Data; @Data public class CounterRequest { @NotNull private final Integer int1; @NotNull private final Integer int2; }
<dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.0</version> </dependency>
<dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.16.10</version> </dependency>
int[][] multD = new int[5][]; multD[0] = new int[10];
int[][] multi = new int[5][]; multi[0] = new int[10]; multi[1] = new int[10]; multi[2] = new int[10]; multi[3] = new int[10]; multi[4] = new int[10];
int[][] multi = new int[][]{ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
int marks[][]={{50,60,55,67,70},{62,65,70,70,81},{72,66,77,80,69}};
marks[0][0] marks[0][1] marks[0][2] marks[0][3] marks[0][4] marks[1][0] marks[1][1] marks[1][2] marks[1][3] marks[1][4] marks[2][0] marks[2][1] marks[2][2] marks[2][3] marks[2][4]
int array[][] = new int[3][]; array[0] = new int[3]; array[1] = new int[2]; array[2] = new int[5];
int[][] multD = new int[5][]; for (int i = 0; i < 5; i++) { multD[i] = new int[10]; }
int[][] multD = new int[5][]; multD[0] = new int[10];
int [][] twoDim = new int [5][5]; int a = (twoDim.length); int b = (twoDim[0].length); for(int i = 0; i < a; i++){ for(int j = 0; j <b; j++) { int x = (i+1)*(j+1); twoDim[i][j] = x; if (x<10) { System.out.print(" " + x + " "); } else { System.out.print(x + " "); } } System.out.println(); }
int rows = 5; int cols = 10; int[] multD = new int[rows * cols]; for (int r = 0; r < rows; r++) { for (int c = 0; c < cols; c++) { int index = r * cols + c; multD[index] = index * 2; } }
int a[][] = {{1,2}, {3,4}}; int b[] = {1, 2, 3, 4};
int[][] multD = new int[3][]; multD[0] = new int[3]; multD[1] = new int[2]; multD[2] = new int[5];
int[][] multD = {{2, 4, 1}, {6, 8}, {7, 3, 6, 5, 1}};
for (int i = 0; i<multD.length; i++) { for (int j = 0; j<multD[i].length; j++) { System.out.print(multD[i][j] + "\t"); } System.out.println(); }
public void method() { synchronized( this ) { .... .... .... } }
... private synchronized void someInputRelatedWork() { ... } private synchronized void someOutputRelatedWork() { ... }
Object inputLock = new Object(); Object outputLock = new Object(); private void someInputRelatedWork() { synchronized(inputLock) { ... } } private void someOutputRelatedWork() { synchronized(outputLock) { ... } }
private void method() { ... code here ... code here ... code here synchronized( lock ) { ... very few lines of code here } ... code here ... code here ... code here ... code here }
synchronized void foo() { ... } void foo() { synchronized (this) { ... } }
package test; public class SynchTest implements Runnable { private int c = 0; public static void main(String[] args) { new SynchTest().test(); } public void test() { Runnable runnable = new SynchTest(); Runnable runnable2 = new SynchTest(); Thread thread = new Thread(runnable,"thread-1"); Thread thread2 = new Thread(runnable,"thread-2"); thread.start(); thread2.start(); } public synchronized void increment() { System.out.println("Begin thread " + Thread.currentThread().getName()); System.out.println(this.hashCode() + "Value of C = " + c); for (int i = 0; i < 9999999; i++) { c += i; } System.out.println("End thread " + Thread.currentThread().getName()); } public int value() { return c; } @Override public void run() { this.increment(); } }
public class MyClass { public static synchronized void foo() { } public static void foo() { synchronized(MyClass.class) { } } }
public class SynchronizationExample { private int i; public synchronized int synchronizedMethodGet() { return i; } public int synchronizedBlockGet() { synchronized( this ) { return i; } } }
0: aload_0 1: getfield 2: nop 3: iconst_m1 4: ireturn
0: aload_0 1: dup 2: astore_1 3: monitorenter 4: aload_0 5: getfield 6: nop 7: iconst_m1 8: aload_1 9: monitorexit 10: ireturn 11: astore_2 12: aload_1 13: monitorexit 14: aload_2 15: athrow
private List<Foo> myList = new ArrayList<Foo>(); private Map<String,Bar) myMap = new HashMap<String,Bar>(); public void put( String s, Bar b ) { synchronized( myMap ) { myMap.put( s,b ); } } public void hasKey( String s, ) { synchronized( myMap ) { myMap.hasKey( s ); } } public void add( Foo f ) { synchronized( myList ) { myList.add( f ); } } public Thing getMedianFoo() { Foo med = null; synchronized( myList ) { Collections.sort(myList); med = myList.get(myList.size()/2); } return med; }
for (Method m : Hashtable.class.getMethods()) { if (Modifier.isSynchronized(m.getModifiers())) { System.out.println(m); } }
class MethodLevel { SharedResource x, y ; public void synchronized method1() { } public void synchronized method2() { } public void method3() { } }
class BlockLevel { SharedResource x, y ; Object xLock = new Object(); Object yLock = new Object(); public void method1() { synchronized(xLock){ } synchronized(xLock) { synchronized(yLock) { } } } }
Map myMap = Collections.synchronizedMap (myMap); List myList = Collections.synchronizedList (myList);
class X { private final ReentrantLock lock = new ReentrantLock(); public void m() { lock.lock(); try { } finally { lock.unlock() } } }
Class Example { String test = "abc"; synchronized (test) { } lock will be acquired on Example Object public synchronized void testMethod() { } }
public class ListHelper<E> { public List<E> list = Collections.syncrhonizedList(new ArrayList<>()); ... public syncrhonized boolean putIfAbsent(E x) { boolean absent = !list.contains(x); if(absent) { list.add(x); } return absent; }
public boolean putIfAbsent(E x) { synchronized(list) { boolean absent = !list.contains(x); if(absent) { list.add(x); } return absent; } }
public class MyService { private final lock = new Object(); public void doThis() { synchronized(lock) { } } public void doThat() { synchronized(lock) { } } }
public class MyService { private final lock1 = new Object(); private final lock2 = new Object(); public void doThis() { synchronized(lock1) { synchronized(lock2) { } } public void doThat() { synchronized(lock1) { } } public void doMore() { synchronized(lock2) { } } }
import java.util.*; /** RaceCondition - Shows that when multiple threads compete for resources thread one may grab the resource expecting to update a particular area but is removed from the CPU before finishing. Thread one still points to that resource. Then thread two grabs that resource and completes the update. Then thread one gets to complete the update, which over writes thread two DEMO: 1) Run as is - see missing counts from race condition, Run severa times, values change 2) Uncomment "synchronized(countLock){ }" - see counts work Synchronized creates a lock on that block of code, no other threads can execute code within a block that another thread has a lock. 3) Comment ArrayList, unComment Vector - See no loss in collection Vectors work like ArrayList, but Vectors are "Thread Safe" May use this code as long as attribution to the author remains intact. /mf */ public class RaceCondition { private ArrayList<Integer> raceList = new ArrayList<Integer>(); private String countLock="lock"; private int raceCount = 0; private int MAX = 10000; private int NUM_THREADS = 100; public static void main(String [] args) { new RaceCondition(); } public RaceCondition() { ArrayList<Thread> arT = new ArrayList<Thread>(); for( int i=0; i<NUM_THREADS; i++){ Thread rt = new RaceThread( ); arT.add( rt ); } for( Thread rt : arT ){ rt.start(); } for( int i=0; i<NUM_THREADS; i++){ try { arT.get(i).join(); } catch( InterruptedException ie ) { System.out.println("Interrupted thread "+i); } } System.out.printf("\nRace condition, should have %,d. Really have %,d in array, and count of %,d.\n", MAX*NUM_THREADS, raceList.size(), raceCount ); System.out.printf("Array lost %,d. Count lost %,d\n", MAX*NUM_THREADS-raceList.size(), MAX*NUM_THREADS-raceCount ); } class RaceThread extends Thread { public void run() { for ( int i=0; i<MAX; i++){ try { update( i ); } catch( ArrayIndexOutOfBoundsException ai ){ System.out.print("A"); } catch( OutOfMemoryError oome ) { System.out.print("O"); } } } public void update(int i){ raceCount = raceCount + 1; raceList.add( i ); } } }
public class Student { private Long id; private String firstName = "Philip"; private String middleName = "J."; private String initials = "P.F"; private String lastName = "Fry"; private Country country; private Country countryOfBirth; } public class Country { private Long id; private String name; private Object other; }
<interceptor-ref name="json"> <param name="enableSMD">true</param> <param name="excludeProperties"> login.password, studentList.*\.sin </param> </interceptor-ref>
Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
public class TestExclStrat implements ExclusionStrategy { public boolean shouldSkipClass(Class<?> arg0) { return false; } public boolean shouldSkipField(FieldAttributes f) { return (f.getDeclaringClass() == Student.class && f.getName().equals("firstName"))|| (f.getDeclaringClass() == Country.class && f.getName().equals("name")); } }
Gson gson = new GsonBuilder() .setExclusionStrategies(new TestExclStrat()) .create(); Student src = new Student(); String json = gson.toJson(src); System.out.println(json);
public boolean shouldSkipField(FieldAttributes f) { return f.getName().toLowerCase().contains("name"); }
public class TestExclStrat implements ExclusionStrategy { private Class<?> c; private String fieldName; public TestExclStrat(String fqfn) throws SecurityException, NoSuchFieldException, ClassNotFoundException { this.c = Class.forName(fqfn.substring(0, fqfn.lastIndexOf("."))); this.fieldName = fqfn.substring(fqfn.lastIndexOf(".")+1); } public boolean shouldSkipClass(Class<?> arg0) { return false; } public boolean shouldSkipField(FieldAttributes f) { return (f.getDeclaringClass() == c && f.getName().equals(fieldName)); } }
Gson gson = new GsonBuilder() .setExclusionStrategies(new TestExclStrat("in.naishe.test.Country.name")) .create(); Student src = new Student(); String json = gson.toJson(src); System.out.println(json);
{ "firstName": "Philip" , "middleName": "J.", "initials": "P.F", "lastName": "Fry", "country": { "id": 91 }}
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface Exclude { }
public class AnnotationExclusionStrategy implements ExclusionStrategy { @Override public boolean shouldSkipField(FieldAttributes f) { return f.getAnnotation(Exclude.class) != null; } @Override public boolean shouldSkipClass(Class<?> clazz) { return false; } }
new GsonBuilder().setExclusionStrategies(new AnnotationExclusionStrategy()).create();
new GsonBuilder() .addSerializationExclusionStrategy(new ExclusionStrategy() { @Override public boolean shouldSkipField(FieldAttributes fieldAttributes) { final Expose expose = fieldAttributes.getAnnotation(Expose.class); return expose != null && !expose.serialize(); } @Override public boolean shouldSkipClass(Class<?> aClass) { return false; } }) .addDeserializationExclusionStrategy(new ExclusionStrategy() { @Override public boolean shouldSkipField(FieldAttributes fieldAttributes) { final Expose expose = fieldAttributes.getAnnotation(Expose.class); return expose != null && !expose.deserialize(); } @Override public boolean shouldSkipClass(Class<?> aClass) { return false; } }) .create();
public class GsonFactory { public static Gson build(final List<String> fieldExclusions, final List<Class<?>> classExclusions) { GsonBuilder b = new GsonBuilder(); b.addSerializationExclusionStrategy(new ExclusionStrategy() { @Override public boolean shouldSkipField(FieldAttributes f) { return fieldExclusions == null ? false : fieldExclusions.contains(f.getName()); } @Override public boolean shouldSkipClass(Class<?> clazz) { return classExclusions == null ? false : classExclusions.contains(clazz); } }); return b.create(); } }
static { List<String> fieldExclusions = new ArrayList<String>(); fieldExclusions.add("id"); fieldExclusions.add("provider"); fieldExclusions.add("products"); List<Class<?>> classExclusions = new ArrayList<Class<?>>(); classExclusions.add(Product.class); GSON = GsonFactory.build(null, classExclusions); } private static final Gson GSON; public String getSomeJson(){ List<Provider> list = getEntitiesFromDatabase(); return GSON.toJson(list); }
gson.toJsonTree(student).getAsJsonObject() .get("country").getAsJsonObject().remove("name");
gson.toJsonTree(student).getAsJsonObject().addProperty("isGoodStudent", false);
@Target (ElementType.FIELD) public @interface SkipSerialisation { }
gsonBuilder.addSerializationExclusionStrategy(new ExclusionStrategy() { @Override public boolean shouldSkipField (FieldAttributes f) { return f.getAnnotation(SkipSerialisation.class) != null; } @Override public boolean shouldSkipClass (Class<?> clazz) { return false; } });
public class User implements Serializable { public String firstName; public String lastName; @SkipSerialisation public String email; }
Gson gson = gsonBuilder.excludeFieldsWithModifiers(Modifier.TRANSIENT).create();
Gson gson = new GsonBuilder() .registerTypeAdapter(BloodPressurePost.class, new BloodPressurePostSerializer())
public class BloodPressurePostSerializer implements JsonSerializer<BloodPressurePost> { @Override public JsonElement serialize(BloodPressurePost src, Type typeOfSrc, JsonSerializationContext context) { final JsonObject jsonObject = new JsonObject(); if (src.systolic > 0) { jsonObject.addProperty("systolic", src.systolic); } if (src.diastolic > 0) { jsonObject.addProperty("diastolic", src.diastolic); } jsonObject.addProperty("units", src.units); return jsonObject; } }
public class Dummy { @SerializedName("VisibleValue") final String visibleValue; final String hiddenValue; public Dummy(String visibleValue, String hiddenValue) { this.visibleValue = visibleValue; this.hiddenValue = hiddenValue; } } public class SerializedNameOnlyStrategy implements ExclusionStrategy { @Override public boolean shouldSkipField(FieldAttributes f) { return f.getAnnotation(SerializedName.class) == null; } @Override public boolean shouldSkipClass(Class<?> clazz) { return false; } } Gson gson = new GsonBuilder() .setExclusionStrategies(new SerializedNameOnlyStrategy()) .create(); Dummy dummy = new Dummy("I will see this","I will not see this"); String json = gson.toJson(dummy);
public EndPointsApi connectRestApi() { OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(90000, TimeUnit.SECONDS) .readTimeout(90000,TimeUnit.SECONDS).build(); Retrofit retrofit = new Retrofit.Builder() .baseUrl(ConstantRestApi.ROOT_URL) .addConverterFactory(GsonConverterFactory.create()) .client(client) .build(); return retrofit.create (EndPointsApi.class); }
@Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FIELD) internal annotation class JsonSkip class SkipFieldsStrategy : ExclusionStrategy { override fun shouldSkipClass(clazz: Class<*>): Boolean { return false } override fun shouldSkipField(f: FieldAttributes): Boolean { return f.getAnnotation(JsonSkip::class.java) != null } }
val gson = GsonBuilder() .setExclusionStrategies(SkipFieldsStrategy()) .create() return GsonConverterFactory.create(gson)
data class Json( @field:SerializedName("serialized_field_1") val field1: String, @field:SerializedName("serialized_field_2") val field2: String, @Transient val field3: String )
{"serialized_field_1":"VALUE1","serialized_field_2":"VALUE2"}
Integer k = Integer.valueOf(Integer.parseInt("123"))
/** * Parses the specified string as a signed decimal integer value. * * @param string * the string representation of an integer value. * @return an {@code Integer} instance containing the integer value * represented by {@code string}. * @throws NumberFormatException * if {@code string} cannot be parsed as an integer value. * @see */ public static Integer valueOf(String string) throws NumberFormatException { return valueOf(parseInt(string)); }
/** * Parses the specified string as a signed decimal integer value. The ASCII * character \u002d ( * * @param string * the string representation of an integer value. * @return the primitive integer value represented by {@code string}. * @throws NumberFormatException * if {@code string} cannot be parsed as an integer value. */ public static int parseInt(String string) throws NumberFormatException { return parseInt(string, 10); }
String base5String = "230"; int result = Integer.valueOf(base5String);
interface Collection { public boolean containsAll(Collection c); ... }
interface Collection<E> { public boolean containsAll(Collection<E> c); ... }
HashMap<String, Integer> h = new HashMap<String, Integer>(Equal.stringEqual, Hash.stringHash); h.add("one", 1); h.get("one"); h.get(Integer.valueOf(1));
public static String html2text(String html) { return Jsoup.parse(html).text(); }
import java.io.*; import javax.swing.text.html.*; import javax.swing.text.html.parser.*; public class Html2Text extends HTMLEditorKit.ParserCallback { StringBuffer s; public Html2Text() { } public void parse(Reader in) throws IOException { s = new StringBuffer(); ParserDelegator delegator = new ParserDelegator(); delegator.parse(in, this, Boolean.TRUE); } public void handleText(char[] text, int pos) { s.append(text); } public String getText() { return s.toString(); } public static void main(String[] args) { try { FileReader in = new FileReader("java-new.html"); Html2Text parser = new Html2Text(); parser.parse(in); in.close(); System.out.println(parser.getText()); } catch (Exception e) { e.printStackTrace(); } } }
private static final Pattern REMOVE_TAGS = Pattern.compile("<.+?>"); public static String removeTags(String string) { if (string == null || string.length() == 0) { return string; } Matcher m = REMOVE_TAGS.matcher(string); return m.replaceAll(""); }
Source htmlSource = new Source(htmlText); Segment htmlSeg = new Segment(htmlSource, 0, htmlSource.length()); Renderer htmlRend = new Renderer(htmlSeg); System.out.println(htmlRend.toString());
String replace = input.replace("&amp;", ""); String html = StringEscapeUtils.unescapeHtml(replace); String clean = Jsoup.clean(html, "", Whitelist.none(), new Document.OutputSettings().prettyPrint(false)); return StringEscapeUtils.unescapeHtml(clean);
{"regular string", "regular string"}, {"<a href=\"link\">A link</a>", "A link"}, {"<script src=\"http: {"&lt;script&gt;", ""}, {"&amp;lt;script&amp;gt;", "lt;scriptgt;"}, {"\"
import java.io.IOException; import java.io.StringReader; import java.util.logging.Logger; import org.ccil.cowan.tagsoup.Parser; import org.xml.sax.Attributes; import org.xml.sax.ContentHandler; import org.xml.sax.InputSource; import org.xml.sax.Locator; import org.xml.sax.SAXException; import org.xml.sax.XMLReader; /** * Take HTML and give back the text part while dropping the HTML tags. * * There is some risk that using TagSoup means we * However, it seems to work the best so far in test cases. * * @author dan * @see <a href="http: */ public class Html2Text2 implements ContentHandler { private StringBuffer sb; public Html2Text2() { } public void parse(String str) throws IOException, SAXException { XMLReader reader = new Parser(); reader.setContentHandler(this); sb = new StringBuffer(); reader.parse(new InputSource(new StringReader(str))); } public String getText() { return sb.toString(); } @Override public void characters(char[] ch, int start, int length) throws SAXException { for (int idx = 0; idx < length; idx++) { sb.append(ch[idx+start]); } } @Override public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException { sb.append(ch); } @Override public void endDocument() throws SAXException { } @Override public void endElement(String uri, String localName, String qName) throws SAXException { } @Override public void endPrefixMapping(String prefix) throws SAXException { } @Override public void processingInstruction(String target, String data) throws SAXException { } @Override public void setDocumentLocator(Locator locator) { } @Override public void skippedEntity(String name) throws SAXException { } @Override public void startDocument() throws SAXException { } @Override public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException { } @Override public void startPrefixMapping(String prefix, String uri) throws SAXException { } }
import java.io.IOException; import java.io.Reader; import java.io.StringReader; import java.util.Stack; import java.util.logging.Logger; import javax.swing.text.MutableAttributeSet; import javax.swing.text.html.HTML; import javax.swing.text.html.HTMLEditorKit; import javax.swing.text.html.parser.ParserDelegator; public class HTML2Text extends HTMLEditorKit.ParserCallback { private static final Logger log = Logger .getLogger(Logger.GLOBAL_LOGGER_NAME); private StringBuffer stringBuffer; private Stack<IndexType> indentStack; public static class IndexType { public String type; public int counter; public IndexType(String type) { this.type = type; counter = 0; } } public HTML2Text() { stringBuffer = new StringBuffer(); indentStack = new Stack<IndexType>(); } public static String convert(String html) { HTML2Text parser = new HTML2Text(); Reader in = new StringReader(html); try { parser.parse(in); } catch (Exception e) { log.severe(e.getMessage()); } finally { try { in.close(); } catch (IOException ioe) { } } return parser.getText(); } public void parse(Reader in) throws IOException { ParserDelegator delegator = new ParserDelegator(); delegator.parse(in, this, Boolean.TRUE); } public void handleStartTag(HTML.Tag t, MutableAttributeSet a, int pos) { log.info("StartTag:" + t.toString()); if (t.toString().equals("p")) { if (stringBuffer.length() > 0 && !stringBuffer.substring(stringBuffer.length() - 1) .equals("\n")) { newLine(); } newLine(); } else if (t.toString().equals("ol")) { indentStack.push(new IndexType("ol")); newLine(); } else if (t.toString().equals("ul")) { indentStack.push(new IndexType("ul")); newLine(); } else if (t.toString().equals("li")) { IndexType parent = indentStack.peek(); if (parent.type.equals("ol")) { String numberString = "" + (++parent.counter) + "."; stringBuffer.append(numberString); for (int i = 0; i < (4 - numberString.length()); i++) { stringBuffer.append(" "); } } else { stringBuffer.append("* "); } indentStack.push(new IndexType("li")); } else if (t.toString().equals("dl")) { newLine(); } else if (t.toString().equals("dt")) { newLine(); } else if (t.toString().equals("dd")) { indentStack.push(new IndexType("dd")); newLine(); } } private void newLine() { stringBuffer.append("\n"); for (int i = 0; i < indentStack.size(); i++) { stringBuffer.append(" "); } } public void handleEndTag(HTML.Tag t, int pos) { log.info("EndTag:" + t.toString()); if (t.toString().equals("p")) { newLine(); } else if (t.toString().equals("ol")) { indentStack.pop(); ; newLine(); } else if (t.toString().equals("ul")) { indentStack.pop(); ; newLine(); } else if (t.toString().equals("li")) { indentStack.pop(); ; newLine(); } else if (t.toString().equals("dd")) { indentStack.pop(); ; } } public void handleSimpleTag(HTML.Tag t, MutableAttributeSet a, int pos) { log.info("SimpleTag:" + t.toString()); if (t.toString().equals("br")) { newLine(); } } public void handleText(char[] text, int pos) { log.info("Text:" + new String(text)); stringBuffer.append(text); } public String getText() { return stringBuffer.toString(); } public static void main(String args[]) { String html = "<html><body><p>paragraph at start</p>hello<br />What is happening?<p>this is a<br />mutiline paragraph</p><ol> <li>This</li> <li>is</li> <li>an</li> <li>ordered</li> <li>list <p>with</p> <ul> <li>another</li> <li>list <dl> <dt>This</dt> <dt>is</dt> <dd>sdasd</dd> <dd>sdasda</dd> <dd>asda <p>aasdas</p> </dd> <dd>sdada</dd> <dt>fsdfsdfsd</dt> </dl> <dl> <dt>vbcvcvbcvb</dt> <dt>cvbcvbc</dt> <dd>vbcbcvbcvb</dd> <dt>cvbcv</dt> <dt></dt> </dl> <dl> <dt></dt> </dl></li> <li>cool</li> </ul> <p>stuff</p> </li> <li>cool</li></ol><p></p></body></html>"; System.out.println(convert(html)); } }
<a href=> <b>, <big>, <blockquote>, <br>, <cite>, <dfn> <div align=>, <em>, <font size= color= face=> <h1>, <h2>, <h3>, <h4>, <h5>, <h6> <i>, <p>, <small> <strike>, <strong>, <sub>, <sup>, <tt>, <u>
String Str_Html=" <p>This is about me text that the user can put into their profile</p> ";
Your_TextView_Obj.setText(Html.fromHtml(Str_Html).toString());
MyWriter.toConsole(HtmlToText.htmlToPlainText(htmlResponse));
html = html.replaceAll("&nbsp;",""); html = html.replaceAll("&amp;"."");
static public String getUrlContentsAsText(String url) { String content = ""; StringBean stringBean = new StringBean(); stringBean.setURL(url); content = stringBean.getStrings(); return content; }
public static String removeHTML(String input) { int i = 0; String[] str = input.split(""); String s = ""; boolean inTag = false; for (i = input.indexOf("<"); i < input.indexOf(">"); i++) { inTag = true; } if (!inTag) { for (i = 0; i < str.length; i++) { s = s + str[i]; } } return s; }
private CharSequence removeHtmlFrom(String html) { return new HtmlCleaner().clean(html).getText(); }
InputStream htmlInputStream = .. HtmlParser htmlParser = new HtmlParser(); HtmlContentHandler htmlContentHandler = new HtmlContentHandler(); htmlParser.parse(htmlInputStream, htmlContentHandler, new Metadata()) System.out.println(htmlContentHandler.getBodyText().trim())
String html = "<p>Line one</p><p>Line two</p>Line three<br/>etc."; String NEW_LINE_MARK = "NEWLINESTART1234567890NEWLINEEND"; for (String tag: new String[]{"</p>","<br/>","</h1>","</h2>","</h3>","</h4>","</h5>","</h6>","</li>"}) { html = html.replace(tag, NEW_LINE_MARK+tag); } String text = Jsoup.parse(html).text(); text = text.replace(NEW_LINE_MARK + " ", "\n\n"); text = text.replace(NEW_LINE_MARK, "\n\n");
String[] temp = yourString.split("&amp;"); String tmp = ""; if (temp.length > 1) { for (int i = 0; i < temp.length; i++) { tmp += temp[i] + "&"; } yourString = tmp.substring(0, tmp.length() - 1); }
String BR_ESCAPED = "&lt;br/&gt;"; Element el=Jsoup.parse(html).select("body"); el.select("br").append(BR_ESCAPED); el.select("p").append(BR_ESCAPED+BR_ESCAPED); el.select("h1").append(BR_ESCAPED+BR_ESCAPED); el.select("h2").append(BR_ESCAPED+BR_ESCAPED); el.select("h3").append(BR_ESCAPED+BR_ESCAPED); el.select("h4").append(BR_ESCAPED+BR_ESCAPED); el.select("h5").append(BR_ESCAPED+BR_ESCAPED); String nodeValue=el.text(); nodeValue=nodeValue.replaceAll(BR_ESCAPED, "<br/>"); nodeValue=nodeValue.replaceAll("(\\s*<br[^>]*>){3,}", "<br/><br/>");
nodeValue=nodeValue.replaceAll("(\\s*\n){3,}", "<br/><br/>");
String RemoveTag(String html){ html = html.replaceAll("\\<.*?>","") html = html.replaceAll("&nbsp;",""); html = html.replaceAll("&amp;".""); ---------- ---------- return html; }
string str = "<html><head>sdfkashf sdf</head><body>sdfasdf</body></html>"; System.Text.RegularExpressions.Regex rx = new System.Text.RegularExpressions.Regex("<[^>]*>"); str = rx.Replace(str, "");
String s1 = "Hello World"; String s2 = "Hello World"; String s3 = s1.substring(6); System.out.println(s1); System.out.println(s2); System.out.println(s3); Field field = String.class.getDeclaredField("value"); field.setAccessible(true); char[] value = (char[])field.get(s1); value[6] = value[7] = value[8] = value[9] = value[10] = System.out.println(s1); System.out.println(s2); System.out.println(s3);
String Test1="Hello World"; String Test2="Hello World"; System.out.println(test1==test2);
Field field = String.class.getDeclaredField("value"); field.setAccessible(true);
public String method(String str) { if (str.charAt(str.length()-1)== str = str.replace(str.substring(str.length()-1), ""); return str; } else{ return str; } }
public String method(String str) { if (str != null && str.length() > 0 && str.charAt(str.length() - 1) == str = str.substring(0, str.length() - 1); } return str; }
private static String removeLastChar(String str) { return str.substring(0, str.length() - 1); }
import java.util.*; import java.lang.*; public class Main { public static void main (String[] args) throws java.lang.Exception { String s1 = "Remove Last CharacterY"; String s2 = "Remove Last Character2"; System.out.println("After removing s1==" + removeLastChar(s1) + "=="); System.out.println("After removing s2==" + removeLastChar(s2) + "=="); } private static String removeLastChar(String str) { return str.substring(0, str.length() - 1); } }
StringUtils.removeEnd("string 1|string 2|string 3|", "|");
public String removeLastChar(String s) { if (s == null || s.length() == 0) { return s; } return s.substring(0, s.length()-1); }
if(string.endsWith("x")) { string= string.substring(0, string.length() - 1); }
if (str.endsWith("x")) { return str.substring(0, str.length() - 1); } return str;
System.out.println("aaa xxx aaa xxx ".replaceAll("xxx([^xxx]*)$", "$1"));
System.out.println("aaa xxx aaa ".replaceAll("xxx\\s*$", ""));
public String removeLastChar(String s) { if (!Util.isEmpty(s)) { s = s.substring(0, s.length()-1); } return s; }
StringBuilder sb=new StringBuilder("toto,"); System.out.println(sb.deleteCharAt(sb.length()-1));
public String removeLast(String mes, int n) { return mes != null && !mes.isEmpty() && mes.length()>n ? mes.substring(0, mes.length()-n): mes; } public String leaveBeforeChar(String mes, String last) { return mes != null && !mes.isEmpty() && mes.lastIndexOf(last)!=-1 ? mes.substring(0, mes.lastIndexOf(last)): mes; }
public String removeLastChar(String s){return (s != null && s.length() != 0) ? s.substring(0, s.length() - 1): s;}
import java.util.Optional; public class Test { public static void main(String[] args) throws InterruptedException { System.out.println(removeLastChar("test-abc")); } public static String removeLastChar(String s) { return Optional.ofNullable(s) .filter(str -> str.length() != 0) .map(str -> str.substring(0, str.length() - 1)) .orElse(s); } }
StringBuilder builder = new StringBuilder(requestString); builder.deleteCharAt(requestString.length() - 1);
"String name" = "String name".substring(0, ("String name".length() - 1));
if ("String name".length() > 0) { "String name" = "String name".substring(0, ("String name".length() - 1)); }
static String removeChar(String word, char charToRemove) { for(int i = 0; i < word.lenght(); i++) { if(word.charAt(i) == charToRemove) { String newWord = word.substring(0, i) + word.substring(i + 1); return removeChar(newWord, charToRemove); } } return word; }
public static String removeChar(String word, char charToRemove) { String char_toremove=Character.toString(charToRemove); for(int i = 0; i < word.length(); i++) { if(word.charAt(i) == charToRemove) { String newWord = word.substring(0, i) + word.substring(i + 1); return removeChar(newWord,charToRemove); } } System.out.println(word); return word; }
removeChar ("hello world, let removeChar("you should not go",
public String method(String str) { return str.codePoints() .limit(str.codePoints().count() - 1) .mapToObj(i->new String(Character.toChars(i))) .collect(Collectors.joining()); }
public String method(String str) { return str.isEmpty()? "": str.substring(0, str.length() - Character.charCount(str.codePointBefore(str.length()))); }
public class RemoveStringChar { public static void main(String[] args) { String strGiven = "Java"; System.out.println("Before removing string character - " + strGiven); System.out.println("After removing string character - " + removeCharacter(strGiven, 3)); } public static String removeCharacter(String strRemove, int position) { return strRemove.substring(0, position) + strRemove.substring(position + 1); } }
Scanner in = new Scanner(System.in); String s = in.nextLine(); char array[] = s.toCharArray(); int l = array.length; for (int i = 0; i < l-1; i++) { System.out.print(array[i]); }
byte[] buffer = new byte[1024]; int len = in.read(buffer); while (len != -1) { out.write(buffer, 0, len); len = in.read(buffer); }
/* You can get Path from file also: file.toPath() */ Files.copy(InputStream in, Path target) Files.copy(Path source, OutputStream out)
Files.copy(in, target, StandardCopyOption.REPLACE_EXISTING)
InputStream in; OutputStream out; IOUtils.copy(in,out); in.close(); out.close();
public long transferTo(OutputStream out) throws IOException
byte[] buffer = new byte[1024]; int len; while ((len = in.read(buffer)) != -1) { out.write(buffer, 0, len); }
private void copyInputStreamToFile( InputStream in, File file ) { try { OutputStream out = new FileOutputStream(file); byte[] buf = new byte[1024]; int len; while((len=in.read(buf))>0){ out.write(buf,0,len); } out.close(); in.close(); } catch (Exception e) { e.printStackTrace(); } }
byte[] buffer = new byte[1024]; int len = in.read(buffer); while (len != -1) { out.write(buffer, 0, len); len = in.read(buffer); if (Thread.interrupted()) { throw new InterruptedException(); } }
private static final int BUFFER_SIZE = 8192; /** * Reads all bytes from an input stream and writes them to an output stream. */ private static long copy(InputStream source, OutputStream sink) throws IOException { long nread = 0L; byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = source.read(buf)) > 0) { sink.write(buf, 0, n); nread += n; } return nread; }
try(InputStream inputStream = new FileInputStream("C:\\mov.mp4"); OutputStream outputStream = new FileOutputStream("D:\\mov.mp4")){ byte[] buffer = new byte[10*1024]; for (int length; (length = inputStream.read(buffer)) != -1; ){ outputStream.write(buffer, 0, length); } }catch (FileNotFoundException exception){ exception.printStackTrace(); }catch (IOException ioException){ ioException.printStackTrace(); }
import org.apache.commons.net.io.Util; ... Util.copyStream(in, out);
private void copy(final InputStream in, final OutputStream out) throws IOException { final byte[] b = new byte[8192]; for (int r; (r = in.read(b)) != -1;) { out.write(b, 0, r); } }
byte[] buffer = new byte[4096]; int n; while ((n = in.read(buffer)) > 0) { out.write(buffer, 0, n); } out.close();
byte[] buffer = new byte[2048]; for (int n = in.read(buffer); n >= 0; n = in.read(buffer)) out.write(buffer, 0, n);
public static boolean copyFile(InputStream inputStream, OutputStream out) { byte buf[] = new byte[1024]; int len; long startTime=System.currentTimeMillis(); try { while ((len = inputStream.read(buf)) != -1) { out.write(buf, 0, len); } long endTime=System.currentTimeMillis()-startTime; Log.v("","Time taken to transfer all bytes is : "+endTime); out.close(); inputStream.close(); } catch (IOException e) { return false; } return true; }
public static void copyStream(InputStream is, OutputStream os) { final int buffer_size=1024; try { byte[] bytes=new byte[buffer_size]; for(;;) { int count=is.read(bytes, 0, buffer_size); if(count==-1) break; os.write(bytes, 0, count); } } catch(Exception ex){} }
public class MultiplyTest { public static void main(String[] args) { Random r = new Random(1); long tm = 0, count = 0,result=0; for (int i = 0; i < 400000; i++) { int s1 = 400, s2 = 400; BigInteger a = new BigInteger(s1 * 8, r), b = new BigInteger(s2 * 8, r); long tm1 = System.nanoTime(); BigInteger c = a.multiply(b); if (i > 100000) { tm += System.nanoTime() - tm1; count++; } result+=c.bitLength(); } System.out.println((tm / count) + "nsec/mul"); System.out.println(result); } }
-Xbatch -XX:-TieredCompilation -XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining -XX:CICompilerCount=1
private static BigInteger test() { Random r = new Random(1); BigInteger c = null; for (int i = 0; i < 400000; i++) { int s1 = 400, s2 = 400; BigInteger a = new BigInteger(s1 * 8, r), b = new BigInteger(s2 * 8, r); c = a.multiply(b); } return c; }
java -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining -XX:+PrintIntrinsics -XX:CICompilerCount=2 -XX:+PrintCompilation <YourClassName>
java.math.BigInteger::multiplyToLen (216 bytes) (intrinsic)
@HotSpotIntrinsicCandidate private static int[] implMultiplyToLen
java.math.BigInteger::implMultiplyToLen (216 bytes) (intrinsic)
@EqualsAndHashCode(callSuper = false, of = { "field1", "field2", "field3" })
public class MaxSeconds { public static final int MAX_SECONDS = 25; }
public static final Point ORIGIN = new Point(0,0); public static void main(String[] args){ ORIGIN.x = 3; }
package com.effectivejava.science; public class PhysicalConstants { private PhysicalConstants() { } public static final double AVOGADROS_NUMBER = 6.02214199e23; public static final double BOLTZMANN_CONSTANT = 1.3806503e-23; public static final double ELECTRON_MASS = 9.10938188e-31; }
public interface MyConstants { String CONSTANT_ONE = "foo"; } public class NeddsConstant implements MyConstants { }
public final class Constants { public final class File { public static final int MIN_ROWS = 1; public static final int MAX_ROWS = 1000; private File() {} } public final class DB { public static final String name = "oups"; public final class Connection { public static final String URL = "jdbc:tra-ta-ta"; public static final String USER = "testUser"; public static final String PASSWORD = "testPassword"; private Connection() {} } private DB() {} } private Constants() {} }
public class Constants { private Constants() { throw new AssertionError(); } public interface ConstantType {} public enum StringConstant implements ConstantType { DB_HOST("localhost"); private String value; private StringConstant(String value) { this.value = value; } public String value() { return value; } } public enum IntConstant implements ConstantType { DB_PORT(3128), MAX_PAGE_SIZE(100); private int value; private IntConstant(int value) { this.value = value; } public int value() { return value; } } public enum SimpleConstant implements ConstantType { STATE_INIT, STATE_START, STATE_END; } }
public, so that they are accessible from everywhere static, so that they can be accessed without any instance. Since they are constants it makes little sense to duplicate them for every object. final, since they should not be allowed to change
1. Use a regular enum with a default/private constructor. Most people would define constants this way, IMHO. - drawback: cannot effectively Javadoc each constant member - advantage: var members are implicitly public, static, and final - advantage: type-safe - provides "a limited constructor" in a special way that only takes args which match predefined constructor 2. Use a altered enum WITHOUT a constructor, having all variables defined with prefixed - looks funny just having a floating semi-colon in the code - advantage: you can JavaDoc each variable with an explanation - drawback: you still have to put explicit - drawback: not type-safe - no 3. Use a Class with a private constructor: - advantage: you can JavaDoc each variable with an explanation - drawback: you have to put explicit - you have the option of having a constructor to create an instance of the class if you want to provide additional functions related to your constants (or just keep the constructor private) - drawback: not type-safe 4. Using interface: - advantage: you can JavaDoc each variable with an explanation - advantage: var members are implicitly - you are able to define default interface methods if you want to provide additional functions related to your constants (only if you implement the interface) - drawback: not type-safe
public class MyClass{ public static final String ONE_CONSTANT = "value"; public static final String ANOTHER_CONSTANT = "other value"; . . . }
public void process(String constantExpected){ ... }
public enum MyEnum { ONE_CONSTANT("value"), ANOTHER_CONSTANT(" another value"); private String value; MyEnum(String value) { this.value = value; } ... }
public final class Math { ... public static final double E = 2.7182818284590452354; public static final double PI = 3.14159265358979323846; ... }
public enum TimeUnit { NANOSECONDS { ..... }, MICROSECONDS { ..... }, MILLISECONDS { ..... }, SECONDS { ..... }, ..... }
public class OfficePrinter { public static final String STATE = "Ready"; }
public class OfficePrinter { public enum PrinterState { Ready, PCLoadLetter, OutOfToner, Offline }; public static final PrinterState STATE = PrinterState.Ready; }
public interface MyGlobalConstants { public static final int TIMEOUT_IN_SECS = 25; }
public class MyGlobalConstants { private MyGlobalConstants () {} public static final int TIMEOUT_IN_SECS = 25; }
public interface MyGlobalConstants { public static final int TIMEOUT_IN_SECS = 25; }
public enum myEnum { Option1("String1", 2), Option2("String2", 2) ; String str; int i; myEnum(String str1, int i1) { this.str = str1 ; this.i1 = i } }
@Retention(SOURCE) @IntDef({NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST,NAVIGATION_MODE_TABS}) public @interface NavigationMode {} public static final int NAVIGATION_MODE_STANDARD = 0; public static final int NAVIGATION_MODE_LIST = 1; public static final int NAVIGATION_MODE_TABS = 2; ... public abstract void setNavigationMode(@NavigationMode int mode); @NavigationMode public abstract int getNavigationMode();
public interface CustomerService { public interface Label{ char AssignmentCharacter = public interface Address{ String Street = "Street"; String Unit= "Unit/Suite"; String Municipal = "City"; String County = "County"; String Provincial = "State"; String PostalCode = "Zip" } public interface Person { public interface NameParts{ String Given = "First/Given name" String Auxiliary = "Middle initial" String Family = "Last name" } } } }
CustomerService.Label.Address.Street CustomerService.Label.Person.NameParts.Family
public class PurchaseRequest { private interface Constants{ String INTERESTINGName = "Interesting Name"; String OFFICIALLanguage = "Official Language" int MAXNames = 9; } }
public interface PurchaseOrderConstants { public interface Properties{ default String InterestingName(){ return something(); } String OFFICIALLanguage = "Official Language" int MAXNames = 9; } }
String[] array = new String[] { "a", "b", "c" }; String joined2 = String.join(",", array);
List<String> list = Arrays.asList(array); String joined3 = String.join(",", list);
String[] s = new String[] {"a", "b", "c"}; String joined = StringUtils.join(s, ",");
public static String strJoin(String[] aArr, String sSep) { StringBuilder sbStr = new StringBuilder(); for (int i = 0, il = aArr.length; i < il; i++) { if (i > 0) sbStr.append(sSep); sbStr.append(aArr[i]); } return sbStr.toString(); }
String str = new StringJoiner(",").add("a").add("b").add("c").toString();
String str = Arrays.asList("a", "b", "c").stream().collect(Collectors.joining(","));
String[] strings = {"a", "b", "c"}; String result = Arrays.asList(strings).toString().replaceAll("(^\\[|\\]$)", "").replace(", ", ",");
String[] strings = {"a", "b", "c"}; String result = ("" + Arrays.asList(strings)).replaceAll("(^.|.$)", "").replace(", ", "," );
public static String join(String separator, String ... values) { if (values.length==0)return ""; char[] sep = separator.toCharArray(); int totalSize = (values.length - 1) * sep.length; for (int i = 0; i < values.length; i++) { if (values[i] == null) values[i] = ""; else totalSize += values[i].length(); } char[] joined = new char[totalSize]; int pos = 0; for (int i = 0, end = values.length-1; i < end; i++) { System.arraycopy(values[i].toCharArray(), 0, joined, pos, values[i].length()); pos += values[i].length(); System.arraycopy(sep, 0, joined, pos, sep.length); pos += sep.length; } System.arraycopy(values[values.length-1].toCharArray(), 0, joined, pos, values[values.length-1].length()); return new String(joined); }
public static String join(String separator, String... values) { StringBuilder sb = new StringBuilder(128); int end = 0; for (String s : values) { if (s != null) { sb.append(s); end = sb.length(); sb.append(separator); } } return sb.substring(0, end); }
public static String join(String[] strings, int startIndex, String separator) { StringBuffer sb = new StringBuffer(); for (int i=startIndex; i < strings.length; i++) { if (i != startIndex) sb.append(separator); sb.append(strings[i]); } return sb.toString(); }
public static String join(String[] values) { return join(values, } public static String join(String[] values, char delimiter) { return join(Arrays.asList(values), String.valueOf(delimiter)); } public static String join(String[] values, String delimiter) { return join(Arrays.asList(values), delimiter); } public static String join(Collection<?> values) { return join(values, } public static String join(Collection<?> values, char delimiter) { return join(values, String.valueOf(delimiter)); } public static String join(Collection<?> values, String delimiter) { if (values == null) { return new String(); } StringBuffer strbuf = new StringBuffer(); boolean first = true; for (Object value : values) { if (!first) { strbuf.append(delimiter); } else { first = false; } strbuf.append(value.toString()); } return strbuf.toString(); }
public String join(String[] str, String separator){ String retval = ""; for (String s: str){ retval+= separator + s;} return retval.replaceFirst(separator, ""); }
(new java.util.Date()).getTime() - oldDate.getTime()
Interval interval = new Interval(oldTime, new Instant());
/** * Get a diff between two dates * @param date1 the oldest date * @param date2 the newest date * @param timeUnit the unit in which you want the diff * @return the diff value, in the provided unit */ public static long getDateDiff(Date date1, Date date2, TimeUnit timeUnit) { long diffInMillies = date2.getTime() - date1.getTime(); return timeUnit.convert(diffInMillies,TimeUnit.MILLISECONDS); }
public static Map<TimeUnit,Long> computeDiff(Date date1, Date date2) { long diffInMillies = date2.getTime() - date1.getTime(); List<TimeUnit> units = new ArrayList<TimeUnit>(EnumSet.allOf(TimeUnit.class)); Collections.reverse(units); Map<TimeUnit,Long> result = new LinkedHashMap<TimeUnit,Long>(); long milliesRest = diffInMillies; for ( TimeUnit unit : units ) { long diff = unit.convert(milliesRest,TimeUnit.MILLISECONDS); long diffInMilliesForUnit = unit.toMillis(diff); milliesRest = milliesRest - diffInMilliesForUnit; result.put(unit,diff); } return result; }
Interval interval = new Interval(oldInstant, new Instant());
new Period(LocalDate.now(), LocalDate.now().plusDays(365*5), PeriodType.years()).getYears() new Period(LocalDate.now(), LocalDate.now().plusDays(365*5+1), PeriodType.years()).getYears() Years.yearsBetween(LocalDate.now(), LocalDate.now().plusDays(365*5)).getYears()
int diffInDays = (int)( (newerDate.getTime() - olderDate.getTime()) / (1000 * 60 * 60 * 24) )
ZonedDateTime now = ZonedDateTime.now(); ZonedDateTime oldDate = now.minusDays(1).minusMinutes(10); Duration duration = Duration.between(oldDate, now); System.out.println("ISO-8601: " + duration); System.out.println("Minutes: " + duration.toMinutes());
Duration d = Duration.between( myJavaUtilDate.toInstant() , Instant.now() ) ;
ZoneId zoneId = ZoneId.of ( "America/Montreal" ); ZonedDateTime now = ZonedDateTime.now ( zoneId ); ZonedDateTime future = now.plusMinutes ( 63 ); Duration duration = Duration.between ( now , future );
System.out.println ( "now: " + now + " to future: " + now + " = " + duration );
long daysElapsed = ChronoUnit.DAYS.between( earlier , later );
Instant now = Instant.now(); Instant later = now.plus( Duration.ofHours( 2 ) );  long minutesElapsed = ChronoUnit.MINUTES.between( now , later );
DateTime now = DateTime.now(); Period period = new Period( now, now.plusHours( 4 ).plusMinutes( 30)); System.out.println( "period: " + period );
Days d = Days.daysBetween(startDate, endDate); int days = d.getDays();
/** Manual Method - YIELDS INCORRECT RESULTS - DO NOT USE**/ public long calculateDays(Date dateEarly, Date dateLater) { return (dateLater.getTime() - dateEarly.getTime()) / (24 * 60 * 60 * 1000); }
/** Using Calendar - THE CORRECT WAY**/ public static long daysBetween(Calendar startDate, Calendar endDate) { Calendar date = (Calendar) startDate.clone(); long daysBetween = 0; while (date.before(endDate)) { date.add(Calendar.DAY_OF_MONTH, 1); daysBetween++; } return daysBetween; }
Calendar calendar1 = Calendar.getInstance(); Calendar calendar2 = Calendar.getInstance(); calendar1.set(2012, 04, 02); calendar2.set(2012, 04, 04); long milsecs1= calendar1.getTimeInMillis(); long milsecs2 = calendar2.getTimeInMillis(); long diff = milsecs2 - milsecs1; long dsecs = diff / 1000; long dminutes = diff / (60 * 1000); long dhours = diff / (60 * 60 * 1000); long ddays = diff / (24 * 60 * 60 * 1000); System.out.println("Your Day Difference="+ddays);
LocalDate d1 = LocalDate.of(2017, 5, 1); LocalDate d2 = LocalDate.of(2017, 5, 18); long days = ChronoUnit.DAYS.between(d1, d2); System.out.println( days );
public static final long MSPERDAY = 60 * 60 * 24 * 1000; ... final Calendar dateStartCal = Calendar.getInstance(); dateStartCal.setTime(dateStart); dateStartCal.set(Calendar.HOUR_OF_DAY, 0); dateStartCal.set(Calendar.MINUTE, 0); dateStartCal.set(Calendar.SECOND, 0); dateStartCal.set(Calendar.MILLISECOND, 0); final Calendar dateEndCal = Calendar.getInstance(); dateEndCal.setTime(dateEnd); dateEndCal.set(Calendar.HOUR_OF_DAY, 0); dateEndCal.set(Calendar.MINUTE, 0); dateEndCal.set(Calendar.SECOND, 0); dateEndCal.set(Calendar.MILLISECOND, 0); final long dateDifferenceInDays = ( dateStartCal.getTimeInMillis() - dateEndCal.getTimeInMillis() ) / MSPERDAY; if (dateDifferenceInDays > 15) { }
final static long MILLIS_PER_DAY = 24 * 3600 * 1000; long msDiff= date1.getTime() - date2.getTime(); long daysDiff = Math.round(msDiff / ((double)MILLIS_PER_DAY));
DateTime start = new DateTime(2012, 2, 6, 10, 44, 51, 0); DateTime end = new DateTime(2012, 2, 6, 11, 39, 47, 1); Interval interval = new Interval(start, end); Period period = interval.toPeriod(); System.out.println(period.getYears() + " years, " + period.getMonths() + " months, " + period.getWeeks() + " weeks, " + period.getDays() + " days"); System.out.println(period.getHours() + " hours, " + period.getMinutes() + " minutes, " + period.getSeconds() + " seconds "); Period p = new Period(start, end, PeriodType.yearMonthDayTime()); System.out.println(p.getYears() + " years, " + p.getMonths() + " months, " + p.getWeeks() + " weeks, " + p.getDays() + "days"); System.out.println(p.getHours() + " hours, " + p.getMinutes() + " minutes, " + p.getSeconds() + " seconds ");
public String fill2(int value) { String ret = String.valueOf(value); if (ret.length() < 2) ret = "0" + ret; return ret; } public String get_duration(Date date1, Date date2) { TimeUnit timeUnit = TimeUnit.SECONDS; long diffInMilli = date2.getTime() - date1.getTime(); long s = timeUnit.convert(diffInMilli, TimeUnit.MILLISECONDS); long days = s / (24 * 60 * 60); long rest = s - (days * 24 * 60 * 60); long hrs = rest / (60 * 60); long rest1 = rest - (hrs * 60 * 60); long min = rest1 / 60; long sec = s % 60; String dates = ""; if (days > 0) dates = days + " Days "; dates += fill2((int) hrs) + "h "; dates += fill2((int) min) + "m "; dates += fill2((int) sec) + "s "; return dates; }
import java.util.Calendar; import java.util.Date; public class DateDifferent { public static void main(String[] args) { Date date1 = new Date(2009, 01, 10); Date date2 = new Date(2009, 07, 01); Calendar calendar1 = Calendar.getInstance(); Calendar calendar2 = Calendar.getInstance(); calendar1.setTime(date1); calendar2.setTime(date2); long milliseconds1 = calendar1.getTimeInMillis(); long milliseconds2 = calendar2.getTimeInMillis(); long diff = milliseconds2 - milliseconds1; long diffSeconds = diff / 1000; long diffMinutes = diff / (60 * 1000); long diffHours = diff / (60 * 60 * 1000); long diffDays = diff / (24 * 60 * 60 * 1000); System.out.println("\nThe Date Different Example"); System.out.println("Time in milliseconds: " + diff + " milliseconds."); System.out.println("Time in seconds: " + diffSeconds + " seconds."); System.out.println("Time in minutes: " + diffMinutes + " minutes."); System.out.println("Time in hours: " + diffHours + " hours."); System.out.println("Time in days: " + diffDays + " days."); } }
final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT")); cal.set(Calendar.YEAR, 2011); cal.set(Calendar.MONTH, 9); cal.set(Calendar.DAY_OF_MONTH, 29); cal.set(Calendar.HOUR, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); final Date startDate = cal.getTime(); cal.set(Calendar.YEAR, 2011); cal.set(Calendar.MONTH, 12); cal.set(Calendar.DAY_OF_MONTH, 21); cal.set(Calendar.HOUR, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); final Date endDate = cal.getTime(); System.out.println((endDate.getTime() - startDate.getTime()) % (1000l * 60l * 60l * 24l));
String startDate = "Jan 01 2015"; DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MMM dd yyyy"); LocalDate date = LocalDate.parse(startDate, formatter); String currentDate = "Feb 11 2015"; LocalDate date1 = LocalDate.parse(currentDate, formatter); System.out.println(date1.toEpochDay() - date.toEpochDay());
public static String getDifferenceBtwTime(Date dateTime) { long timeDifferenceMilliseconds = new Date().getTime() - dateTime.getTime(); long diffSeconds = timeDifferenceMilliseconds / 1000; long diffMinutes = timeDifferenceMilliseconds / (60 * 1000); long diffHours = timeDifferenceMilliseconds / (60 * 60 * 1000); long diffDays = timeDifferenceMilliseconds / (60 * 60 * 1000 * 24); long diffWeeks = timeDifferenceMilliseconds / (60 * 60 * 1000 * 24 * 7); long diffMonths = (long) (timeDifferenceMilliseconds / (60 * 60 * 1000 * 24 * 30.41666666)); long diffYears = (long)(timeDifferenceMilliseconds / (1000 * 60 * 60 * 24 * 365)); if (diffSeconds < 1) { return "one sec ago"; } else if (diffMinutes < 1) { return diffSeconds + " seconds ago"; } else if (diffHours < 1) { return diffMinutes + " minutes ago"; } else if (diffDays < 1) { return diffHours + " hours ago"; } else if (diffWeeks < 1) { return diffDays + " days ago"; } else if (diffMonths < 1) { return diffWeeks + " weeks ago"; } else if (diffYears < 12) { return diffMonths + " months ago"; } else { return diffYears + " years ago"; } }
int daysDiff = (date1.getTime() - date2.getTime()) / MILLIS_PER_DAY;
class Duration { private final TimeUnit unit; private final long length; }
DateTime a = ..., b = ...; Duration d = new Duration(a, b);
import org.joda.time.Duration; import org.joda.time.Interval; Interval interval = new Interval(startDate.getTime(), endDate.getTime); Duration period = interval.toDuration(); period.getStandardDays()
period.getStandardHours(); period.getStandardMinutes(); period.getStandardSeconds();
Date dahora = new Date(); long MillisToYearsByDiv = 1000l *60l * 60l * 24l * 365l; long javaOffsetInMillis = 1990l * MillisToYearsByDiv; long realNowInMillis = dahora.getTime() + javaOffsetInMillis; long realBirthDayInMillis = this.getFechaNac().getTime() + javaOffsetInMillis; long ageInMillis = realNowInMillis - realBirthDayInMillis; return ageInMillis / MillisToYearsByDiv;
import scala.concurrent.duration._ val diff = (System.currentTimeMillis() - oldDate.getTime).milliseconds val diffSeconds = diff.toSeconds val diffMinutes = diff.toMinutes val diffHours = diff.toHours val diffDays = diff.toDays
public static int countDaysBetween(Date date1, Date date2) { Calendar c1 = removeTime(from(date1)); Calendar c2 = removeTime(from(date2)); if (c1.get(YEAR) == c2.get(YEAR)) { return Math.abs(c1.get(DAY_OF_YEAR) - c2.get(DAY_OF_YEAR)) + 1; } if (c1.get(YEAR) > c2.get(YEAR)) { Calendar c = c1; c1 = c2; c2 = c; } int y1 = c1.get(YEAR); int y2 = c2.get(YEAR); int d1 = c1.get(DAY_OF_YEAR); int d2 = c2.get(DAY_OF_YEAR); return d2 + ((y2 - y1) * 365) - d1 + countLeapYearsBetween(y1, y2) + 1; } private static int countLeapYearsBetween(int y1, int y2) { if (y1 < 1 || y2 < 1) { throw new IllegalArgumentException("Year must be > 0."); } if (y1 > y2) { int i = y1; y1 = y2; y2 = i; } int diff = 0; int firstDivisibleBy4 = y1; if (firstDivisibleBy4 % 4 != 0) { firstDivisibleBy4 += 4 - (y1 % 4); } diff = y2 - firstDivisibleBy4 - 1; int divisibleBy4 = diff < 0 ? 0 : diff / 4 + 1; int firstDivisibleBy100 = y1; if (firstDivisibleBy100 % 100 != 0) { firstDivisibleBy100 += 100 - (firstDivisibleBy100 % 100); } diff = y2 - firstDivisibleBy100 - 1; int divisibleBy100 = diff < 0 ? 0 : diff / 100 + 1; int firstDivisibleBy400 = y1; if (firstDivisibleBy400 % 400 != 0) { firstDivisibleBy400 += 400 - (y1 % 400); } diff = y2 - firstDivisibleBy400 - 1; int divisibleBy400 = diff < 0 ? 0 : diff / 400 + 1; return divisibleBy4 - divisibleBy100 + divisibleBy400; } public static Calendar from(Date date) { Calendar c = Calendar.getInstance(); c.setTime(date); return c; } public static Calendar removeTime(Calendar c) { c.set(HOUR_OF_DAY, 0); c.set(MINUTE, 0); c.set(SECOND, 0); c.set(MILLISECOND, 0); return c; }
public static long daysBetweenDates(Date d1, Date d2) { Instant instant1 = d1.toInstant(); Instant instant2 = d2.toInstant(); long diff = ChronoUnit.DAYS.between(instant1, instant2); return diff; }
int epoch = (int) (new java.text.SimpleDateFormat("MM/dd/yyyy HH:mm:ss").parse("01/01/1970 00:00:00").getTime() / 1000);
@FunctionalInterface public interface CheckedFunction<T, R> { R apply(T t) throws IOException; }
public Integer myWrappedMethod(String s) { try { return myMethod(s); } catch(IOException e) { throw new UncheckedIOException(e); } }
Function<String, Integer> f = (String t) -> myWrappedMethod(t);
Function<String, Integer> f = (String t) -> { try { return myMethod(t); } catch(IOException e) { throw new UncheckedIOException(e); } };
@FunctionalInterface public interface ThrowingConsumer<T> extends Consumer<T> { @Override default void accept(final T elem) { try { acceptThrows(elem); } catch (final Exception e) { System.out.println("handling an exception..."); throw new RuntimeException(e); } } void acceptThrows(T elem) throws Exception; }
final List<String> list = Arrays.asList("A", "B", "C");
final Consumer<String> consumer = aps -> { try { throw new Exception("asdas"); } catch (final Exception ex) { System.out.println("handling an exception..."); } }; list.forEach(consumer);
final ThrowingConsumer<String> throwingConsumer = aps -> { throw new Exception("asdas"); }; list.forEach(throwingConsumer);
list.forEach((ThrowingConsumer<String>) aps -> { throw new Exception("asda"); });
list.forEach(Errors.rethrow().wrap(c -> somethingThatThrows(c)));
interface I { void m(); } class C implements I { public void m() throws Exception {} }
(String s) -> { try { return myMethod(s); } catch (IOException ex) { throw new RuntimeException(ex); } }
public interface FunctionThatThrowsIOException<I, O> { O apply(I input) throws IOException; }
CheckedFunction1<String, Integer> f = this::myMethod;
Function<String, Integer> func1 = s -> Unthrow.wrap(() -> myMethod(s));
Function<String, Integer> func2 = s1 -> Unthrow.wrap((s2) -> myMethod(s2), s1);
public final class LambdaExceptionUtil { @FunctionalInterface public interface Function_WithExceptions<T, R, E extends Exception> { R apply(T t) throws E; } /** * .map(rethrowFunction(name -> Class.forName(name))) or .map(rethrowFunction(Class::forName)) */ public static <T, R, E extends Exception> Function<T, R> rethrowFunction(Function_WithExceptions<T, R, E> function) throws E { return t -> { try { return function.apply(t); } catch (Exception exception) { throwActualException(exception); return null; } }; } @SuppressWarnings("unchecked") private static <E extends Exception> void throwActualException(Exception exception) throws E { throw (E) exception; } } public class LambdaExceptionUtilTest { @Test public void testFunction() throws MyTestException { List<Integer> sizes = Stream.of("ciao", "hello").<Integer>map(rethrowFunction(s -> transform(s))).collect(toList()); assertEquals(2, sizes.size()); assertEquals(4, sizes.get(0).intValue()); assertEquals(5, sizes.get(1).intValue()); } private Integer transform(String value) throws MyTestException { if(value==null) { throw new MyTestException(); } return value.length(); } private static class MyTestException extends Exception { } }
final ThrowingFunction<String, Integer> f = yourMethodReferenceHere;
public Object uncheckedNewInstanceForName (String name) { try { return Class.forName(name).newInstance(); } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) { throw new RuntimeException(e); } }
@FunctionalInterface public interface UseInstance<T, X extends Throwable> { void accept(T instance) throws X; }
import java.io.FileWriter; import java.io.IOException; public class FileWriterEAM { private final FileWriter writer; private FileWriterEAM(final String fileName) throws IOException { writer = new FileWriter(fileName); } private void close() throws IOException { System.out.println("close called automatically..."); writer.close(); } public void writeStuff(final String message) throws IOException { writer.write(message); } public static void use(final String fileName, final UseInstance<FileWriterEAM, IOException> block) throws IOException { final FileWriterEAM writerEAM = new FileWriterEAM(fileName); try { block.accept(writerEAM); } finally { writerEAM.close(); } } public static void main(final String[] args) throws IOException { FileWriterEAM.use("eam.txt", writerEAM -> writerEAM.writeStuff("sweet")); FileWriterEAM.use("eam2.txt", writerEAM -> { writerEAM.writeStuff("how"); writerEAM.writeStuff("sweet"); }); FileWriterEAM.use("eam3.txt", FileWriterEAM::writeIt); } void writeIt() throws IOException{ this.writeStuff("How "); this.writeStuff("sweet "); this.writeStuff("it is"); } }
import static Throwing.rethrow; @Test public void testRethrow() { thrown.expect(IOException.class); thrown.expectMessage("i=3"); Arrays.asList(1, 2, 3).forEach(rethrow(e -> { int i = e.intValue(); if (i == 3) { throw new IOException("i=" + i); } })); }
public final class Throwing { private Throwing() {} @Nonnull public static <T> Consumer<T> rethrow(@Nonnull final ThrowingConsumer<T> consumer) { return consumer; } /** * The compiler sees the signature with the throws T inferred to a RuntimeException type, so it * allows the unchecked exception to propagate. * * http: */ @SuppressWarnings("unchecked") @Nonnull public static <E extends Throwable> void sneakyThrow(@Nonnull Throwable ex) throws E { throw (E) ex; } }
public interface ThrowableFunction<A, B> { B apply(A a) throws Exception; } public abstract class Try<A> { public static boolean isSuccess(Try tryy) { return tryy instanceof Success; } public static <A, B> Function<A, Try<B>> tryOf(ThrowableFunction<A, B> function) { return a -> { try { B result = function.apply(a); return new Success<B>(result); } catch (Exception e) { return new Failure<>(e); } }; } public abstract boolean isSuccess(); public boolean isError() { return !isSuccess(); } public abstract A getResult(); public abstract Exception getError(); } public class Success<A> extends Try<A> { private final A result; public Success(A result) { this.result = result; } @Override public boolean isSuccess() { return true; } @Override public A getResult() { return result; } @Override public Exception getError() { return new UnsupportedOperationException(); } @Override public boolean equals(Object that) { if(!(that instanceof Success)) { return false; } return Objects.equal(result, ((Success) that).getResult()); } } public class Failure<A> extends Try<A> { private final Exception exception; public Failure(Exception exception) { this.exception = exception; } @Override public boolean isSuccess() { return false; } @Override public A getResult() { throw new UnsupportedOperationException(); } @Override public Exception getError() { return exception; } }
List<Try<Integer>> result = Lists.newArrayList(1, 2, 3).stream(). map(Try.<Integer, Integer>tryOf(i -> someMethodThrowingAnException(i))). collect(Collectors.toList());
ExceptionTranslator et = ET.newConfiguration().done(); ... Function<String, Integer> f = (t) -> et.withReturningTranslation(() -> myMethod(t)); Consumer<String> c = (t) -> et.withTranslation(() -> myMethod(t));
acceptMyMethod(s -> { try { Integer i = doSomeOperation(s); return i; } catch (IOException e) { e.printStackTrace(); } return null; });
public interface MyAmazingAPI { Integer myMethod(String s) throws IOException; }
public interface MyAmazingAPI { Integer myMethod(String s) throws IOException; default Optional<Integer> myMethod(String s, Consumer<? super Exception> exceptionConsumer) { try { return Optional.ofNullable(this.myMethod(s)); } catch (Exception e) { if (exceptionConsumer != null) { exceptionConsumer.accept(e); } else { e.printStackTrace(); } } return Optional.empty(); } }
strStream.map(str -> amazingAPIs.myMethod(str, Exception::printStackTrace)) .filter(Optional::isPresent) .map(Optional::get).collect(toList());
public static interface CheckedValueSupplier<V> { public V get () throws Exception; }
public class CheckedValue<V> { private final V v; private final Optional<Exception> opt; public Value (V v) { this.v = v; } public Value (Exception e) { this.opt = Optional.of(e); } public V get () throws Exception { if (opt.isPresent()) { throw opt.get(); } return v; } public Optional<Exception> getException () { return opt; } public static <T> CheckedValue<T> returns (T t) { return new CheckedValue<T>(t); } public static <T> CheckedValue<T> rethrows (Exception e) { return new CheckedValue<T>(e); } public static <V> CheckedValue<V> from (CheckedValueSupplier<V> sup) { try { return CheckedValue.returns(sup.get()); } catch (Exception e) { return Result.rethrows(e); } } public static <V> CheckedValue<V> escalates (CheckedValueSupplier<V> sup) { try { return CheckedValue.returns(sup.get()); } catch (Exception e) { throw new RuntimeException(e); } } }
Function<String, FileReader> sToFr = (fn) -> new FileReader(Paths.get(fn).toFile()); Function<String, CheckedValue<FileReader>> sToFr = (fn) -> { return CheckedValue.from ( () -> new FileReader(Paths.get("/home/" + f).toFile())); }; FileReader readMe = pToFr.apply("/home/README").get(); List<String> paths = ...; Collection<CheckedValue<FileReader>> frs = paths.stream().map(pToFr).collect(Collectors.toList()); boolean anyErrors = frs.stream() .filter(f -> f.getException().isPresent()) .findAny().isPresent();
List<String> lst = Lists.newArrayList(); lst.stream().forEach(e -> throwyMethod(e)); lst.stream() .map(e -> CheckedValueSupplier.from( () -> {throwyMethod(e); return e;})) .filter(v -> v.getException().isPresent());
@FunctionalInterface public interface FunctionWithException<T, R, E extends Exception> { R apply(T t) throws E; }
private FunctionWithException<String, Integer, IOException> myMethod = (str) -> { if ("abc".equals(str)) { throw new IOException(); } return 1; };
public static <T, R> Function<? super T, ? extends R> defaultIfThrows(FunctionThatThrows<? super T, ? extends R> delegate, R defaultValue) { return x -> { try { return delegate.apply(x); } catch (Throwable throwable) { return defaultValue; } }; } @FunctionalInterface public interface FunctionThatThrows<T, R> { R apply(T t) throws Throwable; }
Function<String, Integer> standardFn = FluentFunctions.ofChecked(this::myMethod);
FluentFunctions.ofChecked(this::myMethod) .log(s->log.debug(s),e->log.error(e,e.getMessage()) .try(5,1000) .apply("my param");
public interface Lambda { @FunctionalInterface public interface CheckedFunction<T> { T get() throws Exception; } public static <T> T handle(CheckedFunction<T> supplier) { try { return supplier.get(); } catch (Exception exception) { throw new RuntimeException(exception); } } }
public class UncheckedExceptions { /** * throws {@code exception} as unchecked exception, without wrapping exception. * * @return will never return anything, return type is set to {@code exception} only to be able to write <code>throw unchecked(exception)</code> * @throws T {@code exception} as unchecked exception */ @SuppressWarnings("unchecked") public static <T extends Throwable> T unchecked(Exception exception) throws T { throw (T) exception; } @FunctionalInterface public interface UncheckedFunction<R> { R call() throws Exception; } /** * Executes given function, * catches and rethrows checked exceptions as unchecked exceptions, without wrapping exception. * * @return result of function * @see */ public static <R> R unchecked(UncheckedFunction<R> function) { try { return function.call(); } catch (Exception e) { throw unchecked(e); } } @FunctionalInterface public interface UncheckedMethod { void call() throws Exception; } /** * Executes given method, * catches and rethrows checked exceptions as unchecked exceptions, without wrapping exception. * * @see */ public static void unchecked(UncheckedMethod method) { try { method.call(); } catch (Exception e) { throw unchecked(e); } } }
public void frankTest() { int pageId= -1; List<Book> users= null; try { Object page= DatabaseConnection.getSpringConnection().queryForObject("SELECT * FROM bookmark_page", (rw, n) -> { try { final Book bk= users.stream().filter(bp -> { String name= null; try { name = rw.getString("name"); } catch (Exception e) { e.printStackTrace(); } return bp.getTitle().equals(name); }).limit(1).collect(Collectors.toList()).get(0); } catch (Exception e) { e.printStackTrace(); } return new Portal(rw.getInt("id"), "", users.get(0), rw.getString("name")); } ); } catch (Exception e) { e.printStackTrace(); } }
@Entity public Parent { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; @OneToMany(mappedBy="parent", fetch=FetchType.EAGER) private List<Child> children; }
@Entity public Child { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; @ManyToOne private Parent parent; }
@Entity public Parent { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; @ManyToOne private AntoherParent anotherParent; @OneToMany(mappedBy="parent", fetch=FetchType.EAGER) private List<Child> children; }
@Entity public AntoherParent { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; @OneToMany(mappedBy="parent", fetch=FetchType.EAGER) private List<AnotherChild> anotherChildren; }
@OneToMany(mappedBy="parent", fetch=FetchType.EAGER) @Fetch(value = FetchMode.SUBSELECT) private List<Child> childs;
[...] @OneToMany(mappedBy="parent", fetch=FetchType.EAGER) @OrderColumn(name="orderIndex") private List<Child> children; [...]
@Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); return result; }
x = session.get(ClassName.class, id); Hibernate.initialize(x.getNestedField());
@XXXToXXX(targetEntity = XXXX.class, fetch = FetchType.LAZY)
$java -version java version "1.6.0_35" Java(TM) SE Runtime Environment (build 1.6.0_35-b10-428-11M3811) Java HotSpot(TM) 64-Bit Server VM (build 20.10-b01-428, mixed mode)
export JAVA_HOME="/System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home"
sudo rm /usr/bin/java sudo ln -s /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java /usr/bin
export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_11.jdk/Contents/Home"
export PATH=/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin:$PATH
export PATH="/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin:$PATH"
java version "1.6.0_31" Java(TM) SE Runtime Environment (build 1.6.0_31-b04) Java HotSpot(TM) 64-Bit Server VM (build 20.6-b01, mixed mode)
java version "1.8.0_05" Java(TM) SE Runtime Environment (build 1.8.0_05-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)
sudo rm /usr/bin/java sudo ln -s /Library/Java/JavaVirtualMachines/jdk1.8.0_31.jdk/Contents/Home/jre/bin/java /usr/bin/java
export PATH="/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin:$PATH"
ls -la /Library/Java/JavaVirtualMachines drwxr-xr-x 3 root wheel 96B Nov 16 2014 jdk1.7.0_71.jdk/ drwxr-xr-x 3 root wheel 96B Mar 1 2015 jdk1.8.0_31.jdk/
export JAVA_HOME=YOUR_JAVA_PATH/Contents/Home export PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_71.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_31.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH
java -version java version "1.7.0_71" Java(TM) SE Runtime Environment (build 1.7.0_71-b14)
java -version java version "1.8.0_31" Java(TM) SE Runtime Environment (build 1.8.0_31-b13)
defaults read /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Info.plist CFBundleVersion
lrwxr-xr-x CurrentJDK -> /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents** lrwxr-xr-x Current -> A lrwxr-xr-x 1 root wheel 10 Oct 18 14:39 1.6.0 -> CurrentJDK lrwxr-xr-x 1 root wheel 10 Oct 18 14:39 1.6 -> CurrentJDK lrwxr-xr-x 1 root wheel 10 Oct 18 14:39 1.5.0 -> CurrentJDK lrwxr-xr-x 1 root wheel 10 Oct 18 14:39 1.5 -> CurrentJDK lrwxr-xr-x 1 root wheel 10 Oct 18 14:39 1.4.2 -> CurrentJDK lrwxr-xr-x 1 root wheel 10 Oct 18 14:39 1.4 -> CurrentJDK
class Foo { companion object { fun a() : Int = 1 } }
class MyClass { companion object Factory { fun create(): MyClass = MyClass() } }
class Foo { companion object { @JvmStatic fun a() : Int = 1; } }
class Foo { companion object Blah { fun a() : Int = 1; } }
object Foo{ fun sayFoo() = println("Foo") val bar ="bar" }
package xxx class ClassName { companion object { fun helloWord(str: String): String { return stringValue } } }
class Test{ companion object{ fun isCheck(a:Int):Boolean{ if(a==0) true else false } } }
object Test{ fun isCheck(a:Int):Boolean{ if(a==0) true else false } }
class AppHelper { public static int getAge() { return 30; } }
class AppHelper { companion object { fun getAge() : Int = 30 } }
class MyClass { companion object { } } fun MyClass.Companion.newStaticFunction() { }
class Foo { companion object { fun square(x : Int) : Int = x*x } }
class UtilClass { companion object { fun repeatIt5Times(str: String): String = str.repeat(5) } }
class KotlinClass{ fun main(args : Array<String>) { UtilClass.repeatIt5Times("Hello") } }
import Packagename.UtilClass.Companion.repeatIt5Times class KotlinClass{ fun main(args : Array<String>) { repeatIt5Times("Hello") } }
class JavaClass{ public static void main(String [] args){ UtilClass.Companion.repeatIt5Times("Hello"); } }
class JavaClass{ public static void main(String [] args){ UtilClass.repeatIt5Times("Hello") } }
import static Packagename.UtilClass.repeatIt5Times class JavaClass{ public static void main(String [] args){ repeatIt5Times("Hello") } }
class SomeClass() { val id: Int init { id = nextId++ } private companion object { var nextId = 1 } } fun main(args: Array<String>) { repeat(2) { println(SomeClass().id) } }
class Util{ public static String capitalize(String text){ return text.toUpperCase();} } class Util { companion object { @JvmStatic fun capitalize(text:String): String { return text.toUpperCase() } } }
package xxx; class XxxUtils { public static final Yyy xxx(Xxx xxx) { return xxx.xxx(); } }
@file:JvmName("XxxUtils") package xxx fun xxx(xxx: Xxx): Yyy = xxx.xxx()
class Student(var name: String, var city: String, var rollNumber: Double = 0.0) { companion object { fun getUniversityName(): String = "MBSTU" var totalStudent = 30 } }
println("University : " + Student.getUniversityName() + ", Total Student: " + Student.totalStudent)
class MyClass{ companion object { val staticField = "This is an example of static field Object Decleration" fun getStaticFunction(): String { return "This is example of static function for Object Decleration" } } }
companion object { @JvmStatic fun main(args: Array<String>) { } fun staticMethod() { } }
class Foo { companion object { fun a() : Int = 1 } }
companion object { @JvmStatic fun newInstance(param1: String, param2: String) = EditProfileFragment().apply { arguments = Bundle().apply { putString(ARG_PARAM1, param1) putString(ARG_PARAM2, param2) } } }
object StringUtils { fun toUpper(s: String) : String { ... } }
List<A> listOfAs = new ArrayList<>(); List<B> listOfBs = (List<B>)(Object)listOfAs;
Object[] objectArray = bar; objectArray[0] = Arrays.asList(new Integer(42)); T firstElement = bar[0].get(0);
public static void testCode(){ List[] b = new List[1]; test(b); } @SafeVarargs public static void test(List<A>... a){ }
long time; final int len = 50000000; int arbitrary = 0; int[][] nums = new int[2][len]; for (double fraction = 0 ; fraction <= 0.9 ; fraction += 0.0078125) { for(int i = 0 ; i < 2 ; i++) { for(int j = 0 ; j < len ; j++) { double random = Math.random(); if(random < fraction) nums[i][j] = 0; else nums[i][j] = (int) (random*15 + 1); } } time = System.currentTimeMillis(); for(int i = 0 ; i < len ; i++) { if( /*insert nums[0][i]*nums[1][i]!=0 or nums[0][i]!=0 && nums[1][i]!=0*/ ) arbitrary++; } System.out.println(System.currentTimeMillis() - time); }
bool aNotZero = (nums[0][i] != 0); bool bNotZero = (nums[1][i] != 0); if (aNotZero && bNotZero) { }
int a = nums[0][i]; int b = nums[1][i]; if (a != 0 && b != 0) { }
public static String padRight(String s, int n) { return String.format("%1$-" + n + "s", s); } public static String padLeft(String s, int n) { return String.format("%1$" + n + "s", s); } ... public static void main(String args[]) throws Exception { System.out.println(padRight("Howto", 20) + "*"); System.out.println(padLeft("Howto", 20) + "*"); }
String.format("%10s", "foo").replace( String.format("%-10s", "bar").replace( String.format("%10s", "longer than 10 chars").replace(
String password = "secret123"; String padded = String.format("%"+password.length()+"s", "").replace(
Strings.padStart("string", 10, Strings.padEnd("string", 10,
String padded="00000000".substring(value.length()) + value;
String padded = value + ("ABCDEFGH".substring(value.length()));
String padString = "ABCDEFGH"; String padded = (padString.substring(0, padString.length() - value.length())) + value;
public String pad(String str, int size, char padChar) { StringBuffer padded = new StringBuffer(str); while (padded.length() < size) { padded.append(padChar); } return padded.toString(); }
public static String LPad(String str, Integer length, char car) { return (str + String.format("%" + length + "s", "").replace(" ", String.valueOf(car))).substring(0, length); } public static String RPad(String str, Integer length, char car) { return (String.format("%" + length + "s", "").replace(" ", String.valueOf(car)) + str).substring(str.length(), length + str.length()); } LPad("Hi", 10, RPad("Hi", 10, RPad("Hi", 10, RPad("Hi", 1,
final byte[] data = getData(); final MessageDigest md5= MessageDigest.getInstance("MD5"); md5.update(data); final BigInteger digest = new BigInteger(1,md5.digest()); String hex = String.format( "%1$32x", digest ); hex = hex.replace(" ","0"); System.out.println(hex);
public static String pad(String str, int size, char padChar) { if (str.length() < size) { char[] temp = new char[size]; int i = 0; while (i < str.length()) { temp[i] = str.charAt(i); i++; } while (i < size) { temp[i] = padChar; i++; } str = new String(temp); } return str; }
StringBuffer padded = new StringBuffer(pad); padded.append(value);
String paddedString = "--------------------"; String myStringToBePadded = "I like donuts"; myStringToBePadded = myStringToBePadded + paddedString.substring(myStringToBePadded.length()); myStringToBePadded = "I like donuts-------";
public class RightPadder { private int length; private String padding; public RightPadder(int length, String pad) { this.length = length; StringBuilder sb = new StringBuilder(pad); while (sb.length() < length) { sb.append(sb); } padding = sb.toString(); } public String pad(String s) { return (s.length() < length ? s + padding : s).substring(0, length); } }
AbstractStringBuilder append(CharSequence s, int start, int end) ;
private static final String MAX_STRING = " "; Set<StringBuilder> set= new HashSet<StringBuilder>(); set.add(new StringBuilder("12345678")); set.add(new StringBuilder("123456789")); set.add(new StringBuilder("1234567811")); set.add(new StringBuilder("12345678123")); set.add(new StringBuilder("1234567812234")); set.add(new StringBuilder("1234567812222")); set.add(new StringBuilder("12345678122334")); for(StringBuilder padMe: set) padMe.append(MAX_STRING, padMe.length(), MAX_STRING.length());
"".format("%1$-" + 9 + "s", "XXX").replaceAll(" ", "0")
public static String padLeft(String in, int size, char padChar) { if (in.length() <= size) { char[] temp = new char[size]; for(int i =0;i<size;i++){ temp[i]= padChar; } int posIniTemp = size-in.length(); for(int i=0;i<in.length();i++){ temp[posIniTemp]=in.charAt(i); posIniTemp++; } return new String(temp); } return ""; }
StringUtils.defaultString(StringUtils.leftPad(myString, 1))
public static String pad(String source, char fill, int length, boolean right){ if(source.length() > length) return source; char[] out = new char[length]; if(right){ System.arraycopy(source.toCharArray(), 0, out, 0, source.length()); Arrays.fill(out, source.length(), length, fill); }else{ int sourceOffset = length - source.length(); System.arraycopy(source.toCharArray(), 0, out, sourceOffset, source.length()); Arrays.fill(out, 0, sourceOffset, fill); } return new String(out); }
public static void main(String... args){ System.out.println("012345678901234567890123456789"); System.out.println(pad("cats", System.out.println(pad("cats", System.out.println(pad("cats", System.out.println(pad("cats", System.out.println(pad("too long for your own good, buddy", }
012345678901234567890123456789 cats cats cats cats$$$$$$$$$$$$$$$$$$$$$$$$$$ too long for your own good, buddy
private String leftPadding(String word, int length, char ch) { return (length > word.length()) ? leftPadding(ch + word, length, ch) : word; }
public static String padRight(String s, int n, char padding){ StringBuilder builder = new StringBuilder(s.length() + n); builder.append(s); for(int i = 0; i < n; i++){ builder.append(padding); } return builder.toString(); } public static String padLeft(String s, int n, char padding) { StringBuilder builder = new StringBuilder(s.length() + n); for(int i = 0; i < n; i++){ builder.append(Character.toString(padding)); } return builder.append(s).toString(); } public static String pad(String s, int n, char padding){ StringBuilder pad = new StringBuilder(s.length() + n * 2); StringBuilder value = new StringBuilder(n); for(int i = 0; i < n; i++){ pad.append(padding); } return value.append(pad).append(s).append(pad).toString(); }
public String pad(String num, int len){ if(len-num.length() <=0) return num; StringBuffer sb = new StringBuffer(); for(i=0; i<(len-num.length()); i++){ sb.append("0"); } sb.append(num); return sb.toString(); }
String pad = "******"; String input = "" | "abcd" | "abcdefgh"
result = pad.substring(Math.min(input.length(),pad.length())) + input; results: "******" | "**abcd" | "abcdefgh"
result = input + pad.substring(Math.min(input.length(),pad.length())); results: "******" | "abcd**" | "abcdefgh"
result = (pad + input).substring(input.length(), input.length() + pad.length()); results: "******" | "**abcd" | "cdefgh"
result = (input + pad).substring(0, pad.length()); results: "******" | "abcd**" | "abcdef"
public static char[] lpad(char[] pStringChar, int pTotalLength, char pPad) { if (pStringChar.length < pTotalLength) { char[] retChar = new char[pTotalLength]; int padIdx = pTotalLength - pStringChar.length; Arrays.fill(retChar, 0, padIdx, pPad); System.arraycopy(pStringChar, 0, retChar, padIdx, pStringChar.length); return retChar; } else { return pStringChar; } }
System.out.println("*".repeat(5)+"apple"); System.out.println("apple"+"*".repeat(5));
package nl; public class Padder { public static void main(String[] args) { String s = "123" ; System.out.println(" } }
String ax="Hello"; while(ax.length() < 15) ax="0"+ax;
public static void permutation(String str) { permutation("", str); } private static void permutation(String prefix, String str) { int n = str.length(); if (n == 0) System.out.println(prefix); else { for (int i = 0; i < n; i++) permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n)); } }
/** * List permutations of a string. * * @param s the input string * @return the list of permutations */ public static ArrayList<String> permutation(String s) { ArrayList<String> res = new ArrayList<String>(); if (s.length() == 1) { res.add(s); } else if (s.length() > 1) { int lastIndex = s.length() - 1; String last = s.substring(lastIndex); String rest = s.substring(0, lastIndex); res = merge(permutation(rest), last); } return res; } /** * @param list a result of permutation, e.g. {"ab", "ba"} * @param c the last character * @return a merged new list, e.g. {"cab", "acb" ... } */ public static ArrayList<String> merge(ArrayList<String> list, String c) { ArrayList<String> res = new ArrayList<>(); for (String s : list) { for (int i = 0; i <= s.length(); ++i) { String ps = new StringBuffer(s).insert(i, c).toString(); res.add(ps); } } return res; }
public class PermTest { public static void main(String[] args) throws Exception { String str = "abcdef"; StringBuffer strBuf = new StringBuffer(str); doPerm(strBuf,str.length()); } private static void doPerm(StringBuffer str, int index){ if(index <= 0) System.out.println(str); else { doPerm(str, index-1); int currPos = str.length()-index; for (int i = currPos+1; i < str.length(); i++) { swap(str,currPos, i); doPerm(str, index-1); swap(str,i, currPos); } } } private static void swap(StringBuffer str, int pos1, int pos2){ char t1 = str.charAt(pos1); str.setCharAt(pos1, str.charAt(pos2)); str.setCharAt(pos2, t1); } }
public static Set<String> generatePerm(String input) { Set<String> set = new HashSet<String>(); if (input == "") return set; Character a = input.charAt(0); if (input.length() > 1) { input = input.substring(1); Set<String> permSet = generatePerm(input); for (String x : permSet) { for (int i = 0; i <= x.length(); i++) { set.add(x.substring(0, i) + a + x.substring(i)); } } } else { set.add(a + ""); } return set; }
public static void main(String[] args) { String ourword = "abc"; String[] ourArray = ourword.split(""); permute(ourArray, ourArray.length); } private static void swap(String[] ourarray, int right, int left) { String temp = ourarray[right]; ourarray[right] = ourarray[left]; ourarray[left] = temp; } public static void permute(String[] ourArray, int currentPosition) { if (currentPosition == 1) { System.out.println(Arrays.toString(ourArray)); } else { for (int i = 0; i < currentPosition; i++) { permute(ourArray, currentPosition - 1); if (currentPosition % 2 == 1) { swap(ourArray, 0, currentPosition - 1); } else { swap(ourArray, i, currentPosition - 1); } } } }
public static void permute(String s) { if(null==s || s.isEmpty()) { return; } List<String> strings = new LinkedList<String>(); strings.add(String.valueOf(s.charAt(0))); List<String> tempList = new LinkedList<String>(); for(int i=1; i< s.length(); i++) { for(int j=0; j<strings.size(); j++) { tempList.addAll(merge(s.charAt(i), strings.get(j))); } strings.removeAll(strings); strings.addAll(tempList); tempList.removeAll(tempList); } for(int i=0; i<strings.size(); i++) { System.out.println(strings.get(i)); } } /** * helper method that appends the given character at each position in the given string * and returns a set of such modified strings * - set removes duplicates if any(in case a character is repeated) */ private static Set<String> merge(Character c, String s) { if(s==null || s.isEmpty()) { return null; } int len = s.length(); StringBuilder sb = new StringBuilder(); Set<String> list = new HashSet<String>(); for(int i=0; i<= len; i++) { sb = new StringBuilder(); sb.append(s.substring(0, i) + c + s.substring(i, len)); list.add(sb.toString()); } return list; }
"a" + "bc" = ["abc", "bac", "bca"] and "a" + "cb" = ["acb" ,"cab", "cba"]
public class Test { static Set<String> permutations; static Set<String> result = new HashSet<String>(); public static Set<String> permutation(String string) { permutations = new HashSet<String>(); int n = string.length(); for (int i = n - 1; i >= 0; i--) { shuffle(string.charAt(i)); } return permutations; } private static void shuffle(char c) { if (permutations.size() == 0) { permutations.add(String.valueOf(c)); } else { Iterator<String> it = permutations.iterator(); for (int i = 0; i < permutations.size(); i++) { String temp1; for (; it.hasNext();) { temp1 = it.next(); for (int k = 0; k < temp1.length() + 1; k += 1) { StringBuilder sb = new StringBuilder(temp1); sb.insert(k, c); result.add(sb.toString()); } } } permutations = result; result = new HashSet<String>(); } } public static void main(String[] args) { Set<String> result = permutation("abc"); System.out.println("\nThere are total of " + result.size() + " permutations:"); Iterator<String> it = result.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } }
public static StringBuilder[] permutations(String s) { if (s.length() == 0) return null; int length = fact(s.length()); StringBuilder[] sb = new StringBuilder[length]; for (int i = 0; i < length; i++) { sb[i] = new StringBuilder(); } for (int i = 0; i < s.length(); i++) { char ch = s.charAt(i); int times = length / (i + 1); for (int j = 0; j < times; j++) { for (int k = 0; k < length / times; k++) { sb[j * length / times + k].insert(k, ch); } } } return sb; }
public static void main(String[] args) { String str="abcdefgh"; perm(str); } public static void perm(String str) { char[] char_arr=str.toCharArray(); helper(char_arr,0); } public static void helper(char[] char_arr, int i) { if(i==char_arr.length-1) { String str=""; for(int j=0; j<char_arr.length; j++) { str=str+char_arr[j]; } System.out.println(str); } else { for(int j=i; j<char_arr.length; j++) { char tmp = char_arr[i]; char_arr[i] = char_arr[j]; char_arr[j] = tmp; helper(char_arr,i+1); char tmp1 = char_arr[i]; char_arr[i] = char_arr[j]; char_arr[j] = tmp1; } } }
import java.util.Arrays; public class StringPermutations{ public static void main(String args[]) { String inputString = "ABC"; permute(inputString.toCharArray(), 0, inputString.length()-1); } public static void permute(char[] ary, int startIndex, int endIndex) { if(startIndex == endIndex){ System.out.println(String.valueOf(ary)); }else{ for(int i=startIndex;i<=endIndex;i++) { swap(ary, startIndex, i ); permute(ary, startIndex+1, endIndex); swap(ary, startIndex, i ); } } } public static void swap(char[] ary, int x, int y) { char temp = ary[x]; ary[x] = ary[y]; ary[y] = temp; } }
import java.util.ArrayList; import java.util.List; class Permutation { private static List<String> permutation(String prefix, String str) { List<String> permutations = new ArrayList<>(); int n = str.length(); if (n == 0) { permutations.add(prefix); } else { for (int i = 0; i < n; i++) { permutations.addAll(permutation(prefix + str.charAt(i), str.substring(i + 1, n) + str.substring(0, i))); } } return permutations; } public static void main(String[] args) { List<String> perms = permutation("", "abcd"); String[] array = new String[perms.size()]; for (int i = 0; i < perms.size(); i++) { array[i] = perms.get(i); } int x = array.length; for (final String anArray : array) { System.out.println(anArray); } } }
def getPermutation(s, prefix= if len(s) == 0: print prefix for i in range(len(s)): getPermutation(s[0:i]+s[i+1:len(s)],prefix+s[i] ) getPermutation(
import java.io.IOException; import java.util.ArrayList; import java.util.Scanner; public class hello { public static void main(String[] args) throws IOException { hello h = new hello(); h.printcomp(); } int fact=1; public void factrec(int a,int k){ if(a>=k) {fact=fact*k; k++; factrec(a,k); } else {System.out.println("The string will have "+fact+" permutations"); } } public void printcomp(){ String str; int k; Scanner in = new Scanner(System.in); System.out.println("enter the string whose permutations has to b found"); str=in.next(); k=str.length(); factrec(k,1); String[] arr =new String[fact]; char[] array = str.toCharArray(); while(p<fact) printcomprec(k,array,arr); } int y=1; int p = 0; int g=1; int z = 0; public void printcomprec(int k,char array[],String arr[]){ for (int l = 0; l < k; l++) { for (int b=0;b<k-1;b++){ for (int i=1; i<k-g; i++) { char temp; String stri = ""; temp = array[i]; array[i] = array[i + g]; array[i + g] = temp; for (int j = 0; j < k; j++) stri += array[j]; arr[z] = stri; System.out.println(arr[z] + " " + p++); z++; } } char temp; temp=array[0]; array[0]=array[y]; array[y]=temp; if (y >= k-1) y=y-(k-1); else y++; } if (g >= k-1) g=1; else g++; } }
/** Returns an array list containing all * permutations of the characters in s. */ public static ArrayList<String> permute(String s) { ArrayList<String> perms = new ArrayList<>(); int slen = s.length(); if (slen > 0) { perms.add(Character.toString(s.charAt(0))); for (int i = 1; i < slen; ++i) { char c = s.charAt(i); int size = perms.size(); for (int j = 0; j < size; ++j) { String p = perms.remove(0); int plen = p.length(); for (int k = 0; k <= plen; ++k) { perms.add(p.substring(0, k) + c + p.substring(k)); } } } } return perms; }
public static ArrayList<String> permutations(String s) { ArrayList<String> out = new ArrayList<String>(); if (s.length() == 1) { out.add(s); return out; } char first = s.charAt(0); String rest = s.substring(1); for (String permutation : permutations(rest)) { out.addAll(insertAtAllPositions(first, permutation)); } return out; } public static ArrayList<String> insertAtAllPositions(char ch, String s) { ArrayList<String> out = new ArrayList<String>(); for (int i = 0; i <= s.length(); ++i) { String inserted = s.substring(0, i) + ch + s.substring(i); out.add(inserted); } return out; }
public class LexicographicPermutations { public static void main(String[] args) { String s="abc"; List<String>combinations=new ArrayList<String>(); combinations=permutations(s); Collections.sort(combinations); System.out.println(combinations); } private static List<String> permutations(String s) { List<String>combinations=new ArrayList<String>(); if(s.length()==1){ combinations.add(s); } else{ for(int i=0;i<s.length();i++){ List<String>temp=permutations(s.substring(0, i)+s.substring(i+1)); for (String string : temp) { combinations.add(s.charAt(i)+string); } } } return combinations; }}
public Set<String> permutate(String s){ Queue<String> permutations = new LinkedList<String>(); Set<String> v = new HashSet<String>(); permutations.add(s); while(permutations.size()!=0){ String str = permutations.poll(); if(!v.contains(str)){ v.add(str); for(int i = 0;i<str.length();i++){ String c = String.valueOf(str.charAt(i)); permutations.add(str.substring(i+1) + c + str.substring(0,i)); } } } return v; }
public class StringPermute { static String str; static String word; static int top1 = -1; static int top2 = -1; static String[] stringArray1; static String[] stringArray2; static int strlength = 0; public static void main(String[] args) throws IOException { System.out.println("Enter String : "); InputStreamReader isr = new InputStreamReader(System.in); BufferedReader bfr = new BufferedReader(isr); str = bfr.readLine(); word = str; strlength = str.length(); int n = 1; for (int i = 1; i <= strlength; i++) { n = n * i; } stringArray1 = new String[n]; stringArray2 = new String[n]; push(word, 1); doPermute(); display(); } public static void push(String word, int x) { if (x == 1) stringArray1[++top1] = word; else stringArray2[++top2] = word; } public static String pop(int x) { if (x == 1) return stringArray1[top1--]; else return stringArray2[top2--]; } public static void doPermute() { for (int j = strlength; j >= 2; j--) popper(j); } public static void popper(int length) { if (top1 > -1) { while (top1 > -1) { word = pop(1); for (int j = 0; j < length; j++) { rotate(length); push(word, 2); } } } else { while (top2 > -1) { word = pop(2); for (int j = 0; j < length; j++) { rotate(length); push(word, 1); } } } } public static void rotate(int position) { char[] charstring = new char[100]; for (int j = 0; j < word.length(); j++) charstring[j] = word.charAt(j); int startpos = strlength - position; char temp = charstring[startpos]; for (int i = startpos; i < strlength - 1; i++) { charstring[i] = charstring[i + 1]; } charstring[strlength - 1] = temp; word = new String(charstring).trim(); } public static void display() { int top; if (top1 > -1) { while (top1 > -1) System.out.println(stringArray1[top1--]); } else { while (top2 > -1) System.out.println(stringArray2[top2--]); } } }
static public int facts(int x){ int sum = 1; for (int i = 1; i < x; i++) { sum *= (i+1); } return sum; } public static void permutation(String str) { char[] str2 = str.toCharArray(); int n = str2.length; int permutation = 0; if (n == 1) { System.out.println(str2[0]); } else if (n == 2) { System.out.println(str2[0] + "" + str2[1]); System.out.println(str2[1] + "" + str2[0]); } else { for (int i = 0; i < n; i++) { if (true) { char[] str3 = str.toCharArray(); char temp = str3[i]; str3[i] = str3[0]; str3[0] = temp; str2 = str3; } for (int j = 1, count = 0; count < facts(n-1); j++, count++) { if (j != n-1) { char temp1 = str2[j+1]; str2[j+1] = str2[j]; str2[j] = temp1; } else { char temp1 = str2[n-1]; str2[n-1] = str2[1]; str2[1] = temp1; j = 1; } permutation++; System.out.print("permutation " + permutation + " is -> "); for (int k = 0; k < n; k++) { System.out.print(str2[k]); } System.out.println(); } } } }
import java.util.*; import java.lang.*; import java.io.*; /* Complexity O(n*n!) */ class Ideone { public static ArrayList<String> strPerm(String str, ArrayList<String> list) { int len = str.length(); if(len==1){ list.add(str); return list; } list = strPerm(str.substring(0,len-1),list); int ls = list.size(); char ap = str.charAt(len-1); for(int i=0;i<ls;i++){ String temp = list.get(i); int tl = temp.length(); for(int j=0;j<=tl;j++){ list.add(temp.substring(0,j)+ap+temp.substring(j,tl)); } } while(true){ String temp = list.get(0); if(temp.length()<len) list.remove(temp); else break; } return list; } public static void main (String[] args) throws java.lang.Exception { String str = "abc"; ArrayList<String> list = new ArrayList<>(); list = strPerm(str,list); System.out.println("Total Permutations : "+list.size()); for(int i=0;i<list.size();i++) System.out.println(list.get(i)); } }
public static void main(String[] args) { String word = "12345"; Character[] array = ArrayUtils.toObject(word.toCharArray()); long[] factorials = Permutation.getFactorials(array.length + 1); for (long i = 0; i < factorials[array.length]; i++) { Character[] permutation = Permutation.<Character>getPermutation(i, array, factorials); printPermutation(permutation); } } private static void printPermutation(Character[] permutation) { for (int i = 0; i < permutation.length; i++) { System.out.print(permutation[i]); } System.out.println(); }
public class Permutation { public static <T> T[] getPermutation(long permutationNumber, T[] array, long[] factorials) { int[] sequence = generateSequence(permutationNumber, array.length - 1, factorials); T[] permutation = generatePermutation(array, sequence); return permutation; } public static <T> T[] generatePermutation(T[] array, int[] sequence) { T[] clone = array.clone(); for (int i = 0; i < clone.length - 1; i++) { swap(clone, i, i + sequence[i]); } return clone; } private static int[] generateSequence(long permutationNumber, int size, long[] factorials) { int[] sequence = new int[size]; for (int j = 0; j < sequence.length; j++) { long factorial = factorials[sequence.length - j]; sequence[j] = (int) (permutationNumber / factorial); permutationNumber = (int) (permutationNumber % factorial); } return sequence; } private static <T> void swap(T[] array, int i, int j) { T t = array[i]; array[i] = array[j]; array[j] = t; } public static long[] getFactorials(int length) { long[] factorials = new long[length]; long factor = 1; for (int i = 0; i < length; i++) { factor *= i <= 1 ? 1 : i; factorials[i] = factor; } return factorials; } }
public static void main(String args[]) { permu(0,"ABCD"); } static void permu(int fixed,String s) { char[] chr=s.toCharArray(); if(fixed==s.length()) System.out.println(s); for(int i=fixed;i<s.length();i++) { char c=chr[i]; chr[i]=chr[fixed]; chr[fixed]=c; permu(fixed+1,new String(chr)); } }
import java.util.Set; import java.util.HashSet; public class PrintAllPermutations2 { public static void main(String[] args) { String str = "AAC"; PrintAllPermutations2 permutation = new PrintAllPermutations2(); Set<String> uniqueStrings = new HashSet<>(); permutation.permute("", str, uniqueStrings); } void permute(String prefixString, String s, Set<String> set) { int n = s.length(); if(n == 0) { if(!set.contains(prefixString)) { System.out.println(prefixString); set.add(prefixString); } } else { for(int i=0; i<n; i++) { permute(prefixString + s.charAt(i), s.substring(0,i) + s.substring(i+1,n), set); } } } }
static ArrayList al = new ArrayList(); private static void findPermutation (String str){ for (int k = 0; k < str.length(); k++) { addOneChar(str.charAt(k)); } } private static void addOneChar(char ch){ String lastPerStr; String tempStr; ArrayList locAl = new ArrayList(); for (int i = 0; i < al.size(); i ++ ){ lastPerStr = al.get(i).toString(); for (int j = 0; j <= lastPerStr.length(); j++) { tempStr = lastPerStr.substring(0,j) + ch + lastPerStr.substring(j, lastPerStr.length()); locAl.add(tempStr); } } if(al.isEmpty()){ al.add(ch); } else { al.clear(); al = locAl; } } private static void printArrayList(ArrayList al){ for (int i = 0; i < al.size(); i++) { System.out.print(al.get(i) + " "); } }
/* * eg: abc =>{a,bc},{b,ac},{c,ab} * =>{ca,b},{cb,a} * =>cba,cab * =>{ba,c},{bc,a} * =>bca,bac * =>{ab,c},{ac,b} * =>acb,abc */ public void nonRecpermute(String prefix, String word) { String[] currentstr ={prefix,word}; Stack<String[]> stack = new Stack<String[]>(); stack.add(currentstr); while(!stack.isEmpty()) { currentstr = stack.pop(); String currentPrefix = currentstr[0]; String currentWord = currentstr[1]; if(currentWord.equals("")) { System.out.println("Word ="+currentPrefix); } for(int i=0;i<currentWord.length();i++) { String[] newstr = new String[2]; newstr[0]=currentPrefix + String.valueOf(currentWord.charAt(i)); newstr[1] = currentWord.substring(0, i); if(i<currentWord.length()-1) { newstr[1] = newstr[1]+currentWord.substring(i+1); } stack.push(newstr); } } }
void main() { String insertAt(String a, String b, int index) { return a.substring(0, index) + b + a.substring(index); } List<String> Permute(String word) { var letters = word.split( var p_list = [ letters.first ]; for (var c in letters.sublist(1)) { var new_list = [ ]; for (var p in p_list) for (int i = 0; i <= p.length; i++) new_list.add(insertAt(p, c, i)); p_list = new_list; } return p_list; } print(Permute("ABCD")); }
private void PrintAllPermutations(int[] a, int index, ref int count) { if (index == (a.Length - 1)) { count++; var s = string.Format("{0}: {1}", count, string.Join(",", a)); Debug.WriteLine(s); } for (int i = index; i < a.Length; i++) { Utilities.swap(ref a[i], ref a[index]); this.PrintAllPermutations(a, index + 1, ref count); Utilities.swap(ref a[i], ref a[index]); } } private int PrintAllPermutations(int[] a) { a.ThrowIfNull("a"); int count = 0; this.PrintAllPermutations(a, index:0, count: ref count); return count; }
private int[][] GetAllPermutations(int[] a, int index) { List<int[]> permutations = new List<int[]>(); if (index == (a.Length - 1)) { permutations.Add(a.ToArray()); } for (int i = index; i < a.Length; i++) { Utilities.swap(ref a[i], ref a[index]); var r = this.GetAllPermutations(a, index + 1); permutations.AddRange(r); Utilities.swap(ref a[i], ref a[index]); } return permutations.ToArray(); } private int[][] GetAllPermutations(int[] p) { p.ThrowIfNull("p"); return this.GetAllPermutations(p, 0); }
[TestMethod] public void PermutationsTests() { List<int> input = new List<int>(); int[] output = { 0, 1, 2, 6, 24, 120 }; for (int i = 0; i <= 5; i++) { if (i != 0) { input.Add(i); } Debug.WriteLine("================PrintAllPermutations==================="); int count = this.PrintAllPermutations(input.ToArray()); Assert.IsTrue(count == output[i]); Debug.WriteLine("=====================GetAllPermutations================="); var r = this.GetAllPermutations(input.ToArray()); Assert.IsTrue(count == r.Length); for (int j = 1; j <= r.Length;j++ ) { string s = string.Format("{0}: {1}", j, string.Join(",", r[j - 1])); Debug.WriteLine(s); } Debug.WriteLine("No.OfElements: {0}, TotalPerms: {1}", i, count); } }
List<String> permute(String str) { if (str == null) { return null; } char[] chars = str.toCharArray(); boolean[] used = new boolean[chars.length]; List<String> res = new ArrayList<String>(); StringBuilder sb = new StringBuilder(); Arrays.sort(chars); helper(chars, used, sb, res); return res; } void helper(char[] chars, boolean[] used, StringBuilder sb, List<String> res) { if (sb.length() == chars.length) { res.add(sb.toString()); return; } for (int i = 0; i < chars.length; i++) { if (i > 0 && chars[i] == chars[i - 1] && !used[i - 1]) { continue; } if (!used[i]) { used[i] = true; sb.append(chars[i]); helper(chars, used, sb, res); sb.deleteCharAt(sb.length() - 1); used[i] = false; } } }
char* addLetter(char* string, char *c) { char* result = malloc(sizeof(string) + 2); strcpy(result, string); strncat(result, c, 1); return result; } char* removeLetter(char* string, char *c) { char* result = malloc(sizeof(string)); int j = 0; for (int i = 0; i < strlen(string); i++) { if (string[i] != *c) { result[j++] = string[i]; } } result[j] = return result; } void makeAnagram(char *anagram, char *letters) { if (*letters == printf("%s\n", anagram); return; } char *c = letters; while (*c != makeAnagram(addLetter(anagram, c), removeLetter(letters, c)); c++; } } int main() { makeAnagram("", "computer"); return 0; }
private String capitalize(final String line) { return Character.toUpperCase(line.charAt(0)) + line.substring(1); }
public static String capitalizeString(String string) { char[] chars = string.toLowerCase().toCharArray(); boolean found = false; for (int i = 0; i < chars.length; i++) { if (!found && Character.isLetter(chars[i])) { chars[i] = Character.toUpperCase(chars[i]); found = true; } else if (Character.isWhitespace(chars[i]) || chars[i]== found = false; } } return String.valueOf(chars); }
public static String toTitleCase(String givenString) { String[] arr = givenString.split(" "); StringBuffer sb = new StringBuffer(); for (int i = 0; i < arr.length; i++) { sb.append(Character.toUpperCase(arr[i].charAt(0))) .append(arr[i].substring(1)).append(" "); } return sb.toString().trim(); }
==================================== SIMPLE USAGE ==================================== Source: cApItAlIzE this string after WHITE SPACES Output: Capitalize This String After White Spaces ==================================== SINGLE CUSTOM-DELIMITER USAGE ==================================== Source: capitalize this string ONLY before Output: Capitalize this string only beforE ==================================== MULTIPLE CUSTOM-DELIMITER USAGE ==================================== Source: capitalize this string AFTER SPACES, BEFORE Output: Capitalize This String After Spaces, BeforE ==================================== SIMPLE USAGE WITH CUSTOM LOCALE ==================================== Source: Uniforming the first and last vowels (different kind of Output: Uniforming The First And Last Vowels (different Kind Of ==================================== SIMPLE USAGE WITH A SURROGATE PAIR ==================================== Source: ab c de  Output: Ab c De 
import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.Locale; public class WordsCapitalizer { public static String capitalizeEveryWord(String source) { return capitalizeEveryWord(source,null,null); } public static String capitalizeEveryWord(String source, Locale locale) { return capitalizeEveryWord(source,null,locale); } public static String capitalizeEveryWord(String source, List<Delimiter> delimiters, Locale locale) { char[] chars; if (delimiters == null || delimiters.size() == 0) delimiters = getDefaultDelimiters(); if (locale!=null) chars = source.toLowerCase(locale).toCharArray(); else chars = source.toLowerCase().toCharArray(); if (chars.length>0 && Character.isLetter(chars[0]) && !isSurrogate(chars[0])){ chars[0] = Character.toUpperCase(chars[0]); } for (int i = 0; i < chars.length; i++) { if (!isSurrogate(chars[i]) && !Character.isLetter(chars[i])) { for (Delimiter delimiter : delimiters){ if (delimiter.getDelimiter()==chars[i]){ if (delimiter.capitalizeBefore() && i>0 && Character.isLetter(chars[i-1]) && !isSurrogate(chars[i-1])) { chars[i-1] = Character.toUpperCase(chars[i-1]); } if (delimiter.capitalizeAfter() && i<chars.length-1 && Character.isLetter(chars[i+1]) && !isSurrogate(chars[i+1])) { chars[i+1] = Character.toUpperCase(chars[i+1]); } break; } } } } return String.valueOf(chars); } private static boolean isSurrogate(char chr){ return (Character.isHighSurrogate(chr) || Character.isLowSurrogate(chr)); } private static List<Delimiter> getDefaultDelimiters(){ List<Delimiter> delimiters = new ArrayList<Delimiter>(); delimiters.add(new Delimiter(Behavior.CAPITALIZE_AFTER_MARKER, return delimiters; } public static class Delimiter { private Behavior behavior; private char delimiter; public Delimiter(Behavior behavior, char delimiter) { super(); this.behavior = behavior; this.delimiter = delimiter; } public boolean capitalizeBefore(){ return (behavior.equals(Behavior.CAPITALIZE_BEFORE_MARKER) || behavior.equals(Behavior.CAPITALIZE_BEFORE_AND_AFTER_MARKER)); } public boolean capitalizeAfter(){ return (behavior.equals(Behavior.CAPITALIZE_AFTER_MARKER) || behavior.equals(Behavior.CAPITALIZE_BEFORE_AND_AFTER_MARKER)); } public char getDelimiter() { return delimiter; } } public static enum Behavior { CAPITALIZE_AFTER_MARKER(0), CAPITALIZE_BEFORE_MARKER(1), CAPITALIZE_BEFORE_AND_AFTER_MARKER(2); private int value; private Behavior(int value) { this.value = value; } public int getValue() { return value; } }
String toBeCapped = "i want this sentence capitalized"; String[] tokens = toBeCapped.split("\\s"); toBeCapped = ""; for(int i = 0; i < tokens.length; i++){ char capLetter = Character.toUpperCase(tokens[i].charAt(0)); toBeCapped += " " + capLetter + tokens[i].substring(1); } toBeCapped = toBeCapped.trim();
public String firstLetterCapitalWithSingleSpace(final String words) { return Stream.of(words.trim().split("\\s")) .filter(word -> word.length() > 0) .map(word -> word.substring(0, 1).toUpperCase() + word.substring(1)) .collect(Collectors.joining(" ")); }
public static String capitalize(String text){ String c = (text != null)? text.trim() : ""; String[] words = c.split(" "); String result = ""; for(String w : words){ result += (w.length() > 1? w.substring(0, 1).toUpperCase(Locale.US) + w.substring(1, w.length()).toLowerCase(Locale.US) : w) + " "; } return result.trim(); }
string = "the sentence you want to apply caps to"; words = string.split(" ") string = "" for(String w: words) word = word.toUpperCase().replace(word.substring(1), word.substring(1).toLowerCase()) string += word
private static String capitalize(String string) { if (string == null) return null; String[] wordArray = string.split(" "); int i = 0; lowercase: for (String word : wordArray) { if (word != wordArray[0]) { String [] lowercaseWords = {"a", "an", "as", "and", "although", "at", "because", "but", "by", "for", "in", "nor", "of", "on", "or", "so", "the", "to", "up", "yet"}; for (String word2 : lowercaseWords) { if (word.equals(word2)) { wordArray[i] = word; i++; continue lowercase; } } } char[] characterArray = word.toCharArray(); characterArray[0] = Character.toTitleCase(characterArray[0]); wordArray[i] = new String(characterArray); i++; } return StringUtils.join(wordArray, " "); }
String example="hello"; example=example.substring(0,1).toUpperCase()+example.substring(1, example.length()); System.out.println(example);
public static String toTitleCase(String word){ return Character.toUpperCase(word.charAt(0)) + word.substring(1); } public static void main(String[] args){ String phrase = "this is to be title cased"; String[] splitPhrase = phrase.split(" "); String result = ""; for(String word: splitPhrase){ result += toTitleCase(word) + " "; } System.out.println(result.trim()); }
BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println("Enter the sentence : "); try { String str = br.readLine(); char[] str1 = new char[str.length()]; for(int i=0; i<str.length(); i++) { str1[i] = Character.toLowerCase(str.charAt(i)); } str1[0] = Character.toUpperCase(str1[0]); for(int i=0;i<str.length();i++) { if(str1[i] == { str1[i+1] = Character.toUpperCase(str1[i+1]); } System.out.print(str1[i]); } } catch(Exception e) { System.err.println("Error: " + e.getMessage()); }
public static String capEachWord(String source){ String result = ""; String[] splitString = source.split(" "); for(String target : splitString){ result += Character.toUpperCase(target.charAt(0)) + target.substring(1) + " "; } return result.trim(); }
public static String capitalize(String string) { final int sl = string.length(); final StringBuilder sb = new StringBuilder(sl); boolean lod = false; for(int s = 0; s < sl; s++) { final int cp = string.codePointAt(s); sb.appendCodePoint(lod ? Character.toLowerCase(cp) : Character.toUpperCase(cp)); lod = Character.isLetterOrDigit(cp); if(!Character.isBmpCodePoint(cp)) s++; } return sb.toString(); }
System.out.println(capitalize("An  la carte StRiNg. Surrogate pairs: ."));
public String capitalize(String str){ String c = str.replaceAll("\\s+", " "); String s = c.trim(); String l = ""; for(int i = 0; i < s.length(); i++){ if(i == 0){ l += s.toUpperCase().charAt(i); i++; } l += s.charAt(i); if(s.charAt(i) == 32){ /* If we meet whitespace (32 in ASCII Code is whitespace) */ l += s.toUpperCase().charAt(i+1); i++; } } return l; }
public static void upperCaseAllFirstCharacter(String text) { String regex = "\\b(.)(.*?)\\b"; String result = Pattern.compile(regex).matcher(text).replaceAll( matche -> matche.group(1).toUpperCase() + matche.group(2) ); System.out.println(result); }
upperCaseAllFirstCharacter("hello this is Just a test");
package com.test; /** * @author Prasanth Pillai * @date 01-Feb-2012 * @description : Below is the test class details * * inputs a String from a user. Expect the String to contain spaces and alphanumeric characters only. * capitalizes all first letters of the words in the given String. * preserves all other characters (including spaces) in the String. * displays the result to the user. * * Approach : I have followed a simple approach. However there are many string utilities available * for the same purpose. Example : WordUtils.capitalize(str) (from apache commons-lang) * */ import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Test { public static void main(String[] args) throws IOException{ System.out.println("Input String :\n"); InputStreamReader converter = new InputStreamReader(System.in); BufferedReader in = new BufferedReader(converter); String inputString = in.readLine(); int length = inputString.length(); StringBuffer newStr = new StringBuffer(0); int i = 0; int k = 0; /* This is a simple approach * step 1: scan through the input string * step 2: capitalize the first letter of each word in string * The integer k, is used as a value to determine whether the * letter is the first letter in each word in the string. */ while( i < length){ if (Character.isLetter(inputString.charAt(i))){ if ( k == 0){ newStr = newStr.append(Character.toUpperCase(inputString.charAt(i))); k = 2; } else { newStr = newStr.append(inputString.charAt(i)); } } else { newStr = newStr.append(inputString.charAt(i)); k=0; } i+=1; } System.out.println("new String ->"+newStr); } }
String text = "jon skeet, miles o Pattern pattern = Pattern.compile("\\b([a-z])([\\w]*)"); Matcher matcher = pattern.matcher(text); StringBuffer buffer = new StringBuffer(); while (matcher.find()) { matcher.appendReplacement(buffer, matcher.group(1).toUpperCase() + matcher.group(2)); } String capitalized = matcher.appendTail(buffer).toString(); System.out.println(capitalized);
private String capitalize(String line) { StringTokenizer token =new StringTokenizer(line); String CapLine=""; while(token.hasMoreTokens()) { String tok = token.nextToken().toString(); CapLine += Character.toUpperCase(tok.charAt(0))+ tok.substring(1)+" "; } return CapLine.substring(0,CapLine.length()-1); }
public class YarlagaddaSireeshTest{ public static void main(String[] args) { String FinalStringIs = ""; String testNames = "sireesh yarlagadda test"; String[] name = testNames.split("\\s"); for(String nameIs :name){ FinalStringIs += getIntiCapString(nameIs) + ","; } System.out.println("Final Result "+ FinalStringIs); } public static String getIntiCapString(String param) { if(param != null && param.length()>0){ char[] charArray = param.toCharArray(); charArray[0] = Character.toUpperCase(charArray[0]); return new String(charArray); } else { return ""; } } }
package com.lincolnwdaniel.interactivestory.model; public class StringS { /** * @param s is a string of any length, ideally only one word * @return a capitalized string. * only the first letter of the string is made to uppercase */ public static String capSingleWord(String s) { if(s.isEmpty() || s.length()<2) { return Character.toUpperCase(s.charAt(0))+""; } else { return Character.toUpperCase(s.charAt(0)) + s.substring(1); } } /** * * @param s is a string of any length * @return a title cased string. * All first letter of each word is made to uppercase */ public static String capString(String s) { if(s.isEmpty()){ return s; } String[] arr = s.split(" "); StringBuffer sb = new StringBuffer(); if( arr.length < 1 ){ return s; } for (int i = 0; i < arr.length; i++) { sb.append(Character.toUpperCase(arr[i].charAt(0))) .append(arr[i].substring(1)).append(" "); } return sb.toString().trim(); } }
String s="hi dude i want apple"; s = s.replaceAll("\\s+"," "); String[] split = s.split(" "); s=""; for (int i = 0; i < split.length; i++) { split[i]=Character.toUpperCase(split[i].charAt(0))+split[i].substring(1); s+=split[i]+" "; System.out.println(split[i]); } System.out.println(s);
package corejava.string.intern; import java.io.DataInputStream; import java.util.ArrayList; /* * wap to accept only 3 sentences and convert first character of each word into upper case */ public class Accept3Lines_FirstCharUppercase { static String line; static String words[]; static ArrayList<String> list=new ArrayList<String>(); /** * @param args */ public static void main(String[] args) throws java.lang.Exception{ DataInputStream read=new DataInputStream(System.in); System.out.println("Enter only three sentences"); int i=0; while((line=read.readLine())!=null){ method(line); if((i++)==2){ break; } } display(); System.out.println("\n End of the program"); } /* * this will display all the elements in an array */ public static void display(){ for(String display:list){ System.out.println(display); } } /* * this divide the line of string into words * and first char of the each word is converted to upper case * and to an array list */ public static void method(String lineParam){ words=line.split("\\s"); for(String s:words){ String result=s.substring(0,1).toUpperCase()+s.substring(1); list.add(result); } } }
String myString = ...; String capWords = Joiner.on( public String apply(String input) { return Character.toUpperCase(input.charAt(0)) + input.substring(1); } }));
String toUpperCaseFirstLetterOnly(String str) { String[] words = str.split(" "); StringBuilder ret = new StringBuilder(); for(int i = 0; i < words.length; i++) { ret.append(Character.toUpperCase(words[i].charAt(0))); ret.append(words[i].substring(1)); if(i < words.length - 1) { ret.append( } } return ret.toString(); }
String name = "test"; name = (name.length() != 0) ?name.toString().toLowerCase().substring(0,1).toUpperCase().concat(name.substring(1)): name;
-------------------- Output -------------------- Test T empty --------------------
public static String capitalize (String givenString) { String Separateur = " ,.-;"; StringBuffer sb = new StringBuffer(); boolean ToCap = true; for (int i = 0; i < givenString.length(); i++) { if (ToCap) sb.append(Character.toUpperCase(givenString.charAt(i))); else sb.append(Character.toLowerCase(givenString.charAt(i))); if (Separateur.indexOf(givenString.charAt(i)) >=0) ToCap = true; else ToCap = false; } return sb.toString().trim(); }
public void connect() throws A_WHOLE_BUNCH_OF_EXCEPTIONS { HttpPost post = new HttpPost(new URI(PROD_URL)); post.setEntity(new StringEntity(BODY)); KeyStore trusted = KeyStore.getInstance("BKS"); trusted.load(null, "".toCharArray()); SSLSocketFactory sslf = new SSLSocketFactory(trusted); sslf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); SchemeRegistry schemeRegistry = new SchemeRegistry(); schemeRegistry.register(new Scheme ("https", sslf, 443)); SingleClientConnManager cm = new SingleClientConnManager(post.getParams(), schemeRegistry); HttpClient client = new DefaultHttpClient(cm, post.getParams()); HttpResponse result = client.execute(post); }
W/System.err( 901): javax.net.ssl.SSLException: Not trusted server certificate W/System.err( 901): at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:360) W/System.err( 901): at org.apache.http.conn.ssl.AbstractVerifier.verify(AbstractVerifier.java:92) W/System.err( 901): at org.apache.http.conn.ssl.SSLSocketFactory.connectSocket(SSLSocketFactory.java:321) W/System.err( 901): at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:129) W/System.err( 901): at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:164) W/System.err( 901): at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:119) W/System.err( 901): at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:348) W/System.err( 901): at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:555) W/System.err( 901): at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:487) W/System.err( 901): at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:465) W/System.err( 901): at me.harrisonlee.test.ssl.MainActivity.connect(MainActivity.java:129) W/System.err( 901): at me.harrisonlee.test.ssl.MainActivity.access$0(MainActivity.java:77) W/System.err( 901): at me.harrisonlee.test.ssl.MainActivity$2.run(MainActivity.java:49) W/System.err( 901): Caused by: java.security.cert.CertificateException: java.security.InvalidAlgorithmParameterException: the trust anchors set is empty W/System.err( 901): at org.apache.harmony.xnet.provider.jsse.TrustManagerImpl.checkServerTrusted(TrustManagerImpl.java:157) W/System.err( 901): at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:355) W/System.err( 901): ... 12 more W/System.err( 901): Caused by: java.security.InvalidAlgorithmParameterException: the trust anchors set is empty W/System.err( 901): at java.security.cert.PKIXParameters.checkTrustAnchors(PKIXParameters.java:645) W/System.err( 901): at java.security.cert.PKIXParameters.<init>(PKIXParameters.java:89) W/System.err( 901): at org.apache.harmony.xnet.provider.jsse.TrustManagerImpl.<init>(TrustManagerImpl.java:89) W/System.err( 901): at org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl.engineGetTrustManagers(TrustManagerFactoryImpl.java:134) W/System.err( 901): at javax.net.ssl.TrustManagerFactory.getTrustManagers(TrustManagerFactory.java:226)W/System.err( 901): at org.apache.http.conn.ssl.SSLSocketFactory.createTrustManagers(SSLSocketFactory.java:263) W/System.err( 901): at org.apache.http.conn.ssl.SSLSocketFactory.<init>(SSLSocketFactory.java:190) W/System.err( 901): at org.apache.http.conn.ssl.SSLSocketFactory.<init>(SSLSocketFactory.java:216) W/System.err( 901): at me.harrisonlee.test.ssl.MainActivity.connect(MainActivity.java:107) W/System.err( 901): ... 2 more
import java.io.IOException; import java.net.Socket; import java.net.UnknownHostException; import java.security.KeyManagementException; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.UnrecoverableKeyException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import org.apache.http.conn.ssl.SSLSocketFactory; public class MySSLSocketFactory extends SSLSocketFactory { SSLContext sslContext = SSLContext.getInstance("TLS"); public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException { super(truststore); TrustManager tm = new X509TrustManager() { public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { } public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { } public X509Certificate[] getAcceptedIssuers() { return null; } }; sslContext.init(null, new TrustManager[] { tm }, null); } @Override public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException { return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose); } @Override public Socket createSocket() throws IOException { return sslContext.getSocketFactory().createSocket(); } }
public HttpClient getNewHttpClient() { try { KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); trustStore.load(null, null); MySSLSocketFactory sf = new MySSLSocketFactory(trustStore); sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); HttpParams params = new BasicHttpParams(); HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(params, HTTP.UTF_8); SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80)); registry.register(new Scheme("https", sf, 443)); ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry); return new DefaultHttpClient(ccm, params); } catch (Exception e) { return new DefaultHttpClient(); } }
Certificate chain 0 s:/O=www.yourserver.com/OU=Go to https: certificate/OU=Domain Validated/CN=www.yourserver.com i:/C=US/O=Thawte, Inc./OU=Domain Validated SSL/CN=Thawte DV SSL CA 1 s:/C=US/O=Thawte, Inc./OU=Domain Validated SSL/CN=Thawte DV SSL CA i:/C=US/O=thawte, Inc./OU=Certification Services Division/OU=(c) 2006 thawte, Inc. - For authorized use only/CN=thawte Primary Root CA
echo | openssl s_client -connect ${MY_SERVER}:443 2>&1 | \ sed -ne
export CLASSPATH=/path/to/bouncycastle/bcprov-jdk15on-155.jar CERTSTORE=res/raw/mystore.bks if [ -a $CERTSTORE ]; then rm $CERTSTORE || exit 1 fi keytool \ -import \ -v \ -trustcacerts \ -alias 0 \ -file <(openssl x509 -in mycert.pem) \ -keystore $CERTSTORE \ -storetype BKS \ -provider org.bouncycastle.jce.provider.BouncyCastleProvider \ -providerpath /path/to/bouncycastle/bcprov-jdk15on-155.jar \ -storepass some-password
final SchemeRegistry schemeRegistry = new SchemeRegistry(); schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80)); schemeRegistry.register(new Scheme("https", createAdditionalCertsSSLSocketFactory(), 443)); final HttpParams params = new BasicHttpParams(); ... final ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(params,schemeRegistry);
protected org.apache.http.conn.ssl.SSLSocketFactory createAdditionalCertsSSLSocketFactory() { try { final KeyStore ks = KeyStore.getInstance("BKS"); final InputStream in = context.getResources().openRawResource( R.raw.mystore); try { ks.load(in, context.getString( R.string.mystore_password ).toCharArray()); } finally { in.close(); } return new AdditionalKeyStoresSSLSocketFactory(ks); } catch( Exception e ) { throw new RuntimeException(e); } }
/** * Allows you to trust certificates from additional KeyStores in addition to * the default KeyStore */ public class AdditionalKeyStoresSSLSocketFactory extends SSLSocketFactory { protected SSLContext sslContext = SSLContext.getInstance("TLS"); public AdditionalKeyStoresSSLSocketFactory(KeyStore keyStore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException { super(null, null, null, null, null, null); sslContext.init(null, new TrustManager[]{new AdditionalKeyStoresTrustManager(keyStore)}, null); } @Override public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException { return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose); } @Override public Socket createSocket() throws IOException { return sslContext.getSocketFactory().createSocket(); } /** * Based on http: */ public static class AdditionalKeyStoresTrustManager implements X509TrustManager { protected ArrayList<X509TrustManager> x509TrustManagers = new ArrayList<X509TrustManager>(); protected AdditionalKeyStoresTrustManager(KeyStore... additionalkeyStores) { final ArrayList<TrustManagerFactory> factories = new ArrayList<TrustManagerFactory>(); try { final TrustManagerFactory original = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); original.init((KeyStore) null); factories.add(original); for( KeyStore keyStore : additionalkeyStores ) { final TrustManagerFactory additionalCerts = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); additionalCerts.init(keyStore); factories.add(additionalCerts); } } catch (Exception e) { throw new RuntimeException(e); } /* * Iterate over the returned trustmanagers, and hold on * to any that are X509TrustManagers */ for (TrustManagerFactory tmf : factories) for( TrustManager tm : tmf.getTrustManagers() ) if (tm instanceof X509TrustManager) x509TrustManagers.add( (X509TrustManager)tm ); if( x509TrustManagers.size()==0 ) throw new RuntimeException("Couldn } /* * Delegate to the default trust manager. */ public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { final X509TrustManager defaultX509TrustManager = x509TrustManagers.get(0); defaultX509TrustManager.checkClientTrusted(chain, authType); } /* * Loop over the trustmanagers until we find one that accepts our server */ public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { for( X509TrustManager tm : x509TrustManagers ) { try { tm.checkServerTrusted(chain,authType); return; } catch( CertificateException e ) { } } throw new CertificateException(); } public X509Certificate[] getAcceptedIssuers() { final ArrayList<X509Certificate> list = new ArrayList<X509Certificate>(); for( X509TrustManager tm : x509TrustManagers ) list.addAll(Arrays.asList(tm.getAcceptedIssuers())); return list.toArray(new X509Certificate[list.size()]); } } }
private void trustEveryone() { try { HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){ public boolean verify(String hostname, SSLSession session) { return true; }}); SSLContext context = SSLContext.getInstance("TLS"); context.init(null, new X509TrustManager[]{new X509TrustManager(){ public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {} public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {} public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }}}, new SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory( context.getSocketFactory()); } catch (Exception e) { e.printStackTrace(); } }
KeyStore ks = KeyStore.getInstance("JKS"); char[] password = ("mykspassword")).toCharArray(); ClassLoader cl = this.getClass().getClassLoader(); InputStream stream = cl.getResourceAsStream("myjks.jks"); ks.load(stream, password); stream.close(); SSLContext sc = SSLContext.getInstance("TLS"); KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509"); TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509"); kmf.init(ks, password); tmf.init(ks); sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null); return sc.getSocketFactory();
HttpURLConnection conn = (HttpURLConnection) url.openConnection(); if (conn instanceof HttpsURLConnection) { HttpsURLConnection httpsConn = (HttpsURLConnection) conn; httpsConn.setSSLSocketFactory(SSLCertificateSocketFactory.getInsecure(0, null)); httpsConn.setHostnameVerifier(new AllowAllHostnameVerifier()); }
public static HttpClient getTestHttpClient() { try { SSLSocketFactory sf = new SSLSocketFactory(new TrustStrategy(){ @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException { return true; } }, new AllowAllHostnameVerifier()); SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme("https",8444, sf)); ClientConnectionManager ccm = new ThreadSafeClientConnManager(registry); return new DefaultHttpClient(ccm); } catch (Exception e) { e.printStackTrace(); return new DefaultHttpClient(); } }
@Override public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException { SSLSocket sslSocket = (SSLSocket)sslContext.getSocketFactory().createSocket(socket, host, port, autoClose); getHostnameVerifier().verify(host, sslSocket); return sslSocket; }
import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import org.apache.http.HttpResponse; import org.apache.http.client.HttpClient; import org.apache.http.client.HttpResponseException; import org.apache.http.client.fluent.ContentResponseHandler; import org.apache.http.client.methods.HttpPost; import org.apache.http.conn.ssl.NoopHostnameVerifier; import org.apache.http.conn.ssl.SSLConnectionSocketFactory; import org.apache.http.conn.ssl.TrustStrategy; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.ssl.SSLContextBuilder; public class HttpClientUtils{ public static HttpClient getHttpClientWithoutSslValidation_UsingHttpClient_4_5_2() { try { SSLContextBuilder builder = new SSLContextBuilder(); builder.loadTrustMaterial(null, new TrustStrategy() { @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException { return true; } }); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(builder.build(), new NoopHostnameVerifier()); CloseableHttpClient httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); return httpclient; } catch (Exception e) { throw new RuntimeException(e); } } }
final KeyStore trustStore = KeyStore.getInstance("BKS"); final InputStream in = context.getResources().openRawResource( R.raw.geotrust_cert); trustStore.load(in, null); final TrustManagerFactory tmf = TrustManagerFactory .getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(trustStore); final SSLContext sslCtx = SSLContext.getInstance("TLS"); sslCtx.init(null, tmf.getTrustManagers(), new java.security.SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx .getSocketFactory());
public static HttpClient getTestHttpClient() { try { SSLSocketFactory sf = new SSLSocketFactory(new TrustStrategy(){ @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException { return true; } }); SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme("https", 443, sf)); ClientConnectionManager ccm = new ThreadSafeClientConnManager(registry); return new DefaultHttpClient(ccm); } catch (Exception e) { return new DefaultHttpClient(); } }
public HttpClient getNewHttpClient() { try { InputStream in = null; KeyStore trusted = KeyStore.getInstance(KeyStore.getDefaultType()); try { in = new BufferedInputStream(new FileInputStream(System.getProperty("javax.net.ssl.trustStore"))); trusted.load(in, null); } finally { if (in != null) { in.close(); in = null; } } try { KeyStore appTrusted = KeyStore.getInstance("BKS"); in = context.getResources().openRawResource(R.raw.mykeystore); appTrusted.load(in, null); for (Enumeration<String> e = appTrusted.aliases(); e.hasMoreElements();) { final String alias = e.nextElement(); final KeyStore.Entry entry = appTrusted.getEntry(alias, null); trusted.setEntry(System.currentTimeMillis() + ":" + alias, entry, null); } } finally { if (in != null) { in.close(); in = null; } } HttpParams params = new BasicHttpParams(); HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(params, HTTP.UTF_8); SSLSocketFactory sf = new SSLSocketFactory(trusted); sf.setHostnameVerifier(SSLSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER); SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80)); registry.register(new Scheme("https", sf, 443)); ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry); return new DefaultHttpClient(ccm, params); } catch (Exception e) { return new DefaultHttpClient(); } }
keytool -importkeystore -destkeystore cacerts.bks -deststoretype BKS -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath bcprov-jdk16-141.jar -deststorepass changeit -srcstorepass changeit -srckeystore $JAVA_HOME/jre/lib/security/cacerts -srcstoretype JKS -noprompt
public class CommonsHttpOAuthProvider extends AbstractOAuthProvider { private static final long serialVersionUID = 1L; private transient HttpClient httpClient; public CommonsHttpOAuthProvider(String requestTokenEndpointUrl, String accessTokenEndpointUrl, String authorizationWebsiteUrl) { super(requestTokenEndpointUrl, accessTokenEndpointUrl, authorizationWebsiteUrl); this.httpClient = MySSLSocketFactory.getNewHttpClient(); }
package com.netcomps.oauth_example; import java.io.IOException; import java.net.Socket; import java.net.UnknownHostException; import java.security.KeyManagementException; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.UnrecoverableKeyException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import org.apache.http.HttpVersion; import org.apache.http.client.HttpClient; import org.apache.http.conn.ClientConnectionManager; import org.apache.http.conn.scheme.PlainSocketFactory; import org.apache.http.conn.scheme.Scheme; import org.apache.http.conn.scheme.SchemeRegistry; import org.apache.http.conn.ssl.SSLSocketFactory; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpParams; import org.apache.http.params.HttpProtocolParams; import org.apache.http.protocol.HTTP; public class MySSLSocketFactory extends SSLSocketFactory { SSLContext sslContext = SSLContext.getInstance("TLS"); public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException { super(truststore); TrustManager tm = new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { } @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { } @Override public X509Certificate[] getAcceptedIssuers() { return null; } }; sslContext.init(null, new TrustManager[] { tm }, null); } @Override public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException { return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose); } @Override public Socket createSocket() throws IOException { return sslContext.getSocketFactory().createSocket(); } public static HttpClient getNewHttpClient() { try { KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); trustStore.load(null, null); SSLSocketFactory sf = new MySSLSocketFactory(trustStore); sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); HttpParams params = new BasicHttpParams(); HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(params, HTTP.UTF_8); SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80)); registry.register(new Scheme("https", sf, 443)); ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry); return new DefaultHttpClient(ccm, params); } catch (Exception e) { return new DefaultHttpClient(); } }
/** * Disables the SSL certificate checking for new instances of {@link HttpsURLConnection} This has been created to * aid testing on a local box, not for use on production. */ private static void disableSSLCertificateChecking() { TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() { public X509Certificate[] getAcceptedIssuers() { return null; } @Override public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException { } @Override public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException { } } }; try { SSLContext sc = SSLContext.getInstance("TLS"); sc.init(null, trustAllCerts, new java.security.SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); } catch (KeyManagementException e) { e.printStackTrace(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } }
`export CLASSPATH=bcprov-jdk16-145.jar CERTSTORE=res/raw/mystore.bks if [ -a $CERTSTORE ]; then rm $CERTSTORE || exit 1 fi keytool \ -import \ -v \ -trustcacerts \ -alias 0 \ -file <(openssl x509 -in mycert.pem) \ -keystore $CERTSTORE \ -storetype BKS \ -provider org.bouncycastle.jce.provider.BouncyCastleProvider \ -providerpath /usr/share/java/bcprov.jar \ -storepass some-password`
`export CLASSPATH=bcprov-jdk16-145.jar CERTSTORE=res/raw/mystore.bks if [ -a $CERTSTORE ]; then rm $CERTSTORE || exit 1 fi keytool \ -import \ -v \ -trustcacerts \ -alias 0 \ -file <(openssl x509 -in ca.pem) \ -keystore $CERTSTORE \ -storetype BKS \ -provider org.bouncycastle.jce.provider.BouncyCastleProvider \ -providerpath /usr/share/java/bcprov.jar \ -storepass some-password`
public class WCFs { private static final String NAMESPACE = "http: private static final String URL = "192.168.30.8"; private static final String SERVICE = "/myservice.svc?wsdl"; private static String SOAP_ACTION = "http: public static Thread myMethod(Runnable rp) { String METHOD_NAME = "myMethod"; SoapObject request = new SoapObject(NAMESPACE, METHOD_NAME); request.addProperty("Message", "Https WCF Running..."); return _call(rp,METHOD_NAME, request); } protected static HandlerThread _call(final RunProcess rp,final String METHOD_NAME, SoapObject soapReq) { final SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); int TimeOut = 5*1000; envelope.dotNet = true; envelope.bodyOut = soapReq; envelope.setOutputSoapObject(soapReq); final HttpsTransportSE httpTransport_net = new HttpsTransportSE(URL, 443, SERVICE, TimeOut); try { HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; } }); KeyStore k = getFromRaw(R.raw.key, "PKCS12", "password"); ((HttpsServiceConnectionSE) httpTransport_net.getServiceConnection()).setSSLSocketFactory(getSSLSocketFactory(k, "SSL")); } catch(Exception e){} HandlerThread thread = new HandlerThread("wcfTd"+ Generator.getRandomNumber()) { @Override public void run() { Handler h = new Handler(Looper.getMainLooper()); Object response = null; for(int i=0; i<4; i++) { response = send(envelope, httpTransport_net , METHOD_NAME, null); try {if(Thread.currentThread().isInterrupted()) return;}catch(Exception e){} if(response != null) break; ThreadHelper.threadSleep(250); } if(response != null) { if(rp != null) { rp.setArguments(response.toString()); h.post(rp); } } else { if(Thread.currentThread().isInterrupted()) return; if(rp != null) { rp.setExceptionState(true); h.post(rp); } } ThreadHelper.stopThread(this); } }; thread.start(); return thread; } private static Object send(SoapSerializationEnvelope envelope, HttpTransportSE androidHttpTransport, String METHOD_NAME, List<HeaderProperty> headerList) { try { if(headerList != null) androidHttpTransport.call(SOAP_ACTION + METHOD_NAME, envelope, headerList); else androidHttpTransport.call(SOAP_ACTION + METHOD_NAME, envelope); Object res = envelope.getResponse(); if(res instanceof SoapPrimitive) return (SoapPrimitive) envelope.getResponse(); else if(res instanceof SoapObject) return ((SoapObject) envelope.getResponse()); } catch(Exception e) {} return null; } public static KeyStore getFromRaw(@RawRes int id, String algorithm, String filePassword) { try { InputStream inputStream = ResourceMaster.openRaw(id); KeyStore keystore = KeyStore.getInstance(algorithm); keystore.load(inputStream, filePassword.toCharArray()); inputStream.close(); return keystore; } catch(Exception e) {} return null; } public static SSLSocketFactory getSSLSocketFactory(KeyStore trustKey, String SSLAlgorithm) { try { TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(trustKey); SSLContext context = SSLContext.getInstance(SSLAlgorithm); context.init(null, tmf.getTrustManagers(), null); return context.getSocketFactory(); } catch(Exception e){} return null; }
httpClient = new DefaultHttpClient(); SSLContext ctx = SSLContext.getInstance("TLS"); X509TrustManager tm = new X509TrustManager() { public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException { } public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException { } public X509Certificate[] getAcceptedIssuers() { return null; } }; ctx.init(null, new TrustManager[]{tm}, null); SSLSocketFactory ssf = new SSLSocketFactory(ctx, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); httpClient.getConnectionManager().getSchemeRegistry().register(new Scheme("https", 443, ssf));
public static HttpClient wrapClient(HttpClient base) { try { SSLContext ctx = SSLContext.getInstance("TLS"); X509TrustManager tm = new X509TrustManager() { public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException { } public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException { } public X509Certificate[] getAcceptedIssuers() { return null; } }; ctx.init(null, new TrustManager[]{tm}, null); SSLSocketFactory ssf = new SSLSocketFactory(ctx); ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); ClientConnectionManager ccm = base.getConnectionManager(); SchemeRegistry sr = ccm.getSchemeRegistry(); sr.register(new Scheme("https", ssf, 443)); return new DefaultHttpClient(ccm, base.getParams()); } catch (Exception ex) { return null; } }
DefaultHttpClient baseClient = new DefaultHttpClient(); HttpClient httpClient = wrapClient(baseClient );
public DefaultHttpClient wrapClient(HttpClient base) { try { SSLContext ctx = SSLContext.getInstance("TLS"); X509TrustManager tm = new X509TrustManager() { public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException { } public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException { } public X509Certificate[] getAcceptedIssuers() { return null; } }; ctx.init(null, new TrustManager[]{tm}, null); SSLSocketFactory ssf = new SSLSocketFactory(ctx); ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); ClientConnectionManager ccm = base.getConnectionManager(); SchemeRegistry sr = ccm.getSchemeRegistry(); sr.register(new Scheme("https", ssf, 443)); return new DefaultHttpClient(ccm, base.getParams()); } catch (Exception ex) { return null; } }
SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80)); registry.register(new Scheme("https", sf, 443)); ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry); SchemeRegistry registry = ccm.getShemeRegistry() registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80)); registry.register(new Scheme("https", sf, 443));
public static String executePost(String targetURL, String urlParameters) { HttpURLConnection connection = null; try { URL url = new URL(targetURL); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("POST"); connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); connection.setRequestProperty("Content-Length", Integer.toString(urlParameters.getBytes().length)); connection.setRequestProperty("Content-Language", "en-US"); connection.setUseCaches(false); connection.setDoOutput(true); DataOutputStream wr = new DataOutputStream ( connection.getOutputStream()); wr.writeBytes(urlParameters); wr.close(); InputStream is = connection.getInputStream(); BufferedReader rd = new BufferedReader(new InputStreamReader(is)); StringBuilder response = new StringBuilder(); String line; while ((line = rd.readLine()) != null) { response.append(line); response.append( } rd.close(); return response.toString(); } catch (Exception e) { e.printStackTrace(); return null; } finally { if (connection != null) { connection.disconnect(); } } }
import java.net.*; import java.io.*; public class URLConnectionReader { public static void main(String[] args) throws Exception { URL yahoo = new URL("http: URLConnection yc = yahoo.openConnection(); BufferedReader in = new BufferedReader( new InputStreamReader( yc.getInputStream())); String inputLine; while ((inputLine = in.readLine()) != null) System.out.println(inputLine); in.close(); } }
URL url = new URL("http: InputStream is = url.openStream(); try { ... } finally { is.close(); }
class GETHTTPResource { public static void main(String[] args) throws Exception { try (java.util.Scanner s = new java.util.Scanner(new java.net.URL("http: System.out.println(s.useDelimiter("\\A").next()); } } }
import com.google.api.client.http.GenericUrl; import com.google.api.client.http.HttpRequest; import com.google.api.client.http.HttpResponse; import com.google.api.client.http.HttpTransport; import com.google.api.client.http.javanet.NetHttpTransport; import java.io.IOException; import java.io.InputStream; public class Network { static final HttpTransport HTTP_TRANSPORT = new NetHttpTransport(); public void getRequest(String reqUrl) throws IOException { GenericUrl url = new GenericUrl(reqUrl); HttpRequest request = HTTP_TRANSPORT.createRequestFactory().buildGetRequest(url); HttpResponse response = request.execute(); System.out.println(response.getStatusCode()); InputStream is = response.getContent(); int ch; while ((ch = is.read()) != -1) { System.out.print((char) ch); } response.disconnect(); } }
import java.io.FileOutputStream; import java.io.IOException; import org.apache.commons.httpclient.HttpClient; import org.apache.commons.httpclient.HttpStatus; import org.apache.commons.httpclient.NameValuePair; import org.apache.commons.httpclient.methods.PostMethod; public class MainSendRequest { static String url = "http: public static void main(String[] args) { HttpClient client = new HttpClient(); PostMethod method = new PostMethod(url); method.setRequestHeader("Content-type", "text/xml; charset=ISO-8859-1"); NameValuePair nvp1= new NameValuePair("firstName","fname"); NameValuePair nvp2= new NameValuePair("lastName","lname"); NameValuePair nvp3= new NameValuePair("email","email@email.com"); method.setQueryString(new NameValuePair[]{nvp1,nvp2,nvp3}); try{ int statusCode = client.executeMethod(method); System.out.println("Status Code = "+statusCode); System.out.println("QueryString>>> "+method.getQueryString()); System.out.println("Status Text>>>" +HttpStatus.getStatusText(statusCode)); System.out.println(method.getResponseBodyAsString()); byte [] res = method.getResponseBody(); FileOutputStream fos= new FileOutputStream("donepage.html"); fos.write(res); method.releaseConnection(); } catch(IOException e) { e.printStackTrace(); } } }
String host = "www.yourhost.com"; Socket socket = new Socket(host, 80); String request = "GET / HTTP/1.0\r\n\r\n"; OutputStream os = socket.getOutputStream(); os.write(request.getBytes()); os.flush(); InputStream is = socket.getInputStream(); int ch; while( (ch=is.read())!= -1) System.out.print((char)ch); socket.close();
try { String data = URLEncoder.encode("key1", "UTF-8") + "=" + URLEncoder.encode("value1", "UTF-8"); data += "&" + URLEncoder.encode("key2", "UTF-8") + "=" + URLEncoder.encode("value2", "UTF-8"); URL url = new URL("http: URLConnection conn = url.openConnection(); conn.setDoOutput(true); OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); wr.write(data); wr.flush(); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = rd.readLine()) != null) { } wr.close(); rd.close(); } catch (Exception e) { }
interface Person { String getName(); String getAddress(); int getAge(); } Person p; String name = p.<CTRL-SHIFT-SPACE>
interface Country{ } interface Address { String getStreetAddress(); String getZipCode(); Country getCountry(); } interface Person { String getName(); Address getAddress(); int getAge(); } Person p; Country c = p.<CTRL-SHIFT-SPACE>
function Person(name,address) { this.getName = function() { return name }; this.getAddress = function() { return address }; } Person.prototype.hello = function() { return "I }
<ui:obfuscateJavaScript>function something(){...}</ui:obfuscateJavaScript>
Map<String, Integer> m = ... m.contains|Key("Wibble");
ArrayList<String> stringArrayList = new ArrayList<String>();
MyClass mc = new Gson().fromJson(result, new List<MyClass>(){}.getClass());
Type listType = new TypeToken<List<MyClass>>() { }.getType(); MyClass mc = new Gson().fromJson(result, listType);
java.lang.NullPointerException at org.apache.harmony.luni.lang.reflect.ListOfTypes.length(ListOfTypes.java:47) at org.apache.harmony.luni.lang.reflect.ImplForType.toString(ImplForType.java:83) at java.lang.StringBuilder.append(StringBuilder.java:203) at com.google.gson.JsonDeserializerExceptionWrapper.deserialize(JsonDeserializerExceptionWrapper.java:56) at com.google.gson.JsonDeserializationVisitor.invokeCustomDeserializer(JsonDeserializationVisitor.java:88) at com.google.gson.JsonDeserializationVisitor.visitUsingCustomHandler(JsonDeserializationVisitor.java:76) at com.google.gson.ObjectNavigator.accept(ObjectNavigator.java:106) at com.google.gson.JsonDeserializationContextDefault.fromJsonArray(JsonDeserializationContextDefault.java:64) at com.google.gson.JsonDeserializationContextDefault.deserialize(JsonDeserializationContextDefault.java:49) at com.google.gson.Gson.fromJson(Gson.java:568) at com.google.gson.Gson.fromJson(Gson.java:515) at com.google.gson.Gson.fromJson(Gson.java:484) at com.google.gson.Gson.fromJson(Gson.java:434)
import java.lang.reflect.Type; import com.google.gson.reflect.TypeToken; ... Type listType = new TypeToken<ArrayList<YourClass>>(){}.getType(); List<YourClass> yourClassList = new Gson().fromJson(jsonArray, listType);
MyClass[] mcArray = gson.fromJson(jsonString, MyClass[].class);
List<MyClass> mcList = new ArrayList<>(Arrays.asList(mcArray));
public class ListOfJson<T> implements ParameterizedType { private Class<?> wrapped; public ListOfJson(Class<T> wrapper) { this.wrapped = wrapper; } @Override public Type[] getActualTypeArguments() { return new Type[] { wrapped }; } @Override public Type getRawType() { return List.class; } @Override public Type getOwnerType() { return null; } }
public static <T> List<T> toList(String json, Class<T> typeClass) { return sGson.fromJson(json, new ListOfJson<T>(typeClass)); }
Type listType = new TypeToken<ArrayList<YourClass>>(){}.getType(); List<YourClass> list = new Gson().fromJson(jsonArray, listType);
public class YourClassList extends ArrayList<YourClass> {}
List<YourClass> list = new Gson().fromJson(jsonArray, YourClassList.class);
public static final <T> List<T> getList(final Class<T[]> clazz, final String json) { final T[] jsonToObject = new Gson().fromJson(json, clazz); return Arrays.asList(jsonToObject); }
public <T> List<T> getList(String jsonArray, Class<T> clazz) { Type typeOfT = TypeToken.getParameterized(List.class, clazz).getType(); return new Gson().fromJson(jsonArray, typeOfT); }
String jsonArray = ... List<User> user = getList(jsonArray, User.class);
public static <T> List<T> fromJsonList(String json, Class<T> clazz) { Object [] array = (Object[])java.lang.reflect.Array.newInstance(clazz, 0); array = gson.fromJson(json, array.getClass()); List<T> list = new ArrayList<T>(); for (int i=0 ; i<array.length ; i++) list.add(clazz.cast(array[i])); return list; }
import java.lang.reflect.Type import com.google.gson.reflect.TypeToken ... val type = object : TypeToken<ArrayList<T>>() {}.type
fun <T> buildType(): Type { return object : TypeToken<ArrayList<T>>() {}.type }
{ "results": [ { "a": 100, "b": "value1", "c": true }, { "a": 200, "b": "value2", "c": false }, { "a": 300, "b": "value3", "c": true } ]
public class ClassName implements Parcelable { public ArrayList<InnerClassName> results = new ArrayList<InnerClassName>(); public static class InnerClassName { int a; String b; boolean c; } }
Gson gson = new Gson(); final ClassName className = gson.fromJson(data, ClassName.class); int currentTotal = className.results.size();
public static void deserializeResturant(){ String empList ="[{\"name\":\"Ram\",\"empId\":1},{\"name\":\"Surya\",\"empId\":2},{\"name\":\"Prasants\",\"empId\":3}]"; Gson gson = new Gson(); Employee[] emp = gson.fromJson(empList, Employee[].class); int numberOfElementInJson = emp.length(); System.out.println("Total JSON Elements" + numberOfElementInJson); for(Employee e: emp){ System.out.println(e.getName()); System.out.println(e.getEmpId()); } }
public static void deserializeResturantUsingList(){ String empList ="[{\"name\":\"Ram\",\"empId\":1},{\"name\":\"Surya\",\"empId\":2},{\"name\":\"Prasants\",\"empId\":3}]"; Gson gson = new Gson(); Type empTypeList = new TypeToken<ArrayList<Employee>>(){}.getType(); List<Employee> emp = gson.fromJson(empList, empTypeList); int numberOfElementInJson = emp.size(); System.out.println("Total JSON Elements" + numberOfElementInJson); for(Employee e: emp){ System.out.println(e.getName()); System.out.println(e.getEmpId()); } }
public class JsonListHelper{ public static final <T> List<T> getList(String json) throws Exception { Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss").create(); Type typeOfList = new TypeToken<List<T>>(){}.getType(); return gson.fromJson(json, typeOfList); } }
List<MyClass> MyList= JsonListHelper.getList(jsonArrayString);
String jsonDuplicatedItems = request.getSession().getAttribute("jsonDuplicatedItems").toString(); List<Map.Entry<Product, Integer>> entries = gson.fromJson(jsonDuplicatedItems, List.class);
DateFormat df = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss"); Date today = Calendar.getInstance().getTime(); String reportDate = df.format(today); System.out.println("Report Date: " + reportDate);
Format formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String s = formatter.format(date);
DateFormatUtils.format(yourDate, "yyyy-MM-dd HH:mm:SS");
myUtilDate.toInstant() .atOffset( ZoneOffset.UTC ) .format( DateTimeFormatter.ISO_LOCAL_DATE_TIME ) .replace( "T" , " " )
OffsetDateTime odt = instant.atOffset( ZoneOffset.UTC );
String output = odt.format( DateTimeFormatter.ISO_LOCAL_DATE_TIME ) .replace( "T" , " " );
ZoneId z = ZoneId.of( "America/Montreal" ); ZonedDateTime zdt = instant.atZone( z );
String output = zdt.format( DateTimeFormatter.ISO_LOCAL_DATE_TIME ) .replace( "T" , " " );
DateTimeFormatter f = DateTimeFormatter.ofPattern( "uuuu-MM-dd HH:mm:ss" );
String.format("The date: %tY-%tm-%td", date, date, date); String.format("The date: %1$tY-%1$tm-%1$td", date); String.format("Time with tz: %tY-%<tm-%<td %<tH:%<tM:%<tS.%<tL%<tz", date); String.format("The date and time in ISO format: %tF %<tT", date);
Date currentDate = GregorianCalendar.getInstance().getTime(); String output = new DateTime( currentDate ).toString("yyyy-MM-dd HH:mm:ss");
public static String formateDate(String dateString) { Date date; String formattedDate = ""; try { date = new SimpleDateFormat("yyyy-MM-dd formattedDate = new SimpleDateFormat("dd/MM/yyyy",Locale.getDefault()).format(date); } catch (ParseException e) { e.printStackTrace(); } return formattedDate; }
Date test = new Date(); String dayString = test.toString(); String timeString = dayString.substring( 11 , 19 );
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss:SSS Z") .withZone(ZoneOffset.UTC); String utcFormatted = formatter.format(date.toInstant()); ZonedDateTime utcDatetime = date.toInstant().atZone(ZoneOffset.UTC); String utcFormatted2 = utcDatetime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss:SSS Z")); ZonedDateTime localDatetime = date.toInstant().atZone(ZoneId.systemDefault()); String localFormatted = localDatetime.format(DateTimeFormatter.ISO_ZONED_DATE_TIME); String nowFormatted = LocalDateTime.now().toString();
String date = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(new Date());
String time = new SimpleDateFormat("hh:mm", Locale.getDefault()).format(new Date());
String dateTime = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss", Locale.getDefaut()).format(new Date());
import java.text.ParseException; import java.text.SimpleDateFormat; public class Date { public static void main(String[] args) { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String strDate = "2013-05-14 17:07:21"; try { java.util.Date dt = sdf.parse(strDate); System.out.println(sdf.format(dt)); } catch (ParseException pe) { pe.printStackTrace(); } } }
public static void main(String[] args) { Date d = new Date(); SimpleDateFormat form = new SimpleDateFormat("dd-mm-yyyy hh:mm:ss"); System.out.println(form.format(d)); String str = form.format(d); System.out.println(str); }
public static void main(String args[]) { Calendar cal = GregorianCalendar.getInstance(); Date today = cal.getTime(); DateFormat df7 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try { String str7 = df7.format(today); System.out.println("String in yyyy-MM-dd format is: " + str7); } catch (Exception ex) { ex.printStackTrace(); } }
public String convertDateToString(Date date, String format) { String dateStr = null; DateFormat df = new SimpleDateFormat(format); try { dateStr = df.format(date); } catch (Exception ex) { ex.printStackTrace(); } return dateStr; }
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date = "2010-05-30 22:15:52"; java.util.Date formatedDate = sdf.parse(date); System.out.println(sdf.format(formatedDate));
public class MyTest { @Test public void test1(){} @Test public void test2(){} }
@FixMethodOrder(MethodSorters.NAME_ASCENDING) public class SampleTest { @Test public void testAcreate() { System.out.println("first"); } @Test public void testBupdate() { System.out.println("second"); } @Test public void testCdelete() { System.out.println("third"); } }
@Test public void test1() { ... } @Test public void test2() { test1(); ... }
void test1(); void test2(); void test3(); @Test public void testOrder1() { test1(); test3(); } @Test(expected = Exception.class) public void testOrder2() { test2(); test3(); test1(); } @Test(expected = NullPointerException.class) public void testOrder3() { test3(); test1(); test2(); }
@Test public void testAllOrders() { for (Object[] sample: permute(1, 2, 3)) { for (Object index: sample) { switch (((Integer) index).intValue()) { case 1: test1(); break; case 2: test2(); break; case 3: test3(); break; } } } }
@FixMethodOrder(MethodSorters.NAME_ASCENDING) public class SampleTest { @Test void stage1_prepareAndTest(){}; @Test void stage2_checkSomething(){}; @Test void stage2_checkSomethingElse(){}; @Test void stage3_thisDependsOnStage2(){}; @Test void callTimeDoesntMatter(){} }
import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; import org.junit.runners.BlockJUnit4ClassRunner; import org.junit.runners.model.FrameworkMethod; import org.junit.runners.model.InitializationError; public class OrderedRunner extends BlockJUnit4ClassRunner { public OrderedRunner(Class<?> clazz) throws InitializationError { super(clazz); } @Override protected List<FrameworkMethod> computeTestMethods() { List<FrameworkMethod> list = super.computeTestMethods(); List<FrameworkMethod> copy = new ArrayList<FrameworkMethod>(list); Collections.sort(copy, new Comparator<FrameworkMethod>() { @Override public int compare(FrameworkMethod f1, FrameworkMethod f2) { Order o1 = f1.getAnnotation(Order.class); Order o2 = f2.getAnnotation(Order.class); if (o1 == null || o2 == null) { return -1; } return o1.order() - o2.order(); } }); return copy; } }
@Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD}) public @interface Order { public int order(); }
(@runWith=OrderRunner.class) Class A{ @Test @Order(order = 1) void method(){ } }
Class testStateChanges extends TestCase public void testCreateObjectPlacesTheObjectInStateA() public void testTransitionToStateBAndValidateStateB() public void testTransitionToStateCAndValidateStateC() public void testTryToDeleteObjectinStateCAndValidateObjectStillExists() public void testTransitionToStateAAndValidateStateA() public void testDeleteObjectInStateAAndObjectDoesNotExist() public void cleanupIfAnythingWentWrong()
@FixMethodOrder(MethodSorters.NAME_ASCENDING) @FixMethodOrder(MethodSorters.JVM) @FixMethodOrder(MethodSorters.DEFAULT)
@FixMethodOrder(MethodSorters.JVM)OR `@FixMethodOrder(MethodSorters.DEFAULT)` OR `@FixMethodOrder(MethodSorters.NAME_ASCENDING)` before your test class like this: @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class BookTest { ...}
@Entity @Table(name = "ROOM") public class Room implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue @Column(name = "room_id") private Integer id; @Column(name = "number") private String number; @Column(name = "capacity") private Integer capacity; @ManyToOne(fetch = FetchType.LAZY, optional = false) @JoinColumn(name = "building_id") private Building building; Room() { } public Room(Building building, String number) { notNull(building, "Method called with null parameter (application)"); notNull(number, "Method called with null parameter (name)"); this.building = building; this.number = number; } @Override public boolean equals(final Object otherObj) { if ((otherObj == null) || !(otherObj instanceof Room)) { return false; } final Room other = (Room) otherObj; return new EqualsBuilder().append(getNumber(), other.getNumber()) .append(getBuilding().getId(), other.getBuilding().getId()) .isEquals(); } public Building getBuilding() { return building; } public Integer getId() { return id; } public String getNumber() { return number; } @Override public int hashCode() { return new HashCodeBuilder().append(getNumber()).append(getBuilding().getId()).toHashCode(); } public void setCapacity(Integer capacity) { this.capacity = capacity; } }
public interface Entity<I> extends Serializable { /** * @return entity identity */ I getId(); /** * @return HashCode of entity identity */ int identityHashCode(); /** * @param other * Other entity * @return true if identities of entities are equal */ boolean identityEquals(Entity<?> other); }
public abstract class AbstractEntity<I> implements Entity<I> { @Override public final boolean identityEquals(Entity<?> other) { if (getId() == null) { return false; } return getId().equals(other.getId()); } @Override public final int identityHashCode() { return new HashCodeBuilder().append(this.getId()).toHashCode(); } @Override public final int hashCode() { return identityHashCode(); } @Override public final boolean equals(final Object o) { if (this == o) { return true; } if ((o == null) || (getClass() != o.getClass())) { return false; } return identityEquals((Entity<?>) o); } @Override public String toString() { return getClass().getSimpleName() + ": " + identity(); } }
@Entity @Table(name = "ROOM") public class Room extends AbstractEntity<Integer> { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(name = "room_id") private Integer id; @Column(name = "number") private String number; @Column(name = "capacity") private Integer capacity; @ManyToOne(fetch = FetchType.LAZY, optional = false) @JoinColumn(name = "building_id") private Building building; Room() { } public Room(Building building, String number) { notNull(building, "Method called with null parameter (application)"); notNull(number, "Method called with null parameter (name)"); this.building = building; this.number = number; } public Integer getId(){ return id; } public Building getBuilding() { return building; } public String getNumber() { return number; } public void setCapacity(Integer capacity) { this.capacity = capacity; } }
String key = "av45k1pfb024xa3bl359vsb4esortvks74sksr5oy4s5serondry84jsrryuhsr5ys49y5seri5shrdliheuirdygliurguiy5ru"; try { Cipher c = Cipher.getInstance("ARCFOUR"); SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes("UTF-8"), "ARCFOUR"); c.init(Cipher.DECRYPT_MODE, secretKeySpec); return new String(c.doFinal(Hex.decodeHex(data.toCharArray())), "UTF-8"); } catch (InvalidKeyException e) { throw new CryptoException(e); }
Caused by: java.security.InvalidKeyException: Illegal key size or default parameters at javax.crypto.Cipher.a(DashoA13*..) ~[na:1.6] at javax.crypto.Cipher.a(DashoA13*..) ~[na:1.6] at javax.crypto.Cipher.a(DashoA13*..) ~[na:1.6] at javax.crypto.Cipher.init(DashoA13*..) ~[na:1.6] at javax.crypto.Cipher.init(DashoA13*..) ~[na:1.6] at my.package.Something.decode(RC4Decoder.java:25) ~[my.package.jar:na] ... 5 common frames omitted
Security.setProperty("crypto.policy", "unlimited");
import javax.crypto.Cipher; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.Map;
public static void fixKeyLength() { String errorString = "Failed manually overriding key-length permissions."; int newMaxKeyLength; try { if ((newMaxKeyLength = Cipher.getMaxAllowedKeyLength("AES")) < 256) { Class c = Class.forName("javax.crypto.CryptoAllPermissionCollection"); Constructor con = c.getDeclaredConstructor(); con.setAccessible(true); Object allPermissionCollection = con.newInstance(); Field f = c.getDeclaredField("all_allowed"); f.setAccessible(true); f.setBoolean(allPermissionCollection, true); c = Class.forName("javax.crypto.CryptoPermissions"); con = c.getDeclaredConstructor(); con.setAccessible(true); Object allPermissions = con.newInstance(); f = c.getDeclaredField("perms"); f.setAccessible(true); ((Map) f.get(allPermissions)).put("*", allPermissionCollection); c = Class.forName("javax.crypto.JceSecurityManager"); f = c.getDeclaredField("defaultPolicy"); f.setAccessible(true); Field mf = Field.class.getDeclaredField("modifiers"); mf.setAccessible(true); mf.setInt(f, f.getModifiers() & ~Modifier.FINAL); f.set(null, allPermissions); newMaxKeyLength = Cipher.getMaxAllowedKeyLength("AES"); } } catch (Exception e) { throw new RuntimeException(errorString, e); } if (newMaxKeyLength < 256) throw new RuntimeException(errorString); }
grant { permission javax.crypto.CryptoPermission "DES", 64; permission javax.crypto.CryptoPermission "DESede", *; permission javax.crypto.CryptoPermission "RC2", 128, "javax.crypto.spec.RC2ParameterSpec", 128; permission javax.crypto.CryptoPermission "RC4", 128; permission javax.crypto.CryptoPermission "RC5", 128, "javax.crypto.spec.RC5ParameterSpec", *, 12, *; permission javax.crypto.CryptoPermission "RSA", *; permission javax.crypto.CryptoPermission *, 128; };
grant { permission javax.crypto.CryptoAllPermission; };
SecretKeySpec getKey() { final pass = "47e7717f0f37ee72cb226278279aebef".getBytes("UTF-8"); final sha = MessageDigest.getInstance("SHA-256"); def key = sha.digest(pass); key = Arrays.copyOf(key, 16); return new SecretKeySpec(key, AES); }
Java Security: Illegal key size or default parameters?
$ java -XX:+PrintFlagsFinal -version 2>&1 | grep -i -E uintx AdaptivePermSizeWeight = 20 {product} uintx ErgoHeapSizeLimit = 0 {product} uintx InitialHeapSize := 66328448 {product} uintx LargePageHeapSizeThreshold = 134217728 {product} uintx MaxHeapSize := 1063256064 {product} uintx MaxPermSize = 67108864 {pd product} uintx PermSize = 16777216 {pd product} java version "1.6.0_24"
$ java -client -XX:+PrintFlagsFinal -version 2>&1 | grep -i -E uintx AdaptivePermSizeWeight = 20 {product} uintx ErgoHeapSizeLimit = 0 {product} uintx InitialHeapSize := 16777216 {product} uintx LargePageHeapSizeThreshold = 134217728 {product} uintx MaxHeapSize := 268435456 {product} uintx MaxPermSize = 67108864 {pd product} uintx PermSize = 12582912 {pd product} java version "1.6.0_24"
package com.blogspot.sdoulger; public class LoopTest { public LoopTest() { super(); } public static void main(String[] args) { long start = System.currentTimeMillis(); spendTime(); long end = System.currentTimeMillis(); System.out.println("Time spent: "+ (end-start)); LoopTest loopTest = new LoopTest(); } private static void spendTime() { for (int i =500000000;i>0;i--) { } } }
initial heap size of 1/64 of physical memory up to 1Gbyte maximum heap size of  of physical memory up to 1Gbyte
try { ... } catch (Exception e) { if (e is FooException) throw; }
try { ... } catch (FooException fe){ throw fe; } catch (Exception e) { ... }
try { ... } catch (Exception e) { throw new YourOwnException(e); }
try { ... } catch (Exception e) { if (e instanceof FooException) throw e; }
try { ... } catch (FooException e) { throw e; } catch (Exception e) { ... }
public int read(byte[] a) throws IOException { try { return in.read(a); } catch (final Throwable t) { throw t; } }
int orientation = getResources().getConfiguration().orientation; if (orientation == Configuration.ORIENTATION_LANDSCAPE) { } else { }
CONDITION[17:37:10.345] screen: rotation: 270 orientation: square CONDITION[17:37:12.774] screen: rotation: 0 orientation: portrait CONDITION[17:37:15.898] screen: rotation: 90 CONDITION[17:37:21.451] screen: rotation: 0 CONDITION[17:38:42.120] screen: rotation: 270 orientation: square
CONDITION[11:34:41.134] screen: rotation: 0 CONDITION[11:35:04.533] screen: rotation: 90 CONDITION[11:35:06.312] screen: rotation: 0 CONDITION[11:35:07.938] screen: rotation: 90 CONDITION[11:35:09.336] screen: rotation: 0
public int getScreenOrientation() { Display getOrient = getWindowManager().getDefaultDisplay(); int orientation = Configuration.ORIENTATION_UNDEFINED; if(getOrient.getWidth()==getOrient.getHeight()){ orientation = Configuration.ORIENTATION_SQUARE; } else{ if(getOrient.getWidth() < getOrient.getHeight()){ orientation = Configuration.ORIENTATION_PORTRAIT; }else { orientation = Configuration.ORIENTATION_LANDSCAPE; } } return orientation; }
<?xml version="1.0" encoding="utf-8"?> <resources> <bool name="is_landscape">true</bool> </resources>
<?xml version="1.0" encoding="utf-8"?> <resources> <bool name="is_landscape">false</bool> </resources>
context.getResources().getBoolean(R.bool.is_landscape)
public String getRotation(Context context){ final int rotation = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getOrientation(); switch (rotation) { case Surface.ROTATION_0: return "portrait"; case Surface.ROTATION_90: return "landscape"; case Surface.ROTATION_180: return "reverse portrait"; default: return "reverse landscape"; } }
@Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); int nCurrentOrientation = _getScreenOrientation(); _doSomeThingWhenChangeOrientation(nCurrentOrientation); }
private int _getScreenOrientation(){ return getResources().getConfiguration().orientation; }
private int _getScreenOrientation(){ Display display = ((WindowManager) getSystemService(WINDOW_SERVICE)).getDefaultDisplay(); return display.getOrientation(); }
int ot = getResources().getConfiguration().orientation; switch(ot) { case Configuration.ORIENTATION_LANDSCAPE: Log.d("my orient" ,"ORIENTATION_LANDSCAPE"); break; case Configuration.ORIENTATION_PORTRAIT: Log.d("my orient" ,"ORIENTATION_PORTRAIT"); break; case Configuration.ORIENTATION_SQUARE: Log.d("my orient" ,"ORIENTATION_SQUARE"); break; case Configuration.ORIENTATION_UNDEFINED: Log.d("my orient" ,"ORIENTATION_UNDEFINED"); break; default: Log.d("my orient", "default val"); break; }
protected int getScreenOrientation() { Display getOrient = getWindowManager().getDefaultDisplay(); Point size = new Point(); getOrient.getSize(size); int orientation; if (size.x < size.y) { orientation = Configuration.ORIENTATION_PORTRAIT; } else { orientation = Configuration.ORIENTATION_LANDSCAPE; } return orientation; }
@Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) { Toast.makeText(this, "landscape", Toast.LENGTH_SHORT).show(); } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){ Toast.makeText(this, "portrait", Toast.LENGTH_SHORT).show(); } }
public int getOrientation() { if(getResources().getDisplayMetrics().widthPixels>getResources().getDisplayMetrics().heightPixels) { Toast t = Toast.makeText(this,"LANDSCAPE",Toast.LENGTH_SHORT); t.show(); return 1; } else { Toast t = Toast.makeText(this,"PORTRAIT",Toast.LENGTH_SHORT); t.show(); return 2; } }
Display getOrient = getWindowManager().getDefaultDisplay(); int orientation = getOrient.getOrientation();
Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay(); Point size = new Point(); display.getSize(size); int width = size.x; int height = size.y; if(width>height)
private void initActivityScreenOrientPortrait() { this.activity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); DisplayMetrics metrics = new DisplayMetrics(); this.activity.getWindowManager().getDefaultDisplay().getMetrics(metrics); boolean bIsVisualPortrait = ( metrics.heightPixels >= metrics.widthPixels ); if( !bIsVisualPortrait ) { if( this.activity.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT ) { this.activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); } else { this.activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT ); } } else { this.activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR); } }
int orientation = getResources().getConfiguration().orientation; String Orintaion = ""; switch (orientation) { case Configuration.ORIENTATION_UNDEFINED: Orintaion = "Undefined"; break; case Configuration.ORIENTATION_LANDSCAPE: Orintaion = "Landscrape"; break; case Configuration.ORIENTATION_PORTRAIT: Orintaion = "Portrait"; break; default: Orintaion = "Square";break; }
if (this.getWindow().getWindowManager().getDefaultDisplay() .getOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT) { } else if (this.getWindow().getWindowManager().getDefaultDisplay() .getOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) { }
intOrientation = getResources().getConfiguration().orientation; if (intOrientation == Configuration.ORIENTATION_PORTRAIT) setContentView(R.layout.activity_main); else setContentView(R.layout.layout_land);
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT){ user_todat_latout = true; } else { user_todat_latout = false; }
public static boolean isScreenOriatationPortrait(Context context) { return context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT; }
public static int getRotation(Context context){ final int rotation = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getOrientation(); if(rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180){ return Configuration.ORIENTATION_PORTRAIT; } if(rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270){ return Configuration.ORIENTATION_LANDSCAPE; } return -1; }
@Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); checkOrientation(newConfig); } private void checkOrientation(Configuration newConfig){ if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) { Log.d(TAG, "Current Orientation : Landscape"); } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT){ Log.d(TAG, "Current Orientation : Portrait"); } }
<activity android:name=".ActivityName" android:configChanges="orientation|screenSize">
public static boolean isPortrait(Activity activity) { final int currentOrientation = getCurrentOrientation(activity); return currentOrientation == ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT || currentOrientation == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT; } public static int getCurrentOrientation(Activity activity) { final Display display = activity.getWindowManager().getDefaultDisplay(); final int rotation = display.getRotation(); final Point size = new Point(); display.getSize(size); int result; if (rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180) { if (size.x > size.y) { if (rotation == Surface.ROTATION_0) { result = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE; } else { result = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE; } } else { if (rotation == Surface.ROTATION_0) { result = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT; } else { result = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT; } } } else { if (size.x > size.y) { if (rotation == Surface.ROTATION_90) { result = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE; } else { result = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE; } } else { if (rotation == Surface.ROTATION_90) { result = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT; } else { result = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT; } } } return result; }
android { debug { A_VAR_RETRIEVABLE_IN_JAVA = 42 } release { A_VAR_RETRIEVABLE_IN_JAVA = 42+52 } }
android { buildTypes { debug { buildConfigField "int", "FOO", "42" buildConfigField "String", "FOO_STRING", "\"foo\"" buildConfigField "boolean", "LOG", "true" } release { buildConfigField "int", "FOO", "52" buildConfigField "String", "FOO_STRING", "\"bar\"" buildConfigField "boolean", "LOG", "false" } } }
android { buildTypes { debug{ resValue "string", "app_name", "My App Name Debug" } release { resValue "string", "app_name", "My App Name" } } }
buildTypes { buildTypes.each { it.buildConfigField it.resValue } }
Log.d("UserActivity", "onCreate, APP_KEY: " + getString(R.string.APP_KEY_2)); BuildConfig.APP_KEY_1
apply plugin: group = version = repositories { mavenCentral() } dependencies { testCompile compile } test { logger.info systemProperty }
package example; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld { static final Logger log=LoggerFactory.getLogger(HelloWorld.class); public static void main(String args[]) { log.info("entering main..."); final String val = System.getProperty("MY-VAR1", "UNSET (MAIN)"); System.out.println("(main.out) hello, world: " + val); log.info("main.log) MY-VAR1=" + val); } }
package example; ... public class HelloWorldTest { static final Logger log=LoggerFactory.getLogger(HelloWorldTest.class); @Test public void testEnv() { HelloWorld.main(new String[]{}); final String val = System.getProperty("MY-VAR1", "UNSET (TEST)"); System.out.println("(test.out) var1=" + val); log.info("(test.log) MY-VAR1=" + val); assertEquals("env MY-VAR1 set.", "VALUE-TEST", val); } }
$ gradle cleanTest test :cleanTest :compileJava UP-TO-DATE :processResources UP-TO-DATE :classes UP-TO-DATE :compileTestJava UP-TO-DATE :processTestResources UP-TO-DATE :testClasses UP-TO-DATE :test BUILD SUCCESSFUL
$ cat app.log INFO Test worker example.HelloWorld - entering main... INFO Test worker example.HelloWorld - main.log) MY-VAR1=VALUE-TEST INFO Test worker example.HelloWorldTest - (test.log) MY-VAR1=VALUE-TEST
example.HelloWorldTest > testEnv FAILED org.junit.ComparisonFailure at HelloWorldTest.java:14
<configuration> <appender name="FILE" class="ch.qos.logback.core.FileAppender"> <file>app.log</file> <layout class="ch.qos.logback.classic.PatternLayout"> <pattern>%d %p %t %c - %m%n</pattern> </layout> </appender> <root level="info"> <appender-ref ref="FILE"/> </root> </configuration>
buildTypes { def serverUrl = debug{ buildConfigField "String", "SERVER_URL", serverUrl } release { minifyEnabled true proguardFiles getDefaultProguardFile( buildConfigField "String", "SERVER_URL", serverUrl } }
android { defaultConfig { buildConfigField "String", "APP_NAME", "\"APP_NAME\"" } }
def baseUrl = def googleServerKey = android { buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile( buildConfigField buildConfigField } releasedebug { initWith debug buildConfigField buildConfigField } debug { buildConfigField buildConfigField } } }
KeyGenerator kgen = KeyGenerator.getInstance("AES"); kgen.init(128); SecretKey skey = kgen.generateKey(); byte[] raw = skey.getEncoded();
byte[] key = null; byte[] input = null; byte[] output = null; SecretKeySpec keySpec = null; keySpec = new SecretKeySpec(key, "AES"); Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding"); cipher.init(Cipher.ENCRYPT_MODE, keySpec); output = cipher.doFinal(input)
SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256"); KeySpec spec = new PBEKeySpec(password, salt, 65536, 256); SecretKey tmp = factory.generateSecret(spec); SecretKey secret = new SecretKeySpec(tmp.getEncoded(), "AES");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); cipher.init(Cipher.ENCRYPT_MODE, secret); AlgorithmParameters params = cipher.getParameters(); byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV(); byte[] ciphertext = cipher.doFinal("Hello, World!".getBytes("UTF-8"));
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv)); String plaintext = new String(cipher.doFinal(ciphertext), "UTF-8"); System.out.println(plaintext);
import org.springframework.security.crypto.encrypt.Encryptors; import org.springframework.security.crypto.encrypt.TextEncryptor; import org.springframework.security.crypto.keygen.KeyGenerators; public class CryptoExample { public static void main(String[] args) { final String password = "I AM SHERLOCKED"; final String salt = KeyGenerators.string().generateKey(); TextEncryptor encryptor = Encryptors.text(password, salt); System.out.println("Salt: \"" + salt + "\""); String textToEncrypt = "*royal secrets*"; System.out.println("Original text: \"" + textToEncrypt + "\""); String encryptedText = encryptor.encrypt(textToEncrypt); System.out.println("Encrypted text: \"" + encryptedText + "\""); TextEncryptor decryptor = Encryptors.text(password, salt); String decryptedText = decryptor.decrypt(encryptedText); System.out.println("Decrypted text: \"" + decryptedText + "\""); if(textToEncrypt.equals(decryptedText)) { System.out.println("Success: decrypted text matches"); } else { System.out.println("Failed: decrypted text does not match"); } } }
import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.AlgorithmParameters; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.security.spec.InvalidParameterSpecException; import java.security.spec.KeySpec; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.CipherInputStream; import javax.crypto.CipherOutputStream; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; import javax.crypto.spec.SecretKeySpec; import org.apache.commons.codec.DecoderException; import org.apache.commons.codec.binary.Hex; public class Crypto { String mPassword = null; public final static int SALT_LEN = 8; byte [] mInitVec = null; byte [] mSalt = null; Cipher mEcipher = null; Cipher mDecipher = null; private final int KEYLEN_BITS = 128; private final int ITERATIONS = 65536; private final int MAX_FILE_BUF = 1024; /** * create an object with just the passphrase from the user. Don * @param password */ public Crypto (String password) { mPassword = password; } /** * return the generated salt for this object * @return */ public byte [] getSalt () { return (mSalt); } /** * return the initialization vector created from setupEncryption * @return */ public byte [] getInitVec () { return (mInitVec); } /** * debug/print messages * @param msg */ private void Db (String msg) { System.out.println ("** Crypt ** " + msg); } /** * this must be called after creating the initial Crypto object. It creates a salt of SALT_LEN bytes * and generates the salt bytes using secureRandom(). The encryption secret key is created * along with the initialization vectory. The member variable mEcipher is created to be used * by the class later on when either creating a CipherOutputStream, or encrypting a buffer * to be written to disk. * * @throws NoSuchAlgorithmException * @throws InvalidKeySpecException * @throws NoSuchPaddingException * @throws InvalidParameterSpecException * @throws IllegalBlockSizeException * @throws BadPaddingException * @throws UnsupportedEncodingException * @throws InvalidKeyException */ public void setupEncrypt () throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, InvalidKeyException { SecretKeyFactory factory = null; SecretKey tmp = null; mSalt = new byte [SALT_LEN]; SecureRandom rnd = new SecureRandom (); rnd.nextBytes (mSalt); Db ("generated salt :" + Hex.encodeHexString (mSalt)); factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1"); /* Derive the key, given password and salt. * * in order to do 256 bit crypto, you have to muck with the files for Java * The end user must also install them (not compiled in) so beware. * see here: http: */ KeySpec spec = new PBEKeySpec (mPassword.toCharArray (), mSalt, ITERATIONS, KEYLEN_BITS); tmp = factory.generateSecret (spec); SecretKey secret = new SecretKeySpec (tmp.getEncoded(), "AES"); mEcipher = Cipher.getInstance ("AES/CBC/PKCS5Padding"); mEcipher.init (Cipher.ENCRYPT_MODE, secret); AlgorithmParameters params = mEcipher.getParameters (); mInitVec = params.getParameterSpec (IvParameterSpec.class).getIV(); Db ("mInitVec is :" + Hex.encodeHexString (mInitVec)); } /** * If a file is being decrypted, we need to know the pasword, the salt and the initialization vector (iv). * We have the password from initializing the class. pass the iv and salt here which is * obtained when encrypting the file initially. * * @param initvec * @param salt * @throws NoSuchAlgorithmException * @throws InvalidKeySpecException * @throws NoSuchPaddingException * @throws InvalidKeyException * @throws InvalidAlgorithmParameterException * @throws DecoderException */ public void setupDecrypt (String initvec, String salt) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, DecoderException { SecretKeyFactory factory = null; SecretKey tmp = null; SecretKey secret = null; mSalt = Hex.decodeHex (salt.toCharArray ()); Db ("got salt " + Hex.encodeHexString (mSalt)); mInitVec = Hex.decodeHex (initvec.toCharArray ()); Db ("got initvector :" + Hex.encodeHexString (mInitVec)); factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1"); KeySpec spec = new PBEKeySpec(mPassword.toCharArray (), mSalt, ITERATIONS, KEYLEN_BITS); tmp = factory.generateSecret(spec); secret = new SecretKeySpec(tmp.getEncoded(), "AES"); mDecipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); mDecipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(mInitVec)); } /** * This is where we write out the actual encrypted data to disk using the Cipher created in setupEncrypt(). * Pass two file objects representing the actual input (cleartext) and output file to be encrypted. * * there may be a way to write a cleartext header to the encrypted file containing the salt, but I ran * into uncertain problems with that. * * @param input - the cleartext file to be encrypted * @param output - the encrypted data file * @throws IOException * @throws IllegalBlockSizeException * @throws BadPaddingException */ public void WriteEncryptedFile (File input, File output) throws IOException, IllegalBlockSizeException, BadPaddingException { FileInputStream fin; FileOutputStream fout; long totalread = 0; int nread = 0; byte [] inbuf = new byte [MAX_FILE_BUF]; fout = new FileOutputStream (output); fin = new FileInputStream (input); while ((nread = fin.read (inbuf)) > 0 ) { Db ("read " + nread + " bytes"); totalread += nread; byte [] trimbuf = new byte [nread]; for (int i = 0; i < nread; i++) trimbuf[i] = inbuf[i]; byte [] tmp = mEcipher.update (trimbuf); if (tmp != null) fout.write (tmp); } byte [] finalbuf = mEcipher.doFinal (); if (finalbuf != null) fout.write (finalbuf); fout.flush(); fin.close(); fout.close(); Db ("wrote " + totalread + " encrypted bytes"); } /** * Read from the encrypted file (input) and turn the cipher back into cleartext. Write the cleartext buffer back out * to disk as (output) File. * * I left CipherInputStream in here as a test to see if I could mix it with the update() and final() methods of encrypting * and still have a correctly decrypted file in the end. Seems to work so left it in. * * @param input - File object representing encrypted data on disk * @param output - File object of cleartext data to write out after decrypting * @throws IllegalBlockSizeException * @throws BadPaddingException * @throws IOException */ public void ReadEncryptedFile (File input, File output) throws IllegalBlockSizeException, BadPaddingException, IOException { FileInputStream fin; FileOutputStream fout; CipherInputStream cin; long totalread = 0; int nread = 0; byte [] inbuf = new byte [MAX_FILE_BUF]; fout = new FileOutputStream (output); fin = new FileInputStream (input); cin = new CipherInputStream (fin, mDecipher); while ((nread = cin.read (inbuf)) > 0 ) { Db ("read " + nread + " bytes"); totalread += nread; byte [] trimbuf = new byte [nread]; for (int i = 0; i < nread; i++) trimbuf[i] = inbuf[i]; fout.write (trimbuf); } fout.flush(); cin.close(); fin.close (); fout.close(); Db ("wrote " + totalread + " encrypted bytes"); } /** * adding main() for usage demonstration. With member vars, some of the locals would not be needed */ public static void main(String [] args) { File input = new File ("input.txt"); File eoutput = new File ("encrypted.aes"); File doutput = new File ("decrypted.txt"); String iv = null; String salt = null; Crypto en = new Crypto ("mypassword"); /* * setup encryption cipher using password. print out iv and salt */ try { en.setupEncrypt (); iv = Hex.encodeHexString (en.getInitVec ()).toUpperCase (); salt = Hex.encodeHexString (en.getSalt ()).toUpperCase (); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (InvalidKeySpecException e) { e.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } catch (InvalidParameterSpecException e) { e.printStackTrace(); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } /* * write out encrypted file */ try { en.WriteEncryptedFile (input, eoutput); System.out.printf ("File encrypted to " + eoutput.getName () + "\niv:" + iv + "\nsalt:" + salt + "\n\n"); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } /* * decrypt file */ Crypto dc = new Crypto ("mypassword"); try { dc.setupDecrypt (iv, salt); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (InvalidKeySpecException e) { e.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } catch (InvalidAlgorithmParameterException e) { e.printStackTrace(); } catch (DecoderException e) { e.printStackTrace(); } /* * write out decrypted file */ try { dc.ReadEncryptedFile (eoutput, doutput); System.out.println ("decryption finished to " + doutput.getName ()); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } }
byte[] raw = ...; Key skey = new javax.crypto.spec.SecretKeySpec(raw, "AES");
Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, skey); byte[] encrypted = cipher.doFinal(plainText.getBytes());
SecretKeySpec key = new SecretKeySpec(keyBytes, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] encryptedBytes = cipher.doFinal(clearText.getBytes());
import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.security.AlgorithmParameters; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.spec.InvalidKeySpecException; import java.security.spec.InvalidParameterSpecException; import java.security.spec.KeySpec; import java.util.logging.Level; import java.util.logging.Logger; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.CipherInputStream; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; import javax.crypto.spec.SecretKeySpec; public class AES { public final static int SALT_LEN = 8; static final String HEXES = "0123456789ABCDEF"; String mPassword = null; byte[] mInitVec = null; byte[] mSalt = new byte[SALT_LEN]; Cipher mEcipher = null; Cipher mDecipher = null; private final int KEYLEN_BITS = 128; private final int ITERATIONS = 65536; private final int MAX_FILE_BUF = 1024; /** * create an object with just the passphrase from the user. Don * @param password */ public AES(String password) { mPassword = password; } public static String byteToHex(byte[] raw) { if (raw == null) { return null; } final StringBuilder hex = new StringBuilder(2 * raw.length); for (final byte b : raw) { hex.append(HEXES.charAt((b & 0xF0) >> 4)).append(HEXES.charAt((b & 0x0F))); } return hex.toString(); } public static byte[] hexToByte(String hexString) { int len = hexString.length(); byte[] ba = new byte[len / 2]; for (int i = 0; i < len; i += 2) { ba[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16)); } return ba; } /** * debug/print messages * @param msg */ private void Db(String msg) { System.out.println("** Crypt ** " + msg); } /** * This is where we write out the actual encrypted data to disk using the Cipher created in setupEncrypt(). * Pass two file objects representing the actual input (cleartext) and output file to be encrypted. * * there may be a way to write a cleartext header to the encrypted file containing the salt, but I ran * into uncertain problems with that. * * @param input - the cleartext file to be encrypted * @param output - the encrypted data file * @throws IOException * @throws IllegalBlockSizeException * @throws BadPaddingException */ public void WriteEncryptedFile(InputStream inputStream, OutputStream outputStream) throws IOException, IllegalBlockSizeException, BadPaddingException { try { long totalread = 0; int nread = 0; byte[] inbuf = new byte[MAX_FILE_BUF]; SecretKeyFactory factory = null; SecretKey tmp = null; mSalt = new byte[SALT_LEN]; SecureRandom rnd = new SecureRandom(); rnd.nextBytes(mSalt); Db("generated salt :" + byteToHex(mSalt)); factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1"); /* * Derive the key, given password and salt. * * in order to do 256 bit crypto, you have to muck with the files for Java * The end user must also install them (not compiled in) so beware. * see here: http: */ KeySpec spec = new PBEKeySpec(mPassword.toCharArray(), mSalt, ITERATIONS, KEYLEN_BITS); tmp = factory.generateSecret(spec); SecretKey secret = new SecretKeySpec(tmp.getEncoded(), "AES"); /* * Create the Encryption cipher object and store as a member variable */ mEcipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); mEcipher.init(Cipher.ENCRYPT_MODE, secret); AlgorithmParameters params = mEcipher.getParameters(); mInitVec = params.getParameterSpec(IvParameterSpec.class).getIV(); Db("mInitVec is :" + byteToHex(mInitVec)); outputStream.write(mSalt); outputStream.write(mInitVec); while ((nread = inputStream.read(inbuf)) > 0) { Db("read " + nread + " bytes"); totalread += nread; byte[] trimbuf = new byte[nread]; for (int i = 0; i < nread; i++) { trimbuf[i] = inbuf[i]; } byte[] tmpBuf = mEcipher.update(trimbuf); if (tmpBuf != null) { outputStream.write(tmpBuf); } } byte[] finalbuf = mEcipher.doFinal(); if (finalbuf != null) { outputStream.write(finalbuf); } outputStream.flush(); inputStream.close(); outputStream.close(); outputStream.close(); Db("wrote " + totalread + " encrypted bytes"); } catch (InvalidKeyException ex) { Logger.getLogger(AES.class.getName()).log(Level.SEVERE, null, ex); } catch (InvalidParameterSpecException ex) { Logger.getLogger(AES.class.getName()).log(Level.SEVERE, null, ex); } catch (NoSuchAlgorithmException ex) { Logger.getLogger(AES.class.getName()).log(Level.SEVERE, null, ex); } catch (NoSuchPaddingException ex) { Logger.getLogger(AES.class.getName()).log(Level.SEVERE, null, ex); } catch (InvalidKeySpecException ex) { Logger.getLogger(AES.class.getName()).log(Level.SEVERE, null, ex); } } /** * Read from the encrypted file (input) and turn the cipher back into cleartext. Write the cleartext buffer back out * to disk as (output) File. * * I left CipherInputStream in here as a test to see if I could mix it with the update() and final() methods of encrypting * and still have a correctly decrypted file in the end. Seems to work so left it in. * * @param input - File object representing encrypted data on disk * @param output - File object of cleartext data to write out after decrypting * @throws IllegalBlockSizeException * @throws BadPaddingException * @throws IOException */ public void ReadEncryptedFile(InputStream inputStream, OutputStream outputStream) throws IllegalBlockSizeException, BadPaddingException, IOException { try { CipherInputStream cin; long totalread = 0; int nread = 0; byte[] inbuf = new byte[MAX_FILE_BUF]; inputStream.read(this.mSalt); Db("generated salt :" + byteToHex(mSalt)); SecretKeyFactory factory = null; SecretKey tmp = null; SecretKey secret = null; factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1"); KeySpec spec = new PBEKeySpec(mPassword.toCharArray(), mSalt, ITERATIONS, KEYLEN_BITS); tmp = factory.generateSecret(spec); secret = new SecretKeySpec(tmp.getEncoded(), "AES"); mDecipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); AlgorithmParameters params = mDecipher.getParameters(); mInitVec = params.getParameterSpec(IvParameterSpec.class).getIV(); inputStream.read(this.mInitVec); Db("mInitVec is :" + byteToHex(mInitVec)); mDecipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(mInitVec)); cin = new CipherInputStream(inputStream, mDecipher); while ((nread = cin.read(inbuf)) > 0) { Db("read " + nread + " bytes"); totalread += nread; byte[] trimbuf = new byte[nread]; for (int i = 0; i < nread; i++) { trimbuf[i] = inbuf[i]; } outputStream.write(trimbuf); } outputStream.flush(); cin.close(); inputStream.close(); outputStream.close(); Db("wrote " + totalread + " encrypted bytes"); } catch (Exception ex) { Logger.getLogger(AES.class.getName()).log(Level.SEVERE, null, ex); } } /** * adding main() for usage demonstration. With member vars, some of the locals would not be needed */ public static void main(String[] args) { File input = new File("input.txt"); File eoutput = new File("encrypted.aes"); File doutput = new File("decrypted.txt"); String iv = null; String salt = null; AES en = new AES("mypassword"); /* * write out encrypted file */ try { en.WriteEncryptedFile(new FileInputStream(input), new FileOutputStream(eoutput)); System.out.printf("File encrypted to " + eoutput.getName() + "\niv:" + iv + "\nsalt:" + salt + "\n\n"); } catch (IllegalBlockSizeException | BadPaddingException | IOException e) { e.printStackTrace(); } /* * decrypt file */ AES dc = new AES("mypassword"); /* * write out decrypted file */ try { dc.ReadEncryptedFile(new FileInputStream(eoutput), new FileOutputStream(doutput)); System.out.println("decryption finished to " + doutput.getName()); } catch (IllegalBlockSizeException | BadPaddingException | IOException e) { e.printStackTrace(); } } }
public class ObjectCrypter { public static byte[] encrypt(byte[] ivBytes, byte[] keyBytes, byte[] mes) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException { AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes); SecretKeySpec newKey = new SecretKeySpec(keyBytes, "AES"); Cipher cipher = null; cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec); return cipher.doFinal(mes); } public static byte[] decrypt(byte[] ivBytes, byte[] keyBytes, byte[] bytes) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException, ClassNotFoundException { AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes); SecretKeySpec newKey = new SecretKeySpec(keyBytes, "AES"); Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec); return cipher.doFinal(bytes); }
String key = "e8ffc7e56311679f12b6fc91aa77a5eb"; byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; keyBytes = key.getBytes("UTF-8");
String password = "mysupersecretpassword"; Key key = KeyFactory.AES.keyFromPassword(password.toCharArray()); Encryptor encryptor = new Encryptor(key, "AES/CBC/PKCS7Padding", 16);
myShapesCollection.stream() .filter(e -> e.getColor() == Color.RED) .forEach(e -> System.out.println(e.getName())); myShapesCollection.parallelStream() .filter(e -> e.getColor() == Color.RED) .forEach(e -> System.out.println(e.getName()));
int cores = Runtime.getRuntime().availableProcessors();
private int getNumberOfCPUCores() { OsValidator osValidator = new OsValidator(); String command = ""; if(osValidator.isMac()){ command = "sysctl -n machdep.cpu.core_count"; }else if(osValidator.isUnix()){ command = "lscpu"; }else if(osValidator.isWindows()){ command = "cmd /C WMIC CPU Get /Format:List"; } Process process = null; int numberOfCores = 0; int sockets = 0; try { if(osValidator.isMac()){ String[] cmd = { "/bin/sh", "-c", command}; process = Runtime.getRuntime().exec(cmd); }else{ process = Runtime.getRuntime().exec(command); } } catch (IOException e) { e.printStackTrace(); } BufferedReader reader = new BufferedReader( new InputStreamReader(process.getInputStream())); String line; try { while ((line = reader.readLine()) != null) { if(osValidator.isMac()){ numberOfCores = line.length() > 0 ? Integer.parseInt(line) : 0; }else if (osValidator.isUnix()) { if (line.contains("Core(s) per socket:")) { numberOfCores = Integer.parseInt(line.split("\\s+")[line.split("\\s+").length - 1]); } if(line.contains("Socket(s):")){ sockets = Integer.parseInt(line.split("\\s+")[line.split("\\s+").length - 1]); } } else if (osValidator.isWindows()) { if (line.contains("NumberOfCores")) { numberOfCores = Integer.parseInt(line.split("=")[1]); } } } } catch (IOException e) { e.printStackTrace(); } if(osValidator.isUnix()){ return numberOfCores * sockets; } return numberOfCores; }
public class OSValidator { private static String OS = System.getProperty("os.name").toLowerCase(); public static void main(String[] args) { System.out.println(OS); if (isWindows()) { System.out.println("This is Windows"); } else if (isMac()) { System.out.println("This is Mac"); } else if (isUnix()) { System.out.println("This is Unix or Linux"); } else if (isSolaris()) { System.out.println("This is Solaris"); } else { System.out.println("Your OS is not support!!"); } } public static boolean isWindows() { return (OS.indexOf("win") >= 0); } public static boolean isMac() { return (OS.indexOf("mac") >= 0); } public static boolean isUnix() { return (OS.indexOf("nix") >= 0 || OS.indexOf("nux") >= 0 || OS.indexOf("aix") > 0 ); } public static boolean isSolaris() { return (OS.indexOf("sunos") >= 0); } public static String getOS(){ if (isWindows()) { return "win"; } else if (isMac()) { return "osx"; } else if (isUnix()) { return "uni"; } else if (isSolaris()) { return "sol"; } else { return "err"; } }
SystemInfo systemInfo = new SystemInfo(); HardwareAbstractionLayer hardwareAbstractionLayer = systemInfo.getHardware(); CentralProcessor centralProcessor = hardwareAbstractionLayer.getProcessor();
C:\Users\myUserName\AppData\Local\Android\android-studio\bin
JAVA_HOME -> C:\Program Files\Java\jdk1.6.0_45 path -> C:\Program Files\Java\jdk1.6.0_45\bin
| v notice broken path The system cannot find the file C:\Users\Daniel \studio64.exe.vmoptions. Exception in thread "main" java.lang.NoClassDefFoundError: com/intellij/idea/Main Caused by: java.lang.ClassNotFoundException: com.intellij.idea.Main at java.net.URLClassLoader$1.run(URLClassLoader.java:202) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:190) at java.lang.ClassLoader.loadClass(ClassLoader.java:306) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301) at java.lang.ClassLoader.loadClass(ClassLoader.java:247) Could not find the main class: com.intellij.idea.Main. Program will exit.
JAVA_HOME = C:\JAVA\JDK\jdk1.6.0_38;C:\JAVA\JDK\jdk1.7.0_10
JAVA_HOME -> C:\Program Files\Java\jdk1.7.0_4 path -> C:\Program Files\Java\jdk1.7.0_4\bin
linear = (LinearLayout) findViewById(R.id.LinearView); Button button = new Button(this); button.setText("Button"); button.setOnClickListener(listener); button.setLayoutParams( new LayoutParams( android.view.ViewGroup.LayoutParams.FILL_PARENT, android.view.ViewGroup.LayoutParams.WRAP_CONTENT ) ); linear.addView(button);
Drawable img = getContext().getResources().getDrawable( R.drawable.smiley ); img.setBounds( 0, 0, 60, 60 ); txtVw.setCompoundDrawables( img, null, null, null );
Drawable img = getContext().getResources().getDrawable( R.drawable.smiley ); txtVw.setCompoundDrawablesWithIntrinsicBounds( img, null, null, null);
txtVw.setCompoundDrawablesWithIntrinsicBounds( R.drawable.smiley, 0, 0, 0);
txtVw.setCompoundDrawablesWithIntrinsicBounds(R.drawable.smiley, 0, 0, 0);
button.setCompoundDrawablesWithIntrinsicBounds(com.example.project1.R.drawable.ic_launcher, 0, 0, 0);
myEdtiText.setCompoundDrawablesWithIntrinsicBounds( R.drawable.smiley,0, 0, 0);
Drawable[] drawables = button.getCompoundDrawables(); Drawable leftCompoundDrawable = drawables[0]; Drawable img = getContext().getResources().getDrawable(R.drawable.ic_launcher); img.setBounds(leftCompoundDrawable.getBounds()); button.setCompoundDrawables(img, null, null, null);
Drawable leftDrawable = getContext().getResources() .getDrawable(R.drawable.yourdrawable); Drawable[] drawables = button.getCompoundDrawables(); button.setCompoundDrawablesWithIntrinsicBounds(leftDrawable,drawables[1], drawables[2], drawables[3]);
TextView location; location=(TextView)view.findViewById(R.id.complain_location); location.setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.arrow,0);
Drawable img = getResources().getDrawable( R.drawable.user ); img.setBounds( 0, 0, 60, 60 ); mNameEditText.setCompoundDrawables(img,null, null, null); int color = ContextCompat.getColor(this, R.color.blackColor); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { DrawableCompat.setTint(img, color); } else { img.mutate().setColorFilter(color, PorterDuff.Mode.SRC_IN); }
val drawable = ContextCompat.getDrawable(context, R.drawable.ic_favorite_white_16dp) button.setCompoundDrawablesWithIntrinsicBounds(drawable, null, null, null)
android { defaultConfig { vectorDrawables.useSupportLibrary = true } }
class MyApplication : Application() { override fun onCreate() { super.onCreate() AppCompatDelegate.setCompatVectorFromResourcesEnabled(true) } }
((Button)btn).getCompoundDrawables()[0].setAlpha(btn.isEnabled() ? 255 : 100);
ArrayList<String> list = new ArrayList<String>(); list.add("one"); list.add("two"); list.add("three"); String listString = ""; for (String s : list) { listString += s + "\t"; } System.out.println(listString);
61: new 64: dup 65: invokespecial 68: aload_2 69: invokevirtual 72: aload 4 74: invokevirtual 77: ldc 79: invokevirtual 82: invokevirtual
ArrayList<String> list = new ArrayList<String>(); list.add("one"); list.add("two"); list.add("three"); StringBuilder sb = new StringBuilder(); for (String s : list) { sb.append(s); sb.append("\t"); } System.out.println(sb.toString());
33: new 36: dup 37: invokespecial 40: astore_2 66: aload_2 67: aload 4 69: invokevirtual 72: pop 73: aload_2 74: ldc 76: invokevirtual 79: pop
String listString = list.stream().map(Object::toString) .collect(Collectors.joining(", "));
List<String> list = new ArrayList<String>(); list.add("Item 1"); list.add("Item 2"); String joined = TextUtils.join(", ", list);
StringUtils.join(list) StringUtils.join(list, ", ")
import org.apache.commons.lang3.StringUtils; String str = StringUtils.join(myList);
import java.util.Arrays; String str = Arrays.toString(myList.toArray());
myList.toString().replaceAll("\\[|\\]", "").replaceAll(", ","\t")
Arrays.toString(myList).replaceAll("\\[|\\]", "").replaceAll(", ","\t")
StringBuilder out = new StringBuilder(); for (Object o : list) { out.append(o.toString()); out.append("\t"); } return out.toString();
public static java.lang.String join(java.util.Collection collection, char separator) public static String join(Iterator iterator, String separator) { Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuffer buf = new StringBuffer(256); if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); }
StringBuilder buf = new StringBuilder(); Separator sep = new Separator("\t"); for (String each: list) buf.append(sep).append(each); String s = buf.toString();
String csv = org.apache.commons.lang3.StringUtils.join(yourArray, "\t");
StringBuilder sb = new StringBuilder(); for (Object obj : list) { sb.append(obj.toString()); sb.append("\t"); } String finalString = sb.toString();
public static <T> String asString(List<T> list) { return StreamSupport.stream(list) .map(Object::toString) .collect(Collectors.joining("\n")); }
import java.util.Arrays; public class Test { public static void main(String[] args) { System.out.println(Arrays.deepToString(Arrays.asList("Test", "Test2").toArray())); } }
ArrayList<String> list = new ArrayList<String>(); list.add("one"); list.add("two"); list.add("three"); Assert.assertEquals( "one\ttwo\tthree", ArrayListAdapter.adapt(list).makeString("\t"));
Assert.assertEquals( "one\ttwo\tthree", FastList.newListWith("one", "two", "three").makeString("\t"));
List<String> stringList = getMyListOfStrings(); StringJoiner sj = new StringJoiner(" "); stringList.stream().forEach(e -> sj.add(e)); String spaceSeparated = sj.toString()
List<String> list = new ArrayList<String>(); list.add("one"); list.add("two"); list.add("three"); StringBuilder sb = new StringBuilder(list.size() * apprAvg); for (int i = 0; i < list.size(); i++) { sb.append(list.get(i)); if (i < list.size() - 1) { sb.append("\t"); } } System.out.println(sb.toString());
List list = new ArrayList(); list.add("1"); list.add("2"); list.add("3"); String str = list.toString(); System.out.println("Step-1 : " + str); str = str.replaceAll("[\\[\\]]", ""); System.out.println("Step-2 : " + str);
String result = Arrays.asList(1,2,3).stream().map(Object::toString).reduce((t, u) -> t + "\t" + u).orElse("");
String result = Arrays.asList(1,2,3).stream() .map(Object::toString) .reduce((t, u) -> t + "\t" + u) .orElse("");
List<String> streamValues = new ArrayList<>(); Arrays.deepToString(streamValues.toArray()));
List<Account> accounts = new ArrayList<>(); public String accountList() { Account[] listingArray = accounts.toArray(new Account[accounts.size()]); String listingString = Arrays.toString(listingArray); return listingString; }
ArrayList<String> mylist = new ArrayList<String>(); mylist.add("C Programming"); mylist.add("Java"); mylist.add("C++"); mylist.add("Perl"); mylist.add("Python"); for (String each : mylist) { System.out.print(each); System.out.print("\t"); }
System.out.println(yourArrayList.toString().replaceAll("\\[|\\]|[,][ ]","\t"));
public static String toString(final Collection<?> collection) { final StringBuilder sb = new StringBuilder("{"); boolean isFirst = true; for (final Object object : collection) { if (!isFirst) sb.append( else isFirst = false; sb.append(object); } sb.append( return sb.toString(); }
String srt= list.toString().replaceAll("\\[|\\]|,","");
Error occurred during initialization of VM java/lang/NoClassDefFoundError: java/lang/Object
java version "1.8.0_91" Java(TM) SE Runtime Environment (build 1.8.0_91-b15) Java HotSpot(TM) 64-Bit Server VM (build 25.91-b15, mixed mode)
@ECHO OFF SETLOCAL ENABLEDELAYEDEXPANSION SET ROOT=%cd% REM Get the tools.zip from the innards of the installer 7z e *.exe .rsrc/1033/JAVA_CAB10/111 7z e 111 7z x tools.zip REM Extract all 7z x -aoa tools.zip -ojdk del tools.zip del 111 REM Searching directory structure from root for subfolders and zipfiles. FOR /F "delims==" %%d IN ( echo Descending into %%d FOR /F "delims==" %%f IN ( echo Extracting "%%d\%%f" REM Extract all packs into jars. jdk\bin\unpack200 -r "%%d\%%f" "%%d\%%~nf.jar" ) ) ENDLOCAL pause;
@echo off cd /d "%~dp0" for /r %%x in (*.pack) do .\bin\unpack200 -r "%%x" "%%~dx%%~px%%~nx.jar"
ArgumentCaptor<Foo> firstFooCaptor = ArgumentCaptor.forClass(Foo.class); ArgumentCaptor<Foo> secondFooCaptor = ArgumentCaptor.forClass(Foo.class); verify(mockBar).doSomething(firstFooCaptor.capture()); verify(mockBar).doSomething(secondFooCaptor.capture());
ArgumentCaptor<Person> peopleCaptor = ArgumentCaptor.forClass(Person.class); verify(mock, times(2)).doSomething(peopleCaptor.capture()); List<Person> capturedPeople = peopleCaptor.getAllValues(); assertEquals("John", capturedPeople.get(0).getName()); assertEquals("Jane", capturedPeople.get(1).getName());
verify(mockBar).doSth(argThat((arg) -> arg.getSurname().equals("OneSurname"))); verify(mockBar).doSth(argThat((arg) -> arg.getSurname().equals("AnotherSurname")));
verify(mockBar).doSth(argThat(new ArgumentMatcher<Employee>() { @Override public boolean matches(Object emp) { return ((Employee) emp).getSurname().equals("SomeSurname"); } }));
InOrder inOrder = inOrder(mockBar); inOrder.verify(mockBar).doSth(argThat((arg) -> arg.getSurname().equals("FirstSurname"))); inOrder.verify(mockBar).doSth(argThat((arg) -> arg.getSurname().equals("SecondSurname")));
verify(mockBar).doSth(assertArg(arg -> assertThat(arg.getSurname()).isEqualTo("Surname")));
ArgumentCaptor<Foo> fooCaptor = ArgumentCaptor.forClass(Foo.class); verify(mockBar, times(2)).doSomething(fooCaptor.capture()); assertEquals("2nd one", fooCaptor.getValue().getName());
@Mock List<String> mockedList; @Captor ArgumentCaptor<String> argCaptor; @BeforeTest public void init() { MockitoAnnotations.initMocks(this); } @Test public void shouldCallAddMethodTwice() { mockedList.add("one"); mockedList.add("two"); Mockito.verify(mockedList, times(2)).add(argCaptor.capture()); assertEquals("one", argCaptor.getAllValues().get(0)); assertEquals("two", argCaptor.getAllValues().get(1)); }
org.mockito.invocation.InvocationOnMock when(client.deleteByQuery(anyString(), anyString())).then(invocationOnMock -> { assertEquals("myCollection", invocationOnMock.getArgument(0)); assertThat(invocationOnMock.getArgument(1), Matchers.startsWith("id:")); }
Long.parseLong("0", 10) Long.parseLong("473", 10) Long.parseLong("-0", 10) Long.parseLong("-FF", 16) Long.parseLong("1100110", 2) Long.parseLong("99", 8) Long.parseLong("Hazelnut", 10) Long.parseLong("Hazelnut", 36) Long.parseLong("999")
public class StringToLong { public static void main (String[] args) { String s = "100"; try { long l = Long.parseLong(s); System.out.println("long l = " + l); } catch (NumberFormatException nfe) { System.out.println("NumberFormatException: " + nfe.getMessage()); } } }
String numberAsString = "1234"; long number = Long.valueOf(numberAsString).longValue();
String numberAsString = "1234"; Long longObject = new Long(numberAsString); long number = longObject.longValue();
String numberAsString = "1234"; long number = new Long(numberAsString).longValue();
String numberAsString = "1234"; DecimalFormat decimalFormat = new DecimalFormat(" try { long number = decimalFormat.parse(numberAsString).longValue(); System.out.println("The number is: " + number); } catch (ParseException e) { System.out.println(numberAsString + " is not a valid number."); }
Map map = new HashMap(); map.put("name", "John"); map.put("time", "9648512236521"); map.put("age", "25"); long time = Long.valueOf((String)map.get("time")).longValue() ; int age = Integer.valueOf((String) map.get("aget")).intValue(); System.out.println(time); System.out.println(age);
char[] charArray = { String str = String.valueOf(charArray);
String str = "wwwwww3333dfevvv"; char[] c = str.toCharArray();
package naresh.java; public class TestDoubleString { public static void main(String args[]){ String str="abbcccddef"; char charArray[]=str.toCharArray(); int len=charArray.length; for(int i=0;i<len;i++){ try{ if(charArray[i]==charArray[i+1]){ charArray[i]= }} catch(Exception e){ System.out.println("Exception"); } } for(int k=0;k<charArray.length;k++){ if(charArray[k]!= System.out.println(charArray[k]); } } } }
char[] a = { String b = String.valueOf(a); System.out.println("Char Array back to String is: " + b);
CharSequence[] charArray = {"a","b","c"}; for (int i = 0; i < charArray.length; i++){ String str = charArray.toString().join("", charArray[i]); System.out.print(str); }
   List  Set    Duplicates  YES  NO    Order  ORDERED  DEPENDS ON IMPLEMENTATION    Positional Access  YES  NO  
import java.util.*; public class ListExample { public static void main(String[] args) { List<Integer> l=new LinkedList<Integer>(); l.add(001); l.add(555); l.add(333); l.add(888); l.add(555); l.add(null); l.add(null); Iterator<Integer> il=l.iterator(); System.out.println(l.get(0)); while(il.hasNext()){ System.out.println(il.next()); } for(Integer str : l){ System.out.println("Value:"+str); } } }
import java.util.TreeSet; public class SetExample { public static void main(String[] args) { TreeSet<String> set = new TreeSet<String>(); try { set.add("hello"); set.add("world"); set.add("welcome"); set.add("all"); for (String num : set) { System.out.println( num); } set.add(null); } catch (NullPointerException e) { System.out.println(e); System.out.println("Set doesn } } }
s = [] as Set l = [] max = 5 print "random Numbers :" 20.times{ e = (int)Math.random()*max s << e l << e print "$e, " } println "\n" println "Set : $s " println "list : $l
class Foo { private final String myvar; public Foo(final String initialValue) { this.myvar = initialValue; } public String getValue() { return this.myvar; } }
struct String { char* characters; unsigned int length; }; struct String* substring(struct String* in, unsigned int begin, unsigned int end) { struct String* out = malloc(sizeof(struct String)); out->characters = in->characters + begin; out->length = end - begin; return out; }
foo = foo.substring(0,4) + "a" + foo.substring(5); bar.replace(4,5,"a");
struct String* concatenate(struct String* first, struct String* second) { struct String* new = malloc(sizeof(struct String)); new->length = first->length + second->length; new->characters = malloc(new->length); int i; for(i = 0; i < first->length; i++) new->characters[i] = first->characters[i]; for(; i - first->length < second->length; i++) new->characters[i] = second->characters[i - first->length]; return new; } struct String* astring; char a = astring->characters = &a; astring->length = 1; foo = concatenate(concatenate(slice(foo,0,4),astring),slice(foo,5,foo->length));
String join(String[] strings, String separator) { StringBuilder mutable; boolean first = true; for(int i = 0; i < strings.length; i++) { if(!first) first = false; else mutable.append(separator); mutable.append(strings[i]); } return mutable.toString(); }
public class ColoredString { private String color; private String string; public ColoredString(String color, String string) { this.color = color; this.string = string; } public String getColor() { return this.color; } public String getString() { return this.string; } public void setColor(String newColor) { this.color = newColor; } }
new ColoredString("Blue", "This is a blue string!");
reference | MEMORY | variables | | [s1] --------------->| "Old String" |
| | [s1] --------------->| "Old String" | [s2] ------------------------^
[s1] -----|--------->| "New String" | | | | |~~~~~~~~~X| "Old String" | [s2] ------------------------^
String foo = "Hello"; foo.substring(3); <-- foo here still has the same value "Hello"
LocalDate date = LocalDate.of(2014, 3, 18); date.plusYears(2); System.out.println(date);
LocalDate date = LocalDate.of(2014, 3, 18); LocalDate dateAfterTwoYears = date.plusYears(2);
String s1="Hi"; String s2=s1; s1="Bye"; System.out.println(s2); System.out.println(s1);
class Testimmutablestring{ public static void main(String args[]){ String s="Future"; s.concat(" World"); System.out.println(s); } }
String s="Future"; s=s.concat(" World"); System.out.println(s);
char a = 0; char b = 6; a += 1; a = (char) (a * b); a = (char) (a + b); a = (char) (a - 16); b = (char) (b % 3); b = (char) (b / a); System.out.println(a); System.out.println((int) a); System.out.println((short) a); short c = -4; System.out.println((int) c); a *= 2; a -= 6; a /= 3; a %= 7; a++; a--;
assert( rays.size() > 0 && rays.size() % 2 == 1 ); for( size_t n = 0; n < rays.size(); ++n ) { double angle = delta * fabs( n - (rays.size() - 1) / 2 ); }
Intent intent = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse("http: startActivity(intent);
Intent intent = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse("google.navigation:q=an+address+city"));
Intent intent = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse("geo:0,0?q=37.423156,-122.084917 (" + name + ")")); startActivity(intent);
String uri = String.format(Locale.ENGLISH, "http: Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(uri)); intent.setPackage("com.google.android.apps.maps"); startActivity(intent);
String uri = String.format(Locale.ENGLISH, "http: Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(uri)); intent.setPackage("com.google.android.apps.maps"); startActivity(intent);
String uri = String.format(Locale.ENGLISH, "http: Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(uri)); intent.setPackage("com.google.android.apps.maps"); try { startActivity(intent); } catch(ActivityNotFoundException ex) { try { Intent unrestrictedIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(uri)); startActivity(unrestrictedIntent); } catch(ActivityNotFoundException innerEx) { Toast.makeText(this, "Please install a maps application", Toast.LENGTH_LONG).show(); } }
Uri navigationIntentUri = Uri.parse("google.navigation:q=" + 12f +"," + 2f); Intent mapIntent = new Intent(Intent.ACTION_VIEW, navigationIntentUri); mapIntent.setPackage("com.google.android.apps.maps"); startActivity(mapIntent);
Uri.Builder directionsBuilder = new Uri.Builder() .scheme("https") .authority("www.google.com") .appendPath("maps") .appendPath("dir") .appendPath("") .appendQueryParameter("api", "1") .appendQueryParameter("destination", lat + "," + lon); startActivity(new Intent(Intent.ACTION_VIEW, directionsBuilder.build()));
Uri.Builder builder = new Uri.Builder(); builder.scheme("https") .authority("www.google.com").appendPath("maps").appendPath("dir").appendPath("").appendQueryParameter("api", "1") .appendQueryParameter("destination", 80.00023 + "," + 13.0783); String url = builder.build().toString(); Log.d("Directions", url); Intent i = new Intent(Intent.ACTION_VIEW); i.setData(Uri.parse(url)); startActivity(i);
Intent i = new Intent(Intent.ACTION_VIEW,Uri.parse("geo:37.827500,-122.481670")); i.setClassName("com.google.android.apps.maps", "com.google.android.maps.MapsActivity"); startActivity(i);
Uri gmmIntentUri = Uri.parse("google.navigation:q=latitude,longitude"); Intent mapIntent = new Intent(Intent.ACTION_VIEW, gmmIntentUri); mapIntent.setPackage("com.google.android.apps.maps"); startActivity(mapIntent);
Intent intent = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse("https: startActivity(intent);
Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("http: if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); }
Intent intent = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse("http: intent.setClassName("com.google.android.apps.maps", "com.google.android.maps.MapsActivity"); startActivity(intent);
String kmlWebAddress = "http: String uri = String.format(Locale.ENGLISH, "geo:0,0?q=%s",kmlWebAddress); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(uri)); startActivity(intent);
Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http: intent.setComponent(new ComponentName("com.google.android.apps.maps", "com.google.android.maps.MapsActivity")); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); }
val gmmIntentUri = Uri.parse("google.navigation:q="+destintationLatitude+","+destintationLongitude + "&mode=b") val mapIntent = Intent(Intent.ACTION_VIEW, gmmIntentUri) mapIntent.setPackage("com.google.android.apps.maps") startActivity(mapIntent)
String addressString = "1600 Amphitheatre Parkway, CA"; Uri.Builder builder = new Uri.Builder(); builder.scheme("geo") .path("0,0") .query(addressString); Uri addressUri = builder.build(); Intent intent = new Intent(Intent.ACTION_VIEW, addressUri); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); }
StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace()
/** * Test the speed of various methods for getting the caller class name */ public class TestGetCallerClassName { /** * Abstract class for testing different methods of getting the caller class name */ private static abstract class GetCallerClassNameMethod { public abstract String getCallerClassName(int callStackDepth); public abstract String getMethodName(); } /** * Uses the internal Reflection class */ private static class ReflectionMethod extends GetCallerClassNameMethod { public String getCallerClassName(int callStackDepth) { return sun.reflect.Reflection.getCallerClass(callStackDepth).getName(); } public String getMethodName() { return "Reflection"; } } /** * Get a stack trace from the current thread */ private static class ThreadStackTraceMethod extends GetCallerClassNameMethod { public String getCallerClassName(int callStackDepth) { return Thread.currentThread().getStackTrace()[callStackDepth].getClassName(); } public String getMethodName() { return "Current Thread StackTrace"; } } /** * Get a stack trace from a new Throwable */ private static class ThrowableStackTraceMethod extends GetCallerClassNameMethod { public String getCallerClassName(int callStackDepth) { return new Throwable().getStackTrace()[callStackDepth].getClassName(); } public String getMethodName() { return "Throwable StackTrace"; } } /** * Use the SecurityManager.getClassContext() */ private static class SecurityManagerMethod extends GetCallerClassNameMethod { public String getCallerClassName(int callStackDepth) { return mySecurityManager.getCallerClassName(callStackDepth); } public String getMethodName() { return "SecurityManager"; } /** * A custom security manager that exposes the getClassContext() information */ static class MySecurityManager extends SecurityManager { public String getCallerClassName(int callStackDepth) { return getClassContext()[callStackDepth].getName(); } } private final static MySecurityManager mySecurityManager = new MySecurityManager(); } /** * Test all four methods */ public static void main(String[] args) { testMethod(new ReflectionMethod()); testMethod(new ThreadStackTraceMethod()); testMethod(new ThrowableStackTraceMethod()); testMethod(new SecurityManagerMethod()); } private static void testMethod(GetCallerClassNameMethod method) { long startTime = System.nanoTime(); String className = null; for (int i = 0; i < 1000000; i++) { className = method.getCallerClassName(2); } printElapsedTime(method.getMethodName(), startTime); } private static void printElapsedTime(String title, long startTime) { System.out.println(title + ": " + ((double)(System.nanoTime() - startTime))/1000000 + " ms."); } }
Reflection: 10.195 ms. Current Thread StackTrace: 5886.964 ms. Throwable StackTrace: 4700.073 ms. SecurityManager: 1046.804 ms.
> java -version java version "1.8.0" Java(TM) SE Runtime Environment (build 1.8.0-b132) Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode) > java TestGetCallerClassName Reflection: 0.194s. Current Thread StackTrace: 3.887s. Throwable StackTrace: 3.173s. SecurityManager: 0.565s.
StackWalker walker = StackWalker .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);
walker.walk(frames -> frames .map(StackWalker.StackFrame::getDeclaringClass) .skip(1) .findFirst());
Thread.currentThread().getStackTrace()[2].getMethodName()
sun.reflect.Reflection /** Returns the class of the method <code>realFramesToSkip</code> frames up the stack (zero-based), ignoring frames associated with java.lang.reflect.Method.invoke() and its implementation. The first frame is that associated with this method, so <code>getCallerClass(0)</code> returns the Class object for sun.reflect.Reflection. Frames associated with java.lang.reflect.Method.invoke() and its implementation are completely ignored and do not count toward the number of "real" frames skipped. */ public static native Class getCallerClass(int realFramesToSkip);
/** * Get the method name for a depth in call stack. <br /> * Utility function * @param depth depth in the call stack (0 means current method, 1 means call method, ...) * @return method name */ public static String getMethodName(final int depth) { final StackTraceElement[] ste = new Throwable().getStackTrace(); return ste[ste.length - depth].getMethodName(); }
/** * Returns the first "[class * From the Stack Trace. * @return "[class */ public static String getClassMethodLine() { return getClassMethodLine(null); } /** * Returns the first "[class * Allows to get past a certain class. * @param aclass class to get pass in the stack trace. If null, only try to get past StackTraceUtils. * @return "[class */ public static String getClassMethodLine(final Class aclass) { final StackTraceElement st = getCallingStackTraceElement(aclass); final String amsg = "[" + st.getClassName() + " +")] <" + Thread.currentThread().getName() + ">: "; return amsg; } /** * Returns the first stack trace element of the first class not equal to "StackTraceUtils" or "LogUtils" and aClass. <br /> * Stored in array of the callstack. <br /> * Allows to get past a certain class. * @param aclass class to get pass in the stack trace. If null, only try to get past StackTraceUtils. * @return stackTraceElement (never null, because if aClass is not found, returns first class past StackTraceUtils) * @throws AssertionFailedException if resulting statckTrace is null (RuntimeException) */ public static StackTraceElement getCallingStackTraceElement(final Class aclass) { final Throwable t = new Throwable(); final StackTraceElement[] ste = t.getStackTrace(); int index = 1; final int limit = ste.length; StackTraceElement st = ste[index]; String className = st.getClassName(); boolean aclassfound = false; if(aclass == null) { aclassfound = true; } StackTraceElement resst = null; while(index < limit) { if(shouldExamine(className, aclass) == true) { if(resst == null) { resst = st; } if(aclassfound == true) { final StackTraceElement ast = onClassfound(aclass, className, st); if(ast != null) { resst = ast; break; } } else { if(aclass != null && aclass.getName().equals(className) == true) { aclassfound = true; } } } index = index + 1; st = ste[index]; className = st.getClassName(); } if(resst == null) { throw new AssertionFailedException(StackTraceUtils.getClassMethodLine() + " null argument:" + "stack trace should null"); } return resst; } static private boolean shouldExamine(String className, Class aclass) { final boolean res = StackTraceUtils.class.getName().equals(className) == false && (className.endsWith("LogUtils" ) == false || (aclass !=null && aclass.getName().endsWith("LogUtils"))); return res; } static private StackTraceElement onClassfound(Class aclass, String className, StackTraceElement st) { StackTraceElement resst = null; if(aclass != null && aclass.getName().equals(className) == false) { resst = st; } if(aclass == null) { resst = st; } return resst; }
private void parseExceptionContents( final Exception exception, final OutputStream out) { final StackTraceElement[] stackTrace = exception.getStackTrace(); int index = 0; for (StackTraceElement element : stackTrace) { final String exceptionMsg = "Exception thrown from " + element.getMethodName() + " in class " + element.getClassName() + " [on line number " + element.getLineNumber() + " of file " + element.getFileName() + "]"; try { out.write((headerLine + newLine).getBytes()); out.write((headerTitlePortion + index++ + newLine).getBytes() ); out.write((headerLine + newLine).getBytes()); out.write((exceptionMsg + newLine + newLine).getBytes()); out.write( ("Exception.toString: " + element.toString() + newLine).getBytes()); } catch (IOException ioEx) { System.err.println( "IOException encountered while trying to write " + "StackTraceElement data to provided OutputStream.\n" + ioEx.getMessage() ); } } }
public class InstanceCount{ private static Map<Integer, CounterInstanceLog> instanceMap = new HashMap<Integer, CounterInstanceLog>(); private CounterInstanceLog counterInstanceLog; public void count() { counterInstanceLog= new counterInstanceLog(); if(counterInstanceLog.getIdHashCode() != 0){ try { if (instanceMap .containsKey(counterInstanceLog.getIdHashCode())) { counterInstanceLog= instanceMap .get(counterInstanceLog.getIdHashCode()); } counterInstanceLog.incrementCounter(); instanceMap .put(counterInstanceLog.getIdHashCode(), counterInstanceLog); } (...) }
public class CounterInstanceLog{ private int idHashCode; private StackTraceElement[] arrayStackTraceElements; private int instanceCount; private String callerClassName; private StackTraceElement getProjectClasses(int depth) { if(depth< 10){ getCallerClassName(sun.reflect.Reflection.getCallerClass(depth).getName()); if(getCallerClassName().startsWith("com.yourproject.model")){ setStackTraceElements(Thread.currentThread().getStackTrace()); setIdHashCode(); return arrayStackTraceElements[depth]; } return getProjectClasses(profundidade+2); }else{ return null; } } private void setIdHashCode() { if(getNomeClasse() != null){ this.idHashCode = (getCallerClassName()).hashCode(); } } public void incrementaContador() { this.instanceCount++; } (...) }
import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.PrintWriter; class DBConnection { String createdBy = null; DBConnection(Throwable whoCreatedMe) { ByteArrayOutputStream os = new ByteArrayOutputStream(); PrintWriter pw = new PrintWriter(os); whoCreatedMe.printStackTrace(pw); try { createdBy = os.toString(); pw.close(); os.close(); } catch (IOException e) { e.printStackTrace(); } } } public class ThrowableTest { public static void main(String[] args) { Throwable createdBy = new Throwable( "Connection created from DBConnectionManager"); DBConnection conn = new DBConnection(createdBy); System.out.println(conn.createdBy); } }
public static interface ICallback<T> { T doOperation(); } public class TestCallerOfMethod { public static <T> T callTwo(final ICallback<T> c){ System.out.println(c.getClass().getEnclosingMethod().getName()); return c.doOperation(); } public static boolean callOne(){ ICallback callBackInstance = new ICallback(Boolean){ @Override public Boolean doOperation() { return true; } }; return callTwo(callBackInstance); } public static void main(String[] args) { callOne(); } }
StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace(); stackTraceElement e = stacktrace[2]; System.out.println(e.getMethodName());
public class TestString { public static void main(String[] args) { TestString testString = new TestString(); testString.doit1(); testString.doit2(); testString.doit3(); testString.doit4(); } public void doit() { StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace(); StackTraceElement e = stacktrace[2]; System.out.println(e.getMethodName()); } public void doit1() { doit(); } public void doit2() { doit(); } public void doit3() { doit(); } public void doit4() { doit(); } }
public class Array { int data[] = new int[10]; /** Creates a new instance of Array */ public Array() { data[10] = {10,20,30,40,50,60,71,80,90,91}; } }
int[] data = {10,20,30,40,50,60,71,80,90,91}; int[] data; data = new int[] {10,20,30,40,50,60,71,80,90,91};
public class Array { int[] data = new int[10]; /** Creates a new instance of an int Array */ public Array() { for(int i = 0; i < data.length; i++) { data[i] = i*10; } } }
Datatype[] variable = new Datatype[] { value1,value2.... } Datatype variable[] = new Datatype[] { value1,value2.... }
int n; int[] a = new int[n]; for (int i = 0; i < a.length; i++) { a[i] = Integer.parseInt(s.nextLine()); }
for (int i = 0; i < a.length; i++) { System.out.println(a[i] + " "); }
public class Array { int[] data; public Array() { data = new int[] {10,20,30,40,50,60,71,80,90,91}; } }
public class Array { int data[] = new int[10]; public Array() { data= {10,20,30,40,50,60,71,80,90,91}; } }
public interface MyInterface { String doSomething(int param1, String param2); }
class MyClass { public MyInterface myInterface = (p1, p2) -> { return p2 + p1; }; }
new Thread(new Runnable() { someMethod(); }).start();
public T myMethod(Callable<T> func) { return func.call(); }
public int methodToPass() { } public void dansMethod(int i, Callable<Integer> myFunc) { }
dansMethod(100, new Callable<Integer>() { public Integer call() { return methodToPass(); } });
import java.lang.reflect.Method; public class Demo { public static void main(String[] args) throws Exception{ Class[] parameterTypes = new Class[1]; parameterTypes[0] = String.class; Method method1 = Demo.class.getMethod("method1", parameterTypes); Demo demo = new Demo(); demo.method2(demo, method1, "Hello World"); } public void method1(String message) { System.out.println(message); } public void method2(Object object, Method method, String message) throws Exception { Object[] parameters = new Object[1]; parameters[0] = message; method.invoke(object, parameters); } }
obj.aMethod(new AFunctionalInterface() { @Override public boolean anotherMethod(int i) { return i == 982 } });
p -> p.getGender() == Person.Sex.MALE && p.getAge() >= 18 && p.getAge() <= 25
p.getGender() == Person.Sex.MALE && p.getAge() >= 18 && p.getAge() <= 25
p -> { return p.getGender() == Person.Sex.MALE && p.getAge() >= 18 && p.getAge() <= 25; }
class A { public static void methodToPass(int i) { } }
import java.util.function.IntConsumer; class B { public void dansMethod(int i, IntConsumer aMethod) { /* you can now call the passed method by saying aMethod.accept(i), and it will be the equivalent of saying A.methodToPass(i) */ } }
class C { B b = new B(); public C() { b.dansMethod(100, j -> A.methodToPass(j)); } }
static boolean exists(java.util.Collection collection, Predicate predicate)
CollectionUtils.exists(someCollection, new Predicate() { public boolean evaluate(Object object) { return ("a".equals(object.toString()); } });
public Runnable foo(final int x) { return new Runnable() { public void run() { System.out.println(x); } }; }
public interface Callable<I, O> { public O call(I input); }
public class Demo { public Demo(/.../){ } public void view(Action a){ a.preform(); } /** * The Action Class is for making the Demo * View Custom Code */ public abstract class Action { public Action(/.../){ } abstract void preform(); } }
/... Demo d = new Demo; Action a = new Action() { @Override void preform() { } }; /.../ d.view(a)
java.lang.NoClassDefFoundError: org/apache/activemq/ActiveMQConnectionFactory
public class Test1 { } public class Test { public static void main(String[] args) { Test1 = new Test1(); } }
Exception in thread "main" java.lang.NoClassDefFoundError: Test at Test1.main(Test1.java:5) Caused by: java.lang.ClassNotFoundException: Test at java.net.URLClassLoader$1.run(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) ... 1 more
class A{ void met(){ Class.forName("com.example.Class1"); } }
Class B{ void met(){ com.example.Class2 c = new com.example.Class2(); } }
ClassNotFoundException extends ReflectiveOperationException extends Exception extends Throwable
NoClassDefFoundError extends LinkageError extends Error extends Throwable
public class MainClass { public static void main(String[] args) { try { Class.forName("oracle.jdbc.driver.OracleDriver"); }catch (ClassNotFoundException e) { e.printStackTrace(); } } } java.lang.ClassNotFoundException: oracle.jdbc.driver.OracleDriver at java.net.URLClassLoader.findClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Unknown Source) at pack1.MainClass.main(MainClass.java:17)
class A { } public class B { public static void main(String[] args) { A a = new A(); } }
Exception in thread "main" java.lang.NoClassDefFoundError: A at MainClass.main(MainClass.java:10) Caused by: java.lang.ClassNotFoundException: A at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
Iterator<String> sourceIterator = Arrays.asList("A", "B", "C").iterator(); Collection<String> copyList = new ArrayList<String>(); sourceIterator.forEachRemaining(copyList::add); Stream<String> targetStream = copyList.stream();
public static void main(String[] args) throws Exception { Iterator<String> sourceIterator = Arrays.asList("A", "B", "C").iterator(); Stream<String> targetStream = Stream.generate(sourceIterator::next); targetStream.forEach(System.out::println); }
Iterator<String> sourceIterator = Arrays.asList("A", "B", "C").iterator(); Stream<String> targetStream = StreamSupport.stream( Spliterators.spliteratorUnknownSize(sourceIterator, Spliterator.ORDERED), false);
Iterator<String> sourceIterator = Arrays.asList("A", "B", "C").iterator(); Iterable<String> iterable = () -> sourceIterator; Stream<String> targetStream = StreamSupport.stream(iterable.spliterator(), false);
public class StreamUtils { public static <T> Stream<T> asStream(Iterator<T> sourceIterator) { return asStream(sourceIterator, false); } public static <T> Stream<T> asStream(Iterator<T> sourceIterator, boolean parallel) { Iterable<T> iterable = () -> sourceIterator; return StreamSupport.stream(iterable.spliterator(), parallel); } }
List<String> aPrefixedStrings = asStream(sourceIterator) .filter(t -> t.startsWith("A")) .collect(toList());
Stream.generate(iterator::next) .takeWhile(i -> iterator.hasNext()) .forEach(System.out::println);
Stream.generate(() -> null) .takeWhile(x -> iterator.hasNext()) .map(n -> iterator.next()) .forEach(System.out::println);
Spliterator<Model> spliterator = Spliterators.spliteratorUnknownSize( iterator, Spliterator.NONNULL); Stream<Model> stream = StreamSupport.stream(spliterator, false);
import static org.mockito.Mockito.*; List mockedList = mock(List.class); mockedList.clear(); verify(mockedList).clear();
import mockit.Mockit; ... Mockit.redefineMethods(MyClassWithStaticInit.class, MyReplacementClass.class); ... class MyReplacementClass { public void $init() {...} public static void $clinit{...} public static void myStatic{...} }
import mockit.Expectations; import org.testng.annotations.Test; public class ExpecationsTest { private MyClass obj; @Test public void testFoo() { new Expectations(true) { MyClass c; { obj = c; invokeReturning(c.getFoo("foo", false), "bas"); } }; assert "bas".equals(obj.getFoo("foo", false)); Expectations.assertSatisfied(); } public static class MyClass { public String getFoo(String str, boolean bool) { if (bool) { return "foo"; } else { return "bar"; } } } }
def request = [isUserInRole: { roleName -> roleName == "testRole"}] as HttpServletRequest
val propSqrt = forAll { (n: Int) => (n >= 0) ==> scala.Math.sqrt(n*n) == n }
StreamSupport.stream(iterable.spliterator(), false) .filter(...) .moreStreamOps(...);
public static <T> Stream<T> stream(Iterable<T> iterable) { return StreamSupport.stream( Spliterators.spliteratorUnknownSize( iterable.iterator(), Spliterator.ORDERED ), false ); }
public class Streams { /** * Converts Iterable to stream */ public static <T> Stream<T> streamOf(final Iterable<T> iterable) { return toStream(iterable, false); } /** * Converts Iterable to parallel stream */ public static <T> Stream<T> parallelStreamOf(final Iterable<T> iterable) { return toStream(iterable, true); } private static <T> Stream<T> toStream(final Iterable<T> iterable, final boolean isParallel) { return StreamSupport.stream(iterable.spliterator(), isParallel); } }
interface Streamable<T> extends Iterable<T> { default Stream<T> stream() { return StreamSupport.stream(spliterator(), false); } }
public static <T> Stream<T> stream(Iterable<T> iterable) { return (iterable instanceof Collection) ? ((Collection<T>) iterable).stream() : StreamSupport.stream(iterable.spliterator(), false); } public static <T> Stream<T> stream(Iterator<T> iterator) { return StreamSupport.stream( Spliterators.spliteratorUnknownSize(iterator, 0), false ); }
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { Action action = ActionFactory.getAction(request); String view = action.execute(request, response); if (view.equals(request.getPathInfo().substring(1)) { request.getRequestDispatcher("/WEB-INF/" + view + ".jsp").forward(request, response); } else { response.sendRedirect(view); } } catch (Exception e) { throw new ServletException("Executing action failed.", e); } }
public interface Action { public String execute(HttpServletRequest request, HttpServletResponse response) throws Exception; }
public class LoginAction implements Action { public String execute(HttpServletRequest request, HttpServletResponse response) throws Exception { String username = request.getParameter("username"); String password = request.getParameter("password"); User user = userDAO.find(username, password); if (user != null) { request.getSession().setAttribute("user", user); return "home"; } else { request.setAttribute("error", "Unknown username/password. Please retry."); return "login"; } } }
public static Action getAction(HttpServletRequest request) { return actions.get(request.getMethod() + request.getPathInfo()); }
actions.put("POST/register", new RegisterAction()); actions.put("POST/login", new LoginAction()); actions.put("GET/logout", new LogoutAction());
for (Entry entry : configuration) { actions.put(entry.getKey(), Class.forName(entry.getValue()).newInstance()); }
for (ClassFile classFile : classpath) { if (classFile.isInstanceOf(Action.class)) { actions.put(classFile.getAnnotation("mapping"), classFile.newInstance()); } }
public void method1() { do something ... synchronized(this) { a ++; } ................ } public void method2() { do something ... synchronized(this) { b ++; } ................ }
class Test { private Object lockA = new Object(); private Object lockB = new Object(); public void method1() { do something ... synchronized(lockA) { a ++; } ................ } public void method2() { do something ... synchronized(lockB) { b ++; } ................ }
private readonly object _syncObj = new object(); ... lock(_syncObj) { }
washbasin1; washbasin2; Object lock1=new Object(); Object lock2=new Object(); synchronized(lock1) { washbasin1; } synchronized(lock2) { washbasin2; }
class X { private final ReentrantLock lock = new ReentrantLock(); public void m() { lock.lock(); try { } finally { lock.unlock() } } }
class Point{ private int x; private int y; public Point(int x, int y){ this.x = x; this.y = y; } public synchronized void changeCoordinates(int x, int y){ this.x = x; this.y = y; } }
class BadObject { private Something mStuff; synchronized setStuff(Something stuff) { mStuff = stuff; } synchronized getStuff(Something stuff) { return mStuff; } private MyListener myListener = new MyListener() { public void onMyEvent(...) { setStuff(...); } } synchronized void longOperation(MyListener l) { ... l.onMyEvent(...); ... } }
private final Object $lock = new Object[0]; public int foo() { synchronized($lock) { return 0; } }
public final synchronized void addListener(IListener l) {listeners.add(l);} public final synchronized void removeListener(IListener l) {listeners.remove(l);} public void run() { Set ls; synchronized(this) { ls = listeners.clone(); } for (IListener l : ls) { l.processEvent(event); } }
private static HashMap<String, Object> locks = new HashMap<String, Object>(); private static Object atomic() { StackTraceElement [] stack = Thread.currentThread().getStackTrace(); StackTraceElement exepoint = stack[2]; String key = String.format("%s Object lock = locks.get(key); if (lock == null) { lock = new Object(); locks.put(key, lock); } return lock; } void dosomething1() { synchronized (atomic()) { ... } } void dosomething2() { synchronized (atomic()) { ... } }
StringBuilder sb = new StringBuilder(); sb.append(""); sb.append(number); return sb.toString();
int i; String s = Integer.toString(i); or String s = String.valueOf(i);
/** * @param a * @return */ private String convertToString(int a) { int c; char m; StringBuilder ans = new StringBuilder(); while (a > 0) { c = a % 10; a = a / 10; m = (char) ( ans.append(m); } return ans.reverse().toString(); }
MySingleton.getInstance(Context c) { // sInstance = new MySingleton(c.getApplicationContext()); }
Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("http:
public class AndroidApplication extends Application { private static AndroidApplication sInstance; public static AndroidApplication getInstance(){ return sInstance; } @Override public void onCreate() { super.onCreate(); sInstance = this; } }
public abstract class BasicPage extends WebPage { public BasicPage() { add(new Label("title", getTitle())); } protected abstract String getTitle(); }
public class ConstructorCallsOverride { public static void main(String[] args) { abstract class Base { Base() { overrideMe(); } abstract void overrideMe(); } class Child extends Base { final int x; Child(int x) { this.x = x; } @Override void overrideMe() { System.out.println(x); } } new Child(42); } }
public class Telescope { final String name; final int levels; final boolean isAdjustable; public Telescope(String name) { this(name, 5); } public Telescope(String name, int levels) { this(name, levels, false); } public Telescope(String name, int levels, boolean isAdjustable) { this.name = name; this.levels = levels; this.isAdjustable = isAdjustable; } }
new Telescope("X/1999"); new Telescope("X/1999", 13); new Telescope("X/1999", 13, true);
Telescope telly = new Telescope.Builder("X/1999").setAdjustable(true).build();
public class Main { static abstract class A { abstract void foo(); A() { System.out.println("Constructing A"); foo(); } } static class C extends A { C() { System.out.println("Constructing C"); } void foo() { System.out.println("Using C"); } } public static void main(String[] args) { C c = new C(); } }
class A { protected int minWeeklySalary; protected int maxWeeklySalary; protected static final int MIN = 1000; protected static final int MAX = 2000; public A() { setSalaryRange(); } protected void setSalaryRange() { throw new RuntimeException("not implemented"); } public void pr() { System.out.println("minWeeklySalary: " + minWeeklySalary); System.out.println("maxWeeklySalary: " + maxWeeklySalary); } } class B extends A { private int factor = 1; public B(int _factor) { this.factor = _factor; } @Override protected void setSalaryRange() { this.minWeeklySalary = MIN * this.factor; this.maxWeeklySalary = MAX * this.factor; } } public static void main(String[] args) { B b = new B(2); b.pr(); }
public abstract class BasicPage extends WebPage { public BasicPage() { } @Override public void onInitialize() { add(new Label("title", getTitle())); } protected abstract String getTitle(); }
+-------------------------------------------------------------------------------------------------------+  Feature  Junit 4  Junit 5  --------------------------------------------------------------------------+--------------+-------------  Execute before all test methods of the class are executed.  @BeforeClass  @BeforeAll   Used with static method.     For example, This method could contain some initialization code    -------------------------------------------------------------------------------------------------------  Execute after all test methods in the current class.  @AfterClass  @AfterAll   Used with static method.     For example, This method could contain some cleanup code.    -------------------------------------------------------------------------------------------------------  Execute before each test method.  @Before  @BeforeEach   Used with non-static method.     For example, to reinitialize some class attributes used by the methods.    -------------------------------------------------------------------------------------------------------  Execute after each test method.  @After  @AfterEach   Used with non-static method.     For example, to roll back database modifications.    +-------------------------------------------------------------------------------------------------------+
public class SampleClass { public String initializeData(){ return "Initialize"; } public String processDate(){ return "Process"; } }
public class SampleTest { private SampleClass sampleClass; @BeforeClass public static void beforeClassFunction(){ System.out.println("Before Class"); } @Before public void beforeFunction(){ sampleClass=new SampleClass(); System.out.println("Before Function"); } @After public void afterFunction(){ System.out.println("After Function"); } @AfterClass public static void afterClassFunction(){ System.out.println("After Class"); } @Test public void initializeTest(){ Assert.assertEquals("Initailization check", "Initialize", sampleClass.initializeData() ); } @Test public void processTest(){ Assert.assertEquals("Process check", "Process", sampleClass.processDate() ); } }
Before Class Before Function After Function Before Function After Function After Class
@Before = @BeforeEach @BeforeClass = @BeforeAll @After = @AfterEach @AfterClass = @AfterAll
String s = "someString"; StringBuffer buf = new StringBuffer(s); buf.append("x"); assertEquals("someStringx", buf.toString()); Date date = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH).parse("2001-01-02"); Calendar cal = Calendar.getInstance(); cal.setTime(date); cal.add(Calendar.YEAR, 1); Date newDate = cal.getTime(); assertEquals(new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH).parse("2002-01-02"), newDate);
ZoneId z = ZoneId.of( "America/Montreal" ); ZonedDateTime zdt = instant.atZone();
ZoneOffset offset = ZoneOffset.parse( "+05:30" ); OffsetDateTime odt = instant.atOffset( offset );
Date date = new Date(); ZonedDateTime zonedDateTime = date.toInstant().atZone(ZoneId.systemDefault());
public void insertUpdate(DocumentEvent e) { String split[], docStr = null; Document textAreaDoc = (Document)e.getDocument(); try { docStr = textAreaDoc.getText(textAreaDoc.getStartPosition().getOffset(), textAreaDoc.getEndPosition().getOffset()); } catch (BadLocationException e1) { e1.printStackTrace(); } split = docStr.split("\\n"); }
String.split(System.getProperty("line.separator"));
jshell> "lorem \n ipusm \n sit".lines().forEach(System.out::println) lorem ipusm sit jshell> "lorem \n ipusm \r sit".lines().forEach(System.out::println) lorem ipusm sit jshell> "lorem \n ipusm \r\n sit".lines().forEach(System.out::println) lorem ipusm sit
List<String> lines = new BufferedReader(new StringReader(string)) .lines() .collect(Collectors.toList());
article = "Alice phoned\n bob."; article = article.replace("\\n", " NEWLINE "); String sen [] = article.split(" NEWLINE ");
import com.google.common.base.Splitter; Iterable<String> split = Splitter.onPattern("\r?\n").trimResults().omitEmptyStrings().split(docStr);
String split[], docStr = null; Document textAreaDoc = (Document)e.getDocument(); try { docStr = textAreaDoc.getText(textAreaDoc.getStartPosition().getOffset(), textAreaDoc.getEndPosition().getOffset()); } catch (BadLocationException e1) { e1.printStackTrace(); } split = docStr.split("\n");
final String[] lines = contents.replace("\r\n", "\n") .replace("\r", "\n") .split("\n", -1);
public class MyClass { public static void main(String args[]) { Stream<String> lines="foo \n bar \n baz".lines(); }}
String[] array = str.lines().toArray(String[]::new);
package in.javadomain; public class JavaSplit { public static void main(String[] args) { String input = "chennai\nvellore\ncoimbatore\nbangalore\narcot"; System.out.println("Before split:\n"); System.out.println(input); String[] inputSplitNewLine = input.split("\\n"); System.out.println("\n After split:\n"); for(int i=0; i<inputSplitNewLine.length; i++){ System.out.println(inputSplitNewLine[i]); } } }
URL: http: java.net.URLEncoder.encode(url.toString(), "ISO-8859-1");
http%3A%2F%2Fsearch.barnesandnoble.com%2Fbooksearch%2Ffirst+book.pdf
URI uri = new URI( "http", "search.barnesandnoble.com", "/booksearch/first book.pdf", null); URL url = uri.toURL();
URI uri = new URI( "http", "search.barnesandnoble.com", "/booksearch/", null); String request = uri.toASCIIString();
URI uri = new URI( "http", "www.google.com", "/ig/api", "weather=So Paulo", null); String request = uri.toASCIIString();
uri = new URI("http", null, "www.google.com", 80, "/help/me/book name+me/", "MY CRZY QUERY! +&+ :)", null);
uri = new URI("http", null, "www.google.com", 80, "/help/me/book name+me/", URLEncoder.encode("MY CRZY QUERY! +&+ :)", "UTF-8"), null);
String urlStr = "http: URL url = new URL(urlStr); URI uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef()); url = uri.toURL();
public class URLParamEncoder { public static String encode(String input) { StringBuilder resultStr = new StringBuilder(); for (char ch : input.toCharArray()) { if (isUnsafe(ch)) { resultStr.append( resultStr.append(toHex(ch / 16)); resultStr.append(toHex(ch % 16)); } else { resultStr.append(ch); } } return resultStr.toString(); } private static char toHex(int ch) { return (char) (ch < 10 ? } private static boolean isUnsafe(char ch) { if (ch > 128 || ch < 0) return true; return " %$&+,/:;=?@<> } }
public URL convertToURLEscapingIllegalCharacters(String string){ try { String decodedURL = URLDecoder.decode(string, "UTF-8"); URL url = new URL(decodedURL); URI uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef()); return uri.toURL(); } catch (Exception ex) { ex.printStackTrace(); return null; } }
public static String encodeURLComponent(final String s) { if (s == null) { return ""; } final StringBuilder sb = new StringBuilder(); try { for (int i = 0; i < s.length(); i++) { final char c = s.charAt(i); if (((c >= ((c >= (c == { sb.append(c); } else { final byte[] bytes = ("" + c).getBytes("UTF-8"); for (byte b : bytes) { sb.append( int upper = (((int) b) >> 4) & 0xf; sb.append(Integer.toHexString(upper).toUpperCase(Locale.US)); int lower = ((int) b) & 0xf; sb.append(Integer.toHexString(lower).toUpperCase(Locale.US)); } } } return sb.toString(); } catch (UnsupportedEncodingException uee) { throw new RuntimeException("UTF-8 unsupported!?", uee); } }
/** * Percent-encodes a string so it */ public static String percentEncode(String encodeMe) { if (encodeMe == null) { return ""; } String encoded = encodeMe.replace("%", "%25"); encoded = encoded.replace(" ", "%20"); encoded = encoded.replace("!", "%21"); encoded = encoded.replace(" encoded = encoded.replace("$", "%24"); encoded = encoded.replace("&", "%26"); encoded = encoded.replace(" encoded = encoded.replace("(", "%28"); encoded = encoded.replace(")", "%29"); encoded = encoded.replace("*", "%2A"); encoded = encoded.replace("+", "%2B"); encoded = encoded.replace(",", "%2C"); encoded = encoded.replace("/", "%2F"); encoded = encoded.replace(":", "%3A"); encoded = encoded.replace(";", "%3B"); encoded = encoded.replace("=", "%3D"); encoded = encoded.replace("?", "%3F"); encoded = encoded.replace("@", "%40"); encoded = encoded.replace("[", "%5B"); encoded = encoded.replace("]", "%5D"); return encoded; } /** * Percent-decodes a string, such as used in a URL Path (not a query string / form encode, which uses + for spaces, etc) */ public static String percentDecode(String encodeMe) { if (encodeMe == null) { return ""; } String decoded = encodeMe.replace("%21", "!"); decoded = decoded.replace("%20", " "); decoded = decoded.replace("%23", " decoded = decoded.replace("%24", "$"); decoded = decoded.replace("%26", "&"); decoded = decoded.replace("%27", " decoded = decoded.replace("%28", "("); decoded = decoded.replace("%29", ")"); decoded = decoded.replace("%2A", "*"); decoded = decoded.replace("%2B", "+"); decoded = decoded.replace("%2C", ","); decoded = decoded.replace("%2F", "/"); decoded = decoded.replace("%3A", ":"); decoded = decoded.replace("%3B", ";"); decoded = decoded.replace("%3D", "="); decoded = decoded.replace("%3F", "?"); decoded = decoded.replace("%40", "@"); decoded = decoded.replace("%5B", "["); decoded = decoded.replace("%5D", "]"); decoded = decoded.replace("%25", "%"); return decoded; }
@Test public void testPercentEncode_Decode() { assertEquals("", percentDecode(percentEncode(null))); assertEquals("", percentDecode(percentEncode(""))); assertEquals("!", percentDecode(percentEncode("!"))); assertEquals(" assertEquals("$", percentDecode(percentEncode("$"))); assertEquals("@", percentDecode(percentEncode("@"))); assertEquals("&", percentDecode(percentEncode("&"))); assertEquals(" assertEquals("(", percentDecode(percentEncode("("))); assertEquals(")", percentDecode(percentEncode(")"))); assertEquals("*", percentDecode(percentEncode("*"))); assertEquals("+", percentDecode(percentEncode("+"))); assertEquals(",", percentDecode(percentEncode(","))); assertEquals("/", percentDecode(percentEncode("/"))); assertEquals(":", percentDecode(percentEncode(":"))); assertEquals(";", percentDecode(percentEncode(";"))); assertEquals("=", percentDecode(percentEncode("="))); assertEquals("?", percentDecode(percentEncode("?"))); assertEquals("@", percentDecode(percentEncode("@"))); assertEquals("[", percentDecode(percentEncode("["))); assertEquals("]", percentDecode(percentEncode("]"))); assertEquals(" ", percentDecode(percentEncode(" "))); assertEquals("[]]", percentDecode(percentEncode("[]]"))); assertEquals("a=d%*", percentDecode(percentEncode("a=d%*"))); assertEquals(") (", percentDecode(percentEncode(") ("))); assertEquals("%21%20%2A%20%27%20%28%20%25%20%29%20%3B%20%3A%20%40%20%26%20%3D%20%2B%20%24%20%2C%20%2F%20%3F%20%23%20%5B%20%5D%20%25", percentEncode("! * assertEquals("! * "%21%20%2A%20%27%20%28%20%25%20%29%20%3B%20%3A%20%40%20%26%20%3D%20%2B%20%24%20%2C%20%2F%20%3F%20%23%20%5B%20%5D%20%25")); assertEquals("%23456", percentDecode(percentEncode("%23456"))); }
String url = "http: URLEncoder.encode(userInput,"UTF-8");
set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG% -Dorg.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH=true
public static URL convertToURLEscapingIllegalCharacters(String toEscape) throws MalformedURLException, URISyntaxException { URL url = new URL(toEscape); URI uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef()); return new URL(uri.toString().replace("%25", "%")); }
URI uri = new URI( "http", null, "www.google.com", 8080, "/ig/api", "weather=So Paulo", null); String request = uri.toASCIIString();
/*** * Replaces any character not specifically unreserved to an equivalent * percent sequence. * @param s * @return */ public static String encodeURIcomponent(String s) { StringBuilder o = new StringBuilder(); for (char ch : s.toCharArray()) { if (isSafe(ch)) { o.append(ch); } else { o.append( o.append(toHex(ch / 16)); o.append(toHex(ch % 16)); } } return o.toString(); } private static char toHex(int ch) { return (char)(ch < 10 ? } public static final HashSet<Character> UnreservedChars = new HashSet<Character>(Arrays.asList( public static boolean isSafe(char ch) { return UnreservedChars.contains(ch); }
new UrlBuilder("search.barnesandnoble.com", "booksearch/first book.pdf").toString()
/** * Encode URL (except :, /, ?, &, =, ... characters) * @param url to encode * @param encodingCharset url encoding charset * @return encoded URL * @throws UnsupportedEncodingException */ public static String encodeUrl (String url, String encodingCharset) throws UnsupportedEncodingException{ return new URLCodec().encode(url, encodingCharset).replace("%3A", ":").replace("%2F", "/").replace("%3F", "?").replace("%3D", "=").replace("%26", "&"); }
String urlToEncode = ""http: Utils.encodeUrl (urlToEncode , "UTF-8")
String retVal = ""; try { retVal = URLEncoder.encode(in_, "UTF8"); } catch (UnsupportedEncodingException ex) { Log.get().exception(Log.Level.Error, "urlEncode ", ex); } return retVal;
import java.io.*; import java.util.*; public class SerializationSample implements Serializable { private String aString = "The value of that string"; private int someInteger = 0; private transient List<File> unInterestingLongLongList; public static void main( String [] args ) throws IOException { SerializationSample instance = new SerializationSample(); ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(new File("o.ser"))); oos.writeObject( instance ); oos.close(); } }
Exception in thread "main" java.io.InvalidClassException: SerializeMe; local class incompatible: stream classdesc :
ObjectInputStream oos = new ObjectInputStream( new FileInputStream( new File("o.ser")) ) ; SerializationSample SS = (SearializationSample) oos.readObject();
public class Item implements Serializable{ /** * This is the Serializable class */ private static final long serialVersionUID = 475918891428093041L; private Long itemId; private String itemName; private transient Double itemCostPrice; public Item(Long itemId, String itemName, Double itemCostPrice) { super(); this.itemId = itemId; this.itemName = itemName; this.itemCostPrice = itemCostPrice; } public Long getItemId() { return itemId; } @Override public String toString() { return "Item [itemId=" + itemId + ", itemName=" + itemName + ", itemCostPrice=" + itemCostPrice + "]"; } public void setItemId(Long itemId) { this.itemId = itemId; } public String getItemName() { return itemName; } public void setItemName(String itemName) { this.itemName = itemName; } public Double getItemCostPrice() { return itemCostPrice; } public void setItemCostPrice(Double itemCostPrice) { this.itemCostPrice = itemCostPrice; } }
public class SerializationExample { public static void main(String[] args){ serialize(); deserialize(); } public static void serialize(){ Item item = new Item(1L,"Pen", 12.55); System.out.println("Before Serialization" + item); FileOutputStream fileOut; try { fileOut = new FileOutputStream("/tmp/item.ser"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(item); out.close(); fileOut.close(); System.out.println("Serialized data is saved in /tmp/item.ser"); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } public static void deserialize(){ Item item; try { FileInputStream fileIn = new FileInputStream("/tmp/item.ser"); ObjectInputStream in = new ObjectInputStream(fileIn); item = (Item) in.readObject(); System.out.println("Serialized data is read from /tmp/item.ser"); System.out.println("After Deserialization" + item); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } }
Before SerializationItem [itemId=1, itemName=Pen, itemCostPrice=12.55] Serialized data is saved in /tmp/item.ser After DeserializationItem [itemId=1, itemName=Pen, itemCostPrice=null]
long hash = ((sha[0] >>> 24) & 0xFF) | > ((sha[0] >>> 16) & 0xFF) << 8 | > ((sha[0] >>> 8) & 0xFF) << 16 | > ((sha[0] >>> 0) & 0xFF) << 24 | > ((sha[1] >>> 24) & 0xFF) << 32 | > ((sha[1] >>> 16) & 0xFF) << 40 | > ((sha[1] >>> 8) & 0xFF) << 48 | > ((sha[1] >>> 0) & 0xFF) << 56;
public class A implements Serializable{ String s; static String staticString = "I won }
public class A implements Serializable {....}; public class B extends A{...}
class ObjectOutputStream extends java.io.OutputStream implements ObjectOutput,
ObjectOutput ObjOut = new ObjectOutputStream(new FileOutputStream(f));
ObjectInputStream obj = new ObjectInputStream(new FileInputStream(f));
import java.io.*; public class SerializeDemo { public static void main(String [] args) { Employee e = new Employee(); e.name = "Reyan Ali"; e.address = "Phokka Kuan, Ambehta Peer"; e.SSN = 11122333; e.number = 101; try { FileOutputStream fileOut = new FileOutputStream("/tmp/employee.ser"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf("Serialized data is saved in /tmp/employee.ser"); }catch(IOException i) { i.printStackTrace(); } } } import java.io.*; public class DeserializeDemo { public static void main(String [] args) { Employee e = null; try { FileInputStream fileIn = new FileInputStream("/tmp/employee.ser"); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); }catch(IOException i) { i.printStackTrace(); return; }catch(ClassNotFoundException c) { System.out.println("Employee class not found"); c.printStackTrace(); return; } System.out.println("Deserialized Employee..."); System.out.println("Name: " + e.name); System.out.println("Address: " + e.address); System.out.println("SSN: " + e.SSN); System.out.println("Number: " + e.number); } }
private static final long serialVersionUID = 3487495895819393L;
+--------------+--------+-------------------------------------+ | Flag Name | Value | Interpretation | +--------------+--------+-------------------------------------+ | ACC_VOLATILE | 0x0040 | Declared volatile; cannot be cached.| +--------------+--------+-------------------------------------+ |ACC_TRANSIENT | 0x0080 | Declared transient; not written or | | | | read by a persistent object manager.| +--------------+--------+-------------------------------------+
class Employee implements Serializable { private static final long serialVersionUID = 2L; static int id; int eno; String name; transient String password; }
class Emp implements Externalizable { int eno; String name; transient String password; @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeInt(eno); out.writeUTF(name); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { this.eno = in.readInt(); this.name = in.readUTF(); } }
public class SerializationDemo { static String fileName = "D:/serializable_file.ser"; public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException { Employee emp = new Employee( ); Employee.id = 1; emp.eno = 77; emp.name = "Yash"; emp.password = "confidential"; objects_WriteRead(emp, fileName); Emp e = new Emp( ); e.eno = 77; e.name = "Yash"; e.password = "confidential"; objects_WriteRead_External(e, fileName); /*String stubHost = "127.0.0.1"; Integer anyFreePort = 7777; socketRead(anyFreePort); socketWrite(emp, stubHost, anyFreePort); } public static void objects_WriteRead( Employee obj, String serFilename ) throws IOException{ FileOutputStream fos = new FileOutputStream( new File( serFilename ) ); ObjectOutputStream objectOut = new ObjectOutputStream( fos ); objectOut.writeObject( obj ); objectOut.close(); fos.close(); System.out.println("Data Stored in to a file"); try { FileInputStream fis = new FileInputStream( new File( serFilename ) ); ObjectInputStream ois = new ObjectInputStream( fis ); Object readObject; readObject = ois.readObject(); String calssName = readObject.getClass().getName(); System.out.println("Restoring Class Name : "+ calssName); Employee emp = (Employee) readObject; System.out.format("Obj[No:%s, Name:%s, Pass:%s]", emp.eno, emp.name, emp.password); ois.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static void objects_WriteRead_External( Emp obj, String serFilename ) throws IOException { FileOutputStream fos = new FileOutputStream(new File( serFilename )); ObjectOutputStream objectOut = new ObjectOutputStream( fos ); obj.writeExternal( objectOut ); objectOut.flush(); fos.close(); System.out.println("Data Stored in to a file"); try { Emp emp = new Emp(); FileInputStream fis = new FileInputStream(new File( serFilename )); ObjectInputStream ois = new ObjectInputStream( fis ); emp.readExternal(ois); System.out.format("Obj[No:%s, Name:%s, Pass:%s]", emp.eno, emp.name, emp.password); ois.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } }
/** * Creates a stream socket and connects it to the specified port number on the named host. */ public static void socketWrite(Employee objectToSend, String stubHost, Integer anyFreePort) { try { Socket client = new Socket(stubHost, anyFreePort); ObjectOutputStream out = new ObjectOutputStream(client.getOutputStream()); out.writeObject(objectToSend); out.flush(); client.close(); } catch (IOException e) { e.printStackTrace(); } } public static void socketRead( Integer anyFreePort ) { try { ServerSocket serverSocket = new ServerSocket( anyFreePort ); System.out.println("Server serves on port and waiting for a client to communicate"); /*System.in.read(); System.in.read();*/ Socket socket = serverSocket.accept(); System.out.println("Client request to communicate on port server accepts it."); ObjectInputStream in = new ObjectInputStream(socket.getInputStream()); Employee objectReceived = (Employee) in.readObject(); System.out.println("Server Obj : "+ objectReceived.name ); socket.close(); serverSocket.close(); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } }
class NamCls implements Serializable { int NumVar; String NamVar; }
class NamCls implements Serializable { int NumVar; static String NamVar = "I won }
class NamCls implements Serializable { int NumVar; transient String NamVar; }
if(todayDate.after(historyDate) && todayDate.before(futureDate)) { }
if(!historyDate.after(todayDate) && !futureDate.before(todayDate)) { }
if(date1.after(date2)){ System.out.println("Date1 is after Date2"); } if(date1.before(date2)){ System.out.println("Date1 is before Date2"); } if(date1.equals(date2)){ System.out.println("Date1 is equal Date2"); }
if(date1.compareTo(date2)>0){ System.out.println("Date1 is after Date2"); }else if(date1.compareTo(date2)<0){ System.out.println("Date1 is before Date2"); }else{ System.out.println("Date1 is equal to Date2"); }
Calendar cal1 = Calendar.getInstance(); Calendar cal2 = Calendar.getInstance(); cal1.setTime(date1); cal2.setTime(date2); if(cal1.after(cal2)){ System.out.println("Date1 is after Date2"); } if(cal1.before(cal2)){ System.out.println("Date1 is before Date2"); } if(cal1.equals(cal2)){ System.out.println("Date1 is equal Date2"); }
LocalDate today = LocalDate.now( ZoneId.of( "America/Montreal" ) ) ; Boolean isBetween = ( ! today.isBefore( localDate1 ) ) && today.isBefore( localDate3 ) ;
LocalDateRange.of( LocalDate.of(  ) , LocalDate.of(  ) ).contains( LocalDate.now() )
ZoneId z = ZoneId.of( "America/Montreal" ); LocalDate today = LocalDate.now( z );
DateTimeFormatter f = DateTimeFormatter.ofPattern( "dd-MM-uuuu" );
LocalDate start = LocalDate.parse( "22-02-2010" , f ); LocalDate stop = LocalDate.parse( "25-12-2010" , f );
Boolean intervalContainsToday = ( ! today.isBefore( start ) ) && today.isBefore( stop ) ;
String string1 = "22-02-2010"; String string2 = "07-04-2010"; String string3 = "25-12-2010";
DateTimeFormatter formatter = DateTimeFormat.forPattern( "dd-MM-yyyy" );
LocalDate localDate1 = formatter.parseLocalDate( string1 ); LocalDate localDate2 = formatter.parseLocalDate( string2 ); LocalDate localDate3 = formatter.parseLocalDate( string3 ); boolean is1After2 = localDate1.isAfter( localDate2 ); boolean is2Before3 = localDate2.isBefore( localDate3 );
System.out.println( "Dates: " + localDate1 + " " + localDate2 + " " + localDate3 ); System.out.println( "is1After2 " + is1After2 ); System.out.println( "is2Before3 " + is2Before3 );
boolean is2Between1And3 = ( ( localDate2.isAfter( localDate1 ) ) && ( localDate2.isBefore( localDate3 ) ) );
Date today = new Date(); Date myDate = new Date(today.getYear(),today.getMonth()-1,today.getDay()); System.out.println("My Date is"+myDate); System.out.println("Today Date is"+today); if (today.compareTo(myDate)<0) System.out.println("Today Date is Lesser than my Date"); else if (today.compareTo(myDate)>0) System.out.println("Today Date is Greater than my date"); else System.out.println("Both Dates are equal");
if (date1.getTime() <= date.getTime() && date.getTime() <= date2.getTime()) { /* * date is between date1 and date2 (both inclusive) */ } /* * when date1 = 2015-01-01 and date2 = 2015-01-10 then * returns true for: * 2015-01-01 * 2015-01-01 00:00:01 * 2015-01-02 * 2015-01-10 * returns false for: * 2014-12-31 23:59:59 * 2015-01-10 00:00:01 * * if one or both dates are exclusive then change <= to < */
public static boolean compareDates(String psDate1, String psDate2) throws ParseException{ SimpleDateFormat dateFormat = new SimpleDateFormat ("dd/MM/yyyy"); Date date1 = dateFormat.parse(psDate1); Date date2 = dateFormat.parse(psDate2); if(date2.after(date1)) { return true; } else { return false; } }
Calendar cstart = Calendar.getInstance(Locale.KOREA); cstart.clear(); cstart.set(startyear, startmonth, startday); Calendar cend = Calendar.getInstance(Locale.KOREA); cend.clear(); cend.set(endyear, endmonth, endday); Calendar c = Calendar.getInstance(Locale.KOREA); if(c.after(cstart) && c.before(cend)) { }
public static String daysBetween(String day1, String day2) { String daysBetween = ""; SimpleDateFormat myFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try { Date date1 = myFormat.parse(day1); Date date2 = myFormat.parse(day2); long diff = date2.getTime() - date1.getTime(); daysBetween = ""+(TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS)); } catch (ParseException e) { e.printStackTrace(); } return daysBetween; }
itsadok@laptop ~/jdk1.6.0_02/src/ $ find . -name "*.java" | xargs grep "void finalize()" | wc -l 41
public void finalize() { ref1 = null; ref2 = null; othercrap = null; }
class MyObject { Test main; public MyObject(Test t) { main = t; } protected void finalize() { main.ref = this; System.out.println("This is finalize"); } } class Test { MyObject ref; public static void main(String[] args) { Test test = new Test(); test.ref = new MyObject(test); test.ref = null; System.gc(); if (test.ref != null) System.out.println("MyObject still alive!"); } }
@Override public void finalize() { try {saveCache();} catch (Exception e) {e.printStackTrace();} } public void saveCache() throws FileNotFoundException, IOException { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("temp/cache.tmp")); out.writeObject(cache); }
public void finalize() throws Throwable { super.finalize(); if (destructiveFinalize) { T item; for (int i = 0, l = length(); i < l; i++) { item = get(i); if (item == null) { continue; } if (item instanceof Window) { ((Window) get(i)).dispose(); } if (item instanceof CompleteObject) { ((CompleteObject) get(i)).finalize(); } set(i, null); } } }
try (BufferedReader br = new BufferedReader(new FileReader(path))) { } catch (Exception e) { } finally { }
File folder = new File("your/path"); File[] listOfFiles = folder.listFiles(); for (int i = 0; i < listOfFiles.length; i++) { if (listOfFiles[i].isFile()) { System.out.println("File " + listOfFiles[i].getName()); } else if (listOfFiles[i].isDirectory()) { System.out.println("Directory " + listOfFiles[i].getName()); } }
List<String> results = new ArrayList<String>(); File[] files = new File("/path/to/the/directory").listFiles(); for (File file : files) { if (file.isFile()) { results.add(file.getName()); } }
public void testNullify() { Collection<Integer> c = new ArrayList<Integer>(); nullify(c); assertNotNull(c); final Collection<Integer> c1 = c; assertTrue(c1.equals(c)); change(c); assertTrue(c1.equals(c)); } private void change(Collection<Integer> c) { c = new ArrayList<Integer>(); } public void nullify(Collection<?> t) { t = null; }
void doSomething( String arg ) { String x = arg; x = "elephant"; arg = "giraffe"; }
void doSomething( String arg ) { final String x = arg; x = "elephant"; arg = "giraffe"; }
void doSomething( final String arg ) { String x = arg; x = "elephant"; arg = "giraffe"; }
public class MyClass { private int x; } void doSomething( final MyClass arg ) { arg = new MyClass(); arg.setX(20); }
public Iterator<Integer> createIntegerIterator(final int from, final int to) { return new Iterator<Integer>(){ int index = from; public Integer next() { return index++; } public boolean hasNext() { return index <= to; } }; }
private String getString(String A, int i, String B, String C) { if (i > 0) A += B; if (i > 100) A += C; return A; }
public static void main(String[] args){ MyParam myParam = thisIsWhy(new MyObj()); myParam.setArgNewName(); System.out.println(myParam.showObjName()); } public static MyParam thisIsWhy(final MyObj obj){ MyParam myParam = new MyParam() { @Override public void setArgNewName() { obj.name = "afterSet"; } @Override public String showObjName(){ return obj.name; } }; return myParam; } public static class MyObj{ String name = "beforeSet"; public MyObj() { } } public abstract static class MyParam{ public abstract void setArgNewName(); public abstract String showObjName(); }
SELECT Field1, Field2 FROM mytable WHERE Field1 LIKE
SELECT Field1, Field2 FROM mytable WHERE Field1 LIKE \
str = str.replaceAll("(?:[^%]|\\A)%(?:[^%]|\\z)", "%%");
Pattern p = Pattern.compile("(?:[^%]|^)(?:(%%)+|)(%)(?:[^%])"); Matcher m1 = p.matcher(log); StringBuffer buf = new StringBuffer(); while (m1.find()) m1.appendReplacement(buf, log.substring(m1.start(), m1.start(2)) + "%%" + log.substring(m1.end(2), m1.end())); String escapedString = m1.appendTail(buf).toString();
void delete(File f) throws IOException { if (f.isDirectory()) { for (File c : f.listFiles()) delete(c); } if (!f.delete()) throw new FileNotFoundException("Failed to delete file: " + f); }
Path directory = Paths.get("/tmp"); Files.walkFileTree(directory, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException { Files.delete(dir); return FileVisitResult.CONTINUE; } });
import java.nio.file.*; public static void removeRecursive(Path path) throws IOException { Files.walkFileTree(path, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException { if (exc == null) { Files.delete(dir); return FileVisitResult.CONTINUE; } else { throw exc; } } }); }
public static void removeDirectory(Path directory) throws IOException { if (Files.exists(directory)) { try { if (SystemUtils.IS_OS_WINDOWS) Processes.execute("%ComSpec%", "/C", "RD /S /Q \"" + directory + else if (SystemUtils.IS_OS_UNIX) Processes.execute("/bin/rm", "-rf", directory.toString()); } catch (ProcessExecutionException | InterruptedException e) { } if (Files.exists(directory)) removeRecursive(directory); } }
Files.walk(Paths.get("c:/dir_to_delete/")) .map(Path::toFile) .sorted((o1, o2) -> -o1.compareTo(o2)) .forEach(File::delete);
Files.walk(Paths.get("c:/dir_to_delete/")) .filter(Files::isRegularFile) .map(Path::toFile) .forEach(File::delete);
public class FileUtils { /** * By default File * We need something a little more brutual - this does the equivalent of "rm -r" * @param path Root File Path * @return true iff the file and all sub files/directories have been removed * @throws FileNotFoundException */ public static boolean deleteRecursive(File path) throws FileNotFoundException{ if (!path.exists()) throw new FileNotFoundException(path.getAbsolutePath()); boolean ret = true; if (path.isDirectory()){ for (File f : path.listFiles()){ ret = ret && deleteRecursive(f); } } return ret && path.delete(); } }
File dir = new File("/path/to/dir"); File[] currList; Stack<File> stack = new Stack<File>(); stack.push(dir); while (! stack.isEmpty()) { if (stack.lastElement().isDirectory()) { currList = stack.lastElement().listFiles(); if (currList.length > 0) { for (File curr: currList) { stack.push(curr); } } else { stack.pop().delete(); } } else { stack.pop().delete(); } }
import org.springframework.util.FileSystemUtils; boolean success = FileSystemUtils.deleteRecursively(new File("directory"));
for(Path p : Files.walk(directoryToDelete). sorted((a, b) -> b.compareTo(a)). toArray(Path[]::new)) { Files.delete(p); }
Files.walk(directoryToDelete). sorted((a, b) -> b.compareTo(a)). forEach(p -> { try { Files.delete(p); } catch(IOException e) { } });
public void deleteRecursive(File path){ File[] c = path.listFiles(); System.out.println("Cleaning out folder:" + path.toString()); for (File file : c){ if (file.isDirectory()){ System.out.println("Deleting file:" + file.toString()); deleteRecursive(file); file.delete(); } else { file.delete(); } } path.delete(); }
static public void deleteDirectory(File path) { if (path == null) return; if (path.exists()) { for(File f : path.listFiles()) { if(f.isDirectory()) { deleteDirectory(f); f.delete(); } else { f.delete(); } } path.delete(); } }
echo test > testfile mkdir dirtodelete ln -s badlink dirtodelete/badlinktodelete
$ ls testfile dirtodelete testfile dirtodelete: linktodelete
Exception in thread "main" java.io.FileNotFoundException: File does not exist: /tmp/dirtodelete/linktodelete
mkdir testdir echo test > testdir/testfile mkdir dirtodelete ln -s ../testdir dirtodelete/dirlinktodelete
$ ls dirtodelete testdir dirtodelete: dirlinktodelete testdir: testfile
$ ls dirtodelete testdir ls: cannot access dirtodelete: No such file or directory testdir:
private void deleteRecursive(File f) throws Exception { try { if (f.isDirectory()) { for (File c : f.listFiles()) { deleteRecursive(c); } } if (!f.delete()) { throw new Exception("Delete command returned false for file: " + f); } } catch (Exception e) { throw new Exception("Failed to delete the folder: " + f, e); } }
public class FileHelper { public static boolean delete(File fileOrFolder) { boolean result = true; if(fileOrFolder.isDirectory()) { for (File file : fileOrFolder.listFiles()) { result = result && delete(file); } } result = result && fileOrFolder.delete(); return result; } }
public class FileHelperTest { @Before public void setup() throws IOException { new File("FOLDER_TO_DELETE/SUBFOLDER").mkdirs(); new File("FOLDER_TO_DELETE/SUBFOLDER_TWO").mkdirs(); new File("FOLDER_TO_DELETE/SUBFOLDER_TWO/TEST_FILE.txt").createNewFile(); } @Test public void deleteFolderWithFiles() { File folderToDelete = new File("FOLDER_TO_DELETE"); Assert.assertTrue(FileHelper.delete(folderToDelete)); Assert.assertFalse(new File("FOLDER_TO_DELETE").exists()); } }
import java.io.File; import java.io.FileNotFoundException; import java.io.IOException; public class DeleteFiles { /** * @param intitial arguments take in a source to read from and a * destination to read to */ public static void main(String[] args) throws FileNotFoundException,IOException { File src = new File(args[0]); if (!src.exists() ) { System.out.println("FAILURE!"); }else{ File[] a = src.listFiles(); for (int i = 0; i < a.length; i++) { fileDelete(a[i]); } src.delete(); System.out.println("Success!"); } } /** * @param srcFile Source file to examine * @throws FileNotFoundException if File not found * @throws IOException if File not found */ private static void fileDelete(File srcFile) throws FileNotFoundException, IOException { if (srcFile.isDirectory()) { File[] b = srcFile.listFiles(); for (int i = 0; i < b.length; i++) { fileDelete(b[i]); } srcFile.delete(); } else { srcFile.delete(); } } }
public static void deleteRecursive(File path){ path.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { if (pathname.isDirectory()) { pathname.listFiles(this); pathname.delete(); } else { pathname.delete(); } return false; } }); path.delete(); }
boolean deleteDirectory(File directoryToBeDeleted) { File[] allContents = directoryToBeDeleted.listFiles(); if (allContents != null) { for (File file : allContents) { deleteDirectory(file); } } return directoryToBeDeleted.delete(); }
public class MyFile extends File { ... <- copy constructor public boolean delete() { if (f.isDirectory()) { for (File c : f.listFiles()) { return new MyFile(c).delete(); } } else { return f.delete(); } } }
public static void clearFolders(String[] args) { for(String st : args){ File folder = new File(st); if (folder.isDirectory()) { File[] files = folder.listFiles(); if(files!=null) { for(File f: files) { if (f.isDirectory()){ clearFolders(new String[]{f.getAbsolutePath()}); f.delete(); } else { f.delete(); } } } } } }
package ch.ethz.idsc.queuey.util; import java.io.File; import java.io.IOException; /** recursive file/directory deletion * * safety from erroneous use is enhanced by three criteria * 1) checking the depth of the directory tree T to be deleted * against a permitted upper bound "max_depth" * 2) checking the number of files to be deleted * against a permitted upper bound "max_count" * 3) if deletion of a file or directory fails, the process aborts */ public final class FileDelete { /** Example: The command * FileDelete.of(new File("/user/name/myapp/recordings/log20171024"), 2, 1000); * deletes given directory with sub directories of depth of at most 2, * and max number of total files less than 1000. No files are deleted * if directory tree exceeds 2, or total of files exceed 1000. * * abort criteria are described at top of class * * @param file * @param max_depth * @param max_count * @return * @throws Exception if criteria are not met */ public static FileDelete of(File file, int max_depth, int max_count) throws IOException { return new FileDelete(file, max_depth, max_count); } private final File root; private final int max_depth; private int removed = 0; /** @param root file or a directory. If root is a file, the file will be deleted. * If root is a directory, the directory tree will be deleted. * @param max_depth of directory visitor * @param max_count of files to delete * @throws IOException */ private FileDelete(final File root, final int max_depth, final int max_count) throws IOException { this.root = root; this.max_depth = max_depth; final int count = visitRecursively(root, 0, false); if (count <= max_count) visitRecursively(root, 0, true); else throw new IOException("more files to be deleted than allowed (" + max_count + "<=" + count + ") in " + root); } private int visitRecursively(final File file, final int depth, final boolean delete) throws IOException { if (max_depth < depth) throw new IOException("directory tree exceeds permitted depth"); int count = 0; if (file.isDirectory()) for (File entry : file.listFiles()) count += visitRecursively(entry, depth + 1, delete); ++count; if (delete) { final boolean deleted = file.delete(); if (!deleted) throw new IOException("cannot delete " + file.getAbsolutePath()); ++removed; } return count; } public int deletedCount() { return removed; } public void printNotification() { int count = deletedCount(); if (0 < count) System.out.println("deleted " + count + " file(s) in " + root); } }
import java.io.File; import java.io.IOException; public class DeleteDirectory { private static final String folder = "D:/project/java"; public static void main(String[] args) throws IOException { File fl = new File(folder); if(!fl.exists()) { System.out.println("Sorry!! directory doesn } else { DeleteDirectory dd = new DeleteDirectory(); dd.deleteDirectory(fl); } } public void deleteDirectory(File file) throws IOException { if(file.isDirectory()) { if(file.list().length == 0) { deleteEmptyDirectory(file); } else { File fe[] = file.listFiles(); for(File deleteFile : fe) { deleteDirectory(deleteFile); } if(file.list().length == 0) { deleteEmptyDirectory(file); } } } else { file.delete(); System.out.println("File deleted : " + file.getAbsolutePath()); } } private void deleteEmptyDirectory(File fi) { fi.delete(); System.out.println("Directory deleted : " + fi.getAbsolutePath()); } }
private static ApplicationContext context = new ClassPathXmlApplicationContext("test-client.xml"); context.getBean(name);
<!-- Scans for annotated @Controllers in the classpath --> <context:component-scan base-package="org.test.web" use-default-filters="false"> <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/> </context:component-scan>
<context:component-scan base-package="org.test"> <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/> </context:component-scan>
<servlet> <servlet-name>DBController</servlet-name> <servlet-class>com.test.controller.DBController</servlet-class> <init-param> <param-name>username</param-name> <param-value>John</param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>DBController</servlet-name> <url-pattern>/DBController</url-pattern> </servlet-mapping>
<context-param> <param-name>email</param-name> <param-value>admin@example.com</param-value> </context-param>
<?xml version="1.0" encoding="UTF-8"?> <web-app xmlns:xsi="http: xmlns="http: xmlns:web="http: xsi:schemaLocation="http: http: id="WebApp_ID" version="3.0"> <display-name>Spring MVC App</display-name> <servlet> <servlet-name>SpringController</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring-servlet.xml</param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>SpringController</servlet-name> <url-pattern>*.htm</url-pattern> </servlet-mapping> </web-app>
<context-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/applicationcontext.xml</param-value> </context-param> <listener> <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> <servlet> <servlet-name>SpringController</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/spring-servlet.xml</param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>SpringController</servlet-name> <url-pattern>*.htm</url-pattern> </servlet-mapping>
ZoneId z = ZoneId.of( "Pacific/Auckland" ); ZonedDateTime zdt = ZonedDateTime.now( z );
OffsetDateTime odt = instant.atOffset( ZoneOffset.UTC );
ZoneId z = ZoneId.of( "America/Montreal" ); ZonedDateTime nowMontreal = instant.atZone( z );
String output = DateTimeFormatter .ofLocalizedDate( FormatStyle.FULL ) .withLocale( Locale.CANADA_FRENCH ) .format ( nowMontreal );
import org.joda.time.DateTime; DateTime now = DateTime.now();
LocalDateTime timePoint = LocalDateTime.now(); System.out.println(timePoint);
public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
class classB { } interface interfaceC { } public class MyClass<T extends classB & interfaceC> { Class<T> variable; }
import java.util.List; interface A{} interface B{} public class Test<E extends B & A, T extends List<E>> { T t; }
public void run() { try { while (!interrupted()) { } } catch (InterruptedException consumed) } } public void cancel() { interrupt(); }
Class Outer { public static volatile flag = true; Outer() { new Test().start(); } class Test extends Thread { public void run() { while (Outer.flag) { } } } }
Thread f = <A thread to be stopped> Method m = Thread.class.getDeclaredMethod( "stop0" , new Class[]{Object.class} ); m.setAccessible( true ); m.invoke( f , new ThreadDeath() );
public class CancelSupport { public static class CommandExecutor implements Runnable { private BlockingQueue<String> queue; public static final String POISON_PILL = stopnow; public CommandExecutor(BlockingQueue<String> queue) { this.queue=queue; } @Override public void run() { boolean stop=false; while(!stop) { try { String command=queue.take(); if(POISON_PILL.equals(command)) { stop=true; } else { System.out.println(command); } } catch (InterruptedException e) { stop=true; } } System.out.println(Stopping execution); } }
BlockingQueue<String> queue=new LinkedBlockingQueue<String>(); Thread t=new Thread(new CommandExecutor(queue)); queue.put(hello); queue.put(world); t.start(); Thread.sleep(1000); queue.put(stopnow);
boolean shouldCheckUpdates = true; private void startupCheckForUpdatesEveryFewSeconds() { Thread t = new Thread(new CheckUpdates()); t.start(); } private class CheckUpdates implements Runnable{ public void run() { while (shouldCheckUpdates){ System.out.println("Do your thing here"); } } } public void stop(){ shouldCheckUpdates = false; }
Iterator<T> source = ...; List<T> target = new ArrayList<>(); source.forEachRemaining(target::add);
public static <E> Collection<E> makeCollection(Iterable<E> iter) { Collection<E> list = new ArrayList<E>(); for (E item : iter) { list.add(item); } return list; }
public static <T> List<T> toList(final Iterable<T> iterable) { return StreamSupport.stream(iterable.spliterator(), false) .collect(Collectors.toList()); }
@SuppressWarnings("unchecked") Collection<Type> list = IteratorUtils.toList(iterable.iterator());
List<T> targetCollection = new ArrayList<T>(); CollectionUtils.addAll(targetCollection, iterable.iterator())
public static <T> void addAll(Collection<T> collection, Iterator<T> iterator) { while (iterator.hasNext()) { collection.add(iterator.next()); } }
Iterator it = sthIterable.iterator(); while (it.hasNext()){ piece = it.next(); .......... }
public static <T> Collection<T> toCollection(Iterable<T> iterable) { if (iterable instanceof Collection) { return (Collection<T>) iterable; } else { return Lists.newArrayList(iterable); } }
@Test public void testToCollectionAlreadyCollection() { ArrayList<String> list = Lists.newArrayList(FIRST, MIDDLE, LAST); assertSame("no need to change, just cast", list, toCollection(list)); } @Test public void testIterableToCollection() { final ArrayList<String> expected = Lists.newArrayList(FIRST, null, MIDDLE, LAST); Collection<String> collection = toCollection(new Iterable<String>() { @Override public Iterator<String> iterator() { return expected.iterator(); } }); assertNotSame("a new list must have been created", expected, collection); assertTrue(expected + " != " + collection, CollectionUtils.isEqualCollection(expected, collection)); }
public static <T> Collection<T> iterableToCollection(Iterable<T> iterable) { Collection<T> collection = new ArrayList<>(); iterable.forEach(collection::add); return collection; }
Observable.from(iterable).toList().toBlocking().single();
import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.LinkedList; import java.util.stream.Collectors; import java.util.stream.IntStream; public class IterableToCollection { public interface CollectionFactory <T, U extends Collection<T>> { U createCollection(); } public static <T, U extends Collection<T>> U collect(Iterable<T> iterable, CollectionFactory<T, U> factory) { U collection = factory.createCollection(); iterable.forEach(collection::add); return collection; } public static void main(String[] args) { Iterable<Integer> iterable = IntStream.range(0, 5).boxed().collect(Collectors.toList()); ArrayList<Integer> arrayList = collect(iterable, ArrayList::new); HashSet<Integer> hashSet = collect(iterable, HashSet::new); LinkedList<Integer> linkedList = collect(iterable, LinkedList::new); } }
if(!(str instanceof String)) { str = str.toString(); }
public class ObjectUtils { private final Object obj; private ObjectUtils(Object obj) { this.obj = obj; } public static ObjectUtils thisObj(Object obj){ return new ObjectUtils(obj); } public boolean isNotA(Class<?> clazz){ return !clazz.isInstance(obj); } }
import static notinstanceof.ObjectUtils.*; public class Main { public static void main(String[] args) { String a = ""; if (thisObj(a).isNotA(String.class)) { System.out.println("It is not a String"); } if (thisObj(a).isNotA(Integer.class)) { System.out.println("It is not an Integer"); } } }
public static boolean isString(Object thing) { return thing instanceof String; } public void someMethod(Object thing){ if (!isString(thing)) { return null; } log.debug("my thing is valid"); }
Predicate<Object> isInstanceOfTheClass = objectToTest -> objectToTest instanceof TheClass; Predicate<Object> isNotInstanceOfTheClass = isInstanceOfTheClass.negate(); if (notInstanceOfTheClass.test(myObject)) { }
try { Thread.sleep(1000); } catch(InterruptedException ex) { Thread.currentThread().interrupt(); }
try { TimeUnit.NANOSECONDS.sleep(100); TimeUnit.MICROSECONDS.sleep(100); TimeUnit.MILLISECONDS.sleep(100); TimeUnit.SECONDS.sleep(100); TimeUnit.MINUTES.sleep(100); TimeUnit.HOURS.sleep(100); TimeUnit.DAYS.sleep(100); } catch (InterruptedException e) { }
try { Thread.sleep(1000); } catch (InterruptedException ie) { }
try { Thread.sleep(100); } catch ( java.lang.InterruptedException ie) { System.out.println(ie); }
final Handler handler = new Handler(); handler.postDelayed(new Runnable() { @Override public void run() { Log.i(TAG, "I } }, 2000);
try{ Thread.sleep(100); }catch(Exception e) { System.out.println("Exception caught"); }
public void pause1(long sleeptime) { try { Thread.sleep(sleeptime); } catch (InterruptedException ex) { } } public void pause2(long sleeptime) { Object obj = new Object(); if (sleeptime > 0) { synchronized (obj) { try { obj.wait(sleeptime); } catch (InterruptedException ex) { } } } } public void pause3(long sleeptime) { expectedtime = System.currentTimeMillis() + sleeptime; while (System.currentTimeMillis() < expectedtime) { } }
public static void main(String[] args) throws InterruptedException { short z=1000; Thread.sleep(z); }
class TypeCasting { public static void main(String[] args) throws InterruptedException { short f = 1; int a = 123687889; short b = 2; long c = 4567; long d=45; short z=1000; System.out.println("Value of a,b and c are\n" + a + "\n" + b + "\n" + c + "respectively"); c = a; b = (short) c; System.out.println("Typecasting..........."); Thread.sleep(z); System.out.println("Value of B after Typecasting" + b); System.out.println("Value of A is" + a); } }
public static void main(String[] args) { long original = System.currentTimeMillis(); while (true) { if (System.currentTimeMillis - original >= 5000) { break; } } }
public static void main(String[] args) { final ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); executorService.scheduleAtFixedRate(App::myTask, 0, 1, TimeUnit.SECONDS); } private static void myTask() { System.out.println("Running"); }
import java.util.concurrent.TimeUnit; public class DelaySample { public static void main(String[] args) { DelayUtil d = new DelayUtil(); System.out.println("started:"+ new Date()); d.delay(500); System.out.println("half second after:"+ new Date()); d.delay(1, TimeUnit.MINUTES); System.out.println("1 minute after:"+ new Date()); } }
import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class DelayUtil { /** * Delays the current thread execution. * The thread loses ownership of any monitors. * Quits immediately if the thread is interrupted * * @param durationInMillis the time duration in milliseconds */ public void delay(final long durationInMillis) { delay(durationInMillis, TimeUnit.MILLISECONDS); } /** * @param duration the time duration in the given {@code sourceUnit} * @param unit */ public void delay(final long duration, final TimeUnit unit) { long currentTime = System.currentTimeMillis(); long deadline = currentTime+unit.toMillis(duration); ReentrantLock lock = new ReentrantLock(); Condition waitCondition = lock.newCondition(); while ((deadline-currentTime)>0) { try { lock.lockInterruptibly(); waitCondition.await(deadline-currentTime, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return; } finally { lock.unlock(); } currentTime = System.currentTimeMillis(); } } }
public static void pause(int seconds){ Date start = new Date(); Date end = new Date(); while(end.getTime() - start.getTime() < seconds * 1000){ end = new Date(); } }
List<List<Object>> list = ... List<Object> flat = list.stream() .flatMap(List::stream) .collect(Collectors.toList());
List<List<Object>> listOfList = ... List<Object> collect = listOfList.stream() .collect(ArrayList::new, List::addAll, List::addAll);
MutableList<List<Object>> list = Lists.mutable.empty(); MutableList<Object> flat = list.flatCollect(each -> each);
List<List<Object>> list = new ArrayList<>(); List<Object> flat = ListAdapter.adapt(list).flatCollect(each -> each);
List<Object> result = new ArrayList<>(); listOfLists.forEach(result::addAll);
listStream.reduce(new ArrayList<>(), (l1, l2) -> { l1.addAll(l2); return l1; });
private <T> List<T> mergeOne(Stream<List<T>> listStream) { return listStream.flatMap(List::stream).collect(toList()); } private <T> List<T> mergeTwo(Stream<List<T>> listStream) { List<T> result = new ArrayList<>(); listStream.forEach(result::addAll); return result; } private <T> List<T> mergeThree(Stream<List<T>> listStream) { return listStream.reduce(new ArrayList<>(), (l1, l2) -> { l1.addAll(l2); return l1; }); } private <T> List<T> mergeFour(Stream<List<T>> listStream) { return listStream.reduce((l1, l2) -> { List<T> l = new ArrayList<>(l1); l.addAll(l2); return l; }).orElse(new ArrayList<>()); } private <T> List<T> mergeFive(Stream<List<T>> listStream) { return listStream.collect(ArrayList::new, List::addAll, List::addAll); }
Class A{ List<Documents> documentList } Class Documents{ List<Excel> excels List<Word> words List<PowerPoint> ppt }
List<Document> documentList = new A().getDocumentList(); Optional<Excel> excelOptional = documentList.stream() .map(doc -> doc.getExcel()) .flatMap(List::stream).findFirst(); if(excelOptional.isPresent()){ Excel exl = optionalExcel.get(); }
Run As - Run Configuration - Arguments - Vm Arguments,
JAVA_OPTS="-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1536m -Xmx1536m -XX:NewSize=256m -XX:MaxNewSize=256m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:+DisableExplicitGC"
long minRunningMemory = (1024*1024); Runtime runtime = Runtime.getRuntime(); if(runtime.freeMemory()<minRunningMemory) System.gc();
-Xms<size> set initial Java heap size -Xmx<size> set maximum Java heap size -Xss<size> set java thread stack size -XX:ParallelGCThreads=8 -XX:+CMSClassUnloadingEnabled -XX:InitiatingHeapOccupancyPercent=70 -XX:+UnlockDiagnosticVMOptions -XX:+UseConcMarkSweepGC -Xms512m -Xmx8192m -XX:MaxPermSize=256m (in java 8 optional)
nano /opt/tomcat/bin/setenv.sh export CATALINA_OPTS="$CATALINA_OPTS -XX:ParallelGCThreads=8" export CATALINA_OPTS="$CATALINA_OPTS -XX:+CMSClassUnloadingEnabled" export CATALINA_OPTS="$CATALINA_OPTS -XX:InitiatingHeapOccupancyPercent=70" export CATALINA_OPTS="$CATALINA_OPTS -XX:+UnlockDiagnosticVMOptions" export CATALINA_OPTS="$CATALINA_OPTS -XX:+UseConcMarkSweepGC" export CATALINA_OPTS="$CATALINA_OPTS -Xms512m" export CATALINA_OPTS="$CATALINA_OPTS -Xmx8192m" export CATALINA_OPTS="$CATALINA_OPTS -XX:MaxMetaspaceSize=256M"
import java.util.Comparator; import java.util.PriorityQueue; public class Test { public static void main(String[] args) { Comparator<String> comparator = new StringLengthComparator(); PriorityQueue<String> queue = new PriorityQueue<String>(10, comparator); queue.add("short"); queue.add("very long indeed"); queue.add("medium"); while (queue.size() != 0) { System.out.println(queue.remove()); } } } import java.util.Comparator; public class StringLengthComparator implements Comparator<String> { @Override public int compare(String x, String y) { if (x.length() < y.length()) { return -1; } if (x.length() > y.length()) { return 1; } return 0; } }
PriorityQueue<String> pq= new PriorityQueue<String>(5,(a,b) -> a.length() - b.length());
PriorityQueue<String> pq= new PriorityQueue<String>(5, Comparator.comparing(String::length));
public static void main(String[] args) { PriorityQueue<String> pq= new PriorityQueue<String>(5, (a,b) -> a.length() - b.length()); pq.add("Apple"); pq.add("PineApple"); pq.add("Custard Apple"); while (pq.size() != 0) { System.out.println(pq.remove()); } }
PriorityQueue(int initialCapacity, Comparator<? super E> comparator)
import java.util.*; import java.util.Collections; import java.util.Comparator; class Checker implements Comparator<String> { public int compare(String str1, String str2) { if (str1.length() < str2.length()) return -1; else return 1; } } class Main { public static void main(String args[]) { PriorityQueue<String> queue=new PriorityQueue<String>(5, new Checker()); queue.add("india"); queue.add("bangladesh"); queue.add("pakistan"); while (queue.size() != 0) { System.out.printf("%s\n",queue.remove()); } } }
PriorityQueue<String> pq3 = new PriorityQueue<String>();
String[] sa = {"a", "A"}; for(String s : sa) pq3.offer(s);
import java.lang.Comparable; import java.util.PriorityQueue; class Test { public static void main(String[] args) { PriorityQueue<MyClass> queue = new PriorityQueue<MyClass>(); queue.add(new MyClass(2, "short")); queue.add(new MyClass(2, "very long indeed")); queue.add(new MyClass(1, "medium")); queue.add(new MyClass(1, "very long indeed")); queue.add(new MyClass(2, "medium")); queue.add(new MyClass(1, "short")); while (queue.size() != 0) System.out.println(queue.remove()); } }
class MyClass implements Comparable<MyClass> { int sortFirst; String sortByLength; public MyClass(int sortFirst, String sortByLength) { this.sortFirst = sortFirst; this.sortByLength = sortByLength; } @Override public int compareTo(MyClass other) { if (sortFirst != other.sortFirst) return Integer.compare(sortFirst, other.sortFirst); else return Integer.compare(sortByLength.length(), other.sortByLength.length()); } public String toString() { return sortFirst + ", " + sortByLength; } }
PriorityQueue<String> queue1 = new PriorityQueue<>(); queue1.offer("Oklahoma"); queue1.offer("Indiana"); queue1.offer("Georgia"); queue1.offer("Texas"); System.out.println("Priority queue using Comparable:"); while (queue1.size() > 0) { System.out.print(queue1.remove() + " "); } PriorityQueue<String> queue2 = new PriorityQueue(4, Collections.reverseOrder()); queue2.offer("Oklahoma"); queue2.offer("Indiana"); queue2.offer("Georgia"); queue2.offer("Texas"); System.out.println("\nPriority queue using Comparator:"); while (queue2.size() > 0) { System.out.print(queue2.remove() + " "); }
Priority queue using Comparable: Georgia Indiana Oklahoma Texas Priority queue using Comparator: Texas Oklahoma Indiana Georgia
import java.util.Comparator; public class StringLengthComparator implements Comparator<String> { @Override public int compare(String x, String y) { } }
import java.util.Comparator; import java.util.PriorityQueue; import java.util.Queue; import java.util.Random; public class PQExample { public static void main(String[] args) { Queue<Customer> cpq = new PriorityQueue<>(7, idComp); addToQueue(cpq); pollFromQueue(cpq); } public static Comparator<Customer> idComp = new Comparator<Customer>(){ @Override public int compare(Customer o1, Customer o2) { return (int) (o1.getId() - o2.getId()); } }; private static void addToQueue(Queue<Customer> cq){ Random rand = new Random(); for(int i=0;i<7;i++){ int id = rand.nextInt(100); cq.add(new Customer(id, "KV"+id)); } } private static void pollFromQueue(Queue<Customer> cq){ while(true){ Customer c = cq.poll(); if(c == null) break; System.out.println("Customer Polled : "+c.getId() + " "+ c.getName()); } } }
int initialCapacity = 10; PriorityQueue<T> pq = new PriorityQueue<>(initialCapacity, (e1, e2) -> { return e1.compareTo(e2); });
int initialCapacity = 10; PriorityQueue<T> pq = new PriorityQueue<>(initialCapacity, new Comparator<T> () { @Override public int compare(T e1, T e2) { return e1.compareTo(e2); } });
JSONObject jsonObj = new JSONObject("{\"phonetype\":\"N95\",\"cat\":\"WP\"}");
JSONParser parser = new JSONParser(); JSONObject json = (JSONObject) parser.parse(stringToParse);
class BagOfPrimitives { private int value1 = 1; private String value2 = "abc"; private transient int value3 = 3; BagOfPrimitives() { } }
BagOfPrimitives obj = new BagOfPrimitives(); Gson gson = new Gson(); String json = gson.toJson(obj); ==> json is {"value1":1,"value2":"abc"}
BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class); ==> obj2 is just like obj
import com.google.gson.Gson; public class TestObjectToJson { private int data1 = 100; private String data2 = "hello"; public static void main(String[] args) { TestObjectToJson obj = new TestObjectToJson(); Gson gson = new Gson(); String json = gson.toJson(obj); System.out.println(json); } }
import javax.json.*; ... String TEXT; JsonObject body = Json.createReader(new StringReader(TEXT)).readObject()
class Phone { public String phonetype; public String cat; } ... String jsonString = "{\"phonetype\":\"N95\",\"cat\":\"WP\"}"; Gson gson = new Gson(); Phone fooFromJson = gson.fromJson(jsonString, Phone.class); ...
JSONObject jsonObject = new JSONObject("{\"phonetype\":\"N95\",\"cat\":\"WP\"}"); System.out.println(jsonObject.getString("phonetype"));
JSONObject jsonObj = new JSONObject("your string");
JSONObject jsonObj = null; try { jsonObj = new JSONObject("{\"phonetype\":\"N95\",\"cat\":\"WP\"}"); } catch (JSONException e) { e.printStackTrace(); }
String myJsonString; JSONObject json = JSONObject.fromObject(myJsonString);
JSONObject json = JSONSerializer.toJSON(myJsonString);
String Data=response.getEntity().getText().toString(); JSONObject json = (JSONObject) new JSONParser().parse(Data); String x=(String) json.get("phonetype"); System.out.println("Check Data"+x); String y=(String) json.get("cat"); System.out.println("Check Data"+y);
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; /** * Simple code exmpl */ ObjectMapper mapper = new ObjectMapper(); JsonNode node = mapper.readTree(jsonString); String phoneType = node.get("phonetype").asText(); String cat = node.get("cat").asText();
ObjectMapper mapper = new ObjectMapper(); mapper.configure(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);
"java.lang.RuntimeException: Unable to invoke no-args constructor for interface XXX. Register an InstanceCreator with Gson for this type may fix this problem."
{ "HTTPStatus": "OK", "class": "com.XXX.YYY.HTTPViewResponse", "code": null, "outputContext": { "class": "com.XXX.YYY.ZZZ.OutputSuccessContext", "eligible": true } }
public class Utility { public static Map<String, Object> jsonToMap(Object json) throws JSONException { if(json instanceof JSONObject) return _jsonToMap_((JSONObject)json) ; else if (json instanceof String) { JSONObject jsonObject = new JSONObject((String)json) ; return _jsonToMap_(jsonObject) ; } return null ; } private static Map<String, Object> _jsonToMap_(JSONObject json) throws JSONException { Map<String, Object> retMap = new HashMap<String, Object>(); if(json != JSONObject.NULL) { retMap = toMap(json); } return retMap; } private static Map<String, Object> toMap(JSONObject object) throws JSONException { Map<String, Object> map = new HashMap<String, Object>(); Iterator<String> keysItr = object.keys(); while(keysItr.hasNext()) { String key = keysItr.next(); Object value = object.get(key); if(value instanceof JSONArray) { value = toList((JSONArray) value); } else if(value instanceof JSONObject) { value = toMap((JSONObject) value); } map.put(key, value); } return map; } public static List<Object> toList(JSONArray array) throws JSONException { List<Object> list = new ArrayList<Object>(); for(int i = 0; i < array.length(); i++) { Object value = array.get(i); if(value instanceof JSONArray) { value = toList((JSONArray) value); } else if(value instanceof JSONObject) { value = toMap((JSONObject) value); } list.add(value); } return list; } }
HashMap<String, Object> hashMap = new HashMap<>(Utility.jsonToMap(
JSONObject obj = new JSONObject(); obj.put("phonetype", "N95"); obj.put("cat", "WP");
synchronized(o) { while (! IsConditionTrue()) { o.wait(); } DoSomethingThatOnlyMakesSenseWhenConditionIsTrue_and_MaybeMakeConditionFalseAgain(); }
public synchronized void put(Object o) { while (buf.size()==MAX_SIZE) { wait(); } buf.add(o); notify(); } public synchronized Object get() { while (buf.size()==0) { wait(); } Object o = buf.remove(0); notify(); return o; }
public class ProducerConsumerExample { private static boolean Even = true; private static boolean Odd = false; public static void main(String[] args) { Dropbox dropbox = new Dropbox(); (new Thread(new Consumer(Even, dropbox))).start(); (new Thread(new Consumer(Odd, dropbox))).start(); (new Thread(new Producer(dropbox))).start(); } }
public class Dropbox { private int number; private boolean empty = true; private boolean evenNumber = false; public synchronized int take(final boolean even) { while (empty || evenNumber != even) { try { System.out.format("%s is waiting ... %n", even ? "Even" : "Odd"); wait(); } catch (InterruptedException e) { } } System.out.format("%s took %d.%n", even ? "Even" : "Odd", number); empty = true; notifyAll(); return number; } public synchronized void put(int number) { while (!empty) { try { System.out.println("Producer is waiting ..."); wait(); } catch (InterruptedException e) { } } this.number = number; evenNumber = number % 2 == 0; System.out.format("Producer put %d.%n", number); empty = false; notifyAll(); } }
import java.util.Random; public class Consumer implements Runnable { private final Dropbox dropbox; private final boolean even; public Consumer(boolean even, Dropbox dropbox) { this.even = even; this.dropbox = dropbox; } public void run() { Random random = new Random(); while (true) { dropbox.take(even); try { Thread.sleep(random.nextInt(100)); } catch (InterruptedException e) { } } } }
import java.util.Random; public class Producer implements Runnable { private Dropbox dropbox; public Producer(Dropbox dropbox) { this.dropbox = dropbox; } public void run() { Random random = new Random(); while (true) { int number = random.nextInt(10); try { Thread.sleep(random.nextInt(100)); dropbox.put(number); } catch (InterruptedException e) { } } } }
synchronized(this) { while(busy) wait(); busy = true; } ... synchronized(this) { busy = false; notifyAll(); }
synchronized(this) { if(busy) wait(); busy = true; } ... synchronized(this) { busy = false; notify(); }
synchronized(this) { while(idx != last+1) wait(); } ... synchronized(this) { last = idx; notifyAll(); }
The notifyAll method should generally be used in preference to notify. If notify is used, great care must be taken to ensure liveness.
It will be NotifyAll, and reason is that it will save from signall hijacking.
long startTime = System.nanoTime(); long estimatedTime = System.nanoTime() - startTime;
private void test() { System.out.println("currentTimeMillis: "+System.currentTimeMillis()); System.out.println("nanoTime : "+System.nanoTime()); System.out.println(); testNano(false); for(int xa=0; xa<10; xa++) { testNano(true); } } private void testNano(boolean shw) { long strMS=System.currentTimeMillis(); long strNS=System.nanoTime(); long curMS; while((curMS=System.currentTimeMillis()) == strMS) { if(shw) { System.out.println("Nano: "+(System.nanoTime()-strNS)); } } if(shw) { System.out.println("Nano: "+(System.nanoTime()-strNS)+", Milli: "+(curMS-strMS)); } }
if (n < 100000){ if (n < 100){ if (n < 10) return 1; else return 2; }else{ if (n < 1000) return 3; else{ if (n < 10000) return 4; else return 5; } } } else { if (n < 10000000) { if (n < 1000000) return 6; else return 7; } else { if (n < 100000000) return 8; else { if (n < 1000000000) return 9; else return 10; } } }
public static void main(String[] args) throws Exception { for (int i = 0; i < 1000; i++) if (method1(i) != method2(i)) System.out.println(i); for (int i = 0; i < 1000; i++) if (method1(i) != method3(i)) System.out.println(i + " " + method1(i) + " " + method3(i)); for (int i = 333; i < 2000000000; i += 1000) if (method1(i) != method3(i)) System.out.println(i + " " + method1(i) + " " + method3(i)); for (int i = 0; i < 1000; i++) if (method1(i) != method4(i)) System.out.println(i + " " + method1(i) + " " + method4(i)); for (int i = 333; i < 2000000000; i += 1000) if (method1(i) != method4(i)) System.out.println(i + " " + method1(i) + " " + method4(i)); allMethod1(); allMethod2(); allMethod3(); allMethod4(); Chronometer c; c = new Chronometer(true); allMethod1(); c.stop(); long baseline = c.getValue(); System.out.println(c); c = new Chronometer(true); allMethod2(); c.stop(); System.out.println(c + " = " + StringTools.formatDouble((double)baseline / c.getValue() , "0.00") + " times faster than baseline"); c = new Chronometer(true); allMethod3(); c.stop(); System.out.println(c + " = " + StringTools.formatDouble((double)baseline / c.getValue() , "0.00") + " times faster than baseline"); c = new Chronometer(true); allMethod4(); c.stop(); System.out.println(c + " = " + StringTools.formatDouble((double)baseline / c.getValue() , "0.00") + " times faster than baseline"); } private static int method1(int n) { return Integer.toString(n).length(); } private static int method2(int n) { if (n == 0) return 1; return (int)(Math.log10(n) + 1); } private static int method3(int n) { if (n == 0) return 1; int l; for (l = 0 ; n > 0 ;++l) n /= 10; return l; } private static int method4(int n) { if (n < 100000) { if (n < 100) { if (n < 10) return 1; else return 2; } else { if (n < 1000) return 3; else { if (n < 10000) return 4; else return 5; } } } else { if (n < 10000000) { if (n < 1000000) return 6; else return 7; } else { if (n < 100000000) return 8; else { if (n < 1000000000) return 9; else return 10; } } } } private static int allMethod1() { int x = 0; for (int i = 0; i < 1000; i++) x = method1(i); for (int i = 1000; i < 100000; i += 10) x = method1(i); for (int i = 100000; i < 1000000; i += 100) x = method1(i); for (int i = 1000000; i < 2000000000; i += 200) x = method1(i); return x; } private static int allMethod2() { int x = 0; for (int i = 0; i < 1000; i++) x = method2(i); for (int i = 1000; i < 100000; i += 10) x = method2(i); for (int i = 100000; i < 1000000; i += 100) x = method2(i); for (int i = 1000000; i < 2000000000; i += 200) x = method2(i); return x; } private static int allMethod3() { int x = 0; for (int i = 0; i < 1000; i++) x = method3(i); for (int i = 1000; i < 100000; i += 10) x = method3(i); for (int i = 100000; i < 1000000; i += 100) x = method3(i); for (int i = 1000000; i < 2000000000; i += 200) x = method3(i); return x; } private static int allMethod4() { int x = 0; for (int i = 0; i < 1000; i++) x = method4(i); for (int i = 1000; i < 100000; i += 10) x = method4(i); for (int i = 100000; i < 1000000; i += 100) x = method4(i); for (int i = 1000000; i < 2000000000; i += 200) x = method4(i); return x; }
final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE }; static int stringSize(int x) { for (int i=0; ; i++) if (x <= sizeTable[i]) return i+1; }
static int numlength(int n) { if (n == 0) return 1; int l; n=Math.abs(n); for (l=0;n>0;++l) n/=10; return l; }
public class Test { public static void main(String[] args) { final int number = 1234; final int digits = 1 + (int)Math.floor(Math.log10(number)); System.out.println(digits); } }
int nDigits = Math.floor(Math.log10(Math.abs(the_integer))) + 1;
public static int numberOfDigits (long n) { if (n < 10000L) { if (n < 100L) { if (n < 10L) { return 1; } else { return 2; } } else { if (n < 1000L) { return 3; } else { return 4; } } } else { if (n < 1000000000000L) { if (n < 100000000L) { if (n < 1000000L) { if (n < 100000L) { return 5; } else { return 6; } } else { if (n < 10000000L) { return 7; } else { return 8; } } } else { if (n < 10000000000L) { if (n < 1000000000L) { return 9; } else { return 10; } } else { if (n < 100000000000L) { return 11; } else { return 12; } } } } else { if (n < 10000000000000000L) { if (n < 100000000000000L) { if (n < 10000000000000L) { return 13; } else { return 14; } } else { if (n < 1000000000000000L) { return 15; } else { return 16; } } } else { if (n < 1000000000000000000L) { if (n < 100000000000000000L) { return 17; } else { return 18; } } else { return 19; } } } } }
long n = 99999999999999999L; int numberOfDigits = String.valueOf(n).length(); int wrongNumberOfDigits = (int) (Math.log10(n) + 1);
final int digits = number==0?1:(1 + (int)Math.floor(Math.log10(Math.abs(number))));
public static int getSize(long number) { int count = 0; while (number > 0) { count += 1; number = (number / 10); } return count; }
public int len(int n){ return (n<100000)?((n<100)?((n<10)?1:2):(n<1000)?3:((n<10000)?4:5)):((n<10000000)?((n<1000000)?6:7):((n<100000000)?8:((n<1000000000)?9:10))); }
import org.junit.Test; import static org.junit.Assert.*; public class TestStack1306727 { @Test public void bench(){ int number=1000; int a= String.valueOf(number).length(); int b= 1 + (int)Math.floor(Math.log10(number)); assertEquals(a,b); int i=0; int s=0; long startTime = System.currentTimeMillis(); for(i=0, s=0; i< 100000000; i++){ a= String.valueOf(number).length(); s+=a; } long stopTime = System.currentTimeMillis(); long runTime = stopTime - startTime; System.out.println("Run time 1: " + runTime); System.out.println("s: "+s); startTime = System.currentTimeMillis(); for(i=0,s=0; i< 100000000; i++){ b= number==0?1:(1 + (int)Math.floor(Math.log10(Math.abs(number)))); s+=b; } stopTime = System.currentTimeMillis(); runTime = stopTime - startTime; System.out.println("Run time 2: " + runTime); System.out.println("s: "+s); assertEquals(a,b); } }
private static int length = 0; public static int length(int n) { length++; if((n / 10) < 10) { length++; } else { length(n / 10); } return length; }
public class long_length { long x,l=1,n; for (n=10;n<x;n*=10){ if (x/n!=0){ l++; } } System.out.print(l); }
public int numLength(int n) { for (int length = 1; n % Math.pow(10, length) != n; length++) {} return length; }
public void createCard(int cardNumber, int cardStatus, int customerId) throws SQLException { if(cardDao.checkIfCardExists(cardNumber) == false) { if(cardDao.createCard(cardNumber, cardStatus, customerId) == true) { System.out.println("Card created successfully"); } else { } } else { System.out.println("Card already exists, try with another Card Number"); do { System.out.println("Enter your new Card Number: "); scan = new Scanner(System.in); int inputCardNumber = scan.nextInt(); cardNumber = inputCardNumber; } while(cardNumber < 95000000); cardDao.createCard(cardNumber, cardStatus, customerId); } }
/** * Returns the number of digits needed to represents an {@code int} value in * the given radix, disregarding any sign. */ public static int len(int n, int radix) { radixCheck(radix); n = Math.abs(n); int len = 1; long min = radix - 1; while (n > min) { n -= min; min *= radix; len++; } return len; }
/** * For radices 2 &le r &le Character.MAX_VALUE (36) */ private static long[] overflowpt = {-1, -1, 4611686018427387904L, 8105110306037952534L, 3458764513820540928L, 5960464477539062500L, 3948651115268014080L, 3351275184499704042L, 8070450532247928832L, 1200757082375992968L, 9000000000000000000L, 5054470284992937710L, 2033726847845400576L, 7984999310198158092L, 2022385242251558912L, 6130514465332031250L, 1080863910568919040L, 2694045224950414864L, 6371827248895377408L, 756953702320627062L, 1556480000000000000L, 3089447554782389220L, 5939011215544737792L, 482121737504447062L, 839967991029301248L, 1430511474609375000L, 2385723916542054400L, 3902460517721977146L, 6269893157408735232L, 341614273439763212L, 513726300000000000L, 762254306892144930L, 1116892707587883008L, 1617347408439258144L, 2316231840055068672L, 3282671350683593750L, 4606759634479349760L}; public static int len(long n, int radix) { radixCheck(radix); n = abs(n); int len = 1; long min = radix - 1; while (n > min) { len++; if (min == overflowpt[radix]) break; n -= min; min *= radix; } return len; }
public enum IntegerLength { One((byte)1,10), Two((byte)2,100), Three((byte)3,1000), Four((byte)4,10000), Five((byte)5,100000), Six((byte)6,1000000), Seven((byte)7,10000000), Eight((byte)8,100000000), Nine((byte)9,1000000000); byte length; int value; IntegerLength(byte len,int value) { this.length = len; this.value = value; } public byte getLenght() { return length; } public int getValue() { return value; } }
public class IntegerLenght { public static byte calculateIntLenght(int num) { for(IntegerLength v : IntegerLength.values()) { if(num < v.getValue()){ return v.getLenght(); } } return 0; } }
int get_int_lenght(current_lenght, value) { if (value / 10 < 10) return (current_lenght + 1); return (get_int_lenght(current_lenght + 1, value)) }
public static int digitCount(int numberInput, int i) { while (numberInput > 0) { i++; numberInput = numberInput / 10; digitCount(numberInput, i); } return i; } public static void printString() { int numberInput = 1234567; int digitCount = digitCount(numberInput, 0); System.out.println("Count of digit in ["+numberInput+"] is ["+digitCount+"]"); }
int num = 02300; int count = 0; while(num>0){ if(num == 0) break; num=num/10; count++; } System.out.println(count);
ArrayList<Integer> a=new ArrayList<>(); while(number > 0) { remainder = num % 10; a.add(remainder); number = number / 10; } int m=a.size();
public static int numberLength(int userNumber) { int numberCounter = 10; boolean condition = true; int digitLength = 1; while (condition) { int numberRatio = userNumber / numberCounter; if (numberRatio < 1) { condition = false; } else { digitLength++; numberCounter *= 10; } } return digitLength; }
public static int repeatingLength(double decimalNumber) { int numberCounter = 1; boolean condition = true; int digitLength = 1; while (condition) { double numberRatio = decimalNumber * numberCounter; if ((numberRatio - Math.round(numberRatio)) < 0.0000001) { condition = false; } else { digitLength++; numberCounter *= 10; } } return digitLength - 1; }
int a=0; if (no < 0) { no = -no; } else if (no == 0) { no = 1; } while (no > 0) { no = no / 10; a++; } System.out.println("Number of digits in given number is: "+a);
public static int intLength(int num){ String n = Integer.toString(num); int newNum = n.length(); return newNum; }
for(String serverId : serverIds) { sb.append(serverId); sb.append(","); }
String prefix = ""; for (String serverId : serverIds) { sb.append(prefix); prefix = ","; sb.append(serverId); }
if (sb.length() > 0) { sb.setLength(sb.length() - 1); }
for(String serverId : serverIds) { sb.append(serverId); sb.append(","); } sb.deleteCharAt(sb.lastIndexOf(","));
public class Test { public static void main(String[] args) { List<String> names = new ArrayList<>(); names.add("James"); names.add("Harry"); names.add("Roy"); System.out.println(String.join(",", names)); } }
for(String serverId : serverIds) { sb.append(","); sb.append(serverId); } sb.deleteCharAt(0);
StringBuilder result = new StringBuilder(); for(String string : collection) { result.append(string); result.append( } return result.substring(0, result.length() - 1) ;
StringBuilder sb = new StringBuilder(); sb.append("abcdef"); sb.deleteCharAt(sb.length() - 1); assertEquals("abcde",sb.toString());
public String join(Collection<String> collection, String seperator) { if (collection.isEmpty()) return ""; Iterator<String> iter = collection.iterator(); StringBuilder sb = new StringBuilder(iter.next()); while (iter.hasNext()) { sb.append(seperator); sb.append(iter.next()); } return sb.toString(); }
String prefix = ""; for (String item : list) { sb.append(prefix); if (TextUtils.isEmpty(prefix)) prefix = ","; sb.append(item); }
for(String serverId : serverIds) { sb.append(serverId); sb.append(","); } sb.append(
List<String> textList = new ArrayList<>(); textList.add("text1"); textList.add("text2"); textList.add("text3"); Joiner joiner = Joiner.on(",").useForNull("null"); String output = joiner.join(textList);
for(String serverId : serverIds) { sb.append(","); sb.append(serverId); } String resultingString = ""; if ( sb.length() > 1 ) { resultingString = sb.substring(1); }
StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < value.length; i++) { stringBuilder.append(values[i]); if (value.length-1) { stringBuilder.append(", "); } }
List<String> supplierNames = new List<String>(); supplierNames.add("sup1"); supplierNames.add("sup2"); supplierNames.add("sup3"); System.out.println(supplierNames.get(1));
List<String> supplierNames1 = new ArrayList<String>(); List<String> supplierNames2 = new LinkedList<String>(); List<String> supplierNames3 = new Vector<String>();
List<String> supplierNames = Arrays.asList("sup1", "sup2", "sup3"); System.out.println(supplierNames.get(1));
List<String> list = Arrays.asList("one", "two", "three");
List<String> list = new ArrayList<>(); list.add("one"); list.add("two"); list.add("three");
List<String> list = Stream.of("one", "two", "three").collect(Collectors.toList());
List<String> list = List.of("one", "two", "three");
List<String> list = Lists.newArrayList("one", "two", "three");
List<String> supplierNames = new ArrayList<String>();
List<String> supplierNames = new LinkedList<String>();
import java.util.ArrayList; ... List<String> supplierNames = new ArrayList<String>();
List<String> abc = new ArrayList<String>(); List<String> xyz = new LinkedList<String>();
List<String> supplierNames = new ArrayList<String>();
List<String> supplierNames = new LinkedList<String>();
List<String> supplierNames = new ArrayList<String>();
List<String> oneObjectList = Collections.singletonList("theOnlyObject);
List<String> supplierNames = new ArrayList<String>();
List<Integer> list = new List<Integer>(){ @Override public int size() { return 0; } @Override public boolean isEmpty() { return false; } @Override public boolean contains(Object o) { return false; }
Connection.prepareStatement(String sql, int autoGeneratedKeys) Connection.prepareStatement(String sql, int[] columnIndexes)
PreparedStatement pstmt = conn.prepareStatement( insertSQL, Statement.RETURN_GENERATED_KEYS );
Connection.prepareStatement(String sql, String[] columnNames)
String columnNames[] = new String[] { "id" }; PreparedStatement pstmt = conn.prepareStatement( insertSQL, columnNames );
public static void insertAutoIncrement_SQL(String UserName, String Language, String Message) { String DB_URL = "jdbc:mysql: String insertSQL = "INSERT INTO `unicodeinfo`( `UserName`, `Language`, `Message`) VALUES (?,?,?)"; int primkey = 0 ; try { Class.forName("com.mysql.jdbc.Driver").newInstance(); Connection conn = DriverManager.getConnection(DB_URL, DB_User, DB_Password); String columnNames[] = new String[] { "id" }; PreparedStatement pstmt = conn.prepareStatement( insertSQL, columnNames ); pstmt.setString(1, UserName ); pstmt.setString(2, Language ); pstmt.setString(3, Message ); if (pstmt.executeUpdate() > 0) { java.sql.ResultSet generatedKeys = pstmt.getGeneratedKeys(); if ( generatedKeys.next() ) { primkey = generatedKeys.getInt(1); } } System.out.println("Record updated with id = "+primkey); } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | SQLException e) { e.printStackTrace(); } }
public String processForm(@ModelAttribute("person") Person person){ person.getStuff(); }
@ModelAttribute("person") public Person getPerson(){ return new Person(); }
@Bean("person") @Before public Person createPerson(){ return new Person(); } @RequestMapping(...) public xxx handlePersonRequest( (@Autowired @Qualifier("person") | @Bean("person")) Person person, xxx){ ... }
<form:form commandName="Book" action="" methon="post"> <form:input type="text" path="title"></form:input> </form:form>
public String controllerPost(@ModelAttribute("Book") Book book)
public class Person { private String name; public String getName() { return name; } public void setName(final String name) { this.name = name; } }
@ModelAttribute(cities) public List<String> checkOptions(){ return new Arrays.asList(new[]{Sofia,Pleven","Ruse}); }
public String findPerson(@ModelAttriute(value="person") Person person) { return "person.jsp"; }
name="Dmitrij"&countries=Lesoto&sponsor.organization="SilkRoad"&authorizedFunds=&authorizedHours=&
<form:form action="processForm" modelAttribute="student"> First Name : <form:input path="firstName" /> <br><br> Last Name : <form:input path="lastName" /> <br><br> <input type="submit" value="submit"/> </form:form>
@RequestMapping("/showForm") public String showForm(Model theModel){ theModel.addAttribute("student", new Student()); return "form"; } @RequestMapping("/processForm") public String processForm(@ModelAttribute("student") Student theStudent){ System.out.println("theStudent :"+ theStudent.getLastName()); return "form-details"; }
<b>Student Information</b> ${student.firstName} ${student.lastName}
@RequestMapping(value = "/test-example", method = RequestMethod.POST) public ModelAndView testExample(@ModelAttribute("testModelAttribute") TestModel testModel, Map<String, Object> map,...) { }
public String add(@ModelAttribute("specified") Model model) { ... }
import java.awt.Panel; import java.awt.Graphics; import java.awt.Canvas; ...
import java.sql.*; import java.util.*; import java.sql.Date;
import java.util.*; import java.awt.*; ... List blah;
ExecutorService taskExecutor = Executors.newFixedThreadPool(4); while(...) { taskExecutor.execute(new MyTask()); }
ExecutorService taskExecutor = Executors.newFixedThreadPool(4); while(...) { taskExecutor.execute(new MyTask()); } taskExecutor.shutdown(); try { taskExecutor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS); } catch (InterruptedException e) { ... }
CountDownLatch latch = new CountDownLatch(totalNumberOfTasks); ExecutorService taskExecutor = Executors.newFixedThreadPool(4); while(...) { taskExecutor.execute(new MyTask()); } try { latch.await(); } catch (InterruptedException E) { }
ExecutorService taskExecutor = Executors.newFixedThreadPool(4); List<Callable<?>> tasks; List<Future<?>> futures = taskExecutor.invokeAll(tasks);
List<Future> futures = new ArrayList<Future>(); futures.add(executorInstance.submit(new Callable<Void>() { public Void call() throws IOException { return null; } }));
ExecutorService taskExecutor = Executors.newFixedThreadPool(4); int numberOfTasks=0; Semaphore s=new Semaphore(0); while(...) { taskExecutor.execute(new MyTask()); numberOfTasks++; } try { s.aquire(numberOfTasks); ...
ExecutorService es = Executors.newFixedThreadPool(4); List<Runnable> tasks = getTasks(); CompletableFuture<?>[] futures = tasks.stream() .map(task -> CompletableFuture.runAsync(task, es)) .toArray(CompletableFuture[]::new); CompletableFuture.allOf(futures).join(); es.shutdown();
ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
for (Callable<Integer> callable : callables) { ListenableFuture<Integer> lf = service.submit(callable); listenableFutures.add(lf) });
ListenableFuture<List<Integer>> lf = Futures.successfulAsList(listenableFutures);
Futures.addCallback(lf, new FutureCallback<List<Integer>>() { @Override public void onSuccess(List<Integer> result) { log.info("@@ finished processing {} elements", Iterables.size(result)); } @Override public void onFailure(Throwable t) { log.info("@@ failed because of :: {}", t); } });
taskExecutor.execute(new Runnable() { public void run() { taskStartedNotification(); new MyTask().run(); taskFinishedNotification(); } });
ExecutorService es = Executors.newCachedThreadPool(); List<Callable<Integer>> tasks = new ArrayList<>(); for (int j = 1; j <= 10; j++) { tasks.add(new Callable<Integer>() { @Override public Integer call() throws Exception { int sum = 0; System.out.println("Starting Thread " + Thread.currentThread().getId()); for (int i = 0; i < 1000000; i++) { sum += i; } System.out.println("Stopping Thread " + Thread.currentThread().getId()); return sum; } }); } try { List<Future<Integer>> futures = es.invokeAll(tasks); int flag = 0; for (Future<Integer> f : futures) { Integer res = f.get(); System.out.println("Sum: " + res); if (!f.isDone()) flag = 1; } if (flag == 0) System.out.println("SUCCESS"); else System.out.println("FAILED"); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); }
public class TaskSubmiter { private final ExecutorService executor; TaskSubmiter(ExecutorService executor) { this.executor = executor; } void doSomethingLarge(AnySourceClass source) { final List<InterestedResult> info = doPartialAsyncProcess(source); CompletionService<PartialResult> completionService = new ExecutorCompletionService<PartialResult>(executor); for (final InterestedResult interestedResultItem : info) completionService.submit(new Callable<PartialResult>() { public PartialResult call() { return InterestedResult.doAnOperationToGetPartialResult(); } }); try { for (int t = 0, n = info.size(); t < n; t++) { Future<PartialResult> f = completionService.take(); PartialResult PartialResult = f.get(); processThisSegment(PartialResult); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } catch (ExecutionException e) { throw somethinghrowable(e.getCause()); } } }
public class MyTask implements Runnable { private CountDownLatch countDownLatch; public MyTask(CountDownLatch countDownLatch { this.countDownLatch = countDownLatch; } @Override public void run() { try { // this.countDownLatch.countDown(); } catch (InterruptedException ex) { Thread.currentThread().interrupt(); } } } CountDownLatch countDownLatch = new CountDownLatch(NUMBER_OF_TASKS); ExecutorService taskExecutor = Executors.newFixedThreadPool(4); for (int i = 0; i < NUMBER_OF_TASKS; i++){ taskExecutor.execute(new MyTask(countDownLatch)); } countDownLatch.await(); System.out.println("Finish tasks");
public class ScheduledThreadPoolExample { public static void main(String[] args) throws InterruptedException { ScheduledExecutorService executorService = Executors.newScheduledThreadPool(5); executorService.scheduleAtFixedRate(() -> System.out.println("process task."), 0, 1, TimeUnit.SECONDS); TimeUnit.SECONDS.sleep(10); executorService.shutdown(); executorService.awaitTermination(1, TimeUnit.DAYS); } }
final List<Runnable> tasks = ...; tasks.stream().parallel().forEach(Runnable::run) new ForkJoinPool(15).submit( () -> tasks.stream().parallel().forEach(Runnable::run) ).get();
ExecutorService executor = Executors.newFixedThreadPool(10); CompletableFuture[] futures = new CompletableFuture[10]; int i = 0; while (...) { futures[i++] = CompletableFuture.runAsync(runner, executor); } CompletableFuture.allOf(futures).join();
package frss.main; import java.util.ArrayList; import java.util.List; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestHilos { void procesar() { ExecutorService es = Executors.newFixedThreadPool(4); List<Runnable> tasks = getTasks(); CompletableFuture<?>[] futures = tasks.stream().map(task -> CompletableFuture.runAsync(task, es)).toArray(CompletableFuture[]::new); CompletableFuture.allOf(futures).join(); es.shutdown(); System.out.println("FIN DEL PROCESO DE HILOS"); } private List<Runnable> getTasks() { List<Runnable> tasks = new ArrayList<Runnable>(); Hilo01 task1 = new Hilo01(); tasks.add(task1); Hilo02 task2 = new Hilo02(); tasks.add(task2); return tasks; } private class Hilo01 extends Thread { @Override public void run() { System.out.println("HILO 1"); } } private class Hilo02 extends Thread { @Override public void run() { try { sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("HILO 2"); } } public static void main(String[] args) { TestHilos test = new TestHilos(); test.procesar(); } }
ExecutorService es = Executors.newFixedThreadPool(4); List<Runnable> tasks = getTasks(); CompletableFuture<?>[] futures = tasks.stream() .map(task -> CompletableFuture.runAsync(task, es)) .toArray(CompletableFuture[]::new); CompletableFuture.allOf(futures).join(); es.shutdown();
ExecutorService es = Executors.newFixedThreadPool(4); List< Future<?>> futures = new ArrayList<>(); for(Runnable task : taskList) { futures.add(es.submit(task)); } for(Future<?> future : futures) { try { future.get(); }catch(Exception e){ } } es.shutdown();
Log.i(LOG_TAG, "shutting down executor..."); executor.shutdown(); while (true) { try { Log.i(LOG_TAG, "Waiting for executor to terminate..."); if (executor.isTerminated()) break; if (executor.awaitTermination(5000, TimeUnit.MILLISECONDS)) { break; } } catch (InterruptedException ignored) {} }
Runner runner = Runner.runner(4); while(...) { runner.run(new MyTask()); } runner.waitTillDone(); runner.shutdown();
while (true) { if (executor.getActiveCount() == 0) { break; } }
class A { class B { } static class C { static int x; } } class Test { public static void main(String str) { A a = new A(); A.B obj1 = a.new B(); A.C obj2 = new A.C(); } }
public class MultipleInner { static class Inner { } public static void main(String[] args) { for (int i = 0; i < 100; i++) { new Inner(); } } }
<bean name="myRepository " class="com.demo.repository.MyRepository " />
public class MyServiceImpl implements MyService { private MyRepository myRepository; public void setMyRepository(MyRepository myRepository) { this.myRepository = myRepository ; } public List<Customer> findAll() { return myRepository.findAll(); } }
@Override public String toString() { return super.super.toString(); }
public class Items { public void add(Item item) { ... } } public class RedItems extends Items { @Override public void add(Item item) { if (!item.isRed()) { throw new NotRedItemException(); } super.add(item); } } public class BigRedItems extends RedItems { @Override public void add(Item item) { if (!item.isBig()) { throw new NotBigItemException(); } super.add(item); } }
public class NaughtyItems extends RedItems { @Override public void add(Item item) { super.super.add(item); } }
interface I { int x = 0; } class T1 implements I { int x = 1; } class T2 extends T1 { int x = 2; } class T3 extends T2 { int x = 3; void test() { System.out.println("x=\t\t" + x); System.out.println("super.x=\t\t" + super.x); System.out.println("((T2)this).x=\t" + ((T2)this).x); System.out.println("((T1)this).x=\t" + ((T1)this).x); System.out.println("((I)this).x=\t" + ((I)this).x); } } class Test { public static void main(String[] args) { new T3().test(); } }
public class A { public void doThat() { ... } } public class B extends A { public void doThat() { /* don } public class C extends B { public void doThat() { Magic.exec(A.class, this, "doThat"); } } public class Magic { public static <Type, ChieldType extends Type> void exec(Class<Type> oneSuperType, ChieldType instance, String methodOfParentToExec) { try { Type type = oneSuperType.newInstance(); shareVars(oneSuperType, instance, type); oneSuperType.getMethod(methodOfParentToExec).invoke(type); shareVars(oneSuperType, type, instance); } catch (Exception e) { throw new RuntimeException(e); } } private static <Type, SourceType extends Type, TargetType extends Type> void shareVars(Class<Type> clazz, SourceType source, TargetType target) throws IllegalArgumentException, IllegalAccessException { Class<?> loop = clazz; do { for (Field f : loop.getDeclaredFields()) { if (!f.isAccessible()) { f.setAccessible(true); } f.set(target, f.get(source)); } loop = loop.getSuperclass(); } while (loop != Object.class); } }
class SuperSuperClass { public String toString() { return DescribeMe(); } protected String DescribeMe() { return "I am super super"; } } class SuperClass extends SuperSuperClass { public String toString() { return "I am super"; } } class ChildClass extends SuperClass { public String toString() { return DescribeMe(); } }
class SuperSuperClass { public String toString() { return "I am super super"; } } class SuperClass extends SuperSuperClass { public String toString() { return DescribeMe(super.toString()); } protected String DescribeMe(string fromSuper) { return "I am super"; } } class ChildClass extends SuperClass { protected String DescribeMe(string fromSuper) { return fromSuper; } }
public class A { @Override public String toString() { return "A"; } } public class B extends A { @Override public String toString() { return "B"; } } public class C extends B { @Override public String toString() { return "C"; } } public class D extends C { @Override public String toString() { String result = ""; try { result = this.getClass().getSuperclass().getSuperclass().getSuperclass().newInstance().toString(); } catch (InstantiationException ex) { Logger.getLogger(D.class.getName()).log(Level.SEVERE, null, ex); } catch (IllegalAccessException ex) { Logger.getLogger(D.class.getName()).log(Level.SEVERE, null, ex); } return result; } } public class Main { public static void main(String... args) { D d = new D(); System.out.println(d); } }
... FrameworkBaseClass (....) extends... { methodA(...){...} methodB(...){...} ... methodX(...) ... methodN(...){...} } CustomBaseClass(...) extends FrameworkBaseClass { private boolean skipMethodX=false; /* implement accessors isSkipMethodX() and setSkipMethodX(boolean)*/ methodA(...){...} methodB(...){...} ... methodN(...){...} methodX(...){ if (isSkipMethodX()) { setSKipMethodX(false); super.methodX(...); return; } ... } } DerivedClass1(...) extends CustomBaseClass DerivedClass2(...) extends CustomBaseClass ... DerivedClassN(...) extends CustomBaseClass... DerivedClassX(...) extends CustomBaseClass... { methodX(...){ super.setSKipMethodX(true); super.methodX(...); } }
public class A { protected void printClass() { System.out.println("In A Class"); } } public class B extends A { @Override protected void printClass() { if (!(this instanceof C)) { System.out.println("In B Class"); } super.printClass(); } } public class C extends B { @Override protected void printClass() { System.out.println("In C Class"); super.printClass(); } }
public class Driver { public static void main(String[] args) { C c = new C(); c.printClass(); } }
import lombok.val; import org.junit.Assert; import org.junit.Test; import java.lang.invoke.*; public class ImplLookupTest { private MethodHandles.Lookup getImplLookup() throws NoSuchFieldException, IllegalAccessException { val field = MethodHandles.Lookup.class.getDeclaredField("IMPL_LOOKUP"); field.setAccessible(true); return (MethodHandles.Lookup) field.get(null); } @Test public void test() throws Throwable { val lookup = getImplLookup(); val baseHandle = lookup.findSpecial(Base.class, "toString", MethodType.methodType(String.class), Sub.class); val objectHandle = lookup.findSpecial(Object.class, "toString", MethodType.methodType(String.class), Base.class); val sub = new Sub(); Assert.assertEquals("Sub", sub.toString()); Assert.assertEquals("Base", baseHandle.invoke(sub)); Assert.assertEquals(toString(sub), objectHandle.invoke(sub)); } private static String toString(Object o) { return o.getClass().getName() + "@" + Integer.toHexString(o.hashCode()); } public class Sub extends Base { @Override public String toString() { return "Sub"; } } public class Base { @Override public String toString() { return "Base"; } } }
public class Foo { public int getNumber() { return 0; } } public class SuperFoo extends Foo { public static Foo superClass = new Foo(); public int getNumber() { return 1; } } public class UltraFoo extends Foo { public static void main(String[] args) { System.out.println(new UltraFoo.getNumber()); System.out.println(new SuperFoo().getNumber()); System.out.println(new SuperFoo().superClass.getNumber()); } public int getNumber() { return 2; } }
public class GrandMa { public void sayYourName(){ System.out.println("Grandma Fedora"); } } public class Mama extends GrandMa { public void sayYourName(boolean lie){ if(lie){ super.sayYourName(); }else { System.out.println("Mama Stephanida"); } } } public class Daughter extends Mama { public void sayYourName(boolean lie){ if(lie){ super.sayYourName(lie); }else { System.out.println("Little girl Masha"); } } } public class TestDaughter { public static void main(String[] args){ Daughter d = new Daughter(); System.out.print("Request to lie: d.sayYourName(true) returns "); d.sayYourName(true); System.out.print("Request not to lie: d.sayYourName(false) returns "); d.sayYourName(false); } }
package com.company.application; public class OneYouWantExtend extends OneThatContainsDesiredMethod { public void method() { if (isDoStuff()) { } super.method(); } protected abstract boolean isDoStuff(); public void methodDelegate() { super.method(); } ... } public class OneThatContainsDesiredMethod { public void method() {...} ... }
public class A internal virtual void foo() ... public class B : A public new void foo() ... public class C : B public new void foo() { (this as A).foo(); }
type A=class procedure foo; ... B=class(A) procedure foo; override; ... C=class(B) procedure foo; override; ... A(objC).foo();
class A { int y=10; void foo(Class X) throws Exception { if(X!=A.class) throw new Exception("Incorrect parameter of "+this.getClass().getName()+".foo("+X.getName()+")"); y++; System.out.printf("A.foo(%s): y=%d\n",X.getName(),y); } void foo() throws Exception { System.out.printf("A.foo()\n"); this.foo(this.getClass()); } } class B extends A { int y=20; @Override void foo(Class X) throws Exception { if(X==B.class) { y++; System.out.printf("B.foo(%s): y=%d\n",X.getName(),y); } else { System.out.printf("B.foo(%s) calls B.super.foo(%s)\n",X.getName(),X.getName()); super.foo(X); } } } class C extends B { int y=30; @Override void foo(Class X) throws Exception { if(X==C.class) { y++; System.out.printf("C.foo(%s): y=%d\n",X.getName(),y); } else { System.out.printf("C.foo(%s) calls C.super.foo(%s)\n",X.getName(),X.getName()); super.foo(X); } } void DoIt() { try { System.out.printf("DoIt: foo():\n"); foo(); Show(); System.out.printf("DoIt: foo(B):\n"); foo(B.class); Show(); System.out.printf("DoIt: foo(A):\n"); foo(A.class); Show(); } catch(Exception e) { } } void Show() { System.out.printf("Show: A.y=%d, B.y=%d, C.y=%d\n\n", ((A)this).y, ((B)this).y, ((C)this).y); } }
DoIt: foo(): A.foo() C.foo(C): y=31 Show: A.y=10, B.y=20, C.y=31 DoIt: foo(B): C.foo(B) calls C.super.foo(B) B.foo(B): y=21 Show: A.y=10, B.y=21, C.y=31 DoIt: foo(A): C.foo(A) calls C.super.foo(A) B.foo(A) calls B.super.foo(A) A.foo(A): y=11 Show: A.y=11, B.y=21, C.y=31
public void methodName() { System.out.println("Class A"); }
public void methodName() { super.methodName(); System.out.println("Class B"); } public void hackSuper() { super.methodName(); }
public static void main(String[] args) { A a = new C(); a.methodName(); } @Override public void methodName() { /*super.methodName();*/ hackSuper(); System.out.println("Class C"); }
public class SubSubClass extends SubClass { @Override public void print() { super.superPrint(); } public static void main(String[] args) { new SubSubClass().print(); } } class SuperClass { public void print() { System.out.println("Printed in the GrandDad"); } } class SubClass extends SuperClass { public void superPrint() { super.print(); } }
class Animal { public void doSth() { System.out.println(this); System.out.println("Animal do sth."); } } class Cat extends Animal { public void doSth() { System.out.println(this); System.out.println("Cat do sth."); super.doSth(); } }
return s1.toLowerCase().contains(s2.toLowerCase());
Pattern.compile(Pattern.quote(wantedStr), Pattern.CASE_INSENSITIVE).matcher(source).find();
Pattern.compile(Pattern.quote(s2), Pattern.CASE_INSENSITIVE).matcher(s1).find();
org.apache.commons.lang3.StringUtils.containsIgnoreCase("AbBaCca", "bac");
public static boolean containsIgnoreCase(String src, String what) { final int length = what.length(); if (length == 0) return true; final char firstLo = Character.toLowerCase(what.charAt(0)); final char firstUp = Character.toUpperCase(what.charAt(0)); for (int i = src.length() - length; i >= 0; i--) { final char ch = src.charAt(i); if (ch != firstLo && ch != firstUp) continue; if (src.regionMatches(true, i, what, 0, length)) return true; } return false; }
RELATIVE SPEED 1/RELATIVE SPEED METHOD EXEC TIME TO SLOWEST TO FASTEST ( ------------------------------------------------------------------------------ 1. Using regionMatches() 670 ms 10.7x 1.0x 2. 2x lowercase+contains 2829 ms 2.5x 4.2x 3. 1x lowercase+contains cache 2446 ms 2.9x 3.7x 4. Regexp 7180 ms 1.0x 10.7x 5. Regexp+cached pattern 1845 ms 3.9x 2.8x
import java.util.regex.Pattern; public class ContainsAnalysis { public static boolean containsIgnoreCase(String src, String what) { final int length = what.length(); if (length == 0) return true; final char firstLo = Character.toLowerCase(what.charAt(0)); final char firstUp = Character.toUpperCase(what.charAt(0)); for (int i = src.length() - length; i >= 0; i--) { final char ch = src.charAt(i); if (ch != firstLo && ch != firstUp) continue; if (src.regionMatches(true, i, what, 0, length)) return true; } return false; } public static boolean containsConverting(String src, String what) { return src.toLowerCase().contains(what.toLowerCase()); } private static final String S = "i am".toLowerCase(); public static boolean containsConverting(String src) { return src.toLowerCase().contains(S); } public static boolean containsIgnoreCaseRegexp(String src, String what) { return Pattern.compile(Pattern.quote(what), Pattern.CASE_INSENSITIVE) .matcher(src).find(); } private static final Pattern P = Pattern.compile( Pattern.quote("i am"), Pattern.CASE_INSENSITIVE); public static boolean containsIgnoreCaseRegexp(String src) { return P.matcher(src).find(); } public static void main(String[] args) throws Exception { final String src = "Hi, I am Adam"; final String what = "i am"; long start, end; final int N = 10_000_000; start = System.nanoTime(); for (int i = 0; i < N; i++) containsIgnoreCase(src, what); end = System.nanoTime(); System.out.println("Case 1 took " + ((end - start) / 1000000) + "ms"); start = System.nanoTime(); for (int i = 0; i < N; i++) containsConverting(src, what); end = System.nanoTime(); System.out.println("Case 2 took " + ((end - start) / 1000000) + "ms"); start = System.nanoTime(); for (int i = 0; i < N; i++) containsConverting(src); end = System.nanoTime(); System.out.println("Case 3 took " + ((end - start) / 1000000) + "ms"); start = System.nanoTime(); for (int i = 0; i < N; i++) containsIgnoreCaseRegexp(src, what); end = System.nanoTime(); System.out.println("Case 4 took " + ((end - start) / 1000000) + "ms"); start = System.nanoTime(); for (int i = 0; i < N; i++) containsIgnoreCaseRegexp(src); end = System.nanoTime(); System.out.println("Case 5 took " + ((end - start) / 1000000) + "ms"); } }
String s1 = "abBaCca"; String s2 = "bac"; String s1Lower = s1; s1Lower = s1Lower.toLowerCase(); String trueStatement = "FALSE!"; if (s1Lower.contains(s2)) { trueStatement = "TRUE!" } return trueStatement;
String foobar = "fooBar"; String bar = "FOO"; if (foobar.toLowerCase().contains(bar.toLowerCase()) { System.out.println("It }
public static boolean containsIgnoreCase(String haystack, String needle) { return indexOfIgnoreCase(haystack, needle) >= 0; } public static int indexOfIgnoreCase(String haystack, String needle) { StringSearch stringSearch = new StringSearch(needle, haystack); stringSearch.getCollator().setStrength(Collator.PRIMARY); return stringSearch.first(); }
for (SongInformation song: songs) { if (song.artist.toLowerCase().indexOf(pattern.toLowercase() > -1) { ... } }
for (SongInformation song: songs) { if (song.artist.matches("(?i).*" + pattern + ".*")) { ... } }
Pattern p = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE); Matcher m = p.matcher(""); for (SongInformation song: songs) { m.reset(song.artist); if (m.find()) { ... } }
String container = " Case SeNsitive "; String sub = "sen"; if (rcontains(container, sub)) { System.out.println("no case"); } public static Boolean rcontains(String container, String sub) { Boolean b = false; for (int a = 0; a < container.length() - sub.length() + 1; a++) { if (sub.equalsIgnoreCase(container.substring(a, a + sub.length()))) { b = true; } } return b; }
public static String lowerCaseAscii(String s) { if (s == null) return null; int len = s.length(); char[] buf = new char[len]; s.getChars(0, len, buf, 0); for (int i=0; i<len; i++) { if (buf[i] >= buf[i] += 0x20; } return new String(buf); } public static boolean containsIgnoreCaseAscii(String str, String searchStr) { return StringUtils.contains(lowerCaseAscii(str), lowerCaseAscii(searchStr)); }
import java.text.Normalizer; import org.apache.commons.lang3.StringUtils; public class ContainsIgnoreCase { public static void main(String[] args) { String in = " Annule "; String key = "annulee"; if (Normalizer.normalize(in, Normalizer.Form.NFD).replaceAll("[\\p{InCombiningDiacriticalMarks}]", "").toLowerCase().contains(key)) { System.out.println("OK"); } else { System.out.println("KO"); } if (StringUtils.containsIgnoreCase(Normalizer.normalize(in, Normalizer.Form.NFD).replaceAll("[\\p{InCombiningDiacriticalMarks}]", ""), key)) { System.out.println("OK"); } else { System.out.println("KO"); } } }
String x="abCd"; System.out.println(Pattern.compile("c",Pattern.CASE_INSENSITIVE).matcher(x).find());
String s1 = "AbBaCca"; String s2 = "bac"; String toLower = s1.toLowerCase(); return toLower.contains(s2);
String str = new String("Welcome"); System.out.print("Found Index :" ); System.out.println(str.indexOf(
"AbCd".toLowerCase().contains("abcD".toLowerCase())
private void checkConnectionStatus() { HttpClient httpClient = new DefaultHttpClient(); try { String url = "http: + strSessionString + "/ConnectionStatus"; Log.d("phobos", "performing get " + url); HttpGet method = new HttpGet(new URI(url)); HttpResponse response = httpClient.execute(method); if (response != null) { String result = getResponse(response.getEntity()); ...
HttpResponse response = httpClient.execute(method);
HttpGet httpGet = new HttpGet(url); HttpParams httpParameters = new BasicHttpParams(); int timeoutConnection = 3000; HttpConnectionParams.setConnectionTimeout(httpParameters, timeoutConnection); int timeoutSocket = 5000; HttpConnectionParams.setSoTimeout(httpParameters, timeoutSocket); DefaultHttpClient httpClient = new DefaultHttpClient(httpParameters); HttpResponse response = httpClient.execute(httpGet);
AndroidHttpClient client = AndroidHttpClient.newInstance("Awesome User Agent V/1.0"); HttpConnectionParams.setConnectionTimeout(client.getParams(), 3000); HttpConnectionParams.setSoTimeout(client.getParams(), 5000);
HttpClient client = new HttpClient(); client.getParams().setParameter(HttpClientParams.CONNECTION_MANAGER_TIMEOUT, new Long(5000)); client.getParams().setParameter(HttpClientParams.SO_TIMEOUT, new Integer(5000)); GetMethod method = new GetMethod("http: method.getParams().setParameter(HttpMethodParams.SO_TIMEOUT, new Integer(5000)); method.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, int statuscode = client.executeMethod(method);
HttpClient client = new DefaultHttpClient(); HttpParams params = client.getParams(); HttpConnectionParams.setConnectionTimeout(params, 3000); HttpConnectionParams.setSoTimeout(params, 3000);
String sURL = "http: int DNSTimeout = 1000; int HTTPTimeout = 2000; URL url= null; try { url = ResolveHostIP(sURL,DNSTimeout); } catch (MalformedURLException e) { Log.d("INFO",e.getMessage()); } if(url==null){ } HttpParams params = new BasicHttpParams(); HttpConnectionParams.setConnectionTimeout(params, HTTPTimeout); HttpConnectionParams.setSoTimeout(params, HTTPTimeout); DefaultHttpClient client = new DefaultHttpClient(params); HttpResponse httpResponse; String text; try { httpResponse = client.execute(new HttpGet(url.toString())); } catch (IOException e) { Log.d("INFO",e.getMessage()); }
public static URL ResolveHostIP (String sURL, int timeout) throws MalformedURLException { URL url= new URL(sURL); DNSResolver dnsRes = new DNSResolver(url.getHost()); Thread t = new Thread(dnsRes); t.start(); try { t.join(timeout); } catch (InterruptedException e) { Log.d("DEBUG", "DNS lookup interrupted"); return null; } InetAddress inetAddr = dnsRes.get(); if(inetAddr==null) { Log.d("DEBUG", "DNS timed out."); return null; } Log.d("DEBUG", "DNS solved."); return new URL(url.getProtocol(),inetAddr.getHostAddress(),url.getPort(),url.getFile()); }
public static class DNSResolver implements Runnable { private String domain; private InetAddress inetAddr; public DNSResolver(String domain) { this.domain = domain; } public void run() { try { InetAddress addr = InetAddress.getByName(domain); set(addr); } catch (UnknownHostException e) { } } public synchronized void set(InetAddress inetAddr) { this.inetAddr = inetAddr; } public synchronized InetAddress get() { return inetAddr; } }
HttpParams httpParameters = new BasicHttpParams(); HttpProtocolParams.setVersion(httpParameters, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(httpParameters, HTTP.DEFAULT_CONTENT_CHARSET); HttpProtocolParams.setUseExpectContinue(httpParameters, true); int timeoutConnection = 35 * 1000; HttpConnectionParams.setConnectionTimeout(httpParameters, timeoutConnection); int timeoutSocket = 30 * 1000; HttpConnectionParams.setSoTimeout(httpParameters, timeoutSocket);
SSLContext sslContext = SSLContexts.createSystemDefault(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory( sslContext, SSLConnectionSocketFactory.STRICT_HOSTNAME_VERIFIER); RequestConfig.Builder requestConfigBuilder = RequestConfig.custom().setCircularRedirectsAllowed(false).setConnectionRequestTimeout(30*1000).setConnectTimeout(30 * 1000).setMaxRedirects(10).setSocketTimeout(60 * 1000); CloseableHttpClient hc = HttpClients.custom().setSSLSocketFactory(sslsf).setDefaultRequestConfig(requestConfigBuilder.build()).build();
final OkHttpClient okHttpClient = new OkHttpClient(); okHttpClient.setReadTimeout(60, TimeUnit.SECONDS); okHttpClient.setConnectTimeout(60, TimeUnit.SECONDS);
okHttpClient.setReadTimeout(1, TimeUnit.MINUTES); okHttpClient.setConnectTimeout(1, TimeUnit.MINUTES);
URL url = new URL(myurl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(CONNECT_TIMEOUT);
public boolean isInternetWorking(){ try { int timeOut = 5000; Socket socket = new Socket(); SocketAddress socketAddress = new InetSocketAddress("8.8.8.8",53); socket.connect(socketAddress,timeOut); socket.close(); return true; } catch (IOException e) { } return false; }
javac -d . -cp ./apache-log4j-1.2.16/log4j-1.2.16.jar:./vensim.jar SpatialModel.java VensimHelper.java VensimException.java VensimContextRepository.java
java -cp ./apache-log4j-1.2.16/log4j-1.2.16.jar:./vensim.jar SpatialModel vars
import java.io.File; import java.text.NumberFormat; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.apache.log4j.Logger; public class SpatialModel { private VensimHelper vh; public static final String DLL_LIBNAME_PARAM = "vensim_lib_nam"; public static final String MODEL_PATH_PARAM = "vensim_model_path"; private final static int VENSIM_CONTEXT_CREATION_MAX_FAILURE_COUNT = 10; public SpatialModel() throws SpatialException { String libName = System.getProperty(DLL_LIBNAME_PARAM); String modelPath = System.getProperty(MODEL_PATH_PARAM); if(libName == null || libName.trim().equals("")) { log.error("Vensim library name has to be set with -D" + DLL_LIBNAME_PARAM); throw new SpatialException("Vensim library name has to be set with -D" + DLL_LIBNAME_PARAM); } if(modelPath == null || modelPath.trim().equals("")) { log.error("Model path has to set with -D" + MODEL_PATH_PARAM); throw new SpatialException("Model path ahs to be set with -D" + MODEL_PATH_PARAM); } for (int i = 0; i < VENSIM_CONTEXT_CREATION_MAX_FAILURE_COUNT && vh == null; i++) { try { log.info("creating new vensim helper\n\tdll lib: " + libName + "\n\tmodel path: " + modelPath); vh = new VensimHelper(libName, modelPath); } catch (Throwable e) { log.error("An exception was thrown when initializing Vensim, try: " + i, e); } } if (vh == null) { throw new SpatialException("Can } } public static void main(String[] args) throws VensimException { long before = System.currentTimeMillis(); String libName = System.getProperty(DLL_LIBNAME_PARAM); String modelPath = System.getProperty(MODEL_PATH_PARAM); if (libName == null) { libName = "libvensim"; } if(modelPath == null) { modelPath = "~/BassModel.vmf"; } System.setProperty(DLL_LIBNAME_PARAM, libName); System.setProperty(MODEL_PATH_PARAM, modelPath); if (args.length > 0 && args[0].equals("info")) { System.out.println(new VensimHelper(libName, modelPath).getVensimInfo()); } else if (args.length > 0 && args[0].equals("vars")) { VensimHelper helper = new VensimHelper(libName, modelPath); String[] vars = helper.getVariables(); for (String var : vars) { System.out.println(helper.getVariableInfo(var)); } } else { File f = new File("."); System.out.println(f.getAbsolutePath()); SpatialModel sm = new SpatialModel(); } System.out.println("Execution time: " + (System.currentTimeMillis() - before)); } }
package thepackagename; public class TheClassName { public static final void main(String[] cmd_lineParams) { System.out.println("Hello World!"); } }
java -cp .:./apache-log4j-1.2.16/log4j-1.2.16.jar:./vensim.jar SpatialModel vars
javac -cp . PackageName/*.java java -cp . PackageName/ClassName_Having_main
$ cd src $ javac -cp . com/test/*.java $ java -cp . com/test/Hello
E:\>set path="c:\programfiles\Java\jdk1.7.0_17\bin" E:\>set classpath=%classpath%;.; E:\>javac XYZ.java E:\>java XYZ
Error: Could not find or load main class mypackage.morepackage.myclass
javac -d . -cp ./apache-log4j-1.2.16/log4j-1.2.16.jar:./vensim.jar SpatialModel.java VensimHelper.java VensimException.java VensimContextRepository.java
import java.util.Random; Random rand = new Random(); int n = rand.nextInt(50) + 1;
double random = Math.random() * 49 + 1; or int random = (int )(Math.random() * 50 + 1);
Random rand = new Random(); int value = rand.nextInt(50);
File theDir = new File("new folder"); if (!theDir.exists()) { System.out.println("creating directory: " + theDir.getName()); boolean result = false; try{ theDir.mkdir(); result = true; } catch(SecurityException se){ } if(result) { System.out.println("DIR created"); } }
Files.createDirectories(Paths.get("/path/to/directory"));
new File("C:\\Directory2\\Sub2\\Sub-Sub2").mkdirs()
private void createUserDir(final String dirName) throws IOException { final File homeDir = new File(System.getProperty("user.home")); final File dir = new File(homeDir, dirName); if (!dir.exists() && !dir.mkdirs()) { throw new IOException("Unable to create " + dir.getAbsolutePath(); } }
Path path = Paths.get("/your/path/string"); if(!Files.exists(path)) { try { Files.createDirectories(path); } catch (IOException e) { e.printStackTrace(); } }
public static void makeDir() { File directory = new File(" dirname "); if (directory.exists() && directory.isFile()) { System.out.println("The dir with name could not be" + " created as it is a normal file"); } else { try { if (!directory.exists()) { directory.mkdir(); } String username = System.getProperty("user.name"); String filename = " path/" + username + ".txt"; } catch (IOException e) { System.out.println("prompt for error"); } } }
File file = new File(filePath); if (file.getParentFile() != null) { file.getParentFile().mkdirs(); }
import java.io.File; public class RevCreateDirectory { public void revCreateDirectory() { File file = new File("D:\\Directory1"); if (!file.exists()) { if (file.mkdir()) { System.out.println("Directory is created!"); } else { System.out.println("Failed to create directory!"); } } File files = new File("D:\\Directory2\\Sub2\\Sub-Sub2"); if (!files.exists()) { if (files.mkdirs()) { System.out.println("Multiple directories are created!"); } else { System.out.println("Failed to create multiple directories!"); } } } }
File dir = new File("path name"); boolean isCreated = dir.mkdir();
File dir = new File("path name"); boolean isCreated = dir.mkdirs();
File filed = new File("C:\\dir1"); if(!filed.exists()){ if(filed.mkdir()){ System.out.println("directory is created"); }} else{ System.out.println("directory exist"); } File filel = new File("C:\\dir1\\dir2"); if(!filel.exists()){ if(filel.mkdir()){ System.out.println("directory is created"); }} else{ System.out.println("directory exist"); } File filet = new File("C:\\dir1\\dir2\\dir3"); if(!filet.exists()){ if(filet.mkdir()){ System.out.println("directory is created"); }} else{ System.out.println("directory exist"); }
private static void createDirectory(final String directoryName) { final File homeDirectory = new File(System.getProperty("user.home")); final File newDirectory = new File(homeDirectory, directoryName); if(!newDirectory.exists()) { boolean result = newDirectory.mkdir(); if(result) { System.out.println("The directory is created !"); } } else { System.out.println("The directory already exist"); } }
final String path = "target/logs/"; final File logsDir = new File(path); final boolean logsDirCreated = logsDir.mkdir(); if (!logsDirCreated) { final boolean logsDirExists = logsDir.exists(); assertThat(logsDirExists).isTrue(); }
public class Test1 { public static void main(String[] args) { String path = System.getProperty("user.home"); File dir=new File(path+"/new folder"); if(dir.exists()){ System.out.println("A folder with name }else{ dir.mkdir(); } } }
thread 1 thread 2 | | write(x) | | | | read(x) | | rollback | v v value (x) is now dirty (incorrect)
public class FooService { private Repository repo1; private Repository repo2; @Transactional(propagation=Propagation.REQUIRES_NEW) public void provideService() { repo1.retrieveFoo(); repo2.retrieveFoo(); } }
@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations="classpath:/fooService.xml") public class FooServiceTests { private @Autowired TransactionManager transactionManager; private @Autowired FooService fooService; @Test public void testProvideService() { TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); fooService.provideService(); transactionManager.rollback(status); }
public class TransactionBehaviour { DataSourceTransactionManager manager=new DataSourceTransactionManager(); SimpleTransactionStatus status=new SimpleTransactionStatus(); ; public void beginTransaction() { DefaultTransactionDefinition Def = new DefaultTransactionDefinition(); manager.setPropagationBehavior(XX); manager.setIsolationLevelName(XX); status = manager.getTransaction(Def); } public void commitTransaction() { if(status.isCompleted()){ manager.commit(status); } } public void rollbackTransaction() { if(!status.isCompleted()){ manager.rollback(status); } } Main method{ beginTransaction() M1(); If error(){ rollbackTransaction() } commitTransaction(); } }
@Service @Transactional(Propagation=REQUIRED) class SignUpService{ ... void SignUp(User user){ ... emailService.sendMail(User); } } @Service @Transactional(Propagation=REQUIRES_NEW) class EmailService{ ... void sendMail(User user){ try{ ... }catch( Exception) } }
@Transactional(Propagation=MANDATORY) class UserDAO{ }
@Transactional(isolation=Isolation.READ_COMMITTED) public void someTransactionalMethod(Object obj) { }
@Transactional @Override public void outerMethod() { customerProfileDAO.method_1(); iWorkflowDetailDao.method_2(); }
@Transactional(propagation=Propagation.MANDATORY) public void method_1() { Session session = null; try { session = getSession(); Temp entity = new Temp(0l, "XXX"); session.save(entity); System.out.println("Method - 1 Id "+entity.getId()); } finally { if (session != null && session.isOpen()) { } } }
@Transactional() @Override public void method_2() { Session session = null; try { session = getSession(); Temp entity = new Temp(0l, "CCC"); session.save(entity); int i = 1/0; System.out.println("Method - 2 Id "+entity.getId()); } finally { if (session != null && session.isOpen()) { } } }
@Autowired private TestDAO testDAO; @Transactional(propagation=TransactionDefinition.PROPAGATION_REQUIRED,isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED) public void someTransactionalMethod(User user) { }
+-------+---------------------------+------------------------------------------------------------------------------------------------------+ | value | Propagation | Description | +-------+---------------------------+------------------------------------------------------------------------------------------------------+ | -1 | TIMEOUT_DEFAULT | Use the default timeout of the underlying transaction system, or none if timeouts are not supported. | | 0 | PROPAGATION_REQUIRED | Support a current transaction; create a new one if none exists. | | 1 | PROPAGATION_SUPPORTS | Support a current transaction; execute non-transactionally if none exists. | | 2 | PROPAGATION_MANDATORY | Support a current transaction; throw an exception if no current transaction exists. | | 3 | PROPAGATION_REQUIRES_NEW | Create a new transaction, suspending the current transaction if one exists. | | 4 | PROPAGATION_NOT_SUPPORTED | Do not support a current transaction; rather always execute non-transactionally. | | 5 | PROPAGATION_NEVER | Do not support a current transaction; throw an exception if a current transaction exists. | | 6 | PROPAGATION_NESTED | Execute within a nested transaction if a current transaction exists. | +-------+---------------------------+------------------------------------------------------------------------------------------------------+
+---------------------------+-------------------+-------------+-------------+------------------------+ | Isolation Level Mode | Read | Insert | Update | Lock Scope | +---------------------------+-------------------+-------------+-------------+------------------------+ | READ_UNCOMMITTED | uncommitted data | Allowed | Allowed | No Lock | | READ_COMMITTED (Default) | committed data | Allowed | Allowed | Lock on Committed data | | REPEATABLE_READ | committed data | Allowed | Not Allowed | Lock on block of table | | SERIALIZABLE | committed data | Not Allowed | Not Allowed | Lock on full table | +---------------------------+-------------------+-------------+-------------+------------------------+
+---------------------------+----------------+----------------------+----------------+ | Isolation Level Mode | Dirty reads | Non-repeatable reads | Phantoms reads | +---------------------------+----------------+----------------------+----------------+ | READ_UNCOMMITTED | allows | allows | allows | | READ_COMMITTED (Default) | prevents | allows | allows | | REPEATABLE_READ | prevents | prevents | allows | | SERIALIZABLE | prevents | prevents | prevents | +---------------------------+----------------+----------------------+----------------+
@Transactional(readOnly = true) public class Banking_CustomerService implements CustomerService { public Customer getDetail(String customername) { } @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW) public void updateCustomer(Customer customer) { } }
@Transactional(propagation = Propagation.REQUIRES_NEW) public EventMessage<ModificaOperativitaRapporto> activate(EventMessage<ModificaOperativitaRapporto> eventMessage) { }
public interface TransactionStatus extends SavepointManager { boolean isNewTransaction(); boolean hasSavepoint(); void setRollbackOnly(); boolean isRollbackOnly(); void flush(); boolean isCompleted(); }
java -XX:+PrintFlagsFinal -version | findstr /i "HeapSize PermSize ThreadStackSize"
public static void foo() { try { foo(); } finally { foo(); } } public static void bar() { bar(); }
foo() calls foo() calls foo() calls foo() calls foo() which fails to call foo() finally calls foo() which fails to call foo() finally foo() calls foo() which fails to call foo() finally calls foo() which fails to call foo() finally calls foo() calls foo() calls foo() which fails to call foo() finally calls foo() which fails to call foo() finally foo() calls foo() which fails to call foo() finally calls foo() which fails to call foo() finally calls foo() calls foo() calls foo() calls foo() which fails to call foo() finally calls foo() which fails to call foo() finally foo() calls foo() which fails to call foo() finally calls foo() which fails to call foo() finally calls foo() calls foo() calls foo() which fails to call foo() finally calls foo() which fails to call foo() finally foo() calls foo() which fails to call foo() finally calls foo() which fails to call foo()
try { throw new Exception("TEST!"); } finally { System.out.println("Finally"); }
public class Main { public static void main(String[] args) { try { Main.foo(1,5); } catch(Exception ex) { System.out.println(ex.toString()); } } public static void foo(int n, int limit) throws Exception { try { System.out.println(n + " - Try"); if (n < limit) foo(n+1,limit); else throw new Exception("StackOverflow@try("+n+")"); } finally { System.out.println(n + " - Finally"); if (n < limit) foo(n+1,limit); else throw new Exception("StackOverflow@finally("+n+")"); } } }
1 - Try 2 - Try 3 - Try 4 - Try 5 - Try 5 - Finally 4 - Finally 5 - Try 5 - Finally 3 - Finally 4 - Try 5 - Try 5 - Finally 4 - Finally 5 - Try 5 - Finally 2 - Finally 3 - Try 4 - Try 5 - Try 5 - Finally 4 - Finally 5 - Try 5 - Finally 3 - Finally 4 - Try 5 - Try 5 - Finally 4 - Finally 5 - Try 5 - Finally 1 - Finally 2 - Try 3 - Try 4 - Try 5 - Try 5 - Finally 4 - Finally 5 - Try 5 - Finally 3 - Finally 4 - Try 5 - Try 5 - Finally 4 - Finally 5 - Try 5 - Finally 2 - Finally 3 - Try 4 - Try 5 - Try 5 - Finally 4 - Finally 5 - Try 5 - Finally 3 - Finally 4 - Try 5 - Try 5 - Finally 4 - Finally 5 - Try 5 - Finally java.lang.Exception: StackOverflow@finally(5)
public static void foo(int x) { System.out.println("foo " + x); try { foo(x+1); } finally { System.out.println("Finally " + x); foo(x+1); } }
[...] foo 3439 foo 3440 foo 3441 foo 3442 foo 3443 foo 3444 Finally 3443 foo 3444 Finally 3442 foo 3443 foo 3444 Finally 3443 foo 3444 Finally 3441 foo 3442 foo 3443 foo 3444 [...]
foo 1 foo 2 foo 3 Finally 3 Finally 2 foo 3 Finally 3 Finally 1 foo 2 foo 3 Finally 3 Finally 2 foo 3 Finally 3 Exception in thread "main" java.lang.StackOverflowError at Main.foo(Main.java:39) at Main.foo(Main.java:45) at Main.foo(Main.java:45) at Main.foo(Main.java:45) at Main.consumeAlmostAllStack(Main.java:26) at Main.consumeAlmostAllStack(Main.java:21) at Main.consumeAlmostAllStack(Main.java:21) ...
import java.util.Arrays; import java.util.Collections; public class Main { static int[] orderOfOperations = new int[2048]; static int operationsCount = 0; static StackOverflowError fooKiller; static Error wontReachHere = new Error("Won static RuntimeException done = new RuntimeException(); public static void main(String[] args) { try { consumeAlmostAllStack(); } catch (RuntimeException e) { if (e != done) throw wontReachHere; printResults(); throw fooKiller; } throw wontReachHere; } public static int consumeAlmostAllStack() { try { int stackDepthRemaining = consumeAlmostAllStack(); if (stackDepthRemaining < 9) { return stackDepthRemaining + 1; } else { try { foo(1); throw wontReachHere; } catch (StackOverflowError e) { fooKiller = e; throw done; } } } catch (StackOverflowError e) { return 0; } } public static void foo(int depth) { orderOfOperations[operationsCount++] = depth; try { foo(depth + 1); } finally { orderOfOperations[operationsCount++] = -depth; foo(depth + 1); } throw wontReachHere; } public static String indent(int depth) { return String.join("", Collections.nCopies(depth, " ")); } public static void printResults() { Arrays.stream(orderOfOperations, 0, operationsCount).forEach(depth -> { if (depth > 0) { System.out.println(indent(depth - 1) + "foo " + depth); } else { System.out.println(indent(-depth - 1) + "Finally " + -depth); } }); } }
enum Strings{ STRING_ONE("ONE"), STRING_TWO("TWO") }
/** * */ package test; /** * @author The Elite Gentleman * */ public enum Strings { STRING_ONE("ONE"), STRING_TWO("TWO") ; private final String text; /** * @param text */ Strings(final String text) { this.text = text; } /* (non-Javadoc) * @see java.lang.Enum */ @Override public String toString() { return text; } }
public enum MyType { ONE { public String toString() { return "this is one"; } }, TWO { public String toString() { return "this is two"; } } }
public class EnumTest { public static void main(String[] args) { System.out.println(MyType.ONE); System.out.println(MyType.TWO); } } this is one this is two
public class Main { public static void main(String[] args) throws Exception { System.out.println(Strings.ONE.name()); } } enum Strings { ONE, TWO, THREE }
enum Strings { STRING_ONE("ONE"), STRING_TWO("TWO"); private final String stringValue; Strings(final String s) { stringValue = s; } public String toString() { return stringValue; } }
public interface Strings{ public static final String STRING_ONE = "ONE"; public static final String STRING_TWO = "TWO"; }
public enum EnumTest { NAME_ONE("Name 1"), NAME_TWO("Name 2"); private final String name; /** * @param name */ private EnumTest(final String name) { this.name = name; } public String getName() { return name; } }
public class Test { public static void main (String args[]){ System.out.println(EnumTest.NAME_ONE.getName()); System.out.println(EnumTest.NAME_TWO.getName()); } }
public enum MyType { ONE { public String getDescription() { return "this is one"; } }, TWO { public String getDescription() { return "this is two"; } }; public abstract String getDescription(); }
public abstract class Human{ ... public abstract void goPee(); }
public class Male extends Human{ ... @Override public void goPee(){ System.out.println("Stand Up"); } }
public class Female extends Human{ ... @Override public void goPee(){ System.out.println("Sit Down"); } }
public static void main(String[] args){ ArrayList<Human> group = new ArrayList<Human>(); group.add(new Male()); group.add(new Female()); for (Human person : group) person.goPee(); }
class Animal { abstract string MakeNoise (); } class Cat : Animal { string MakeNoise () { return "Meow"; } } class Dog : Animal { string MakeNoise () { return "Bark"; } } Main () { Animal animal = Zoo.GetAnimal (); Console.WriteLine (animal.MakeNoise ()); }
abstract class Beverage { boolean isAcceptableTemperature(); } class Coffee extends Beverage { boolean isAcceptableTemperature() { return temperature > 70; } } class Wine extends Beverage { boolean isAcceptableTemperature() { return temperature < 10; } }
class Server { public void pour (Coffee liquid) { new Cup().fillToTopWith(liquid); } public void pour (Wine liquid) { new WineGlass().fillHalfwayWith(liquid); } public void pour (Lemonade liquid, boolean ice) { Glass glass = new Glass(); if (ice) { glass.fillToTopWith(new Ice()); } glass.fillToTopWith(liquid); } }
int countStuff(List stuff) { return stuff.size(); }
List myStuff = new MyTotallyAwesomeList(); int result = countStuff(myStuff);
int countStuff(LinkedList stuff) {...} int countStuff(ArrayList stuff) {...} int countStuff(MyTotallyAwesomeList stuff) {...} etc...
public int DoSomething(int objectId) { ... } public int DoSomething(string objectName) { ... }
import java.util.HashMap; abstract class Game implements Runnable{ protected boolean runGame = true; protected Player player1 = null; protected Player player2 = null; protected Player currentPlayer = null; public Game(){ player1 = new Player("Player 1"); player2 = new Player("Player 2"); currentPlayer = player1; initializeGame(); } protected abstract void initializeGame(); protected void logTimeBetweenMoves(Player player){ System.out.println("Base class: Move Duration: player.PlayerActTime - player.MoveShownTime"); } /* Type 3: Base class provides implementation. Sub-class can enhance base class implementation by calling super.methodName() in first line of the child class method and specific implementation later */ protected void logGameStatistics(){ System.out.println("Base class: logGameStatistics:"); } protected void runGame() throws Exception{ System.out.println("Base class: Defining the flow for Game:"); while ( runGame) { validatePlayerMove(currentPlayer); logTimeBetweenMoves(currentPlayer); Thread.sleep(500); setNextPlayer(); } logGameStatistics(); } protected abstract void validatePlayerMove(Player p); protected void setRunGame(boolean status){ this.runGame = status; } public void setCurrentPlayer(Player p){ this.currentPlayer = p; } public void setNextPlayer(){ if ( currentPlayer == player1) { currentPlayer = player2; }else{ currentPlayer = player1; } } public void run(){ try{ runGame(); }catch(Exception err){ err.printStackTrace(); } } } class Player{ String name; Player(String name){ this.name = name; } public String getName(){ return name; } } class Chess extends Game{ public Chess(){ super(); } public void initializeGame(){ System.out.println("Child class: Initialized Chess game"); } protected void validatePlayerMove(Player p){ System.out.println("Child class: Validate Chess move:"+p.getName()); } protected void logGameStatistics(){ super.logGameStatistics(); System.out.println("Child class: Add Chess specific logGameStatistics:"); } } class TicTacToe extends Game{ public TicTacToe(){ super(); } public void initializeGame(){ System.out.println("Child class: Initialized TicTacToe game"); } protected void validatePlayerMove(Player p){ System.out.println("Child class: Validate TicTacToe move:"+p.getName()); } } public class Polymorphism{ public static void main(String args[]){ try{ Game game = new Chess(); Thread t1 = new Thread(game); t1.start(); Thread.sleep(1000); game.setRunGame(false); Thread.sleep(1000); game = new TicTacToe(); Thread t2 = new Thread(game); t2.start(); Thread.sleep(1000); game.setRunGame(false); }catch(Exception err){ err.printStackTrace(); } } }
Child class: Initialized Chess game Base class: Defining the flow for Game: Child class: Validate Chess move:Player 1 Base class: Move Duration: player.PlayerActTime - player.MoveShownTime Child class: Validate Chess move:Player 2 Base class: Move Duration: player.PlayerActTime - player.MoveShownTime Base class: logGameStatistics: Child class: Add Chess specific logGameStatistics: Child class: Initialized TicTacToe game Base class: Defining the flow for Game: Child class: Validate TicTacToe move:Player 1 Base class: Move Duration: player.PlayerActTime - player.MoveShownTime Child class: Validate TicTacToe move:Player 2 Base class: Move Duration: player.PlayerActTime - player.MoveShownTime Base class: logGameStatistics:
import java.util.Scanner; class VolumeControllerV1 { private int value; int get() { return value; } void set(int value) { System.out.println("Old value of VolumeController \t"+this.value); this.value = value; System.out.println("New value of VolumeController \t"+this.value); } void adjust(int value) { int temp = this.get(); if(((value > 0) && (temp >= 100)) || ((value < 0) && (temp <= 0))) { System.out.println("Can not adjust any further"); return; } this.set(temp + value); } } class BrightnessControllerV1 { private int value; int get() { return value; } void set(int value) { System.out.println("Old value of BrightnessController \t"+this.value); this.value = value; System.out.println("New value of BrightnessController \t"+this.value); } void adjust(int value) { int temp = this.get(); if(((value > 0) && (temp >= 100)) || ((value < 0) && (temp <= 0))) { System.out.println("Can not adjust any further"); return; } this.set(temp + value); } } class ColourControllerV1 { private int value; int get() { return value; } void set(int value) { System.out.println("Old value of ColourController \t"+this.value); this.value = value; System.out.println("New value of ColourController \t"+this.value); } void adjust(int value) { int temp = this.get(); if(((value > 0) && (temp >= 100)) || ((value < 0) && (temp <= 0))) { System.out.println("Can not adjust any further"); return; } this.set(temp + value); } } /* * There can be n number of controllers * */ public class TvApplicationV1 { public static void main(String[] args) { VolumeControllerV1 volumeControllerV1 = new VolumeControllerV1(); BrightnessControllerV1 brightnessControllerV1 = new BrightnessControllerV1(); ColourControllerV1 colourControllerV1 = new ColourControllerV1(); OUTER: while(true) { Scanner sc=new Scanner(System.in); System.out.println(" Enter your option \n Press 1 to increase volume \n Press 2 to decrease volume"); System.out.println(" Press 3 to increase brightness \n Press 4 to decrease brightness"); System.out.println(" Press 5 to increase color \n Press 6 to decrease color"); System.out.println("Press any other Button to shutdown"); int button = sc.nextInt(); switch (button) { case 1: { volumeControllerV1.adjust(5); break; } case 2: { volumeControllerV1.adjust(-5); break; } case 3: { brightnessControllerV1.adjust(5); break; } case 4: { brightnessControllerV1.adjust(-5); break; } case 5: { colourControllerV1.adjust(5); break; } case 6: { colourControllerV1.adjust(-5); break; } default: System.out.println("Shutting down..........."); break OUTER; } } } }
import java.util.Scanner; class VolumeControllerV2 { private int defaultValue = 25; private int value; int getDefaultValue() { return defaultValue; } int get() { return value; } void set(int value) { System.out.println("Old value of VolumeController \t"+this.value); this.value = value; System.out.println("New value of VolumeController \t"+this.value); } void adjust(int value) { int temp = this.get(); if(((value > 0) && (temp >= 100)) || ((value < 0) && (temp <= 0))) { System.out.println("Can not adjust any further"); return; } this.set(temp + value); } } class BrightnessControllerV2 { private int defaultValue = 50; private int value; int get() { return value; } int getDefaultValue() { return defaultValue; } void set(int value) { System.out.println("Old value of BrightnessController \t"+this.value); this.value = value; System.out.println("New value of BrightnessController \t"+this.value); } void adjust(int value) { int temp = this.get(); if(((value > 0) && (temp >= 100)) || ((value < 0) && (temp <= 0))) { System.out.println("Can not adjust any further"); return; } this.set(temp + value); } } class ColourControllerV2 { private int defaultValue = 40; private int value; int get() { return value; } int getDefaultValue() { return defaultValue; } void set(int value) { System.out.println("Old value of ColourController \t"+this.value); this.value = value; System.out.println("New value of ColourController \t"+this.value); } void adjust(int value) { int temp = this.get(); if(((value > 0) && (temp >= 100)) || ((value < 0) && (temp <= 0))) { System.out.println("Can not adjust any further"); return; } this.set(temp + value); } } class ResetFunctionV2 { private VolumeControllerV2 volumeControllerV2 ; private BrightnessControllerV2 brightnessControllerV2; private ColourControllerV2 colourControllerV2; ResetFunctionV2(VolumeControllerV2 volumeControllerV2, BrightnessControllerV2 brightnessControllerV2, ColourControllerV2 colourControllerV2) { this.volumeControllerV2 = volumeControllerV2; this.brightnessControllerV2 = brightnessControllerV2; this.colourControllerV2 = colourControllerV2; } void onReset() { volumeControllerV2.set(volumeControllerV2.getDefaultValue()); brightnessControllerV2.set(brightnessControllerV2.getDefaultValue()); colourControllerV2.set(colourControllerV2.getDefaultValue()); } } /* * so on * There can be n number of controllers * * */ public class TvApplicationV2 { public static void main(String[] args) { VolumeControllerV2 volumeControllerV2 = new VolumeControllerV2(); BrightnessControllerV2 brightnessControllerV2 = new BrightnessControllerV2(); ColourControllerV2 colourControllerV2 = new ColourControllerV2(); ResetFunctionV2 resetFunctionV2 = new ResetFunctionV2(volumeControllerV2, brightnessControllerV2, colourControllerV2); OUTER: while(true) { Scanner sc=new Scanner(System.in); System.out.println(" Enter your option \n Press 1 to increase volume \n Press 2 to decrease volume"); System.out.println(" Press 3 to increase brightness \n Press 4 to decrease brightness"); System.out.println(" Press 5 to increase color \n Press 6 to decrease color"); System.out.println(" Press 7 to reset TV \n Press any other Button to shutdown"); int button = sc.nextInt(); switch (button) { case 1: { volumeControllerV2.adjust(5); break; } case 2: { volumeControllerV2.adjust(-5); break; } case 3: { brightnessControllerV2.adjust(5); break; } case 4: { brightnessControllerV2.adjust(-5); break; } case 5: { colourControllerV2.adjust(5); break; } case 6: { colourControllerV2.adjust(-5); break; } case 7: { resetFunctionV2.onReset(); break; } default: System.out.println("Shutting down..........."); break OUTER; } } } }
import java.util.ArrayList; import java.util.List; import java.util.Scanner; abstract class ControllerV3 { abstract void set(int value); abstract int get(); void adjust(int value) { int temp = this.get(); if(((value > 0) && (temp >= 100)) || ((value < 0) && (temp <= 0))) { System.out.println("Can not adjust any further"); return; } this.set(temp + value); } abstract void setDefault(); } class VolumeControllerV3 extends ControllerV3 { private int defaultValue = 25; private int value; public void setDefault() { set(defaultValue); } int get() { return value; } void set(int value) { System.out.println("Old value of VolumeController \t"+this.value); this.value = value; System.out.println("New value of VolumeController \t"+this.value); } } class BrightnessControllerV3 extends ControllerV3 { private int defaultValue = 50; private int value; public void setDefault() { set(defaultValue); } int get() { return value; } void set(int value) { System.out.println("Old value of BrightnessController \t"+this.value); this.value = value; System.out.println("New value of BrightnessController \t"+this.value); } } class ColourControllerV3 extends ControllerV3 { private int defaultValue = 40; private int value; public void setDefault() { set(defaultValue); } int get() { return value; } void set(int value) { System.out.println("Old value of ColourController \t"+this.value); this.value = value; System.out.println("New value of ColourController \t"+this.value); } } class ResetFunctionV3 { private List<ControllerV3> controllers = null; ResetFunctionV3(List<ControllerV3> controllers) { this.controllers = controllers; } void onReset() { for (ControllerV3 controllerV3 :this.controllers) { controllerV3.setDefault(); } } } /* * so on * There can be n number of controllers * * */ public class TvApplicationV3 { public static void main(String[] args) { VolumeControllerV3 volumeControllerV3 = new VolumeControllerV3(); BrightnessControllerV3 brightnessControllerV3 = new BrightnessControllerV3(); ColourControllerV3 colourControllerV3 = new ColourControllerV3(); List<ControllerV3> controllerV3s = new ArrayList<>(); controllerV3s.add(volumeControllerV3); controllerV3s.add(brightnessControllerV3); controllerV3s.add(colourControllerV3); ResetFunctionV3 resetFunctionV3 = new ResetFunctionV3(controllerV3s); OUTER: while(true) { Scanner sc=new Scanner(System.in); System.out.println(" Enter your option \n Press 1 to increase volume \n Press 2 to decrease volume"); System.out.println(" Press 3 to increase brightness \n Press 4 to decrease brightness"); System.out.println(" Press 5 to increase color \n Press 6 to decrease color"); System.out.println(" Press 7 to reset TV \n Press any other Button to shutdown"); int button = sc.nextInt(); switch (button) { case 1: { volumeControllerV3.adjust(5); break; } case 2: { volumeControllerV3.adjust(-5); break; } case 3: { brightnessControllerV3.adjust(5); break; } case 4: { brightnessControllerV3.adjust(-5); break; } case 5: { colourControllerV3.adjust(5); break; } case 6: { colourControllerV3.adjust(-5); break; } case 7: { resetFunctionV3.onReset(); break; } default: System.out.println("Shutting down..........."); break OUTER; } } } }
import java.util.ArrayList; import java.util.List; import java.util.Scanner; interface OnReset { void setDefault(); } interface OnStart { void checkForDriverUpdate(); } abstract class ControllerV4 implements OnReset,OnStart { abstract void set(int value); abstract int get(); void adjust(int value) { int temp = this.get(); if(((value > 0) && (temp >= 100)) || ((value < 0) && (temp <= 0))) { System.out.println("Can not adjust any further"); return; } this.set(temp + value); } } class VolumeControllerV4 extends ControllerV4 { private int defaultValue = 25; private int value; @Override int get() { return value; } void set(int value) { System.out.println("Old value of VolumeController \t"+this.value); this.value = value; System.out.println("New value of VolumeController \t"+this.value); } @Override public void setDefault() { set(defaultValue); } @Override public void checkForDriverUpdate() { System.out.println("Checking driver update for VolumeController .... Done"); } } class BrightnessControllerV4 extends ControllerV4 { private int defaultValue = 50; private int value; @Override int get() { return value; } @Override void set(int value) { System.out.println("Old value of BrightnessController \t"+this.value); this.value = value; System.out.println("New value of BrightnessController \t"+this.value); } @Override public void setDefault() { set(defaultValue); } @Override public void checkForDriverUpdate() { System.out.println("Checking driver update for BrightnessController .... Done"); } } class ColourControllerV4 extends ControllerV4 { private int defaultValue = 40; private int value; @Override int get() { return value; } void set(int value) { System.out.println("Old value of ColourController \t"+this.value); this.value = value; System.out.println("New value of ColourController \t"+this.value); } @Override public void setDefault() { set(defaultValue); } @Override public void checkForDriverUpdate() { System.out.println("Checking driver update for ColourController .... Done"); } } class ResetFunctionV4 { private List<OnReset> controllers = null; ResetFunctionV4(List<OnReset> controllers) { this.controllers = controllers; } void onReset() { for (OnReset onreset :this.controllers) { onreset.setDefault(); } } } class InitializeDeviceV4 { private List<OnStart> controllers = null; InitializeDeviceV4(List<OnStart> controllers) { this.controllers = controllers; } void initialize() { for (OnStart onStart :this.controllers) { onStart.checkForDriverUpdate(); } } } /* * so on * There can be n number of controllers * * */ public class TvApplicationV4 { public static void main(String[] args) { VolumeControllerV4 volumeControllerV4 = new VolumeControllerV4(); BrightnessControllerV4 brightnessControllerV4 = new BrightnessControllerV4(); ColourControllerV4 colourControllerV4 = new ColourControllerV4(); List<ControllerV4> controllerV4s = new ArrayList<>(); controllerV4s.add(brightnessControllerV4); controllerV4s.add(volumeControllerV4); controllerV4s.add(colourControllerV4); List<OnStart> controllersToInitialize = new ArrayList<>(); controllersToInitialize.addAll(controllerV4s); InitializeDeviceV4 initializeDeviceV4 = new InitializeDeviceV4(controllersToInitialize); initializeDeviceV4.initialize(); List<OnReset> controllersToReset = new ArrayList<>(); controllersToReset.addAll(controllerV4s); ResetFunctionV4 resetFunctionV4 = new ResetFunctionV4(controllersToReset); OUTER: while(true) { Scanner sc=new Scanner(System.in); System.out.println(" Enter your option \n Press 1 to increase volume \n Press 2 to decrease volume"); System.out.println(" Press 3 to increase brightness \n Press 4 to decrease brightness"); System.out.println(" Press 5 to increase color \n Press 6 to decrease color"); System.out.println(" Press 7 to reset TV \n Press any other Button to shutdown"); int button = sc.nextInt(); switch (button) { case 1: { volumeControllerV4.adjust(5); break; } case 2: { volumeControllerV4.adjust(-5); break; } case 3: { brightnessControllerV4.adjust(5); break; } case 4: { brightnessControllerV4.adjust(-5); break; } case 5: { colourControllerV4.adjust(5); break; } case 6: { colourControllerV4.adjust(-5); break; } case 7: { resetFunctionV4.onReset(); break; } default: System.out.println("Shutting down..........."); break OUTER; } } } }
public void See(Friend) { System.out.println("Talk"); }
public void See(Enemy) { System.out.println("Run"); }
class animal { public void makeRumor(){ print("thump"); } } class dog extends animal { public void makeRumor(){ print("woff"); } } animal a = new dog(); dog b = new dog(); a.makeRumor() -> prints thump b.makeRumor() -> prints woff
a.makeRumor() -> prints thump b.makeRumor() -> prints woff
import java.io.IOException; class Super { protected Super getClassName(Super s) throws IOException { System.out.println(this.getClass().getSimpleName() + " - I return null; } } class SubOne extends Super { @Override protected Super getClassName(Super s) { System.out.println(this.getClass().getSimpleName() + " - I return null; } } class SubTwo extends Super { @Override protected Super getClassName(Super s) throws NullPointerException { System.out.println(this.getClass().getSimpleName() + " - I return null; } } class SubThree extends Super { @Override protected SubThree getClassName(Super s) { System.out.println(this.getClass().getSimpleName()+ " - I return null; } } class SubFour extends Super { @Override protected Super getClassName(Super s) throws IOException { System.out.println(this.getClass().getSimpleName()+ " - I return null; } } class SubFive extends Super { @Override public Super getClassName(Super s) { System.out.println(this.getClass().getSimpleName()+ " - I return null; } } class SubSix extends Super { public Super getClassName(Super s, String ol) { System.out.println(this.getClass().getSimpleName()+ " - I return null; } } class SubSeven extends Super { public Super getClassName(SubSeven s) { System.out.println(this.getClass().getSimpleName()+ " - I return null; } } public class Test{ public static void main(String[] args) throws Exception { System.out.println("Overriding\n"); Super s1 = new SubOne(); s1.getClassName(null); Super s2 = new SubTwo(); s2.getClassName(null); Super s3 = new SubThree(); s3.getClassName(null); Super s4 = new SubFour(); s4.getClassName(null); Super s5 = new SubFive(); s5.getClassName(null); System.out.println("Overloading\n"); SubSix s6 = new SubSix(); s6.getClassName(null, null); s6 = new SubSix(); s6.getClassName(null); SubSeven s7 = new SubSeven(); s7.getClassName(s7); s7 = new SubSeven(); s7.getClassName(new Super()); } }
public class ParallelTest { public static void main(String[] args) throws InterruptedException { ExecutorService es = Executors.newCachedThreadPool(); es.execute(() -> runTask(1000)); es.execute(() -> runTask(0)); es.execute(() -> runTask(0)); es.execute(() -> runTask(0)); es.execute(() -> runTask(0)); es.execute(() -> runTask(0)); es.shutdown(); es.awaitTermination(60, TimeUnit.SECONDS); } private static void runTask(int delay) { range(1, 1_000_000).parallel().filter(ParallelTest::isPrime).peek(i -> Utils.sleep(delay)).max() .ifPresent(max -> System.out.println(Thread.currentThread() + " " + max)); } public static boolean isPrime(long n) { return n > 1 && rangeClosed(2, (long) sqrt(n)).noneMatch(divisor -> n % divisor == 0); } }
ForkJoinPool forkJoinPool = new ForkJoinPool(2); forkJoinPool.submit(() -> IntStream.range(1, 1_000_000).parallel().filter(PrimesPrint::isPrime).collect(toList()) ).get();
long start = System.currentTimeMillis(); IntStream s = IntStream.range(0, 20); s.parallel().forEach(i -> { try { Thread.sleep(100); } catch (Exception ignore) {} System.out.print((System.currentTimeMillis() - start) + " "); });
ForkJoinPool forkJoinPool = new ForkJoinPool(2); CompletableFuture<List<Integer>> primes = CompletableFuture.supplyAsync(() -> range(1, 1_000_000).parallel().filter(PrimesPrint::isPrime).collect(toList()), forkJoinPool );
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "10");
Runnable r = () -> IntStream .range(-42, +42) .parallel() .map(i -> Thread.activeCount()) .max() .ifPresent(System.out::println); ForkJoinPool.commonPool().submit(r).join(); new ForkJoinPool(42).submit(r).join();
ForkJoinPool pool = new ForkJoinPool(NR_OF_THREADS); ParallelIntStreamSupport.range(1, 1_000_000, pool) .filter(PrimesPrint::isPrime) .collect(toList())
LongStream.range(4, 1_000_000).parallel(threadNum)...
ReactiveSeq.range(1, 1_000_000) .foldParallel(new ForkJoinPool(10), s->s.filter(i->true) .peek(i->System.out.println("Thread " + Thread.currentThread().getId())) .max(Comparator.naturalOrder()));
ReactiveSeq.range(1, 1_000_000) .parallel(new ForkJoinPool(10), s->s.filter(i->true) .peek(i->System.out.println("Thread " + Thread.currentThread().getId()))) .map(this::processSequentially) .forEach(System.out::println);
private static Set<String> ThreadNameSet = new HashSet<>(); private static Callable<Long> getSum() { List<Long> aList = LongStream.rangeClosed(0, 10_000_000).boxed().collect(Collectors.toList()); return () -> aList.parallelStream() .peek((i) -> { String threadName = Thread.currentThread().getName(); ThreadNameSet.add(threadName); }) .reduce(0L, Long::sum); } private static void testForkJoinPool() { final int parallelism = 10; ForkJoinPool forkJoinPool = null; Long result = 0L; try { forkJoinPool = new ForkJoinPool(parallelism); result = forkJoinPool.submit(getSum()).get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } finally { if (forkJoinPool != null) { forkJoinPool.shutdown(); } } out.println(result); out.println(ThreadNameSet); }
50000005000000 [ForkJoinPool-1-worker-8, ForkJoinPool-1-worker-9, ForkJoinPool-1-worker-6, ForkJoinPool-1-worker-11, ForkJoinPool-1-worker-10, ForkJoinPool-1-worker-1, ForkJoinPool-1-worker-15, ForkJoinPool-1-worker-13, ForkJoinPool-1-worker-4, ForkJoinPool-1-worker-2]
BlockingDeque blockingDeque = new LinkedBlockingDeque(1000); ThreadPoolExecutor fixedSizePool = new ThreadPoolExecutor(10, 20, 60, TimeUnit.SECONDS, blockingDeque, new MyThreadFactory("my-thread"));
List<Path> paths = List.of("/path/file1.csv", "/path/file2.csv", "/path/file3.csv").stream().map(e -> Paths.get(e)).collect(toList()); List<List<Path>> partitions = Lists.partition(paths, 4); partitions.forEach(group -> group.parallelStream().forEach(csvFilePath -> { }));
import java.awt.Graphics; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.logging.Level; import java.util.logging.Logger; import javax.imageio.ImageIO; import javax.swing.JPanel; public class ImagePanel extends JPanel{ private BufferedImage image; public ImagePanel() { try { image = ImageIO.read(new File("image name and path")); } catch (IOException ex) { } } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); g.drawImage(image, 0, 0, this); } }
BufferedImage myPicture = ImageIO.read(new File("path-to-file")); JLabel picLabel = new JLabel(new ImageIcon(myPicture)); add(picLabel);
BufferedImage wPic = ImageIO.read(this.getClass().getResource("snow.png")); JLabel wIcon = new JLabel(new ImageIcon(wPic));
JLabel imgLabel = new JLabel(new ImageIcon("path_to_image.png"));
protected void paintComponent(Graphics gc) { super.paintComponent(gc); Dimension cs=getSize(); gc=gc.create(); gc.clipRect(insets.left,insets.top,(cs.width-insets.left-insets.right),(cs.height-insets.top-insets.bottom)); if(mmImage!=null) { gc.drawImage(mmImage,(((cs.width-mmSize.width)/2) +mmHrzShift),(((cs.height-mmSize.height)/2) +mmVrtShift),null); } if(tlImage!=null) { gc.drawImage(tlImage,(insets.left +tlHrzShift),(insets.top +tlVrtShift),null); } if(trImage!=null) { gc.drawImage(trImage,(cs.width-insets.right-trSize.width+trHrzShift),(insets.top +trVrtShift),null); } if(blImage!=null) { gc.drawImage(blImage,(insets.left +blHrzShift),(cs.height-insets.bottom-blSize.height+blVrtShift),null); } if(brImage!=null) { gc.drawImage(brImage,(cs.width-insets.right-brSize.width+brHrzShift),(cs.height-insets.bottom-brSize.height+brVrtShift),null); } }
Class MapLabel extends Scrollable, MouseMotionListener {...}
MapIcon map = new MapIcon (); MapLabel mapLabel = new MapLabel (map); JScrollPane scrollPane = new JScrollPane(); scrollPane.getViewport ().add (mapLabel);
JPanel jPanel = new JPanel(); jPanel.add(new JLabel(new ImageIcon(getClass().getClassLoader().getResource("resource/images/polygon.jpg"))));
JFrame snakeFrame = new JFrame(); snakeFrame.setBounds(100, 200, 800, 800); snakeFrame.setVisible(true); snakeFrame.add(new JLabel(new ImageIcon("Images/Snake.png"))); snakeFrame.pack();
File f = new File("hello.jpg"); JLabel imgLabel = new JLabel(new ImageIcon(file.getName()));
@Override protected void paintComponent(Graphics g) { super.paintComponent(g); g.drawImage(image, 0, 0, this); }
keystoreFile="c:/.keystore" keystorePass="changeit"
System.setProperty("javax.net.ssl.trustStore", "C:/.keystore"); System.setProperty("javax.net.ssl.trustStorePassword", "changeit");
CATALINA_OPTS -- param name -Djavax.net.ssl.trustStore=C:\.keystore -Djavax.net.ssl.trustStorePassword=changeit ---param value
JAVA_OPTS -- param name -Djavax.net.ssl.trustStore=C:\.keystore -Djavax.net.ssl.trustStorePassword=changeit ---param value
URL url = new URL(urlStr); URLConnection conn = url.openConnection(); if (conn instanceof HttpsURLConnection) { HttpsURLConnection conn1 = (HttpsURLConnection) url.openConnection(); conn1.setHostnameVerifier(new HostnameVerifier() { public boolean verify(String hostname, SSLSession session) { return true; } }); reply.load(conn1.getInputStream());
import java.io.DataOutputStream; import java.net.HttpURLConnection; import java.net.URL; public class HTTPSPlayground { public static void main(String[] args) throws Exception { URL url = new URL("https: HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setRequestMethod("POST"); httpURLConnection.setRequestProperty("Accept-Language", "en-US,en;q=0.5"); httpURLConnection.setDoOutput(true); DataOutputStream wr = new DataOutputStream(httpURLConnection.getOutputStream()); String serializedMessage = "{}"; wr.writeBytes(serializedMessage); wr.flush(); wr.close(); int responseCode = httpURLConnection.getResponseCode(); System.out.println(responseCode); } }
echo -n | openssl s_client -connect <your domain>:443 | sed -ne
keytool -import -v -trustcacerts -alias <your domain> -file ~/<your domain>.crt -keystore <JAVA HOME>/jre/lib/security/cacerts -keypass changeit -storepass changeit
String certificatesTrustStorePath = "<JAVA HOME>/jre/lib/security/cacerts"; System.setProperty("javax.net.ssl.trustStore", certificatesTrustStorePath);
cd %JAVA_HOME%/jre/lib/security/ scp cacerts mylinuxmachin:/tmp
String certificatesTrustStorePath = "/etc/alternatives/jre/lib/security/cacerts"; System.setProperty("javax.net.ssl.trustStore", certificatesTrustStorePath); System.setProperty("javax.net.ssl.trustStorePassword", "changeit");
import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import javax.net.ssl.X509TrustManager; public class TrustAnyTrustManager implements X509TrustManager { public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { } public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { } public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[] {}; } }
HttpsURLConnection conn = null; URL url = new URL(serviceUrl); conn = (HttpsURLConnection) url.openConnection(); SSLContext sc = SSLContext.getInstance("SSL"); sc.init(null, new TrustManager[]{new TrustAnyTrustManager()}, new java.security.SecureRandom()); conn.setSSLSocketFactory(sc.getSocketFactory());
@echo off for /F %%d in ( %ProgramFiles%\Java\%%d\bin\keytool.exe -import -noprompt -trustcacerts -file some-exported-cert-saved-as.crt -keystore %ProgramFiles%\Java\%%d\lib\security\cacerts -storepass changeit ) pause
/home/mcp01$ **ps -ef |grep tomcat** tomcat7 28477 1 0 10:59 ? 00:00:18 **/usr/local/java/jdk1.7.0_15/bin/java** -Djava.util.logging.config.file=/var/lib/tomcat7/conf/logging.properties -Djava.awt.headless=true -Xmx512m -XX:+UseConcMarkSweepGC -Djava.net.preferIPv4Stack=true -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/usr/share/tomcat7/endorsed -classpath /usr/share/tomcat7/bin/bootstrap.jar:/usr/share/tomcat7/bin/tomcat-juli.jar -Dcatalina.base=/var/lib/tomcat7 -Dcatalina.home=/usr/share/tomcat7 -Djava.io.tmpdir=/tmp/tomcat7-tomcat7-tmp org.apache.catalina.startup.Bootstrap start 1005 28567 28131 0 11:34 pts/1 00:00:00 grep --color=auto tomcat
a.p.g.a.ArrayVsList.CreateArray1 [10.933, 11.097] a.p.g.a.ArrayVsList.CreateList1 [10.799, 11.046] a.p.g.a.ArrayVsList.CreateArray10000 [394.899, 404.034] a.p.g.a.ArrayVsList.CreateList10000 [396.706, 401.266]
a.p.g.a.ArrayVsList.getArray [2.958, 2.984] a.p.g.a.ArrayVsList.getList [3.841, 3.874]
a.p.g.a.ArrayVsList.setArray [4.201, 4.236] a.p.g.a.ArrayVsList.setList [6.783, 6.877]
import java.util.*; public class ArrayVsArrayList { static public void main( String[] args ) { String[] array = new String[300]; ArrayList<String> list = new ArrayList<String>(300); for (int i=0; i<300; ++i) { if (Math.random() > 0.5) { array[i] = "abc"; } else { array[i] = "xyz"; } list.add( array[i] ); } int iterations = 100000000; long start_ms; int sum; start_ms = System.currentTimeMillis(); sum = 0; for (int i=0; i<iterations; ++i) { for (int j=0; j<300; ++j) sum += array[j].length(); } System.out.println( (System.currentTimeMillis() - start_ms) + " ms (array)" ); start_ms = System.currentTimeMillis(); sum = 0; for (int i=0; i<iterations; ++i) { for (int j=0; j<300; ++j) sum += list.get(j).length(); } System.out.println( (System.currentTimeMillis() - start_ms) + " ms (ArrayList)" ); } }
private static void readArray(String[] strings) { long totalchars = 0; for (int j = 0; j < ITERATIONS; j++) { totalchars = 0; for (int i = 0; i < strings.length; i++) { totalchars += strings[i].length(); } } } private static void readArrayList(List<String> stringsList) { long totalchars = 0; for (int j = 0; j < ITERATIONS; j++) { totalchars = 0; for (int i = 0; i < stringsList.size(); i++) { totalchars += stringsList.get(i).length(); } } }
intern international internationalize internet internets
intern -> \0 international -> \0 -> ize\0 net ->\0 ->s\0
import java.util.List; import java.util.Arrays; public class IterationTest { private static final long MAX_ITERATIONS = 1000000000; public static void main(String [] args) { Integer [] array = {1, 5, 3, 5}; List<Integer> list = Arrays.asList(array); long start = System.currentTimeMillis(); int test_sum = 0; for (int i = 0; i < MAX_ITERATIONS; ++i) { for (int e : list) { test_sum += e; } } long stop = System.currentTimeMillis(); long ms = (stop - start); System.out.println("Time: " + ms); } }
import java.util.Iterator; import java.util.LinkedList; public class Array_vs_LinkedList { private final static int MAX_SIZE = 40000000; public static void main(String[] args) { LinkedList lList = new LinkedList(); long startTime = System.currentTimeMillis(); for (int i=0; i<MAX_SIZE; i++) { lList.add(i); } long stopTime = System.currentTimeMillis(); long elapsedTime = stopTime - startTime; System.out.println("[Insert]LinkedList insert operation with " + MAX_SIZE + " number of integer elapsed time is " + elapsedTime + " millisecond."); int[] arr = new int[MAX_SIZE]; startTime = System.currentTimeMillis(); for(int i=0; i<MAX_SIZE; i++){ arr[i] = i; } stopTime = System.currentTimeMillis(); elapsedTime = stopTime - startTime; System.out.println("[Insert]Array Insert operation with " + MAX_SIZE + " number of integer elapsed time is " + elapsedTime + " millisecond."); startTime = System.currentTimeMillis(); Iterator itr = lList.iterator(); while(itr.hasNext()) { itr.next(); } stopTime = System.currentTimeMillis(); elapsedTime = stopTime - startTime; System.out.println("[Loop]LinkedList iteration with " + MAX_SIZE + " number of integer elapsed time is " + elapsedTime + " millisecond."); startTime = System.currentTimeMillis(); int t = 0; for (int i=0; i < MAX_SIZE; i++) { t = arr[i]; } stopTime = System.currentTimeMillis(); elapsedTime = stopTime - startTime; System.out.println("[Loop]Array iteration with " + MAX_SIZE + " number of integer elapsed time is " + elapsedTime + " millisecond."); } }
Benchmark Mode Cnt Score Error Units MyBenchmark.testArrayForGet avgt 10 8.121 ? 0.233 ms/op MyBenchmark.testListForGet avgt 10 37.416 ? 0.094 ms/op MyBenchmark.testListForEach avgt 10 75.674 ? 1.897 ms/op
package my.jmh.test; import java.util.ArrayList; import java.util.List; import java.util.concurrent.TimeUnit; import org.openjdk.jmh.annotations.Benchmark; import org.openjdk.jmh.annotations.BenchmarkMode; import org.openjdk.jmh.annotations.Fork; import org.openjdk.jmh.annotations.Measurement; import org.openjdk.jmh.annotations.Mode; import org.openjdk.jmh.annotations.OutputTimeUnit; import org.openjdk.jmh.annotations.Scope; import org.openjdk.jmh.annotations.State; import org.openjdk.jmh.annotations.Warmup; @State(Scope.Benchmark) @Fork(1) @Warmup(iterations = 5, timeUnit = TimeUnit.SECONDS) @Measurement(iterations = 10) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.MILLISECONDS) public class MyBenchmark { public final static int ARR_SIZE = 100; public final static int ITER_COUNT = 100000; String arr[] = new String[ARR_SIZE]; List<String> list = new ArrayList<>(ARR_SIZE); public MyBenchmark() { for( int i = 0; i < ARR_SIZE; i++ ) { list.add(null); } } @Benchmark public void testListForEach() { int count = 0; for( int i = 0; i < ITER_COUNT; i++ ) { for( String str : list ) { if( str != null ) count++; } } if( count > 0 ) System.out.print(count); } @Benchmark public void testListForGet() { int count = 0; for( int i = 0; i < ITER_COUNT; i++ ) { for( int j = 0; j < ARR_SIZE; j++ ) { if( list.get(j) != null ) count++; } } if( count > 0 ) System.out.print(count); } @Benchmark public void testArrayForGet() { int count = 0; for( int i = 0; i < ITER_COUNT; i++ ) { for( int j = 0; j < ARR_SIZE; j++ ) { if( arr[j] != null ) count++; } } if( count > 0 ) System.out.print(count); } }
array Integer[] best 643ms iterator ArrayList<Integer> best 1014ms iterator array Integer[] best 635ms getter ArrayList<Integer> best 891ms getter (strange though)
array int[] best 299ms iterator array int[] best 296ms getter
public static void testArray() { final long MAX_ITERATIONS = 1000000; final int MAX_LENGTH = 1000; Random r = new Random(); int[] array = new int[MAX_LENGTH]; List<Integer> list = new ArrayList<Integer>() {{ for (int i = 0; i < MAX_LENGTH; ++i) { int val = r.nextInt(); add(val); array[i] = val; } }}; long start = System.currentTimeMillis(); int test_sum = 0; for (int i = 0; i < MAX_ITERATIONS; ++i) { for (int j = 0; j < MAX_LENGTH; ++j) { int e = array[j]; test_sum += e; } } long stop = System.currentTimeMillis(); long ms = (stop - start); System.out.println("Time: " + ms); }
public boolean add(E e) { ensureCapacity(size+1); elementData[size++] = e; return true; }
int newCapacity = oldCapacity + (oldCapacity >> 1);
private void f(Button b, final int a){ b.addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { int b = a*5; } }); }
private void f(Button b, final int a){ b.addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { int b = a*5; return b; } }); }
private void f(Button b, final int a) { final int[] res = new int[1]; b.addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { res[0] = a * 5; } }); }
final int[] res = new int[1]; Runnable r = new Runnable() { public void run() { res[0] = 123; } }; r.run(); System.out.println(res[0]);
class A { int k = 0; private void f(Button b, int a){ b.addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { k = a * 5; } }); }
public static void main(String[] args) { final int a = 3;
public class Test { public int a; public void doSomething() { Runnable runnable = new Runnable() { public void run() { System.out.println(a); a = a+1; } }; } }
private void f(Button b, final int a[]) { b.addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { a[0] = a[0] * 5; } }); }
public class Program { interface Interface { public void printInteger(); } static Interface interfaceInstance = null; static void initialize(int val) { class Impl implements Interface { @Override public void printInteger() { System.out.println(val); } } interfaceInstance = new Impl(); } public static void main(String[] args) { initialize(12345); interfaceInstance.printInteger(); } }
private ArrayList f(Button b, final int a) { final ArrayList al = new ArrayList(); b.addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { int b = a*5; al.add(b); } }); return al; }
Boolean var= new anonymousClass(){ private String myVar; @Overriden public Boolean method(int i){ } public String setVar(String var){myVar=var; return this;} }.setVar("Hello").method(3);
public static byte[] hexStringToByteArray(String s) { int len = s.length(); byte[] data = new byte[len / 2]; for (int i = 0; i < len; i += 2) { data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16)); } return data; }
import javax.xml.bind.DatatypeConverter; public static String toHexString(byte[] array) { return DatatypeConverter.printHexBinary(array); } public static byte[] toByteArray(String s) { return DatatypeConverter.parseHexBinary(s); }
import org.apache.commons.codec.binary.Hex; ... byte[] decoded = Hex.decodeHex("00A0BF");
import javax.xml.bind.annotation.adapters.HexBinaryAdapter; public byte[] hexToBytes(String hexString) { HexBinaryAdapter adapter = new HexBinaryAdapter(); byte[] bytes = adapter.unmarshal(hexString); return bytes; }
import javax.xml.bind.DatatypeConverter; public static String toHexString(byte[] array) { return DatatypeConverter.printHexBinary(array); } public static byte[] toByteArray(String s) { return DatatypeConverter.parseHexBinary(s); }
public byte[] parseHexBinary(String s) { final int len = s.length(); if( len%2 != 0 ) throw new IllegalArgumentException("hexBinary needs to be even-length: "+s); byte[] out = new byte[len/2]; for( int i=0; i<len; i+=2 ) { int h = hexToBin(s.charAt(i )); int l = hexToBin(s.charAt(i+1)); if( h==-1 || l==-1 ) throw new IllegalArgumentException("contains illegal character for hexBinary: "+s); out[i/2] = (byte)(h*16+l); } return out; } private static int hexToBin( char ch ) { if( if( if( return -1; } private static final char[] hexCode = "0123456789ABCDEF".toCharArray(); public String printHexBinary(byte[] data) { StringBuilder r = new StringBuilder(data.length*2); for ( byte b : data) { r.append(hexCode[(b >> 4) & 0xF]); r.append(hexCode[(b & 0xF)]); } return r.toString(); }
private static byte[] fromHexString(final String encoded) { if ((encoded.length() % 2) != 0) throw new IllegalArgumentException("Input string must contain an even number of characters"); final byte result[] = new byte[encoded.length()/2]; final char enc[] = encoded.toCharArray(); for (int i = 0; i < enc.length; i += 2) { StringBuilder curr = new StringBuilder(2); curr.append(enc[i]).append(enc[i + 1]); result[i/2] = (byte) Integer.parseInt(curr.toString(), 16); } return result; }
byte[] bytes = ByteString.decodeHex("c000060000").toByteArray();
public static final byte[] fromHexString(final String s) { byte[] arr = new byte[s.length()/2]; for ( int start = 0; start < s.length(); start += 2 ) { String thisByte = s.substring(start, start+2); arr[start/2] = Byte.parseByte(thisByte, 16); } return arr; }
public static byte[] HexStringToByteArray(String s) { byte data[] = new byte[s.length()/2]; for(int i=0;i < s.length();i+=2) { data[i/2] = (Integer.decode("0x"+s.charAt(i)+s.charAt(i+1))).byteValue(); } return data; }
import javax.xml.bind.DatatypeConverter; import java.io.*; public class Test { @Test public void testObjectStreams( ) throws IOException, ClassNotFoundException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); String stringTest = "TEST"; oos.writeObject( stringTest ); oos.close(); baos.close(); byte[] bytes = baos.toByteArray(); String hexString = DatatypeConverter.printHexBinary( bytes); byte[] reconvertedBytes = DatatypeConverter.parseHexBinary(hexString); assertArrayEquals( bytes, reconvertedBytes ); ByteArrayInputStream bais = new ByteArrayInputStream(reconvertedBytes); ObjectInputStream ois = new ObjectInputStream(bais); String readString = (String) ois.readObject(); assertEquals( stringTest, readString); } }
public static byte[] hexStringToByteArray(String input) { int len = input.length(); if (len == 0) { return new byte[] {}; } byte[] data; int startIdx; if (len % 2 != 0) { data = new byte[(len / 2) + 1]; data[0] = (byte) Character.digit(input.charAt(0), 16); startIdx = 1; } else { data = new byte[len / 2]; startIdx = 0; } for (int i = startIdx; i < len; i += 2) { data[(i + 1) / 2] = (byte) ((Character.digit(input.charAt(i), 16) << 4) + Character.digit(input.charAt(i+1), 16)); } return data; }
public static final byte[] fromHexString(final String s) { String[] v = s.split(" "); byte[] arr = new byte[v.length]; int i = 0; for(String val: v) { arr[i++] = Integer.decode("0x" + val).byteValue(); } return arr; }
public byte[] hex2ByteArray( String hexString ) { String hexVal = "0123456789ABCDEF"; byte[] out = new byte[hexString.length() / 2]; int n = hexString.length(); for( int i = 0; i < n; i += 2 ) { int hn = hexVal.indexOf( hexString.charAt( i ) ); int ln = hexVal.indexOf( hexString.charAt( i + 1 ) ); out[i/2] = (byte)( ( hn << 4 ) | ln ); } return out; }
boolean isOdd(int value) { return (value & 0x01) !=0; } private int hexToByte(byte[] out, int value) { String hexVal = "0123456789ABCDEF"; String hexValL = "0123456789abcdef"; String st = Integer.toHexString(value); int len = st.length(); if (isOdd(len)) { len+=1; st = ("0" + st); } out[0]=(byte)(len/2); for (int i =0;i<len;i+=2) { int hh = hexVal.indexOf(st.charAt(i)); if (hh == -1) hh = hexValL.indexOf(st.charAt(i)); int lh = hexVal.indexOf(st.charAt(i+1)); if (lh == -1) lh = hexValL.indexOf(st.charAt(i+1)); out[(i/2)+1] = (byte)((hh << 4)|lh); } return (len/2)+1; }
public static byte [] hexStringToByteArray (final String s) { if (s == null || (s.length () % 2) == 1) throw new IllegalArgumentException (); final char [] chars = s.toCharArray (); final int len = chars.length; final byte [] data = new byte [len / 2]; for (int i = 0; i < len; i += 2) { data[i / 2] = (byte) ((Character.digit (chars[i], 16) << 4) + Character.digit (chars[i + 1], 16)); } return data; }
String hex = "0001027f80fdfeff"; byte[] converted = IntStream.range(0, hex.length() / 2) .map(i -> Character.digit(hex.charAt(i * 2), 16) << 4 | Character.digit(hex.charAt((i * 2) + 1), 16)) .collect(ByteArrayOutputStream::new, ByteArrayOutputStream::write, (s1, s2) -> s1.write(s2.toByteArray(), 0, s2.size())) .toByteArray();
public static byte[] hex2ba(String sHex) throws Hex2baException { if (1==sHex.length()%2) { throw(new Hex2baException("Hex string need even number of chars")); } byte[] ba = new byte[sHex.length()/2]; for (int i=0;i<sHex.length()/2;i++) { ba[i] = (Integer.decode( "0x"+sHex.substring(i*2, (i+1)*2))).byteValue(); } return ba; }
/** * Decodes a hexadecimally encoded binary string. * <p> * Note that this function does <em>NOT</em> convert a hexadecimal number to a * binary number. * * @param hex Hexadecimal representation of data. * @return The byte[] representation of the given data. * @throws NumberFormatException If the hexadecimal input string is of odd * length or invalid hexadecimal string. */ public static byte[] hex2bin(String hex) throws NumberFormatException { if (hex.length() % 2 > 0) { throw new NumberFormatException("Hexadecimal input string must have an even length."); } byte[] r = new byte[hex.length() / 2]; for (int i = hex.length(); i > 0;) { r[i / 2 - 1] = (byte) (digit(hex.charAt(--i)) | (digit(hex.charAt(--i)) << 4)); } return r; } private static int digit(char ch) { int r = Character.digit(ch, 16); if (r < 0) { throw new NumberFormatException("Invalid hexadecimal string: " + ch); } return r; }
String data = new String(hex2bin("6578616d706c65206865782064617461"));
public final class HexString { private static final char[] digits = "0123456789ABCDEF".toCharArray(); private HexString() {} public static final String fromBytes(final byte[] bytes) { final StringBuilder buf = new StringBuilder(); for (int i = 0; i < bytes.length; i++) { buf.append(HexString.digits[(bytes[i] >> 4) & 0x0f]); buf.append(HexString.digits[bytes[i] & 0x0f]); } return buf.toString(); } public static final byte[] toByteArray(final String hexString) { if ((hexString.length() % 2) != 0) { throw new IllegalArgumentException("Input string must contain an even number of characters"); } final int len = hexString.length(); final byte[] data = new byte[len / 2]; for (int i = 0; i < len; i += 2) { data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16)); } return data; } }
public class TestHexString { @Test public void test() { String[] tests = {"0FA1056D73", "", "00", "0123456789ABCDEF", "FFFFFFFF"}; for (int i = 0; i < tests.length; i++) { String in = tests[i]; byte[] bytes = HexString.toByteArray(in); String out = HexString.fromBytes(bytes); System.out.println(in); System.out.println(out); Assert.assertEquals(in, out); } } }
public static byte[] hexToBinary(String s){ /* * skipped any input validation code */ byte[] data = new byte[s.length()/2]; for( int i=0, j=0; i<s.length() && j<data.length; i+=2, j++) { data[j] = (byte)Integer.parseInt(s.substring(i, i+2), 16); } return data; }
private String createHexDump(byte[] msg, String description) { System.out.println(); String result = "\n" + description; int currentIndex = 0; for(int i=0 ; i<msg.length ; i++){ currentIndex++; if(i == 0){ result += String.format("\n %04x ", i); } if(i % 16 == 0 && i != 0){ result += " | "; for(int j=(i-16) ; j<msg.length && j<i ; j++) { char characterToAdd = (char) msg[j]; if (characterToAdd == characterToAdd = } result += characterToAdd; } result += String.format("\n %04x ", i); } result += String.format("%02x ", msg[i]); } if(currentIndex % 16 != 0){ int fitIns = msg.length / 16; int leftOvers = msg.length - (fitIns * 16); for(int i=0 ; i<16-leftOvers ; i++){ result += " "; } result += " | "; for(int i=msg.length-leftOvers ; i<msg.length ; i++){ char characterToAdd = (char) msg[i]; if (characterToAdd == characterToAdd = } result += characterToAdd; } } result += "\n"; return result; }
S -> C 0000 0b 00 2e 06 4d 6f 72 69 74 7a 53 6f 6d 65 20 54 | .Heyyy Some T 0010 43 50 20 73 74 75 66 66 20 49 20 63 61 70 74 75 | CP stuff I captu 0020 72 65 64 2e 2e 77 65 6c 6c 20 66 6f 72 6d 61 74 | red..well format 0030 3f | ?
private static byte[] decode(String encoded) { byte result[] = new byte[encoded/2]; char enc[] = encoded.toUpperCase().toCharArray(); StringBuffer curr; for (int i = 0; i < enc.length; i += 2) { curr = new StringBuffer(""); curr.append(String.valueOf(enc[i])); curr.append(String.valueOf(enc[i + 1])); result[i] = (byte) Integer.parseInt(curr.toString(), 16); } return result; }
private static byte[] BytesEncode(String encoded) { byte result[] = new byte[encoded.length() / 2]; char enc[] = encoded.toUpperCase().toCharArray(); String curr = ""; for (int i = 0; i < encoded.length(); i=i+2) { curr = encoded.substring(i,i+2); System.out.println(curr); if(i==0){ result[i]=((byte) Integer.parseInt(curr, 16)); }else{ result[i/2]=((byte) Integer.parseInt(curr, 16)); } } return result; }
System.setProperty("file.encoding", "UTF-8"); byte inbytes[] = new byte[1024]; FileInputStream fis = new FileInputStream("response.txt"); fis.read(inbytes); FileOutputStream fos = new FileOutputStream("response-2.txt"); String in = new String(inbytes, "UTF8"); fos.write(in.getBytes());
System.setProperty("file.encoding","UTF-8"); Field charset = Charset.class.getDeclaredField("defaultCharset"); charset.setAccessible(true); charset.set(null,null);
new OutputStreamWriter( new FileOutputStream("Your_file_fullpath" ),Charset.forName("UTF8"))
String s = "    "; String out = new String(s.getBytes("UTF-8"), "ISO-8859-1");
mvn spring-boot:run -Drun.jvmArguments="-Dfile.encoding=UTF-8"
byte inbytes[] = new byte[1024]; FileInputStream fis = new FileInputStream("response.txt"); fis.read(inbytes); String in = new String(inbytes, "UTF8"); DataOutputStream out = new DataOutputStream(new FileOutputStream("response-2.txt")); out.writeUTF(in);
mvn clean install -Dfile.encoding=UTF-8 -Dmaven.repo.local=/path-to-m2
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=512m; support was removed in 8.0 Error occurred during initialization of VM java.nio.charset.IllegalCharsetNameException: "UTF-8" at java.nio.charset.Charset.checkName(Charset.java:315) at java.nio.charset.Charset.lookup2(Charset.java:484) at java.nio.charset.Charset.lookup(Charset.java:464) at java.nio.charset.Charset.defaultCharset(Charset.java:609) at sun.nio.cs.StreamEncoder.forOutputStreamWriter(StreamEncoder.java:56) at java.io.OutputStreamWriter.<init>(OutputStreamWriter.java:111) at java.io.PrintStream.<init>(PrintStream.java:104) at java.io.PrintStream.<init>(PrintStream.java:151) at java.lang.System.newPrintStream(System.java:1148) at java.lang.System.initializeSystemClass(System.java:1192)
-Dfile.encoding=MS950 -Duser.language=zh -Duser.country=TW -Dsun.jnu.encoding=MS950
InputStream in = this.getClass().getClassLoader().getResourceAsStream("SomeTextFile.txt"); InputStream in = this.getClass().getClassLoader().getResourceAsStream("/SomeTextFile.txt"); InputStream in = this.getClass().getClassLoader().getResourceAsStream("
InputStream in = this.getClass().getClassLoader() .getResourceAsStream("SomeTextFile.txt"); InputStream in = this.getClass().getResourceAsStream("/SomeTextFile.txt");
package dummy; import java.io.*; public class Test { public static void main(String[] args) { InputStream stream = Test.class.getResourceAsStream("/SomeTextFile.txt"); System.out.println(stream != null); stream = Test.class.getClassLoader().getResourceAsStream("SomeTextFile.txt"); System.out.println(stream != null); } }
Resource resource = new ClassPathResource("com/example/Foo.class");
... import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Paths; ... Files.readAllLines( Paths.get(this.getClass().getResource("res.txt").toURI()), Charset.defaultCharset());
InputStream in = this.getClass().getResourceAsStream("/SomeTextFile.txt");
try (InputStream stream = new ClassPathResource("package/resource").getInputStream()) { IOUtils.toString(stream); }
InputStream stream = null; try { stream = new ClassPathResource("/log4j.xml").getInputStream(); IOUtils.toString(stream); } finally { IOUtils.closeQuietly(stream); }
String url = this.getClass().getResource("").getPath();
ClassLoader loader = Thread.currentThread().getContextClassLoader(); InputStream is = loader.getResourceAsStream("SomeTextFile.txt");
URL resource = Resources.getResource("test.txt"); String file = resource.getFile();
InputStream is = Resources.getResource("test.txt").openStream();
private String resourceToString(String filePath) throws IOException, URISyntaxException { try (InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(filePath)) { return IOUtils.toString(inputStream); } }
String fileContents = resourceToString("ImOnTheClasspath.txt");
<?xml version="1.0" encoding="UTF-8"?> <project xmlns="http: <modelVersion>4.0.0</modelVersion> <groupId>jar-classpath-resource</groupId> <artifactId>read-classpath-resource</artifactId> <version>1.0-SNAPSHOT</version> <name>classpath-test</name> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <org.springframework.version>4.3.3.RELEASE</org.springframework.version> <mvn.release.plugin>2.5.1</mvn.release.plugin> <output.path>${project.artifactId}</output.path> <io.dropwizard.version>1.0.3</io.dropwizard.version> <commons-io.verion>2.4</commons-io.verion> </properties> <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>${org.springframework.version}</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>${org.springframework.version}</version> </dependency> <dependency> <groupId>commons-io</groupId> <artifactId>commons-io</artifactId> <version>${commons-io.verion}</version> </dependency> </dependencies> <build> <resources> <resource> <directory>src/main/resources</directory> </resource> </resources> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-release-plugin</artifactId> <version>${mvn.release.plugin}</version> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.1</version> <configuration> <source>1.8</source> <target>1.8</target> <encoding>UTF-8</encoding> </configuration> </plugin> <plugin> <artifactId>maven-jar-plugin</artifactId> <version>2.5</version> <configuration> <outputDirectory>${project.build.directory}/lib</outputDirectory> <archive> <manifest> <addClasspath>true</addClasspath> <useUniqueVersions>false</useUniqueVersions> <addDefaultImplementationEntries>true</addDefaultImplementationEntries> <mainClass>demo.read.classpath.resources.ClassPathResourceReadTest</mainClass> </manifest> <manifestEntries> <Implementation-Artifact-Id>${project.artifactId}</Implementation-Artifact-Id> <Class-Path>sample.txt</Class-Path> </manifestEntries> </archive> </configuration> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-shade-plugin</artifactId> <version>2.2</version> <configuration> <createDependencyReducedPom>false</createDependencyReducedPom> <filters> <filter> <artifact>*:*</artifact> <excludes> <exclude>META-INF/*.SF</exclude> <exclude>META-INF/*.DSA</exclude> <exclude>META-INF/*.RSA</exclude> </excludes> </filter> </filters> </configuration> <executions> <execution> <phase>package</phase> <goals> <goal>shade</goal> </goals> <configuration> <transformers> <transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" /> <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"> <mainClass>demo.read.classpath.resources.ClassPathResourceReadTest</mainClass> </transformer> </transformers> </configuration> </execution> </executions> </plugin> </plugins> </build> </project>
package demo.read.classpath.resources; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; public final class ClassPathResourceReadTest { public ClassPathResourceReadTest() throws IOException { InputStream inputStream = getClass().getResourceAsStream("/sample.txt"); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); List<Object> list = new ArrayList<>(); String line; while ((line = reader.readLine()) != null) { list.add(line); } for (Object s1: list) { System.out.println("@@@ " +s1); } System.out.println("getClass().getResourceAsStream( } }
<?xml version="1.0" encoding="UTF-8"?> <project xmlns="http: xmlns:xsi="http: xsi:schemaLocation="http: <modelVersion>4.0.0</modelVersion> <groupId>client-service</groupId> <artifactId>client-service</artifactId> <version>1.0-SNAPSHOT</version> <dependencies> <dependency> <groupId>jar-classpath-resource</groupId> <artifactId>read-classpath-resource</artifactId> <version>1.0-SNAPSHOT</version> </dependency> </dependencies> <build> <plugins> <plugin> <artifactId>maven-jar-plugin</artifactId> <version>2.5</version> <configuration> <outputDirectory>${project.build.directory}/lib</outputDirectory> <archive> <manifest> <addClasspath>true</addClasspath> <useUniqueVersions>false</useUniqueVersions> <addDefaultImplementationEntries>true</addDefaultImplementationEntries> <mainClass>com.crazy.issue.client.AccessClassPathResource</mainClass> </manifest> <manifestEntries> <Implementation-Artifact-Id>${project.artifactId}</Implementation-Artifact-Id> <Implementation-Source-SHA>${buildNumber}</Implementation-Source-SHA> <Class-Path>sample.txt</Class-Path> </manifestEntries> </archive> </configuration> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-shade-plugin</artifactId> <version>2.2</version> <configuration> <createDependencyReducedPom>false</createDependencyReducedPom> <filters> <filter> <artifact>*:*</artifact> <excludes> <exclude>META-INF/*.SF</exclude> <exclude>META-INF/*.DSA</exclude> <exclude>META-INF/*.RSA</exclude> </excludes> </filter> </filters> </configuration> <executions> <execution> <phase>package</phase> <goals> <goal>shade</goal> </goals> <configuration> <transformers> <transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" /> <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"> <mainClass>com.crazy.issue.client.AccessClassPathResource</mainClass> </transformer> </transformers> </configuration> </execution> </executions> </plugin> </plugins> </build> </project>
package com.crazy.issue.client; import demo.read.classpath.resources.ClassPathResourceReadTest; import java.io.IOException; public class AccessClassPathResource { public static void main(String[] args) throws IOException { ClassPathResourceReadTest test = new ClassPathResourceReadTest(); } }
[ravibeli@localhost lib]$ java -jar client-service-1.0-SNAPSHOT.jar **************************************** I am in resources directory of read-classpath-resource-1.0-SNAPSHOT.jar **************************************** 3) getClass().getResourceAsStream(
this.getClass().getResourceAsStream("/SomeTextFile.txt");
import java.io.BufferedReader; import java.io.File; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; public class ReadFile { /** * * feel free to make any modification I have have been here so I feel you * * * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException { File dir = new File("."); if (dir.isDirectory()) { File[] files = dir.listFiles(); for (File file : files) { if (file.getName().contains("txt")) { System.out.println(file.getName()); } if (file.getName().contains("txt")) { try { FileReader fileReader = new FileReader( file.getAbsolutePath()); BufferedReader bufferedReader = new BufferedReader( fileReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } catch (FileNotFoundException ex) { System.out.println("Unable to open file + file.getName() + " } catch (IOException ex) { System.out.println("Error reading file + file.getName() + " ex.printStackTrace(); } } } } } }
Import Project -> (Chosen directory to import) -> Import project from external model, Gradle -> Gradle Home: /usr/local/Cellar/gradle/2.4/libexec Gradle JVM: Use JAVA_HOME (not defined yet)
echo $JAVA_HOME /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home
echo export JAVA_HOME=\"/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home\" >> ~/.bashrc
sudo ln -nsf /Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents \ /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK
export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home"
<key>JVMOptions</key> <dict> <key>ClassPath</key> ... <key>JVMVersion</key> <string>1.8*</string> <key>MainClass</key> <string>com.intellij.idea.Main</string> <key>Properties</key> <dict>
1) brew cask install java (No need to install cask separately it comes with brew) 2) java -version java version "1.8.0_131" Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
class Test{ void add(Set<Integer> ii){} void add(Set<String> ss){} }
class CollectionConverter { List toList(Collection c) {...} }
class Overrider extends CollectionConverter{ List toList(Collection c) {...} }
class CollectionConverter { <T> List<T> toList(Collection<T> c) {...} }
class Overrider extends CollectionConverter { @Override List toList(Collection c) {...} @Override <T> List<T> toList(Collection<T> c) {...} }
org.codehaus.jackson.map.JsonMappingException: Infinite recursion (StackOverflowError)
@Entity @Table(name = "ta_trainee", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})}) public class Trainee extends BusinessObject { @Id @GeneratedValue(strategy = GenerationType.TABLE) @Column(name = "id", nullable = false) private Integer id; @Column(name = "name", nullable = true) private String name; @Column(name = "surname", nullable = true) private String surname; @OneToMany(mappedBy = "trainee", fetch = FetchType.EAGER, cascade = CascadeType.ALL) @Column(nullable = true) private Set<BodyStat> bodyStats; @OneToMany(mappedBy = "trainee", fetch = FetchType.EAGER, cascade = CascadeType.ALL) @Column(nullable = true) private Set<Training> trainings; @OneToMany(mappedBy = "trainee", fetch = FetchType.EAGER, cascade = CascadeType.ALL) @Column(nullable = true) private Set<ExerciseType> exerciseTypes; public Trainee() { super(); } ... getters/setters ...
import javax.persistence.*; import java.util.Date; @Entity @Table(name = "ta_bodystat", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})}) public class BodyStat extends BusinessObject { @Id @GeneratedValue(strategy = GenerationType.TABLE) @Column(name = "id", nullable = false) private Integer id; @Column(name = "height", nullable = true) private Float height; @Column(name = "measuretime", nullable = false) @Temporal(TemporalType.TIMESTAMP) private Date measureTime; @ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinColumn(name="trainee_fk") private Trainee trainee;
import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpServletResponse; import javax.validation.ConstraintViolation; import java.util.*; import java.util.concurrent.ConcurrentHashMap; @Controller @RequestMapping(value = "/trainees") public class TraineesController { final Logger logger = LoggerFactory.getLogger(TraineesController.class); private Map<Long, Trainee> trainees = new ConcurrentHashMap<Long, Trainee>(); @Autowired private ITraineeDAO traineeDAO; /** * Return json repres. of all trainees */ @RequestMapping(value = "/getAllTrainees", method = RequestMethod.GET) @ResponseBody public Collection getAllTrainees() { Collection allTrainees = this.traineeDAO.getAll(); this.logger.debug("A total of " + allTrainees.size() + " trainees was read from db"); return allTrainees; } }
@Repository @Transactional public class TraineeDAO implements ITraineeDAO { @PersistenceContext private EntityManager em; @Transactional public Trainee save(Trainee trainee) { em.persist(trainee); return trainee; } @Transactional(readOnly = true) public Collection getAll() { return (Collection) em.createQuery("SELECT t FROM Trainee t").getResultList(); } }
<persistence xmlns="http: xmlns:xsi="http: xsi:schemaLocation="http: version="1.0"> <persistence-unit name="RDBMS" transaction-type="RESOURCE_LOCAL"> <exclude-unlisted-classes>false</exclude-unlisted-classes> <properties> <property name="hibernate.hbm2ddl.auto" value="validate"/> <property name="hibernate.archive.autodetection" value="class"/> <property name="dialect" value="org.hibernate.dialect.MySQL5InnoDBDialect"/> <!-- <property name="dialect" value="org.hibernate.dialect.HSQLDialect"/> --> </properties> </persistence-unit> </persistence>
@Entity @Table(name = "ta_trainee", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})}) public class Trainee extends BusinessObject { @OneToMany(mappedBy = "trainee", fetch = FetchType.EAGER, cascade = CascadeType.ALL) @Column(nullable = true) @JsonManagedReference private Set<BodyStat> bodyStats;
@Entity @Table(name = "ta_bodystat", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})}) public class BodyStat extends BusinessObject { @ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinColumn(name="trainee_fk") @JsonBackReference private Trainee trainee;
@Entity public class Material{ ... @JsonIgnoreProperties("costMaterials") private List<Supplier> costSuppliers = new ArrayList<>(); ... } @Entity public class Supplier{ ... @JsonIgnoreProperties("costSuppliers") private List<Material> costMaterials = new ArrayList<>(); .... }
@Entity @Table(name = "ta_trainee", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})}) @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@traineeId") public class Trainee extends BusinessObject { @Entity @Table(name = "ta_bodystat", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})}) @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@bodyStatId") public class BodyStat extends BusinessObject {
@ManyToOne @JoinColumn(name = "ID", nullable = false, updatable = false) @JsonIgnore private Member member;
<dependency> <groupId>com.fasterxml.jackson.datatype</groupId> <artifactId>jackson-datatype-hibernate4</artifactId> <version>2.4.0</version> </dependency>
ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new Hibernate4Module());
@OneToMany(mappedBy = "county") private List<Town> towns;
@ManyToOne @JoinColumn(name = "county_id") private County county;
import com.fasterxml.jackson.databind.ObjectMapper; ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(model);
public class Company { private Employee employee; public Company(Employee employee) { this.employee = employee; } public Employee getEmployee() { return employee; } } public class Employee { private Company company; public Company getCompany() { return company; } public void setCompany(Company company) { this.company = company; } }
@SpringBootTest @RunWith(SpringRunner.class) @Transactional public class CompanyTest { @Autowired public ObjectMapper mapper; @Test public void shouldSaveCompany() throws JsonProcessingException { Employee employee = new Employee(); Company company = new Company(employee); employee.setCompany(company); String jsonCompany = mapper.writeValueAsString(company); System.out.println(jsonCompany); assertTrue(true); } }
org.codehaus.jackson.map.JsonMappingException: Infinite recursion (StackOverflowError)
public class Filter { public static interface EmployeeData {}; public static interface CompanyData extends EmployeeData {}; }
public class Company { @JsonView(Filter.CompanyData.class) private Employee employee; public Company(Employee employee) { this.employee = employee; } public Employee getEmployee() { return employee; } }
@SpringBootTest @RunWith(SpringRunner.class) @Transactional public class CompanyTest { @Autowired public ObjectMapper mapper; @Test public void shouldSaveCompany() throws JsonProcessingException { Employee employee = new Employee(); Company company = new Company(employee); employee.setCompany(company); ObjectWriter writter = mapper.writerWithView(Filter.CompanyData.class); String jsonCompany = writter.writeValueAsString(company); System.out.println(jsonCompany); assertTrue(true); } }
import static org.junit.Assert.assertTrue; import javax.transaction.Transactional; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.ObjectWriter; import com.fasterxml.jackson.annotation.JsonView;
@ManyToOne @JoinColumn(name="Key") @JsonBackReference private LgcyIsp Key; @OneToMany(mappedBy="LgcyIsp ") @JsonManagedReference private List<Safety> safety;
@Entity @Table(name = "ta_trainee", uniqueConstraints = {@UniqueConstraint(columnNames = {"id"})}) @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id") public class Trainee extends BusinessObject { ...
@ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinColumn(name="trainee_fk") private Trainee trainee;
@OneToMany(mappedBy = "trainee", fetch = FetchType.EAGER, cascade = CascadeType.ALL) @Column(nullable = true) private Set<BodyStat> bodyStats;
@OneToMany(mappedBy = "course",fetch=FetchType.EAGER) @JsonIgnoreProperties("course") private Set<Student> students;
public class A{ private int id; private String code; private String name; private List<B> bs; } public class B{ private int id; private String code; private String name; private A a; }
public class A{ private int id; private String code; private String name; private List<B> bs; public A(){ } public A(int id, String code, String name){ this.id = id; this.code = code; this.name = name; } }
public A getAById(int id); public List<B> getBsByAId(int idA);
Intent intent = new Intent(getApplicationContext(), Home.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent);
Intent intent = new Intent(getApplicationContext(), LoginActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); intent.putExtra("EXIT", true); startActivity(intent);
if (getIntent().getBooleanExtra("EXIT", false)) { finish(); }
Intent intent = new Intent(this, classObject); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | IntentCompat.FLAG_ACTIVITY_CLEAR_TASK); startActivity(intent);
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
@Override public void onBackPressed() { finishAffinity(); startActivity(new Intent(PaymentDoneActivity.this,Home.class)); }
Intent intent = new Intent(getApplicationContext(), LoginActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK|Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); this.finish();
Intent intent = new Intent(getApplicationContext(), LoginActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent);
Intent intent = new Intent(getApplicationContext(), LoginActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent);
Intent intent = new Intent(getBaseContext(), LoginActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent);
public boolean onKeyDown(int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_BACK) { moveTaskToBack(true); return true; } return super.onKeyDown(keyCode, event); }
{ Intent intent = new Intent(this, loginScreen.class); ntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK); startActivity(intent); }
Intent i1=new Intent(getApplicationContext(),StartUp_Page.class); i1.setAction(Intent.ACTION_MAIN); i1.addCategory(Intent.CATEGORY_HOME); i1.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); i1.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK); i1.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK); startActivity(i1); finish();
import android.support.v4.content.IntentCompat; intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |IntentCompat.FLAG_ACTIVITY_CLEAR_TASK);
Intent nextScreen = new Intent(currentActivity.this, MainActivity.class); nextScreen.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | IntentCompat.FLAG_ACTIVITY_CLEAR_TASK); startActivity(nextScreen); ActivityCompat.finishAffinity(currentActivity.this);
Intent intent = new Intent(this, LoginActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent);
Intent intent = new Intent(this, Screen1.class); intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent);
final Intent intent = new Intent(getBaseContext(), LoginScreen.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); context.startActivity(intent);
Intent startMain = new Intent(Intent.ACTION_MAIN); startMain.addCategory(Intent.CATEGORY_HOME); startMain.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(startMain); Intent intent = new Intent(getApplicationContext(), SplashScreen.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); finish(); System.exit(0);
Intent intent = new Intent(getApplicationContext(), LoginActivity.class); ComponentName cn = intent.getComponent(); Intent mainIntent = IntentCompat.makeRestartActivityTask(cn); startActivity(mainIntent);
android { compileSdkVersion 23 buildToolsVersion defaultConfig { applicationId "yourpackage" minSdkVersion 14 targetSdkVersion 23 versionCode 1 versionName "1.0" multiDexEnabled true } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile( } } packagingOptions { } dexOptions { javaMaxHeapSize "4g" } }
-XX:+UseG1GC -XX:G1HeapRegionSize=n, -XX:MaxGCPauseMillis=m, -XX:ParallelGCThreads=n, -XX:ConcGCThreads=n`
set WLS_HOME=%WL_HOME%\server set XMS_SUN_64BIT=256 set XMS_SUN_32BIT=256 set XMX_SUN_64BIT=3072 set XMX_SUN_32BIT=3072 set XMS_JROCKIT_64BIT=256 set XMS_JROCKIT_32BIT=256 set XMX_JROCKIT_64BIT=1024 set XMX_JROCKIT_32BIT=1024 if "%JAVA_VENDOR%"=="Sun" ( set WLS_MEM_ARGS_64BIT=-Xms256m -Xmx512m set WLS_MEM_ARGS_32BIT=-Xms256m -Xmx512m ) else ( set WLS_MEM_ARGS_64BIT=-Xms512m -Xmx512m set WLS_MEM_ARGS_32BIT=-Xms512m -Xmx512m ) and set MEM_PERM_SIZE_64BIT=-XX:PermSize=256m set MEM_PERM_SIZE_32BIT=-XX:PermSize=256m if "%JAVA_USE_64BIT%"=="true" ( set MEM_PERM_SIZE=%MEM_PERM_SIZE_64BIT% ) else ( set MEM_PERM_SIZE=%MEM_PERM_SIZE_32BIT% ) set MEM_MAX_PERM_SIZE_64BIT=-XX:MaxPermSize=1024m set MEM_MAX_PERM_SIZE_32BIT=-XX:MaxPermSize=1024m
Iterator it = paramMap.entrySet().iterator(); while (it.hasNext()) { Map.Entry pairs = (Map.Entry) it.next(); questionAnswers += pairs.getKey() + ","; }
SortedSet<String> keys = new TreeSet<>(map.keySet()); for (String key : keys) { String value = map.get(key); }
Comparator<Foo> comparator = (Foo o1, Foo o2) -> { ... } SortedSet<Foo> keys = new TreeSet<>(comparator); keys.addAll(map.keySet());
List sortedKeys=new ArrayList(yourMap.keySet()); Collections.sort(sortedKeys);
Map<String, String> map = new HashMap<>(); Map<String, String> treeMap = new TreeMap<>(map); for (String str : treeMap.keySet()) { System.out.println(str); }
Map<String, String> treeMap = new TreeMap<String, String>(yourMap);
import java.util.HashMap; import java.util.Set; import java.util.Map; import java.util.TreeMap; import java.util.Iterator; class SortOnKey { public static void main(String[] args) { HashMap<String,String> hm = new HashMap<String,String>(); hm.put("3","three"); hm.put("1","one"); hm.put("4","four"); hm.put("2","two"); printMap(hm); Map<String, String> treeMap = new TreeMap<String, String>(hm); printMap(treeMap); } public static void printMap(Map<String,String> map) { Set s = map.entrySet(); Iterator it = s.iterator(); while ( it.hasNext() ) { Map.Entry entry = (Map.Entry) it.next(); String key = (String) entry.getKey(); String value = (String) entry.getValue(); System.out.println(key + " => " + value); } System.out.println("========================"); } }
Map<String,String> sample = new HashMap<>(); Map<String, String> newMapSortedByKey = sample.entrySet().stream() .sorted(Map.Entry.<String,String>comparingByKey().reversed()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new)); Map<String, String> newMapSortedByValue = sample.entrySet().stream() .sorted(Map.Entry.<String,String>comparingByValue().reversed()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1,e2) -> e1, LinkedHashMap::new));
Map<String, String> newMapSortedByKey = sample.entrySet().stream() .sorted((e1,e2) -> e1.getKey().compareTo(e2.getKey())) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1,e2) -> e1, LinkedHashMap::new));
<K, V extends Comparable<V>> Map<K, V> sortByValues (final Map<K, V> map, int ascending) { Comparator<K> valueComparator = new Comparator<K>() { private int ascending; public int compare(K k1, K k2) { int compare = map.get(k2).compareTo(map.get(k1)); if (compare == 0) return 1; else return ascending*compare; } public Comparator<K> setParam(int ascending) { this.ascending = ascending; return this; } }.setParam(ascending); Map<K, V> sortedByValues = new TreeMap<K, V>(valueComparator); sortedByValues.putAll(map); return sortedByValues; }
Map<Integer,Double> recommWarrVals = new HashMap<Integer,Double>(); recommWarrVals = sortByValues(recommWarrVals, 1); recommWarrVals = sortByValues(recommWarrVals,-1);
Map<String, Integer> sortedMap = unsortMap.entrySet().stream() .sorted(Map.Entry.comparingByKey()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -> oldValue, LinkedHashMap::new));
List<K> result = map.keySet().stream().sorted().collect(Collectors.toList());
List<Map.Entry<K, V>> result = map.entrySet() .stream() .sorted(Map.Entry.comparingByKey()) .collect(Collectors.toList());
Collator collator = Collator.getInstance(Locale.US); collator.setStrength(Collator.PRIMARY); List<Map.Entry<String, String>> result = map.entrySet() .stream() .sorted(Map.Entry.comparingByKey(collator)) .collect(Collectors.toList());
List<String> list = new ArrayList<String>(); Map<String, String> map = new HashMap<String, String>(); for (String str : map.keySet()) { list.add(str); } Collections.sort(list); for (String str : list) { System.out.println(str); }
Map<String, String> map = new HashMap<String, String>(); Object[] objArr = new Object[map.size()]; for (int i = 0; i < map.size(); i++) { objArr[i] = map.get(i); } Arrays.sort(objArr); for (Object str : objArr) { System.out.println(str); }
myMap.keySet().stream().sorted().forEach(key -> { String value = myMap.get(key); System.out.println("key: " + key); System.out.println("value: " + value); } );
private interface CLibrary extends Library { CLibrary INSTANCE = (CLibrary) Native.loadLibrary("c", CLibrary.class); int getpid (); }
java.lang.management.RuntimeMXBean runtime = java.lang.management.ManagementFactory.getRuntimeMXBean(); java.lang.reflect.Field jvm = runtime.getClass().getDeclaredField("jvm"); jvm.setAccessible(true); sun.management.VMManagement mgmt = (sun.management.VMManagement) jvm.get(runtime); java.lang.reflect.Method pid_method = mgmt.getClass().getDeclaredMethod("getProcessId"); pid_method.setAccessible(true); int pid = (Integer) pid_method.invoke(mgmt);
private Sigar sigar; public synchronized Sigar getSigar() { if (sigar == null) { sigar = new Sigar(); } return sigar; } public synchronized void forceRelease() { if (sigar != null) { sigar.close(); sigar = null; } } public long getPid() { return getSigar().getPid(); }
private static String getProcessId(final String fallback) { final String jvmName = ManagementFactory.getRuntimeMXBean().getName(); final int index = jvmName.indexOf( if (index < 1) { return fallback; } try { return Long.toString(Long.parseLong(jvmName.substring(0, index))); } catch (NumberFormatException e) { } return fallback; }
private static String getPid() throws IOException { byte[] bo = new byte[256]; InputStream is = new FileInputStream("/proc/self/stat"); is.read(bo); for (int i = 0; i < bo.length; i++) { if ((bo[i] < return new String(bo, 0, i); } } return "-1"; }
public abstract class Process { ... public long getPid(); }
String jvmName = ManagementFactory.getRuntimeMXBean().getName(); return jvmName.split("@")[0];
int pid = Integer.parseInt(ManagementFactory.getRuntimeMXBean().getName().split("@")[0]);
ApplicationPid pid = new ApplicationPid(); pid.toString();
public static long getPID() { String processName = java.lang.management.ManagementFactory.getRuntimeMXBean().getName(); if (processName != null && processName.length() > 0) { try { return Long.parseLong(processName.split("@")[0]); } catch (Exception e) { return 0; } } return 0; }
import sys.process._ val pid: Long = Seq("sh", "-c", "echo $PPID").!!.trim.toLong
String jps = [JDK HOME] + "\\bin\\jps.exe"; Process p = Runtime.getRuntime().exec(jps);
java.lang.management.ManagementFactory.getRuntimeMXBean().getName().split("@")[0]
import org.hyperic.sigar.Sigar; Sigar sigar = new Sigar(); long pid = sigar.getPid(); sigar.close();
package my.code.a003.process; import sun.jvmstat.monitor.HostIdentifier; import sun.jvmstat.monitor.MonitorException; import sun.jvmstat.monitor.MonitoredHost; import sun.jvmstat.monitor.MonitoredVm; import sun.jvmstat.monitor.MonitoredVmUtil; import sun.jvmstat.monitor.VmIdentifier; public class GetOwnPid { public static void main(String[] args) { new GetOwnPid().run(); } public void run() { System.out.println(getPid(this.getClass())); } public Integer getPid(Class<?> mainClass) { MonitoredHost monitoredHost; Set<Integer> activeVmPids; try { monitoredHost = MonitoredHost.getMonitoredHost(new HostIdentifier((String) null)); activeVmPids = monitoredHost.activeVms(); MonitoredVm mvm = null; for (Integer vmPid : activeVmPids) { try { mvm = monitoredHost.getMonitoredVm(new VmIdentifier(vmPid.toString())); String mvmMainClass = MonitoredVmUtil.mainClass(mvm, true); if (mainClass.getName().equals(mvmMainClass)) { return vmPid; } } finally { if (mvm != null) { mvm.detach(); } } } } catch (java.net.URISyntaxException e) { throw new InternalError(e.getMessage()); } catch (MonitorException e) { throw new InternalError(e.getMessage()); } return null; } }
public static void main(String[] args) { NodeJS nodeJS = NodeJS.createNodeJS(); int pid = nodeJS.getRuntime().executeIntegerScript("process.pid;\n"); System.out.println(pid); nodeJS.release(); }
final RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean(); final long pid = runtime.getPid(); out.println("Process ID is
public static boolean isPIDInUse(int pid) { try { String s = null; int java_pid; RuntimeMXBean rt = ManagementFactory.getRuntimeMXBean(); java_pid = Integer.parseInt(rt.getName().substring(0, rt.getName().indexOf("@"))); if (java_pid == pid) { System.out.println("In Use\n"); return true; } } catch (Exception e) { System.out.println("Exception: " + e.getMessage()); } return false; }
Path tempDirWithPrefix = Files.createTempDirectory(prefix);
public static File createTempDirectory() throws IOException { final File temp; temp = File.createTempFile("temp", Long.toString(System.nanoTime())); if(!(temp.delete())) { throw new IOException("Could not delete temp file: " + temp.getAbsolutePath()); } if(!(temp.mkdir())) { throw new IOException("Could not create temp directory: " + temp.getAbsolutePath()); } return (temp); }
@Rule public TemporaryFolder folder = new TemporaryFolder();
@Test @ExtendWith(TempDirectory.class) void test(@TempDir Path tempDir) { Path file = tempDir.resolve("test.txt"); writeFile(file); assertExpectedFileContent(file); }
<dependency> <groupId>org.junit-pioneer</groupId> <artifactId>junit-pioneer</artifactId> <version>0.1.2</version> <scope>test</test> </dependency>
public static Path createTempDirectory(Path dir, String prefix, FileAttribute<?>... attrs) throws IOException
public static File createTempDir() { File baseDir = new File(System.getProperty("java.io.tmpdir")); String baseName = System.currentTimeMillis() + "-"; for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) { File tempDir = new File(baseDir, baseName + counter); if (tempDir.mkdir()) { return tempDir; } } throw new IllegalStateException("Failed to create directory within " + TEMP_DIR_ATTEMPTS + " attempts (tried " + baseName + "0 to " + baseName + (TEMP_DIR_ATTEMPTS - 1) + }
private static final int TEMP_DIR_ATTEMPTS = 10000;
/** * Create a new temporary directory. Use something like * {@link * deleted automatically * @return the new directory * @throws IOException if there is an error creating the temporary directory */ public static File createTempDir() throws IOException { final File sysTempDir = new File(System.getProperty("java.io.tmpdir")); File newTempDir; final int maxAttempts = 9; int attemptCount = 0; do { attemptCount++; if(attemptCount > maxAttempts) { throw new IOException( "The highly improbable has occurred! Failed to " + "create a unique temporary directory after " + maxAttempts + " attempts."); } String dirName = UUID.randomUUID().toString(); newTempDir = new File(sysTempDir, dirName); } while(newTempDir.exists()); if(newTempDir.mkdirs()) { return newTempDir; } else { throw new IOException( "Failed to create temp dir named " + newTempDir.getAbsolutePath()); } } /** * Recursively delete file or directory * @param fileOrDir * the file or dir to delete * @return * true iff all files are successfully deleted */ public static boolean recursiveDelete(File fileOrDir) { if(fileOrDir.isDirectory()) { for(File innerFile: fileOrDir.listFiles()) { if(!FileUtilities.recursiveDelete(innerFile)) { return false; } } } return fileOrDir.delete(); }
/** Maximum loop count when creating temp directories. */ private static final int TEMP_DIR_ATTEMPTS = 10000; /** * Atomically creates a new directory somewhere beneath the system * defined by the {@code java.io.tmpdir} system property), and returns its name. * * <p>Use this method instead of {@link File * create a directory, not a regular file. A common pitfall is to call {@code createTempFile}, * delete the file and create a directory in its place, but this leads a race condition which can * be exploited to create security vulnerabilities, especially when executable files are to be * written into the directory. * * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks, * and that it will not be called thousands of times per second. * * @return the newly-created directory * @throws IllegalStateException if the directory could not be created */ public static File createTempDir() { File baseDir = new File(System.getProperty("java.io.tmpdir")); String baseName = System.currentTimeMillis() + "-"; for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) { File tempDir = new File(baseDir, baseName + counter); if (tempDir.mkdir()) { return tempDir; } } throw new IllegalStateException( "Failed to create directory within " + TEMP_DIR_ATTEMPTS + " attempts (tried " + baseName + "0 to " + baseName + (TEMP_DIR_ATTEMPTS - 1) + }
public static final String tempDir = System.getProperty("java.io.tmpdir")+"tmp"+System.nanoTime(); static { File f = new File(tempDir); if(!f.exists()) f.mkdir(); }
Runtime.getRuntime().addShutdownHook(new Thread() { @Override public void run() { String root = MainWindow.tempDir; Stack<String> dirStack = new Stack<String>(); dirStack.push(root); while(!dirStack.empty()) { String dir = dirStack.pop(); File f = new File(dir); if(f.listFiles().length==0) f.delete(); else { dirStack.push(dir); for(File ff: f.listFiles()) { if(ff.isFile()) ff.delete(); else if(ff.isDirectory()) dirStack.push(ff.getPath()); } } } } });
public static File createTempDir() { final String baseTempPath = System.getProperty("java.io.tmpdir"); Random rand = new Random(); int randomInt = 1 + rand.nextInt(); File tempDir = new File(baseTempPath + File.separator + "tempDir" + randomInt); if (tempDir.exists() == false) { tempDir.mkdir(); } tempDir.deleteOnExit(); return tempDir; }
/** * Creates a temporary subdirectory in the standard temporary directory. * This will be automatically deleted upon exit. * * @param prefix * the prefix used to create the directory, completed by a * current timestamp. Use for instance your application * @return the directory */ public static File createTempDirectory(String prefix) { final File tmp = new File(FileUtils.getTempDirectory().getAbsolutePath() + "/" + prefix + System.currentTimeMillis()); tmp.mkdir(); Runtime.getRuntime().addShutdownHook(new Thread() { @Override public void run() { try { FileUtils.deleteDirectory(tmp); } catch (IOException e) { e.printStackTrace(); } } }); return tmp; }
File folder = File.createTempFile("testFileUtils", ""); folder.delete(); folder.mkdirs(); folder.deleteOnExit();
doThrow(new Exception()).when(mockedObject.methodReturningVoid(...));
doThrow(new Exception()).when(mockedObject).methodReturningVoid(...); ^
doThrow(new Exception()).when(mockedObject.methodReturningVoid(...)); ^
willThrow(new Exception()).given(mockedObject).methodReturningVoid(...));
<user username="tomcat" password="tomcat" roles="tomcat,role1,manager-gui"/>
<! 50MB max > <max-file-size>52428800</max-file-size> <max-request-size>52428800</max-request-size> <file-size-threshold>0</file-size-threshold> </multipart-config>
sudo service tomcat7 stop mvn clean package sudo cp target/DestroyTheWorldWithPeace.war /var/lib/tomcat7/webapps/ sudo service tomcat7 start
@RequestMapping(value = "/files/{file_name}", method = RequestMethod.GET) public void getFile( @PathVariable("file_name") String fileName, HttpServletResponse response) { try { InputStream is = ...; org.apache.commons.io.IOUtils.copy(is, response.getOutputStream()); response.flushBuffer(); } catch (IOException ex) { log.info("Error writing file to output stream. Filename was throw new RuntimeException("IOError writing file to output stream"); } }
@RequestMapping(value = "/files/{file_name}", method = RequestMethod.GET) @ResponseBody public FileSystemResource getFile(@PathVariable("file_name") String fileName) { return new FileSystemResource(myService.getFileFor(fileName)); }
response.setContentType("application/pdf"); response.setHeader("Content-Disposition", "attachment; filename=\"somefile.pdf\"");
@RequestMapping(value = "/files/{fileName}", method = RequestMethod.GET) public HttpEntity<byte[]> createPdf( @PathVariable("fileName") String fileName) throws IOException { byte[] documentBody = this.pdfFramework.createPdf(filename); HttpHeaders header = new HttpHeaders(); header.setContentType(MediaType.APPLICATION_PDF); header.set(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + fileName.replace(" ", "_")); header.setContentLength(documentBody.length); return new HttpEntity<byte[]>(documentBody, header); }
@RequestMapping(value = "/files/{fileName}", method = RequestMethod.GET) public HttpEntity<byte[]> createPdf( @PathVariable("fileName") String fileName) throws IOException { File document = this.pdfFramework.createPdf(filename); HttpHeaders header = new HttpHeaders(); header.setContentType(MediaType.APPLICATION_PDF); header.set(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + fileName.replace(" ", "_")); header.setContentLength(document.length()); return new HttpEntity<byte[]>(new FileSystemResource(document), header); }
@RequestMapping(value = "/stuff/{stuffId}", method = RequestMethod.GET) public ResponseEntity<InputStreamResource> downloadStuff(@PathVariable int stuffId) throws IOException { String fullPath = stuffService.figureOutFileNameFor(stuffId); File file = new File(fullPath); HttpHeaders respHeaders = new HttpHeaders(); respHeaders.setContentType("application/pdf"); respHeaders.setContentLength(12345678); respHeaders.setContentDispositionFormData("attachment", "fileNameIwant.pdf"); InputStreamResource isr = new InputStreamResource(new FileInputStream(file)); return new ResponseEntity<InputStreamResource>(isr, respHeaders, HttpStatus.OK); }
@RequestMapping(value="/downloadLogFile") public void getLogFile(HttpSession session,HttpServletResponse response) throws Exception { try { String filePathToBeServed = File fileToDownload = new File(filePathToBeServed); InputStream inputStream = new FileInputStream(fileToDownload); response.setContentType("application/force-download"); response.setHeader("Content-Disposition", "attachment; filename="+fileName+".txt"); IOUtils.copy(inputStream, response.getOutputStream()); response.flushBuffer(); inputStream.close(); } catch (Exception e){ LOGGER.debug("Request could not be completed at this moment. Please try again."); e.printStackTrace(); } }
@RequestMapping(value = "/download", method = RequestMethod.GET) public ResponseEntity<byte[]> getDownloadData() throws Exception { String regData = "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry byte[] output = regData.getBytes(); HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.set("charset", "utf-8"); responseHeaders.setContentType(MediaType.valueOf("text/html")); responseHeaders.setContentLength(output.length); responseHeaders.set("Content-disposition", "attachment; filename=filename.txt"); return new ResponseEntity<byte[]>(output, responseHeaders, HttpStatus.OK); }
request.getRequestDispatcher("/downloads/<RANDOM-FILENAME>.pdf").forward(request, response);
<bean id="pdfViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"> <property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /> <property name="order" value=2/> <property name="prefix" value="/downloads/" /> <property name="suffix" value=".pdf" /> </bean>
@RequestMapping(value = "/download", method = RequestMethod.GET) public void getFile(HttpServletResponse response) { try { DefaultResourceLoader loader = new DefaultResourceLoader(); InputStream is = loader.getResource("classpath:META-INF/resources/Accepted.pdf").getInputStream(); IOUtils.copy(is, response.getOutputStream()); response.setHeader("Content-Disposition", "attachment; filename=Accepted.pdf"); response.flushBuffer(); } catch (IOException ex) { throw new RuntimeException("IOError writing file to output stream"); } }
@RequestMapping(value="/download") public void getLogFile(HttpSession session,HttpServletResponse response) throws Exception { try { String fileName="archivo demo.pdf"; String filePathToBeServed = "C:\\software\\Tomcat 7.0\\tmpFiles\\"; File fileToDownload = new File(filePathToBeServed+fileName); InputStream inputStream = new FileInputStream(fileToDownload); response.setContentType("application/force-download"); response.setHeader("Content-Disposition", "attachment; filename="+fileName); IOUtils.copy(inputStream, response.getOutputStream()); response.flushBuffer(); inputStream.close(); } catch (Exception exception){ System.out.println(exception.getMessage()); } }
@Qualifier @Retention(RUNTIME) public @interface YourQualifier {}
<bean class="com.pkg.SomeBean"> <qualifier type="YourQualifier"/> </bean>
@YourQualifier @Component public class SomeBean implements Foo { .. }
interface parent { } @Service("actualService") class ActualService implements parent{ } @Service("stubbedService") class SubbedService implements parent{ }
@Autowired @Qualifier("actualService") or @Qualifier("stubbedService") Parent object;
import java.util.UUID; public class RandomStringUUID { public static void main(String[] args) { UUID uuid = UUID.randomUUID(); String randomUUIDString = uuid.toString(); System.out.println("UUID=" + randomUUIDString ); } }
import java.util.concurrent.TimeUnit; import org.apache.log4j.Logger; public class StrictMicroSecondTimeBasedGuid { private final static Logger logger = Logger .getLogger(StrictMicroSecondTimeBasedGuid.class); private static final long MICRO_IN_MILL = 1000; private static final long NANO_IN_MICRO = 1000; private static long baseNanoTime; private static long baseTimeInMicro; private static long lastGuid; static { /* * Nanosecond time * needed to calculate time in micro without knowing refrence point of * nano time* */ baseNanoTime = System.nanoTime(); baseTimeInMicro = System.currentTimeMillis() * MICRO_IN_MILL; lastGuid = baseTimeInMicro; } public static synchronized Long newGuid() { long newGuid; while ((newGuid = calNewTimeInMicro()) <= lastGuid) { /** we have to check for this log, we don logger.debug("wait of 10-microsecond is introduced to get new guid"); try { TimeUnit.MICROSECONDS.sleep(10); } catch (InterruptedException e) { logger.error("Error", e); } } lastGuid = newGuid; return newGuid; } private static long calNewTimeInMicro() { return baseTimeInMicro + ((System.nanoTime() - baseNanoTime) / NANO_IN_MICRO); } }
mimeType = file.toURL().openConnection().getContentType();
mimeType= URLConnection.guessContentTypeFromName(file.getName());
InputStream is = new BufferedInputStream(new FileInputStream(file)); mimeType = URLConnection.guessContentTypeFromStream(is);
String fileName = "/path/to/file"; MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap(); String mimeType = mimeTypesMap.getContentType(fileName); File file = new File(fileName); mimeType = mimeTypesMap.getContentType(file);
File file = new File("/path/to/file"); Tika tika = new Tika(); System.out.println(tika.detect(file));
@Grab( import org.apache.tika.Tika; def tika = new Tika() def file = new File("/path/to/file") println tika.detect(file)
String detect(byte[] prefix) String detect(byte[] prefix, String name) String detect(File file) String detect(InputStream stream) String detect(InputStream stream, Metadata metadata) String detect(InputStream stream, String name) String detect(Path path) String detect(String name) String detect(URL url)
try (InputStream is = theInputStream; BufferedInputStream bis = new BufferedInputStream(is);) { AutoDetectParser parser = new AutoDetectParser(); Detector detector = parser.getDetector(); Metadata md = new Metadata(); md.add(Metadata.RESOURCE_NAME_KEY, theFileName); MediaType mediaType = detector.detect(bis, md); return mediaType.toString(); }
private static String getMimeType(String fileUrl) { String extension = MimeTypeMap.getFileExtensionFromUrl(fileUrl); return MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension); }
FileNameMap fileNameMap = URLConnection.getFileNameMap(); String mimeType = fileNameMap.getContentTypeFor("alert.gif");
ContentInfoUtil util = new ContentInfoUtil(); ... ContentInfo info = util.findMatch("/tmp/upload.tmp"); ContentInfo info = util.findMatch(inputStream); ContentInfo info = util.findMatch(contentByteArray); if (info != null) { String mimeType = info.getMimeType(); }
public static String getContentType(byte[] data, String name)
new MimetypesFileTypeMap().getContentType( fileName );
Files.probeContentType(Paths.get("either file name or full path goes here"));
MimeUtil2 mimeUtil = new MimeUtil2(); mimeUtil.registerMimeDetector("eu.medsea.mimeutil.detector.MagicMimeMimeDetector"); String mimeType = MimeUtil2.getMostSpecificMimeType(mimeUtil.getMimeTypes(file)).toString();
byte[] byteArray = ... InputStream is = new BufferedInputStream(new ByteArrayInputStream(byteArray)); String mimeType = URLConnection.guessContentTypeFromStream(is);
String mimetype(file){ Object cmd=Runtime.getRuntime().exec("file --mime-type "+file); if(output){return output.split(":")[1].trim(); } return ""; }
mimetype("/home/nyapp.war") mimetype("/var/www/ggg/au.mp3")
<groupId>eu.medsea.mimeutil</groupId> <artifactId>mime-util</artifactId> <version>2.1.3</version> </dependency> File file = new File("D:/test.tif"); MimeUtil.registerMimeDetector("eu.medsea.mimeutil.detector.MagicMimeMimeDetector"); Collection<?> mimeTypes = MimeUtil.getMimeTypes(file); System.out.println(mimeTypes);
public String getFileContentType(String fileName) { String fileType = "Undetermined"; final File file = new File(fileName); try { fileType = Files.probeContentType(file.toPath()); } catch (IOException ioException) { System.out.println( "ERROR: Unable to determine file type for " + fileName + " due to exception " + ioException); } return fileType; }
import java.io.File; import javax.activation.MimetypesFileTypeMap; public class MimeTest { public static void main(String a[]){ System.out.println(new MimetypesFileTypeMap().getContentType( new File("/path/filename.txt"))); } }
try { File file = new File(keystore location); InputStream is = new FileInputStream(file); KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType()); String password = "password"; keystore.load(is, password.toCharArray()); Enumeration<String> enumeration = keystore.aliases(); while(enumeration.hasMoreElements()) { String alias = enumeration.nextElement(); System.out.println("alias name: " + alias); Certificate certificate = keystore.getCertificate(alias); System.out.println(certificate.toString()); } } catch (java.security.cert.CertificateException e) { e.printStackTrace(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (KeyStoreException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { if(null != is) try { is.close(); } catch (IOException e) { e.printStackTrace(); } }
Key key = keyStore.getKey(alias, password.toCharArray()); String encodedKey = new Base64Encoder().encode(key.getEncoded()); System.out.println("key ? " + encodedKey);
keytool -list -keystore "$JAVA_HOME/jre/lib/security/cacerts"
@RequestMapping(value = "/matches/{matchId}", produces = "application/json") @ResponseBody public String match(@PathVariable String matchId) { String json = matchService.getMatchJson(matchId); if (json == null) { } return json; }
return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
@RequestMapping(value = "/matches/{matchId}", produces = "application/json") @ResponseBody public String match(@PathVariable String matchId, @RequestBody String body, HttpServletRequest request, HttpServletResponse response) { String json = matchService.getMatchJson(matchId); if (json == null) { response.setStatus( HttpServletResponse.SC_BAD_REQUEST ); } return json; }
if(json == null) { throw new BadThingException(); } ... @ExceptionHandler(BadThingException.class) @ResponseStatus(value = HttpStatus.BAD_REQUEST) public @ResponseBody MyError handleException(BadThingException e) { return new MyError("That doesnt work"); }
@ResponseStatus(HttpStatus.NOT_FOUND) public class UnknownMatchException extends RuntimeException { public UnknownMatchException(String matchId) { super("Unknown match: " + matchId); } }
interface MatchService { public Match findMatch(String matchId); }
@RequestMapping(value = "/matches/{matchId}", produces = MediaType.APPLICATION_JSON_VALUE) @ResponseBody public Match match(@PathVariable String matchId) { return matchService.findMatch(matchId); }
@RequestMapping(value = "/matches/{matchId}", produces = MediaType.APPLICATION_JSON_VALUE) @ResponseBody public MatchDTO match(@PathVariable String matchId) { Match match = matchService.findMatch(matchId); return MatchDtoFactory.createDTO(match); }
@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "Not Found") public class NotFoundException extends Exception { public NotFoundException() { } }
@RequestMapping(value = "/matches/{matchId}", produces = "application/json") @ResponseBody public String match(@PathVariable String matchId) { String json = matchService.getMatchJson(matchId); if (json == null) { throw new NotFoundException(); } return json; }
package com.javaninja.cam.exception; import org.springframework.http.HttpStatus; /** * The exception used to return a status and a message to the calling system. * @author norrisshelton */ @SuppressWarnings("ClassWithoutNoArgConstructor") public class ResourceException extends RuntimeException { private HttpStatus httpStatus = HttpStatus.INTERNAL_SERVER_ERROR; /** * Gets the HTTP status code to be returned to the calling system. * @return http status code. Defaults to HttpStatus.INTERNAL_SERVER_ERROR (500). * @see HttpStatus */ public HttpStatus getHttpStatus() { return httpStatus; } /** * Constructs a new runtime exception with the specified HttpStatus code and detail message. * The cause is not initialized, and may subsequently be initialized by a call to {@link * @param httpStatus the http status. The detail message is saved for later retrieval by the {@link * * @param message the detail message. The detail message is saved for later retrieval by the {@link * * @see HttpStatus */ public ResourceException(HttpStatus httpStatus, String message) { super(message); this.httpStatus = httpStatus; } }
package com.javaninja.cam.spring; import com.javaninja.cam.exception.ResourceException; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ExceptionHandler; /** * Exception handler advice class for all SpringMVC controllers. * @author norrisshelton * @see org.springframework.web.bind.annotation.ControllerAdvice */ @org.springframework.web.bind.annotation.ControllerAdvice public class ControllerAdvice { /** * Handles ResourceExceptions for the SpringMVC controllers. * @param e SpringMVC controller exception. * @return http response entity * @see ExceptionHandler */ @ExceptionHandler(ResourceException.class) public ResponseEntity handleException(ResourceException e) { return ResponseEntity.status(e.getHttpStatus()).body(e.getMessage()); } }
throw new ResourceException(HttpStatus.BAD_REQUEST, "My message");
@RequestMapping(value = "/matches/{matchId}", produces = "application/json") @ResponseBody public ResponseEntity<?> match(@PathVariable String matchId, @RequestBody String body, HttpServletRequest request, HttpServletResponse response) { Product p; try { p = service.getProduct(request.getProductId()); } catch(Exception ex) { return new ResponseEntity<String>(HttpStatus.BAD_REQUEST); } return new ResponseEntity(p, HttpStatus.OK); }
@ResponseBody @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(IllegalArgumentException.class) public ErrorMessage handleIllegalArguments(HttpServletRequest httpServletRequest, IllegalArgumentException e) { log.error("Illegal arguments received.", e); ErrorMessage errorMessage = new ErrorMessage(); errorMessage.code = 400; errorMessage.message = e.getMessage(); return errorMessage; }
@SuppressWarnings("unchecked") protected <T> void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException { Class<?> valueType = getReturnValueType(value, returnType); Type declaredType = getGenericType(returnType); HttpServletRequest request = inputMessage.getServletRequest(); List<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request); List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType); if (value != null && producibleMediaTypes.isEmpty()) { throw new IllegalArgumentException("No converter found for return value of type: " + valueType); } @SuppressWarnings("unchecked") protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass, Type declaredType) { Set<MediaType> mediaTypes = (Set<MediaType>) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE); if (!CollectionUtils.isEmpty(mediaTypes)) { return new ArrayList<MediaType>(mediaTypes);
@ResponseBody @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(IllegalArgumentException.class) public ErrorMessage handleIllegalArguments(HttpServletRequest httpServletRequest, IllegalArgumentException e) { Set<MediaType> mediaTypes = new HashSet<>(); mediaTypes.add(MediaType.APPLICATION_JSON_UTF8); httpServletRequest.setAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes); log.error("Illegal arguments received.", e); ErrorMessage errorMessage = new ErrorMessage(); errorMessage.code = 400; errorMessage.message = e.getMessage(); return errorMessage; }
public class ErrorMessage { int code; String message; }
public class ErrorMessage { @JsonProperty("code") private int code; @JsonProperty("message") private String message; public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } }
{"code":400,"message":"An \"url\" parameter must be defined."}
if(Looper.myLooper() == Looper.getMainLooper()) { }
if(Looper.getMainLooper().getThread() == Thread.currentThread()) { }
Thread.currentThread().equals( Looper.getMainLooper().getThread() )
boolean isUiThread = VERSION.SDK_INT >= VERSION_CODES.M ? Looper.getMainLooper().isCurrentThread() : Thread.currentThread() == Looper.getMainLooper().getThread();
new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { } });
if(Looper.myLooper() == Looper.getMainLooper()) { }else{ }
public bool IsMainThread => Build.VERSION.SdkInt >= BuildVersionCodes.M ? Looper.MainLooper.IsCurrentThread : Looper.MyLooper() == Looper.MainLooper;
String s = ""; for (int i = 0; i < 100; i++) { s += ", " + i; }
public String decorateTheString(String orgStr){ StringBuilder builder = new StringBuilder(); builder.append(orgStr); builder.deleteCharAt(orgStr.length()-1); builder.insert(0,builder.hashCode()); return builder.toString(); }
HashMap<String, Object> map = new HashMap<String, Object>(); Map<String, Object> map = new HashMap<String, Object>();
class Foo { private HashMap<String, Object> things; private HashMap<String, Object> moreThings; protected HashMap<String, Object> getThings() { return this.things; } protected HashMap<String, Object> getMoreThings() { return this.moreThings; } public Foo() { this.things = new HashMap<String, Object>(); this.moreThings = new HashMap<String, Object>(); } }
class SpecialFoo extends Foo { private void doSomething(HashMap<String, Object> t) { } public void whatever() { this.doSomething(this.getThings()); this.doSomething(this.getMoreThings()); } }
class Foo { private Map<String, Object> things; private Map<String, Object> moreThings; protected Map<String, Object> getThings() { return this.things; } protected Map<String, Object> getMoreThings() { return this.moreThings; } public Foo() { this.things = new HashMap<String, Object>(); this.moreThings = new HashMap<String, Object>(); } }
class SpecialFoo extends Foo { private void doSomething(Map<String, Object> t) { } public void whatever() { this.doSomething(this.getThings()); this.doSomething(this.getMoreThings()); } }
List collection; if(keepSorted) collection=new LinkedList(); else collection=new ArrayList();
public void foo (HashMap<String, Object) { ... } ... HashMap<String, Object> m1 = ...; Map<String, Object> m2 = ...; foo (m1); foo ((HashMap<String, Object>)m2);
public boolean containsKey(Object key) { return getNode(hash(key), key) != null; }
HashMap<String, Object> map1 = new HashMap<String, Object>(); Map<String, Object> map2 = new HashMap<String, Object>();
for (int i = 0; i < strings.size(); i++) { if (strings.get(i).equalsIgnoreCase("fnoord")) { break; } } if (i < strings.size()) { ... }
for (int i = 0; i < 100; i++); { System.out.println("i is " + i); }
for (int i = 0; i < 100; i++); { System.out.println("i is " + i); }
for (int i = 1; i < 10; i++) { for (j = 1; j < 10; j++) { ... } }
if(somethingIsTrue()) { String message = "Everything is fine"; } else { String message = "We have an error"; } System.out.println(message);
if(somethingIsTrue()) { String message = "Everything is fine"; System.out.println(message); } else { String message = "We have an error"; System.out.println(message); }
String message = "We have an error"; if(somethingIsTrue()) { message = "Everything is fine"; } System.out.println(message);
class demo{ public static void main(String a[]){ System.out.print(name); } }
class demo{ public static void main(String a[]){ String name="smith"; System.out.print(name); } }
public enum Modes { some-really-long-string, mode1, mode2, mode3 }
public enum Modes { mode1 ("Fancy Mode 1"), mode2 ("Fancy Mode 2"), mode3 ("Fancy Mode 3"); private final String name; private Modes(String s) { name = s; } public boolean equalsName(String otherName) { return name.equals(otherName); } public String toString() { return this.name; } }
public final class Modes { public static final String MODE_1 = "Fancy Mode 1"; public static final String MODE_2 = "Fancy Mode 2"; public static final String MODE_3 = "Fancy Mode 3"; private Modes() { } }
public interface Modes { String MODE_1 = "Fancy Mode 1"; String MODE_2 = "Fancy Mode 2"; String MODE_3 = "Fancy Mode 3"; }
String name = Modes.mode1.name(); Modes mode = Modes.valueOf(name);
public enum Country { DE { @Override public String toString() { return "Germany"; } }, IT { @Override public String toString() { return "Italy"; } }, US { @Override public String toString() { return "United States"; } } }
public static void main(String[] args) { System.out.println(Country.DE); System.out.println(Country.IT); System.out.println(Country.US); }
public enum Country{ SPAIN("Espaa"), ITALY("Italia"), PORTUGAL("Portugal"); private String value; Country(final String value) { this.value = value; } public String getValue() { return value; } @Override public String toString() { return this.getValue(); } }
public enum Modes { MODE1("Mode1"), MODE2("Mode2"), MODE3("Mode3"); private String value; public String getValue() { return value; } private Modes(String value) { this.value = value; } }
Mode mode = System.out.println("The mode is "+mode);
public enum Modes { mode1 ("Mode1"), mode2 ("Mode2"), mode3 ("Mode3"); private String name; private Modes(String s) { name = s; } }
enum Animal { DOG, CAT, BIRD; public String toString(){ switch (this) { case DOG: return "Dog"; case CAT: return "Cat"; case BIRD: return "Bird"; } return null; } }
package com.common.test; public enum Days { monday(1,"Monday"),tuesday(2,"Tuesday"),wednesday(3,"Wednesday"), thrusday(4,"Thrusday"),friday(5,"Friday"),saturday(6,"Saturday"),sunday(7,"Sunday"); private int id; private String desc; Days(int id,String desc){ this.id=id; this.desc=desc; } public static String getDay(int id){ for (Days day : Days.values()) { if (day.getId() == id) { return day.getDesc(); } } return null; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } };
public enum Modes { mode1( mode2( mode3( ; char c; private Modes(char c) { this.c = c; } public char character() { return c; } }
public enum MyEnum { VALUE1, VALUE2, VALUE3; public int getValue() { return this.ordinal(); } public static DataType forValue(int value) { return values()[value]; } public String toString() { return forValue(getValue()).name(); } }
import java.util.HashMap; import java.util.Map; public enum MapEnumSample { Mustang("One of the fastest cars in the world!"), Mercedes("One of the most beautiful cars in the world!"), Ferrari("Ferrari or Mercedes, which one is the best?"); private final String description; private static Map<String, String> enumMap; private MapEnumSample(String description) { this.description = description; } public String getEnumValue() { return description; } public static String getEnumKey(String name) { if (enumMap == null) { initializeMap(); } return enumMap.get(name); } private static Map<String, String> initializeMap() { enumMap = new HashMap<String, String>(); for (MapEnumSample access : MapEnumSample.values()) { enumMap.put(access.getEnumValue(), access.toString()); } return enumMap; } public static void main(String[] args) { System.out.println(MapEnumSample.getEnumKey("One of the fastest cars in the world!")); System.out.println(MapEnumSample.Mustang.getEnumValue()); System.out.println(MapEnumSample.getEnumKey("One of the most beautiful cars in the world!")); System.out.println(MapEnumSample.Mercedes.getEnumValue()); System.out.println("Mustang or Mercedes, which one is the best?"); System.out.println(MapEnumSample.getEnumKey("Mustang or Mercedes, which one is the best?") == null ? "I don + MapEnumSample.getEnumKey("Ferrari or Mustang, which one is the best?") + " is the best!."); System.out.println("Ferrari or Mercedes, wich one is the best?"); System.out.println(MapEnumSample.getEnumKey("Ferrari or Mercedes, which one is the best?") == null ? "I don + MapEnumSample.getEnumKey("Ferrari or Mercedes, which one is the best?") + " is the best!"); } }
public static enum Operation { Addition, Subtraction, Multiplication, Division,; public String getUserFriendlyString() { if (this==Addition) { return " + "; } else if (this==Subtraction) { return " - "; } else if (this==Multiplication) { return " * "; } else if (this==Division) { return " / "; } return "undefined"; } }
public enum Environment { PROD("https: SIT("https: CIT("https: DEV("https: private String url; Environment(String envUrl) { this.url = envUrl; } public String getUrl() { return url; } } String prodUrl = Environment.PROD.getUrl();
public enum Modes { some-really-long-string, mode1, mode2, mode3; public String toString(){ switch(this) { case some-really-long-string: return "some-really-long-string"; case mode2: return "mode2"; default: return "undefined"; } }
String myName = "domanokz"; String newName = myName.substring(0,4)+
StringBuilder myName = new StringBuilder("domanokz"); myName.setCharAt(4, System.out.println(myName);
String myName = "domanokz"; char[] myNameChars = myName.toCharArray(); myNameChars[4] = myName = String.valueOf(myNameChars);
public String replace(String str, int index, char replace){ if(str==null){ return str; }else if(index<0 || index>=str.length()){ return str; } char[] chars = str.toCharArray(); chars[index] = replace; return String.valueOf(chars); }
public static void main(String[] args) { String text = "This is a test"; try { Field valueField = String.class.getDeclaredField("value"); valueField.setAccessible(true); char[] value = (char[])valueField.get(text); value[12]= System.out.println(text); } catch (NoSuchFieldException | SecurityException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } }
String myName = "halftime"; myName = myName.substring(0,4)+
String myName="domanokz"; String p=myName.replace(myName.charAt(4), System.out.println(p);
public class Test { private static final int a; static { a = 5; doSomething(a); } private static int doSomething(int x) { return (x+5); } }
package com.example.learnjava; import java.util.ArrayList; public class Fruit { static { System.out.println("Inside Static Initializer."); ArrayList<String> fruits = new ArrayList<>(); fruits.add("Apple"); fruits.add("Orange"); fruits.add("Pear"); for (String fruit : fruits) { System.out.println(fruit); } System.out.println("End Static Initializer.\n"); } public static void main(String[] args) { System.out.println("Inside Main Method."); } }
class JNIGlue { static { System.loadLibrary("foo"); } }
public class Foo { String s = "abc"; public Foo() { System.out.println("constructor called"); } static { System.out.println("static initializer called"); } { System.out.println("instance initializer called"); } public static void main(String[] args) { new Foo(); new Foo(); } }
class MyClass { private int myField = 3; { myField = myField + 2; } public MyClass() { myField = myField * 4; } public MyClass(int _myParam) { if (_myParam > 0) { myField = myField * 4; } else { myField = myField + 5; } } public void setMyField(int _myField) { myField = _myField; } public int getMyField() { return myField; } } public class MainClass{ public static void main(String[] args) { MyClass myFirstInstance_ = new MyClass(); System.out.println(myFirstInstance_.getMyField()); MyClass mySecondInstance_ = new MyClass(1); System.out.println(mySecondInstance_.getMyField()); MyClass myThirdInstance_ = new MyClass(-1); System.out.println(myThirdInstance_.getMyField()); } }
class MyClass { private int myField = 3; public MyClass() { myField = myField + 2; myField = myField * 4; } public MyClass(int _myParam) { myField = myField + 2; if (_myParam > 0) { myField = myField * 4; } else { myField = myField + 5; } } public void setMyField(int _myField) { myField = _myField; } public int getMyField() { return myField; } } public class MainClass{ public static void main(String[] args) { MyClass myFirstInstance_ = new MyClass(); System.out.println(myFirstInstance_.getMyField()); MyClass mySecondInstance_ = new MyClass(1); System.out.println(mySecondInstance_.getMyField()); MyClass myThirdInstance_ = new MyClass(-1); System.out.println(myThirdInstance_.getMyField()); } }
@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String text = "some text"; response.setContentType("text/plain"); response.setCharacterEncoding("UTF-8"); response.getWriter().write(text); }
@WebServlet("/someservlet/*") public class SomeServlet extends HttpServlet { }
@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List<String> list = new ArrayList<>(); list.add("item1"); list.add("item2"); list.add("item3"); String json = new Gson().toJson(list); response.setContentType("application/json"); response.setCharacterEncoding("UTF-8"); response.getWriter().write(json); }
@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Map<String, String> options = new LinkedHashMap<>(); options.put("value1", "label1"); options.put("value2", "label2"); options.put("value3", "label3"); String json = new Gson().toJson(options); response.setContentType("application/json"); response.setCharacterEncoding("UTF-8"); response.getWriter().write(json); }
@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List<Product> products = someProductService.list(); String json = new Gson().toJson(products); response.setContentType("application/json"); response.setCharacterEncoding("UTF-8"); response.getWriter().write(json); }
@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List<Product> products = someProductService.list(); request.setAttribute("products", products); request.getRequestDispatcher("/WEB-INF/xml/products.jsp").forward(request, response); }
@Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String foo = request.getParameter("foo"); String bar = request.getParameter("bar"); String baz = request.getParameter("baz"); boolean ajax = "XMLHttpRequest".equals(request.getHeader("X-Requested-With")); if (ajax) { } else { } }
JsonObject data = new Gson().fromJson(request.getReader(), JsonObject.class); String foo = data.get("foo").getAsString(); String bar = data.get("bar").getAsString(); String baz = data.get("baz").getAsString();
document.open(); document.write(responseText); document.close();
String redirectURL = "http: Map<String, String> data = new HashMap<>(); data.put("redirect", redirectURL); String json = new Gson().toJson(data); response.setContentType("application/json"); response.setCharacterEncoding("UTF-8"); response.getWriter().write(json);
function(responseJson) { if (responseJson.redirect) { window.location = responseJson.redirect; return; } }
<form> Name:<input type="text" name="username"/><br/><br/> Password:<input type="password" name="userpass"/><br/><br/> <input type="button" value="login"/> </form>
$.ajax ({ type: "POST", data: url: url, success:function(content) { $( } });
package abc.servlet; import java.io.File; public class AuthenticationServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try{ HttpSession session = request.getSession(); String username = request.getParameter("name"); String password = request.getParameter("pass"); out.println("sucess / failer") } catch (Exception ex) { ex.printStackTrace(); System.exit(0); } } }
$.ajax({ type: "POST", url: "url to hit on servelet", data: JSON.stringify(json), dataType: "json", success: function(response){ if(response.status == "SUCCESS"){ $( "The Details are as follws : <br> Name : "); }else{ $( } }, error: function(e){ alert( } });
function onChangeSubmitCallWebServiceAJAX() { createXmlHttpRequest(); var firstName=document.getElementById("firstName").value; var lastName=document.getElementById("lastName").value; xmlHttp.open("GET","/AJAXServletCallSample/AjaxServlet?firstName=" +firstName+"&lastName="+lastName,true) xmlHttp.onreadystatechange=handleStateChange; xmlHttp.send(null); }
/** * @see HttpServlet */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String firstName = request.getParameter("firstName"); String lastName = request.getParameter("lastName"); response.setContentType("text/xml"); response.setHeader("Cache-Control", "no-cache"); response.getWriter().write("<details>"); response.getWriter().write("<firstName>"+firstName+"</firstName>"); response.getWriter().write("<lastName>"+lastName+"</lastName>"); response.getWriter().write("</details>"); }
function() { $.ajax({ type : "get", url : "OperatorController", data : "input=" + $( success : function(msg) { var arrayOfObjects = eval(msg); $(" arrayOfObjects); }, dataType : });} }
SELECT my_column FROM my_table where search_column IN (?)
/** * Converts a SQL statement containing exactly one IN clause to an IN clause * using multiple comma-delimited parameters. * * @param sql The SQL statement string with one IN clause. * @param params The number of parameters the SQL statement requires. * @return The SQL statement with (?) replaced with multiple parameter * placeholders. */ public static String any(String sql, final int params) { final StringBuilder sb = new StringBuilder( new String(new char[params]).replace("\0", "?,") ); sb.setLength(Math.max(sb.length() - 1, 0)); if (sb.length() > 1) { sql = sql.replace("(?)", "(" + sb + ")"); } return sql; }
final PreparedStatement statement = connection.prepareStatement( "SELECT my_column FROM my_table where search_column = ANY (?)" ); final String[] values = getValues(); statement.setArray(1, connection.createArrayOf("text", values)); final ResultSet rs = statement.executeQuery(); try { while(rs.next()) { } } finally { rs.close(); }
final PreparedStatement statement = connection.prepareStatement( "SELECT my_column FROM my_table " + "where search_column IN (SELECT * FROM unnest(?))" ); final String[] values = getValues(); statement.setArray(1, connection.createArrayOf("text", values)); final ResultSet rs = statement.executeQuery(); try { while(rs.next()) { } } finally { rs.close(); }
while( i < param.size() ) { ps.setString(i+1,param.get(i)); i++; } while( i < MAX_PARAMS ) { ps.setNull(i+1,Types.VARCHAR); i++; }
select my_column from my_table where search_column in ( SELECT value FROM MYVALUES )
function getCustomers(in_customerIdList clob) return sys_refcursor is begin aux_in_list.parse(in_customerIdList); open res for select * from customer c, in_list v where c.customer_id=v.token; return res; end;
create or replace view in_list as select trim( substr (txt, instr (txt, instr (txt, - instr (txt, from (select connect by level <= length(aux_in_list.getpayload)-length(replace(aux_in_list.getpayload,
create or replace type split_tbl as table of varchar(32767); / create or replace function split ( p_list varchar2, p_del varchar2 := ) return split_tbl pipelined is l_idx pls_integer; l_list varchar2(32767) := p_list; l_value varchar2(32767); begin loop l_idx := instr(l_list,p_del); if l_idx > 0 then pipe row(substr(l_list,1,l_idx-1)); l_list := substr(l_list,l_idx+length(p_del)); else pipe row(l_list); exit; end if; end loop; return; end split; /
select * from table(split( one two three select * from TABLE1 where COL1 in (select * from table(split( value1 AAA value2 BBB
"select * from TABLE where COL in (select * from table(split(?)))"
String inParenthesis = "(?"; for(int i = 1;i < myList.size();i++) { inParenthesis += ", ?"; } inParenthesis += ")"; try(PreparedStatement statement = SQLite.connection.prepareStatement( String.format("UPDATE table SET value= int x = 1; statement.setLong(x++, race.startTime); statement.setString(x++, race.name); statement.setInt(x++, traderIdx); for(String str : race.betFair.winners) { statement.setString(x++, str); } int effected = statement.executeUpdate(); }
PreparedStatement statement = connection.prepareStatement("Select * from emp where field in (?)"); Array array = statement.getConnection().createArrayOf("VARCHAR", new Object[]{"E1", "E2","E3"}); statement.setArray(1, array); ResultSet rs = statement.executeQuery();
SELECT my_column FROM my_table where search_column IN (?)
preparedStatement.setString( 1, preparedStatement.setString( 2, preparedStatement.setString( 3,
/*usage: Util u = new Util(500); String sqlBefore = "select * from myTable where ("; List<Integer> values = new ArrayList<Integer>(Arrays.asList(1,2,4,5)); string sqlAfter = ") and foo = PreparedStatement ps = u.prepareStatements(sqlBefore, values, sqlAfter, connection, "someId"); */ import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class Util { private int numValuesInClause; public Util(int numValuesInClause) { super(); this.numValuesInClause = numValuesInClause; } public int getNumValuesInClause() { return numValuesInClause; } public void setNumValuesInClause(int numValuesInClause) { this.numValuesInClause = numValuesInClause; } /** Split a given list into a list of lists for the given size of numValuesInClause*/ public List<List<Integer>> splitList( List<Integer> values) { List<List<Integer>> newList = new ArrayList<List<Integer>>(); while (values.size() > numValuesInClause) { List<Integer> sublist = values.subList(0,numValuesInClause); List<Integer> values2 = values.subList(numValuesInClause, values.size()); values = values2; newList.add( sublist); } newList.add(values); return newList; } /** * Generates a series of split out in clause statements. * @param sqlBefore ""select * from dual where (" * @param values [1,2,3,4,5,6,7,8,9,10] * @param "sqlAfter ) and id = 5" * @return "select * from dual where (id in (1,2,3) or id in (4,5,6) or id in (7,8,9) or id in (10)" */ public String genInClauseSql(String sqlBefore, List<Integer> values, String sqlAfter, String identifier) { List<List<Integer>> newLists = splitList(values); String stmt = sqlBefore; int j = 0; for (List<Integer> list : newLists) { stmt = stmt + identifier +" in ("; StringBuilder innerBuilder = new StringBuilder(); for (int i = 0; i < list.size(); i++) { innerBuilder.append("?,"); } String inClause = innerBuilder.deleteCharAt( innerBuilder.length() - 1).toString(); stmt = stmt + inClause; stmt = stmt + ")"; if (++j < newLists.size()) { stmt = stmt + " OR "; } } stmt = stmt + sqlAfter; return stmt; } /** * Method to convert your SQL and a list of ID into a safe prepared * statements * * @throws SQLException */ public PreparedStatement prepareStatements(String sqlBefore, ArrayList<Integer> values, String sqlAfter, Connection c, String identifier) throws SQLException { String stmt = genInClauseSql(sqlBefore, values, sqlAfter, identifier); PreparedStatement ps = c.prepareStatement(stmt); int i = 1; for (int val : values) { ps.setInt(i++, val); } return ps; } }
SELECT my_column FROM my_table where search_column IN (select COLUMN_VALUE from table(?))
... WHERE tab.col = ? OR tab.col = ? OR tab.col = ?
public void myQuery(List<String> items, int other) { ... String q4in = generateQsForIn(items.size()); String sql = "select * from stuff where foo in ( " + q4in + " ) and bar = ?"; PreparedStatement ps = connection.prepareStatement(sql); int i = 1; for (String item : items) { ps.setString(i++, item); } ps.setInt(i++, other); ResultSet rs = ps.executeQuery(); ... } private String generateQsForIn(int numQs) { String items = ""; for (int i = 0; i < numQs; i++) { if (i != 0) items += ", "; items += "?"; } return items; }
int i = 1; for(; i <=ids.length; i++){ ps.setInt(i, ids[i-1]); } for(; i<=PARAM_SIZE;i++){ ps.setNull(i, java.sql.Types.INTEGER); }
select * from my_table where REGEXP_LIKE (search_column,
String param1 = "X"; String param2 = "Y"; String param1 = param1.append(",").append(param2);
String query = query.replaceFirst("PARAM",param1); where we have the value of query as query = "select * from TABLE_A where ATTR IN (PARAM)";
query="select f1,f2 from t1 where f3=? and f2 in (" + sListOfIds + ");";
String query = "SELECT my_column FROM my_table where search_column IN ($searchColumns)"; query = query.replace("$searchColumns", " Statement stmt = connection.createStatement(); boolean hasResults = stmt.execute(query); do { if (hasResults) return stmt.getResultSet(); hasResults = stmt.getMoreResults(); } while (hasResults || stmt.getUpdateCount() != -1);
String baseQuery ="SELECT my_column FROM my_table where search_column IN (%s)" String markersString = inputArray.stream().map(e -> "?").collect(joining(",")); String sqlQuery = String.format(baseSQL, markersString); int index=1; for (String input : inputArray) { preparedStatement.setString(index++, input); }
List<String> params = getParams(); String placeHolders = String.join(",", Collections.nCopies(params.size(), "?")); String sql = "select * from your_table where some_column in (" + placeHolders + ")"; try ( Connection connection = getConnection(); PreparedStatement ps = connection.prepareStatement(sql)) { int i = 1; for (String param : params) { ps.setString(i++, param); } /* * Execute query/do stuff */ }
select column from table where search_column = any (string_to_array(
select column from table where search_column = any (string_to_array($1,
select column from table where search_column like any (string_to_array(
var s1 = " SELECT " + "FROM table t " + " where t.field in "; var s3 = for(var i =0;i<searchTerms.length;i++) { if(i+1 == searchTerms.length) { s3 = s3+ } else { s3 = s3+ } } var query = s1+s3; var pstmt = connection.prepareStatement(query); for(var i =0;i<searchTerms.length;i++) { pstmt.setString(i+1, searchTerms[i]); }
public class MyClass { private final String importantField; private final String anotherField; public MyClass(final String equalField, final String anotherField) { this.importantField = equalField; this.anotherField = anotherField; } public String getEqualField() { return importantField; } public String getAnotherField() { return anotherField; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((importantField == null) ? 0 : importantField.hashCode()); return result; } @Override public boolean equals(final Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; final MyClass other = (MyClass) obj; if (importantField == null) { if (other.importantField != null) return false; } else if (!importantField.equals(other.importantField)) return false; return true; } }
MyClass first = new MyClass("a","first"); MyClass second = new MyClass("a","second");
public class Employee { String name; int age; public Employee(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object obj) { if (obj == this) return true; if (!(obj instanceof Employee)) return false; Employee employee = (Employee) obj; return employee.getAge() == this.getAge() && employee.getName() == this.getName(); } /* @Override public int hashCode() { int result=17; result=31*result+age; result=31*result+(name!=null ? name.hashCode():0); return result; } */ }
public class ClientTest { public static void main(String[] args) { Employee employee = new Employee("rajeev", 24); Employee employee1 = new Employee("rajeev", 25); Employee employee2 = new Employee("rajeev", 24); HashSet<Employee> employees = new HashSet<Employee>(); employees.add(employee); System.out.println(employees.contains(employee2)); System.out.println("employee.hashCode(): " + employee.hashCode() + " employee2.hashCode():" + employee2.hashCode()); } }
false employee.hashCode(): 321755204 employee2.hashCode():375890482
true employee.hashCode(): -938387308 employee2.hashCode():-938387308
public class Foo { String id; String whatevs; Foo(String id, String whatevs) { this.id = id; this.whatevs = whatevs; } }
Foo a = new Foo("id", "something"); Foo b = new Foo("id", "something else");
public class Foo { String id; String whatevs; Foo(String id, String whatevs) { this.id = id; this.whatevs = whatevs; } @Override public boolean equals(Object other) { if (other instanceof Foo) { return ((Foo)other).id.equals(this.id); } } @Override public int hashCode() { return this.id.hashCode(); } }
Customer customer1=new Customer("peter"); Customer customer2=customer1; customer1.equals(customer2); ------------------------------ Customer customer1=new Customer("peter"); Customer customer2=new Customer("peter"); customer1.equals(customer2); ------------------------------ Now I have overriden Customer class equals method as follows: @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Customer other = (Customer) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } Customer customer1=new Customer("peter"); Customer customer2=new Customer("peter"); Insteady identify the Object equality by JVM, we can do it by overring equals method. customer1.equals(customer2);
import java.util.HashMap; public class Employee { String name; String mobile; public Employee(String name,String mobile) { this.name=name; this.mobile=mobile; } @Override public int hashCode() { System.out.println("calling hascode method of Employee"); String str=this.name; Integer sum=0; for(int i=0;i<str.length();i++){ sum=sum+str.charAt(i); } return sum; } @Override public boolean equals(Object obj) { System.out.println("calling equals method of Employee"); Employee emp=(Employee)obj; if(this.mobile.equalsIgnoreCase(emp.mobile)){ System.out.println("returning true"); return true; }else{ System.out.println("returning false"); return false; } } public static void main(String[] args) { Employee emp=new Employee("abc", "hhh"); Employee emp2=new Employee("abc", "hhh"); HashMap<Employee, Employee> h=new HashMap<>(); h.put(emp, emp); h.put(emp2, emp2); System.out.println("----------------"); System.out.println("size of hashmap: "+h.size()); } }
public boolean equals(Object obj) { return (this == obj); }
myMap.put(first,someValue) myMap.contains(second); --> But it should be the same since the key are the same.But returns false!!! How?
Bucket 1 : 1,10,19,... (in thousands) Bucket 2 : 2,20,29... Bucket 3 : 3,21,30,... ...
class A { int i; if even number return 0 else return 1 if i = this.i return true else false }
Map.Entry 1 --> 1,3,5,... Map.Entry 2 --> 2,4,6,...
Map.Entry 1 --> 1,3,5,...,1,3,5,... Map.Entry 2 --> 2,4,6,...,2,4,..
Map.Entry 1 --> 1 Map.Entry 2 --> 2 Map.Entry 3 --> 3 Map.Entry 4 --> 1 Map.Entry 5 --> 2 Map.Entry 6 --> 3 So on...
public class Person { String name; int age; String socialSecurityNumber; public Person(String name, int age, String socialSecurityNumber) { this.name = name; this.age = age; this.socialSecurityNumber = socialSecurityNumber; } @Override public boolean equals(Object p) { if ((p instanceof Person) && this.socialSecurityNumber.equals(((Person) p).socialSecurityNumber)) { return true; } else { return false; } } @Override public int hashCode() { return socialSecurityNumber.hashCode(); } } public class Order { String[] items; public void insertOrder(String[] items) { this.items=items; } } import java.util.Hashtable; public class Main { public static void main(String[] args) { Person p1=new Person("Tom",32,"548-56-4412"); Person p2=new Person("Jerry",60,"456-74-4125"); Person p3=new Person("Sherry",38,"418-55-1235"); Order order1=new Order(); order1.insertOrder(new String[]{"mouse","car charger"}); Order order2=new Order(); order2.insertOrder(new String[]{"Multi vitamin"}); Order order3=new Order(); order3.insertOrder(new String[]{"handbag", "iPod"}); Hashtable<Person,Order> hashtable=new Hashtable<Person,Order>(); hashtable.put(p1,order1); hashtable.put(p2,order2); hashtable.put(p3,order3); Order tomOrder= hashtable.get(new Person("Tom", 32, "548-56-4412")); for(String item:tomOrder.items) { System.out.println(item); } } }
public class Car { private String color; public Car(String color) { this.color = color; } public boolean equals(Object obj) { if(obj==null) return false; if (!(obj instanceof Car)) return false; if (obj == this) return true; return this.color.equals(((Car) obj).color); } public static void main(String[] args) { Car a1 = new Car("green"); Car a2 = new Car("red"); HashMap<Car, Integer> m = new HashMap<Car, Integer>(); m.put(a1, 10); m.put(a2, 20); System.out.println(m.get(new Car("green"))); } }
public int hashCode(){ return this.color.hashCode(); }
Person p1 = new Person("A",23); Person p2 = new Person("A",23); HashMap map = new HashMap(); map.put(p1,"value 1"); map.put(p2,"value 2");
public class Employee { private int empId; private String empName; public Employee(int empId, String empName) { super(); this.empId = empId; this.empName = empName; } public int getEmpId() { return empId; } public void setEmpId(int empId) { this.empId = empId; } public String getEmpName() { return empName; } public void setEmpName(String empName) { this.empName = empName; } @Override public String toString() { return "Employee [empId=" + empId + ", empName=" + empName + "]"; } @Override public int hashCode() { return empId + empName.hashCode(); } @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (!(this instanceof Employee)) { return false; } Employee emp = (Employee) obj; return this.getEmpId() == emp.getEmpId() && this.getEmpName().equals(emp.getEmpName()); } }
public class Test { public static void main(String[] args) { Employee emp1 = new Employee(101,"Manash"); Employee emp2 = new Employee(101,"Manash"); Employee emp3 = new Employee(103,"Ranjan"); System.out.println(emp1.hashCode()); System.out.println(emp2.hashCode()); System.out.println(emp1.equals(emp2)); System.out.println(emp1.equals(emp3)); } }
Double myDouble = Double.valueOf(10.0); double dbl = myDouble.doubleValue(); int intgr = (int) dbl; Integer val = Integer.valueOf(intgr);
Double myDouble = Double.valueOf(10.0); Integer val = Integer.valueOf(myDouble.intValue());
Double myDouble = null; Integer val = Integer.valueOf(myDouble.intValue()); Integer val = (myDouble == null)? null : Integer.valueOf(myDouble.intValue());
long rounded = (myDouble == null)? 0L: Math.round(myDouble.doubleValue()); Integer val = Integer.valueOf(rounded);
Integer val1 = 10; Integer val2 = 10.0; Double val3 = 10; Double val4 = 10.0; Double val5 = null; double val6 = val5;
double val7 = (double) 10; Double val8 = (Double) Integer.valueOf(10); Integer val9 = (Integer) 9;
long rounded = (myDouble == null)? 0L: Math.round(myDouble.doubleValue()); Integer val = new Integer(rounded);
double d = 9.5; int i = (int)d; Double D = 9.5; int i = Integer.valueOf(D.intValue()); double d = 9.5; Long L = Math.round(d); int i = Integer.valueOf(L.intValue());
Integer integer = Integer.valueOf((int) Math.round(myDouble)));
Integer integer = myDouble == null ? null : Integer.valueOf((int) Math.round(myDouble)));
Double foo = 123.456; Integer bar = foo.intValue();
double a = 13.34; int b = (int) a; System.out.println(b);
Double d = 13.5578; int i = d.intValue(); System.out.println(i);
double d = 100.04; long l = (long)d; int i = (int)l;
double doubleValue = 6.5;Double doubleObj = new Double(doubleValue);int intResult = doubleObj.intValue();
Double initialValue = 7.12; int finalValue = initialValue.intValue();
Double.valueOf(Math.floor(54644546464/60*60*24*365)).intValue()
double od = Double.parseDouble("1.15"); int oi = (int) od;
String mydata = "some string with Pattern pattern = Pattern.compile(" Matcher matcher = pattern.matcher(mydata); if (matcher.find()) { System.out.println(matcher.group(1)); }
String dataYouWant = StringUtils.substringBetween(mydata, "
import java.util.regex.Matcher; import java.util.regex.Pattern; public class Test { public static void main(String[] args) { Pattern pattern = Pattern.compile(".* String mydata = "some string with Matcher matcher = pattern.matcher(mydata); if(matcher.matches()) { System.out.println(matcher.group(1)); } } }
val text = "some string with text.split(" res: Array[java.lang.String] = Array(the data i want, and even more data)
val ticks = " ticks findFirstIn mydata match { case Some(ticks(inside)) => println(inside) case _ => println("nothing") } for (ticks(inside) <- ticks findAllIn mydata) println(inside) val Some(ticks(inside)) = ticks findFirstIn mydata val ticks = ".* val ticks(inside) = mydata
@RunWith(MockitoJUnitRunner.class) public class SomeManagerTest { @InjectMocks private SomeManager someManager; @Mock private SomeDependency someDependency; }
class Game { private Player player; public Game(Player player) { this.player = player; } public String attack() { return "Player attack with: " + player.getWeapon(); } } class Player { private String weapon; public Player(String weapon) { this.weapon = weapon; } String getWeapon() { return weapon; } }
@RunWith(MockitoJUnitRunner.class) class GameTest { @Mock Player player; @InjectMocks Game game; @Test public void attackWithSwordTest() throws Exception { Mockito.when(player.getWeapon()).thenReturn("Sword"); assertEquals("Player attack with: Sword", game.attack()); } }
@RunWith(MockitoJUnitRunner.class) public class GameTest { @Mock Player player; @Spy List<String> enemies = new ArrayList<>(); @InjectMocks Game game; @Test public void attackWithSwordTest() throws Exception { Mockito.when(player.getWeapon()).thenReturn("Sword"); enemies.add("Dragon"); enemies.add("Orc"); assertEquals(2, game.numberOfEnemies()); assertEquals("Player attack with: Sword", game.attack()); } } class Game { private Player player; private List<String> opponents; public Game(Player player, List<String> opponents) { this.player = player; this.opponents = opponents; } public int numberOfEnemies() { return opponents.size(); }
@Mock StudentDao studentDao; @InjectMocks StudentService service; @Before public void setUp() throws Exception { MockitoAnnotations.initMocks(this); }
@RunWith(MockitoJUnitRunner.class) public class SomeManagerTest { @InjectMocks private SomeManager someManager; @Mock private SomeDependency someDependency; }
public class A{ public class B b; public void doSomething(){ } }
public class TestClassA{ @Mocks public class B b; @InjectMocks public class A a; @Test public testDoSomething(){ } }
System.out.println(Integer.toBinaryString(-1)); System.out.println(Integer.toBinaryString(-1 >> 16)); System.out.println(Integer.toBinaryString(-1 >>> 16));
System.out.println(Integer.toBinaryString(121)); System.out.println(Integer.toBinaryString(121 >> 1)); System.out.println(Integer.toBinaryString(121 >>> 1));
01111111 >>> 2 = 00011111 10000000 >>> 2 = 00100000
int c = -153; System.out.printf("%32s%n",Integer.toBinaryString(c >>= 2)); System.out.printf("%32s%n",Integer.toBinaryString(c <<= 2)); System.out.printf("%32s%n",Integer.toBinaryString(c >>>= 2)); System.out.println(Integer.toBinaryString(c <<= 2)); System.out.println(); c = 153; System.out.printf("%32s%n",Integer.toBinaryString(c >>= 2)); System.out.printf("%32s%n",Integer.toBinaryString(c <<= 2)); System.out.printf("%32s%n",Integer.toBinaryString(c >>>= 2)); System.out.printf("%32s%n",Integer.toBinaryString(c <<= 2));
11111111111111111111111111011001 11111111111111111111111101100100 111111111111111111111111011001 11111111111111111111111101100100 100110 10011000 100110 10011000
@Before public void beforeMethod() { org.junit.Assume.assumeTrue(someCondition()); }
@Test public void calculateTotalSalary() { assumeThat(Database.connect(), is(notNull())); }
@Test @RunIf(DatabaseIsConnected.class) public void calculateTotalSalary() { } class DatabaseIsConnected implements Checker { public boolean satisify() { return Database.connect() != null; } }
public class CustomRunner extends BlockJUnit4ClassRunner { public CTRunner(Class<?> klass) throws initializationError { super(klass); } @Override protected boolean isIgnored(FrameworkMethod child) { if(shouldIgnore()) { return true; } return super.isIgnored(child); } private boolean shouldIgnore(class) { } }
String with @Column(length=50) ==> varchar(50) changed to String with @Column(length=100) ==> still varchar(50), not changed to varchar(100) @Temporal(TemporalType.TIMESTAMP,TIME,DATE) will not update the DB columns if changed
DriverAdapterCPDS driverAdapterCPDS = new DriverAdapterCPDS(); driverAdapterCPDS.setUrl(dataSourceProperties.getProperty("url")); driverAdapterCPDS.setUser(dataSourceProperties.getProperty("username")); driverAdapterCPDS.setPassword(dataSourceProperties.getProperty("password")); driverAdapterCPDS.setDriver(dataSourceProperties.getProperty("driverClass")); driverAdapterCPDS.setMaxActive(Integer.valueOf(dataSourceProperties.getProperty("maxActive"))); driverAdapterCPDS.setMaxIdle(Integer.valueOf(dataSourceProperties.getProperty("maxIdle"))); driverAdapterCPDS.setPoolPreparedStatements(Boolean.valueOf(dataSourceProperties.getProperty("poolPreparedStatements"))); SharedPoolDataSource poolDataSource = new SharedPoolDataSource(); poolDataSource.setConnectionPoolDataSource(driverAdapterCPDS); poolDataSource.setMaxWait(Integer.valueOf(dataSourceProperties.getProperty("maxWait"))); poolDataSource.setDefaultTransactionIsolation(Integer.valueOf(dataSourceProperties.getProperty("defaultTransactionIsolation"))); poolDataSource.setDefaultReadOnly(Boolean.valueOf(dataSourceProperties.getProperty("defaultReadOnly"))); poolDataSource.setTestOnBorrow(Boolean.valueOf(dataSourceProperties.getProperty("testOnBorrow"))); poolDataSource.setValidationQuery("SELECT 0");
ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setMinPoolSize(); dataSource.setMaxPoolSize(); dataSource.setMaxIdleTime(); dataSource.setMaxStatements(); dataSource.setMaxStatementsPerConnection(); dataSource.setMaxIdleTimeExcessConnections();
List<Double> testList = new ArrayList(); testList.add(0.5); testList.add(0.2); testList.add(0.9); testList.add(0.1); testList.add(0.1); testList.add(0.1); testList.add(0.54); testList.add(0.71); testList.add(0.71); testList.add(0.71); testList.add(0.92); testList.add(0.12); testList.add(0.65); testList.add(0.34); testList.add(0.62);
0.92 0.9 0.71 0.71 0.71 0.65 0.62 0.54 0.5 0.34 0.2 0.12 0.1 0.1 0.1
Collections.sort(testList); Collections.reverse(testList);
Collections.sort(mArrayList, new Comparator<CustomData>() { @Override public int compare(CustomData lhs, CustomData rhs) { return lhs.customInt > rhs.customInt ? -1 : (lhs.customInt < rhs.customInt) ? 1 : 0; } });
Collections.sort(List<T> list, Comparator<? super T> c)
List<Double> testList = new ArrayList(); testList.sort(Comparator.naturalOrder());
testList.sort(Comparator.comparing(ClassName::getFieldName));
testList.sort(Comparator.comparing(ClassName::getFieldName).reversed());
testList.stream().sorted(Comparator.comparing(ClassName::getFieldName).reversed()).collect(Collectors.toList());
Collections.sort(testList, (a, b) -> b.compareTo(a));
Comparator<Double> comp = (Double a, Double b) -> { return b.compareTo(a); }; Collections.sort(testList, comp);
public class Circle implements Comparable<Circle> {}
@Override public int compareTo(Circle another) { if (this.getD()<another.getD()){ return -1; }else{ return 1; } }
Collections.sort(testList, Collections.reverseOrder());
package com.mnas.technology.automation.utility; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.Iterator; import java.util.List; import org.apache.log4j.Logger; /** * @author manoj.kumar */ public class SynchronizedArrayList { static Logger log = Logger.getLogger(SynchronizedArrayList.class.getName()); @SuppressWarnings("unchecked") public static void main(String[] args) { List<Employee> synchronizedList = Collections.synchronizedList(new ArrayList<Employee>()); synchronizedList.add(new Employee("Aditya")); synchronizedList.add(new Employee("Siddharth")); synchronizedList.add(new Employee("Manoj")); Collections.sort(synchronizedList, new Comparator() { public int compare(Object synchronizedListOne, Object synchronizedListTwo) { return ((Employee) synchronizedListOne).name .compareTo(((Employee) synchronizedListTwo).name); } }); /*for( Employee sd : synchronizedList) { log.info("Sorted Synchronized Array List..."+sd.name); }*/ synchronized (synchronizedList) { Iterator<Employee> iterator = synchronizedList.iterator(); while (iterator.hasNext()) { log.info("Sorted Synchronized Array List Items: " + iterator.next().name); } } } } class Employee { String name; Employee(String name) { this.name = name; } }
Comparator<Double> compareDouble = (d1, d2) -> d1.compareTo(d2); Collections.sort(testList, Collections.reverseOrder(compareDouble)); testList.forEach(System.out::println);
Collections.sort(NamAryVar, Collections.reverseOrder());
List<String> yourList = new ArrayList<String>(); Collections.sort(yourList, Collections.reverseOrder());
List<String> yourList = new ArrayList<String>(); yourList = yourList.stream().sorted(Collections.reverseOrder()).collect(Collectors.toList());
ArrayList<Group> groupList = new ArrayList<>(); Collections.sort(groupList, Collections.reverseOrder()); Collections.reverse(groupList);
import java.util.Collections; import java.util.ArrayList; import java.util.Arrays; public void main(String[] args){ Person ibrahima=new Person("Timera",40); Person toto=new Person("Toto",35); Person alex=new Person("Alex",50); ArrayList<Person> myList=new ArrayList<Person> Collections.sort(myList, new Comparator<Person>() { @Override public int compare(Person p1, Person p2) { return p1.name.compareTo(p2.name); } }); System.out.println(myList.toString()); Collections.reverse(myList); System.out.println(myList.toString()); }
MutableDoubleList doubleList = DoubleLists.mutable.with( 0.5, 0.2, 0.9, 0.1, 0.1, 0.1, 0.54, 0.71, 0.71, 0.71, 0.92, 0.12, 0.65, 0.34, 0.62) .sortThis().reverseThis(); doubleList.each(System.out::println);
List<Double> objectList = Lists.mutable.with( 0.5, 0.2, 0.9, 0.1, 0.1, 0.1, 0.54, 0.71, 0.71, 0.71, 0.92, 0.12, 0.65, 0.34, 0.62) .sortThis(Collections.reverseOrder()); objectList.forEach(System.out::println);
ArrayList<Double> arrayList = ArrayListIterate.sortThis( new ArrayList<>(objectList), Collections.reverseOrder()); arrayList.forEach(System.out::println);
List<String> alphaNumbers = Arrays.asList("one", "two", "three", "four"); List<String> alphaNumbersUpperCase = alphaNumbers.stream() .map(String::toUpperCase) .sorted() .collect(Collectors.toList()); System.out.println(alphaNumbersUpperCase);
public class WhatTheShoot { public static void main(String args[]){ try { throw null; } catch (Exception e){ System.out.println(e instanceof NullPointerException); System.out.println(e instanceof FileNotFoundException); } } }
try { Exception foo = null; if(false) { foo = new FileNotFoundException(); } throw foo; } catch (Exception e){ System.out.println(e instanceof NullPointerException); System.out.println(e instanceof FileNotFoundException); }
String[] names = {"Sam","Pamela", "Dave", "Pascal", "Erik"}; List<String> nameList; Stream<Integer> indices = intRange(1, names.length).boxed(); nameList = zip(indices, stream(names), SimpleEntry::new) .filter(e -> e.getValue().length() <= e.getKey()) .map(Entry::getValue) .collect(toList());
string[] names = { "Sam", "Pamela", "Dave", "Pascal", "Erik" }; var nameList = names.Where((c, index) => c.Length <= index + 1).ToList();
String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"}; IntStream.range(0, names.length) .filter(i -> names[i].length() <= i) .mapToObj(i -> names[i]) .collect(Collectors.toList());
String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"}; AtomicInteger index = new AtomicInteger(); List<String> list = Arrays.stream(names) .filter(n -> n.length() <= index.incrementAndGet()) .collect(Collectors.toList());
String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"}; List<String> nameList = IntStream.range(0, names.length) .filter(i -> names[i].length() <= i) .mapToObj(i -> names[i]) .collect(toList());
Streams.mapWithIndex( Stream.of("a", "b", "c"), (str, index) -> str + ":" + index) )
import java.util.*; import java.util.function.*; import java.util.stream.Collector; import java.util.stream.Collector.Characteristics; import java.util.stream.Stream; import java.util.stream.StreamSupport; import static java.util.Objects.requireNonNull; public class CollectionUtils { private CollectionUtils() { } /** * Converts an {@link java.util.Iterator} to {@link java.util.stream.Stream}. */ public static <T> Stream<T> iterate(Iterator<? extends T> iterator) { int characteristics = Spliterator.ORDERED | Spliterator.IMMUTABLE; return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, characteristics), false); } /** * Zips the specified stream with its indices. */ public static <T> Stream<Map.Entry<Integer, T>> zipWithIndex(Stream<? extends T> stream) { return iterate(new Iterator<Map.Entry<Integer, T>>() { private final Iterator<? extends T> streamIterator = stream.iterator(); private int index = 0; @Override public boolean hasNext() { return streamIterator.hasNext(); } @Override public Map.Entry<Integer, T> next() { return new AbstractMap.SimpleImmutableEntry<>(index++, streamIterator.next()); } }); } /** * Returns a stream consisting of the results of applying the given two-arguments function to the elements of this stream. * The first argument of the function is the element index and the second one - the element value. */ public static <T, R> Stream<R> mapWithIndex(Stream<? extends T> stream, BiFunction<Integer, ? super T, ? extends R> mapper) { return zipWithIndex(stream).map(entry -> mapper.apply(entry.getKey(), entry.getValue())); } public static void main(String[] args) { String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"}; System.out.println("Test zipWithIndex"); zipWithIndex(Arrays.stream(names)).forEach(entry -> System.out.println(entry)); System.out.println(); System.out.println("Test mapWithIndex"); mapWithIndex(Arrays.stream(names), (Integer index, String name) -> index+"="+name).forEach((String s) -> System.out.println(s)); } }
Seq.seq(Stream.of(names)).zipWithIndex() .filter( namesWithIndex -> namesWithIndex.v1.length() <= namesWithIndex.v2 + 1) .toList();
LazyFutureStream.of(names) .zipWithIndex() .filter( namesWithIndex -> namesWithIndex.v1.length() <= namesWithIndex.v2 + 1) .toList();
String[] names = {"Sam","Pamela", "Dave", "Pascal", "Erik"}; EntryStream.of(names) .filterKeyValue((idx, str) -> str.length() <= idx+1) .values().toList();
public class WithIndex<T> { private int index; private T value; WithIndex(int index, T value) { this.index = index; this.value = value; } public int index() { return index; } public T value() { return value; } @Override public String toString() { return value + "(" + index + ")"; } public static <T> Function<T, WithIndex<T>> indexed() { return new Function<T, WithIndex<T>>() { int index = 0; @Override public WithIndex<T> apply(T t) { return new WithIndex<>(index++, t); } }; } }
public static void main(String[] args) { Stream<String> stream = Stream.of("a", "b", "c", "d", "e"); stream.map(WithIndex.indexed()).forEachOrdered(e -> { System.out.println(e.index() + " -> " + e.value()); }); }
String[] names = {"Sam","Pamela", "Dave", "Pascal", "Erik"}; List<String> nameList; Stream<Integer> indices = IntStream.range(0, names.length).boxed(); nameList = StreamUtils.zip(indices, stream(names),SimpleEntry::new) .filter(e -> e.getValue().length() <= e.getKey()).map(Entry::getValue).collect(toList()); System.out.println(nameList);
String[] names = { "Sam", "Pamela", "Dave", "Pascal", "Erik" }; ImmutableList<String> expected = Lists.immutable.with("Erik"); Predicate<Pair<String, Integer>> predicate = pair -> pair.getOne().length() <= pair.getTwo() + 1; List<String> strings1 = ArrayIterate.zipWithIndex(names) .collectIf(predicate, Pair::getOne); Assert.assertEquals(expected, strings1); List<String> list = Arrays.asList(names); List<String> strings2 = ListAdapter.adapt(list) .zipWithIndex() .collectIf(predicate, Pair::getOne); Assert.assertEquals(expected, strings2); MutableList<String> mutableNames = Lists.mutable.with(names); MutableList<String> strings3 = mutableNames.zipWithIndex() .collectIf(predicate, Pair::getOne); Assert.assertEquals(expected, strings3); ImmutableList<String> immutableNames = Lists.immutable.with(names); ImmutableList<String> strings4 = immutableNames.zipWithIndex() .collectIf(predicate, Pair::getOne); Assert.assertEquals(expected, strings4); MutableList<String> strings5 = mutableNames.asLazy() .zipWithIndex() .collectIf(predicate, Pair::getOne, Lists.mutable.empty()); Assert.assertEquals(expected, strings5);
MutableList<String> mutableNames = Lists.mutable.with("Sam", "Pamela", "Dave", "Pascal", "Erik"); ImmutableList<String> expected = Lists.immutable.with("Erik"); List<String> actual = Lists.mutable.empty(); mutableNames.forEachWithIndex((name, index) -> { if (name.length() <= index + 1) actual.add(name); }); Assert.assertEquals(expected, actual);
List<String> strings = new ArrayList<>(Arrays.asList("First", "Second", "Third", "Fourth", "Fifth")); strings.stream() .collect(HashMap::new, (h, o) -> h.put(h.size(), o), (h, o) -> {}) .forEach((i, o) -> { System.out.println(String.format("%d => %s", i, o)); });
0 => First 1 => Second 2 => Third 3 => Fourth 4 => Fifth
Stream.of(names).indexed() .filter(e -> e.value().length() <= e.index()) .map(Indexed::value).toList();
static class Indexer { int i = 0; } public static String getRegex() { EnumSet<MeasureUnit> range = EnumSet.allOf(MeasureUnit.class); StringBuilder sb = new StringBuilder(); Indexer indexer = new Indexer(); range.stream().forEach( measureUnit -> { sb.append(measureUnit.acronym); if (indexer.i < range.size() - 1) sb.append("|"); indexer.i++; } ); return sb.toString(); }
public static <T> int indexOf(List<T> items, Predicate<T> matches) { return IntStream.range(0, items.size()) .filter(index -> matches.test(items.get(index))) .findFirst().orElse(-1); }
int index = indexOf(myList, item->item.getId()==100);
public static <T> int indexOf(Collection<T> items, Predicate<T> matches) { int index = -1; Iterator<T> it = items.iterator(); while (it.hasNext()) { index++; if (matches.test(it.next())) { return index; } } return -1; }
OptionalInt index = IntStream.range(0, list.size()) .filter(i -> list.get(i) == 3) .findFirst();
IntStream.range(0, list.size()) .filter(i -> list.get(i) == 3) .collect(Collectors.toList());
AtomicInteger index = new AtomicInteger(); Stream.of(names) .map(e->new Object() { String n=e; public i=index.getAndIncrement(); }) .filter(o->o.n.length()<=o.i) .forEach(o->System.out.println("idx:"+o.i+" nam:"+o.n));
public String foo(String key) { return "!" + key + "!"; }
interface Sender { default final void send() { send(null); } void send(String message); }
abstract class Sender { final void send() { send(null); } abstract void send(String message); }
interface A { default void foo() { ... } } interface B { } class C implements A, B { }
public class Stream { public startTime; public endTime; public getDuration() { return startTime - endTime; } }
long startTime = System.currentTimeMillis(); long estimatedTime = System.currentTimeMillis() - startTime;
long startTime = System.nanoTime(); long estimatedTime = System.nanoTime() - startTime;
import com.jamonapi.*; ... Monitor mon=MonitorFactory.start("myFirstMonitor"); ...Code Being Timed... mon.stop();
public aspect MonitorAspect { pointcut monitor() : execution(* *.ClassToMonitor.methodToMonitor(..)); Object arround() : monitor() { Monitor monitor = MonitorFactory.start(thisJoinPoint.toShortString()); Object returnedObject = proceed(); monitor.stop(); return returnedObject; } }
public class TimeWatch { long starts; public static TimeWatch start() { return new TimeWatch(); } private TimeWatch() { reset(); } public TimeWatch reset() { starts = System.currentTimeMillis(); return this; } public long time() { long ends = System.currentTimeMillis(); return ends - starts; } public long time(TimeUnit unit) { return unit.convert(time(), TimeUnit.MILLISECONDS); } }
TimeWatch watch = TimeWatch.start(); long passedTimeInMs = watch.time(); long passedTimeInSeconds = watch.time(TimeUnit.SECONDS);
final StopWatch stopwatch = new StopWatch(); stopwatch.start(); LOGGER.debug("Starting long calculations: {}", stopwatch); ... LOGGER.debug("Time after key part of calcuation: {}", stopwatch); ... LOGGER.debug("Finished calculating {}", stopwatch);
Duration.between( LocalTime.of( 23 , 0 ) , LocalTime.of( 1 , 0 ) ) .toString()
Duration.between( then , Instant.now() ) .toString()
LocalTime sooner = LocalTime.of ( 17, 00 ); LocalTime later = LocalTime.of ( 19, 00 );
Duration duration = Duration.between ( sooner, later );
System.out.println ( "sooner: " + sooner + " | later: " + later + " | duration: " + duration );
LocalTime sooner = LocalTime.of ( 23, 0 ); LocalTime later = LocalTime.of ( 1, 0 );
LocalDate localDate = LocalDate.of ( 2016, 1, 23 ); ZoneId zoneId = ZoneId.of ( "America/Montreal" ); ZonedDateTime sooner = ZonedDateTime.of ( localDate, LocalTime.of ( 23, 0 ), zoneId );
ZonedDateTime later = ZonedDateTime.of ( localDate.plusDays ( 1 ), LocalTime.of ( 1, 0 ), zoneId );
Duration duration = Duration.between ( sooner, later );
System.out.println ( "sooner: " + sooner + " | later: " + later + " | duration: " + duration );
public class Stream { public long startTime; public long endTime; public long getDuration() { return endTime - startTime; } public void start() { startTime = System.currentTimeMillis(); } public void stop() { endTime = System.currentTimeMillis(); } }
Stream s = .... s.start(); s.stop(); s.getDuration();
DateTime start = new DateTime(2004, 12, 25, 0, 0, 0, 0); DateTime end = new DateTime(2005, 1, 1, 0, 0, 0, 0); public Interval getInterval() { Interval interval = new Interval(start, end); }
Date startingTime = Calendar.getInstance().getTime(); Date now = Calendar.getInstance().getTime(); long timeElapsed = now.getTime() - startingTime.getTime();
Byte Stream Reader Elapsed Time for 23.7 MB is 96 secs import java.io.*; import java.io.IOException; import java.util.Scanner; class ElaspedTimetoCopyAFileUsingByteStream { private long startTime = 0; private long stopTime = 0; private boolean running = false; public void start() { this.startTime = System.currentTimeMillis(); this.running = true; } public void stop() { this.stopTime = System.currentTimeMillis(); this.running = false; } public long getElapsedTime() { long elapsed; if (running) { elapsed = (System.currentTimeMillis() - startTime); } else { elapsed = (stopTime - startTime); } return elapsed; } public long getElapsedTimeSecs() { long elapsed; if (running) { elapsed = ((System.currentTimeMillis() - startTime) / 1000); } else { elapsed = ((stopTime - startTime) / 1000); } return elapsed; } public static void main(String[] args) throws IOException { ElaspedTimetoCopyAFileUsingByteStream s = new ElaspedTimetoCopyAFileUsingByteStream(); s.start(); FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream("vowels.txt"); out = new FileOutputStream("output.txt"); int c; while ((c = in.read()) != -1) { out.write(c); } }finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } s.stop(); System.out.println("elapsed time in seconds: " + s.getElapsedTimeSecs()); } } [Elapsed Time for Byte Stream Reader][1] **Character Stream Reader Elapsed Time for 23.7 MB is 3 secs** import java.io.*; import java.io.IOException; import java.util.Scanner; class ElaspedTimetoCopyAFileUsingCharacterStream { private long startTime = 0; private long stopTime = 0; private boolean running = false; public void start() { this.startTime = System.currentTimeMillis(); this.running = true; } public void stop() { this.stopTime = System.currentTimeMillis(); this.running = false; } public long getElapsedTime() { long elapsed; if (running) { elapsed = (System.currentTimeMillis() - startTime); } else { elapsed = (stopTime - startTime); } return elapsed; } public long getElapsedTimeSecs() { long elapsed; if (running) { elapsed = ((System.currentTimeMillis() - startTime) / 1000); } else { elapsed = ((stopTime - startTime) / 1000); } return elapsed; } public static void main(String[] args) throws IOException { ElaspedTimetoCopyAFileUsingCharacterStream s = new ElaspedTimetoCopyAFileUsingCharacterStream(); s.start(); FileReader in = null; FileWriter out = null; try { in = new FileReader("vowels.txt"); out = new FileWriter("output.txt"); int c; while ((c = in.read()) != -1) { out.write(c); } }finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } s.stop(); System.out.println("elapsed time in seconds: " + s.getElapsedTimeSecs()); } } [Elapsed Time for Character Stream Reader][2] [1]: https: [2]: https:
public class Et { public Et() { reset(); } public void reset() { t0=System.nanoTime(); } public long t0() { return t0; } public long dt() { return System.nanoTime()-t0(); } public double etms() { return etms(dt()); } @Override public String toString() { return etms()+" ms."; } public static double etms(long dt) { return dt/1000000.; } private Long t0; }
SimpleDateFormat format = new SimpleDateFormat("HH:mm"); Date d1 = format.parse(strStartTime); Date d2 = format.parse(strEndTime); long diff = d2.getTime() - d1.getTime(); long diffSeconds,diffMinutes,diffHours; if (diff > 0) { diffSeconds = diff / 1000 % 60; diffMinutes = diff / (60 * 1000) % 60; diffHours = diff / (60 * 60 * 1000); } else{ long diffpos = (24*((60 * 60 * 1000))) + diff; diffSeconds = diffpos / 1000 % 60; diffMinutes = diffpos / (60 * 1000) % 60; diffHours = (diffpos / (60 * 60 * 1000)); }
public static String GetElapsed(long aInitialTime, long aEndTime, boolean aIncludeMillis) { StringBuffer elapsed = new StringBuffer(); Map<String, Long> units = new HashMap<String, Long>(); long milliseconds = aEndTime - aInitialTime; long seconds = milliseconds / 1000; long minutes = milliseconds / (60 * 1000); long hours = milliseconds / (60 * 60 * 1000); long days = milliseconds / (24 * 60 * 60 * 1000); units.put("milliseconds", milliseconds); units.put("seconds", seconds); units.put("minutes", minutes); units.put("hours", hours); units.put("days", days); if (days > 0) { long leftoverHours = hours % 24; units.put("hours", leftoverHours); } if (hours > 0) { long leftoeverMinutes = minutes % 60; units.put("minutes", leftoeverMinutes); } if (minutes > 0) { long leftoverSeconds = seconds % 60; units.put("seconds", leftoverSeconds); } if (seconds > 0) { long leftoverMilliseconds = milliseconds % 1000; units.put("milliseconds", leftoverMilliseconds); } elapsed.append(PrependZeroIfNeeded(units.get("days")) + " days ") .append(PrependZeroIfNeeded(units.get("hours")) + " hours ") .append(PrependZeroIfNeeded(units.get("minutes")) + " minutes ") .append(PrependZeroIfNeeded(units.get("seconds")) + " seconds ") .append(PrependZeroIfNeeded(units.get("milliseconds")) + " ms"); return elapsed.toString(); } private static String PrependZeroIfNeeded(long aValue) { return aValue < 10 ? "0" + aValue : Long.toString(aValue); }
import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; public class TimeUtilsTest extends TestCase { public void testGetElapsed() { long start = System.currentTimeMillis(); GregorianCalendar calendar = (GregorianCalendar) Calendar.getInstance(); calendar.setTime(new Date(start)); calendar.add(Calendar.MILLISECOND, 610); calendar.add(Calendar.SECOND, 35); calendar.add(Calendar.MINUTE, 5); calendar.add(Calendar.DAY_OF_YEAR, 5); long end = calendar.getTimeInMillis(); assertEquals("05 days 00 hours 05 minutes 35 seconds 610 ms", TimeUtils.GetElapsed(start, end, true)); } }
@BeforeClass public static void setUpClass() throws Exception { Properties queries = loadPropertiesFile("requests.properties"); Properties responses = loadPropertiesFile("responses.properties"); instance = new ResponseGenerator(queries, responses); } @Test public void testGetResponse() { String request = "<some>request</some>"; String expResult = "<some>response</some>"; String result = instance.getResponse(request); assertEquals(expResult, result); }
System.out.println("match found: " + strExpr); System.out.println("xml not well formed: " + e.getMessage());
private final ByteArrayOutputStream outContent = new ByteArrayOutputStream(); private final ByteArrayOutputStream errContent = new ByteArrayOutputStream(); private final PrintStream originalOut = System.out; private final PrintStream originalErr = System.err; @Before public void setUpStreams() { System.setOut(new PrintStream(outContent)); System.setErr(new PrintStream(errContent)); } @After public void restoreStreams() { System.setOut(originalOut); System.setErr(originalErr); }
@Test public void out() { System.out.print("hello"); assertEquals("hello", outContent.toString()); } @Test public void err() { System.err.print("hello again"); assertEquals("hello again", errContent.toString()); }
public void MyTest { @Rule public final SystemOutRule systemOutRule = new SystemOutRule().enableLog(); @Test public void overrideProperty() { System.out.print("hello world"); assertEquals("hello world", systemOutRule.getLog()); } }
ConsoleWriter writer = new ConsoleWriter(System.out));
ByteArrayOutputStream outSpy = new ByteArrayOutputStream(); ConsoleWriter writer = new ConsoleWriter(new PrintStream(outSpy)); writer.printSomething(); assertThat(outSpy.toString(), is("expected output"));
public class FooTest { @Rule public final ExpectedLogs logs = new ExpectedLogs() {{ captureFor(Foo.class, LogLevel.WARN); }}; @Test public void barShouldLogWarning() { assertThat(logs.isEmpty(), is(true)); Foo foo = new Foo(); assertThat(foo.bar(), is(not(nullValue()))); assertThat(logs.isEmpty(), is(false)); assertThat(logs.contains("Your warning message here"), is(true)); } }
public class TestHelper { public static void captureOutput( CaptureTest test ) throws Exception { ByteArrayOutputStream outContent = new ByteArrayOutputStream(); ByteArrayOutputStream errContent = new ByteArrayOutputStream(); System.setOut(new PrintStream(outContent)); System.setErr(new PrintStream(errContent)); test.test( outContent, errContent ); System.setOut(new PrintStream(new FileOutputStream(FileDescriptor.out))); System.setErr(new PrintStream(new FileOutputStream(FileDescriptor.out))); } } abstract class CaptureTest { public abstract void test( ByteArrayOutputStream outContent, ByteArrayOutputStream errContent ) throws Exception; }
import static package.to.TestHelper.*; public class SimpleTest { @Test public void testOutput() throws Exception { captureOutput( new CaptureTest() { @Override public void test(ByteArrayOutputStream outContent, ByteArrayOutputStream errContent) throws Exception { assertEquals( "the expected output\n", outContent.toString() ); } }); }
@Rule public OutputCapture outputCapture = new OutputCapture(); @Test public void out() { System.out.print("hello"); assertEquals(outputCapture.toString(), "hello"); }
import java.util.Scanner; public class SimpleProgram { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(scanner.next()); scanner.close(); } }
import static org.junit.Assert.*; import java.io.*; import org.junit.*; public class SimpleProgramTest { private final InputStream systemIn = System.in; private final PrintStream systemOut = System.out; private ByteArrayInputStream testIn; private ByteArrayOutputStream testOut; @Before public void setUpOutput() { testOut = new ByteArrayOutputStream(); System.setOut(new PrintStream(testOut)); } private void provideInput(String data) { testIn = new ByteArrayInputStream(data.getBytes()); System.setIn(testIn); } private String getOutput() { return testOut.toString(); } @After public void restoreSystemInputOutput() { System.setIn(systemIn); System.setOut(systemOut); } @Test public void testCase1() { final String testString = "Hello!"; provideInput(testString); SimpleProgram.main(new String[0]); assertEquals(testString, getOutput()); } }
java.lang.AssertionError: expected [21.92] but found [value]
@Test void it_prints_out() { PrintStream save_out=System.out;final ByteArrayOutputStream out = new ByteArrayOutputStream();System.setOut(new PrintStream(out)); System.out.println("Hello World!"); assertEquals("Hello World!\r\n", out.toString()); System.setOut(save_out); }
@Test void it_prints_err() { PrintStream save_err=System.err;final ByteArrayOutputStream err= new ByteArrayOutputStream();System.setErr(new PrintStream(err)); System.err.println("Hello World!"); assertEquals("Hello World!\r\n", err.toString()); System.setErr(save_err); }
package learning; import static org.assertj.core.api.BDDAssertions.then; import java.io.ByteArrayOutputStream; import java.io.PrintStream; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; class SystemOutLT { private PrintStream originalSystemOut; private ByteArrayOutputStream systemOutContent; @BeforeEach void redirectSystemOutStream() { originalSystemOut = System.out; systemOutContent = new ByteArrayOutputStream(); System.setOut(new PrintStream(systemOutContent)); } @AfterEach void restoreSystemOutStream() { System.setOut(originalSystemOut); } @Test void shouldPrintToSystemOut() { System.out.println("example"); then(systemOutContent.toString()).containsIgnoringCase("example"); } }
Days.daysBetween(start.toLocalDate(), end.toLocalDate()).getDays()
DateTimeZone BRAZIL = DateTimeZone.forID("America/Sao_Paulo"); DateTime start = new DateTime(2013, 10, 20, 5, 0, 0, BRAZIL); DateTime end = new DateTime(2013, 10, 21, 13, 0, 0, BRAZIL); System.out.println(daysBetween(start.withTimeAtStartOfDay(), end.withTimeAtStartOfDay()).getDays()); System.out.println(daysBetween(start.toLocalDate(), end.toLocalDate()).getDays());
Days.daysBetween(start.withTimeAtStartOfDay() , end.withTimeAtStartOfDay() ).getDays()
Days.daysBetween(new LocalDate(start), new LocalDate(end)).getDays()
java.time.temporal.ChronoUnit.DAYS.between( earlier.truncatedTo( ChronoUnit.DAYS ) , later.truncatedTo( ChronoUnit.DAYS ) )
java.time.temporal.ChronoUnit.HOURS.between( earlier.truncatedTo( ChronoUnit.HOURS ) , later.truncatedTo( ChronoUnit.HOURS ) )
ZoneId z = ZoneId.of( "Pacific/Auckland" ) ; ZonedDateTime now = ZonedDateTime.now( z ) ;
LocalDate localDateStart = zdtStart.toLocalDate() ; LocalDate localDateStop = zdtStop.toLocalDate() ;
long days = ChronoUnit.DAYS.between( localDateStart , localDateStop ) ;
ZoneId z = ZoneId.of( "America/Montreal" ); ZonedDateTime start = ZonedDateTime.of( 2017 , 1 , 17 , 14 , 45 , 0 , 0 , z ); ZonedDateTime stop = ZonedDateTime.of( 2017 , 1 , 17 , 15 , 12 , 0 , 0 , z ); long hours = ChronoUnit.HOURS.between( start.truncatedTo( ChronoUnit.HOURS ) , stop.truncatedTo( ChronoUnit.HOURS ) );
ZoneId z = ZoneId.of( "America/Montreal" ); ZonedDateTime start = ZonedDateTime.of( 2017 , 1 , 17 , 23 , 55 , 0 , 0 , z ); ZonedDateTime stop = ZonedDateTime.of( 2017 , 1 , 18 , 00 , 05 , 0 , 0 , z ); long days = ChronoUnit.DAYS.between( start.truncatedTo( ChronoUnit.DAYS ) , stop.truncatedTo( ChronoUnit.DAYS ) );
public static int getDaysBetween(DateTime earlier, DateTime later) { return (int) TimeUnit.MILLISECONDS.toDays(later.getMillis()- earlier.getMillis()); }
LocalDate now = LocalDate.now(); LocalDate inputDate = LocalDate.of(2018, 11, 28); Period period = Period.between( inputDate, now); int diff = period.getDays(); System.out.println("diff = " + diff);
DateTime dt = new DateTime(laterDate); DateTime newDate = dt.minus( new DateTime ( previousDate ).getMillis()); System.out.println("No of days : " + newDate.getDayOfYear() - 1 );
public static int getDifferenceIndays(long timestamp1, long timestamp2) { final int SECONDS = 60; final int MINUTES = 60; final int HOURS = 24; final int MILLIES = 1000; long temp; if (timestamp1 < timestamp2) { temp = timestamp1; timestamp1 = timestamp2; timestamp2 = temp; } Calendar startDate = Calendar.getInstance(TimeZone.getDefault()); Calendar endDate = Calendar.getInstance(TimeZone.getDefault()); endDate.setTimeInMillis(timestamp1); startDate.setTimeInMillis(timestamp2); if ((timestamp1 - timestamp2) < 1 * HOURS * MINUTES * SECONDS * MILLIES) { int day1 = endDate.get(Calendar.DAY_OF_MONTH); int day2 = startDate.get(Calendar.DAY_OF_MONTH); if (day1 == day2) { return 0; } else { return 1; } } int diffDays = 0; startDate.add(Calendar.DAY_OF_MONTH, diffDays); while (startDate.before(endDate)) { startDate.add(Calendar.DAY_OF_MONTH, 1); diffDays++; } return diffDays; }
class DbBasedAccountDAO implements AccountDAO class InMemoryAccountDAO implements AccountDAO
interface User { } class DefaultUser implements User { } class AnotherClassOfUser implements User { }
class Number implements Comparable{...} class MyThread implements Runnable{...} class SessionData implements Serializable{....}
public class AdminForumUser extends User implements ForumUserInterface
public void doSomething(Collection someStuff) { ... }
double intermediateResult; for(int i=0; i < 1000; i++){ intermediateResult = i; System.out.println(intermediateResult); }
for(int i=0; i < 1000; i++){ double intermediateResult = i; System.out.println(intermediateResult); }
using System; using System.Collections.Generic; class Test { static void Main() { List<Action> actions = new List<Action>(); int outer; for (int i=0; i < 10; i++) { outer = i; int inner = i; actions.Add(() => Console.WriteLine("Inner={0}, Outer={1}", inner, outer)); } foreach (Action action in actions) { action(); } } }
Inner=0, Outer=9 Inner=1, Outer=9 Inner=2, Outer=9 Inner=3, Outer=9 Inner=4, Outer=9 Inner=5, Outer=9 Inner=6, Outer=9 Inner=7, Outer=9 Inner=8, Outer=9 Inner=9, Outer=9
double r0; for (int i = 0; i < 1000; i++) { r0 = i*i; Console.WriteLine(r0); } for (int j = 0; j < 1000; j++) { double r1 = j*j; Console.WriteLine(r1); }
for (int i = 0; i < 0x3e8; i++) { double r0 = i * i; Console.WriteLine(r0); } for (int j = 0; j < 0x3e8; j++) { double r1 = j * j; Console.WriteLine(r1); }
For i as Integer = 1 to 100 Dim j as Integer Console.WriteLine(j) j = i Next
For i as Integer = 1 to 100 Dim j as Integer = 0 Console.WriteLine(j) j = i Next
0x00000000004004b6 <+0>: push rbp 0x00000000004004b7 <+1>: mov rbp,rsp 0x00000000004004ba <+4>: mov DWORD PTR [rbp-0x4],0x0 0x00000000004004c1 <+11>: jmp 0x4004cd <main+23> 0x00000000004004c3 <+13>: mov eax,DWORD PTR [rbp-0x4] 0x00000000004004c6 <+16>: mov DWORD PTR [rbp-0x8],eax 0x00000000004004c9 <+19>: add DWORD PTR [rbp-0x4],0x1 0x00000000004004cd <+23>: cmp DWORD PTR [rbp-0x4],0x9 0x00000000004004d1 <+27>: jle 0x4004c3 <main+13> 0x00000000004004d3 <+29>: mov eax,0x0 0x00000000004004d8 <+34>: pop rbp 0x00000000004004d9 <+35>: ret
0x00000000004004b6 <+0>: push rbp 0x00000000004004b7 <+1>: mov rbp,rsp 0x00000000004004ba <+4>: mov DWORD PTR [rbp-0x4],0x0 0x00000000004004c1 <+11>: jmp 0x4004cd <main+23> 0x00000000004004c3 <+13>: mov eax,DWORD PTR [rbp-0x4] 0x00000000004004c6 <+16>: mov DWORD PTR [rbp-0x8],eax 0x00000000004004c9 <+19>: add DWORD PTR [rbp-0x4],0x1 0x00000000004004cd <+23>: cmp DWORD PTR [rbp-0x4],0x9 0x00000000004004d1 <+27>: jle 0x4004c3 <main+13> 0x00000000004004d3 <+29>: mov eax,0x0 0x00000000004004d8 <+34>: pop rbp 0x00000000004004d9 <+35>: ret
for(int i=0, double intermediateResult=0; i<1000; i++){ intermediateResult = i; System.out.println(intermediateResult); }
{ double intermediateResult; for (int i=0; i<1000; i++) { intermediateResult = i; System.out.println(intermediateResult); } }
public static void outside() { double intermediateResult; for(int i=0; i < Integer.MAX_VALUE; i++){ intermediateResult = i; } } public static void inside() { for(int i=0; i < Integer.MAX_VALUE; i++){ double intermediateResult = i; } }
typedef struct loop_example{ JXTZ hi; }loop_example_struct; int j = 0; for ( ;j++; ) { loop_example loop_object; }
var now = require("../node_modules/performance-now") function varInside(){ for(var i = 0; i < 100000000; i++){ var temp = i; var temp2 = i + 1; var temp3 = i + 2; } } function varOutside(){ var temp; var temp2; var temp3; for(var i = 0; i < 100000000; i++){ temp = i temp2 = i + 1 temp3 = i + 2 } } var insideAvg = 0; var outsideAvg = 0; for(var i = 0; i < 1000; i++){ var start = now() varInside() var end = now() insideAvg = (insideAvg + (end-start)) / 2 } for(var i = 0; i < 1000; i++){ var start = now() varOutside() var end = now() outsideAvg = (outsideAvg + (end-start)) / 2 } console.log( console.log(
double intermediateResult; int i = byte.MinValue; for(; i < 1000; i++) { intermediateResult = i; System.out.println(intermediateResult); }
String value = WinRegistry.readString ( WinRegistry.HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "ProductName"); System.out.println("Windows Distribution = " + value);
import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.util.ArrayList; import java.util.List; import java.util.prefs.Preferences; public class WinRegistry { public static final int HKEY_CURRENT_USER = 0x80000001; public static final int HKEY_LOCAL_MACHINE = 0x80000002; public static final int REG_SUCCESS = 0; public static final int REG_NOTFOUND = 2; public static final int REG_ACCESSDENIED = 5; private static final int KEY_ALL_ACCESS = 0xf003f; private static final int KEY_READ = 0x20019; private static final Preferences userRoot = Preferences.userRoot(); private static final Preferences systemRoot = Preferences.systemRoot(); private static final Class<? extends Preferences> userClass = userRoot.getClass(); private static final Method regOpenKey; private static final Method regCloseKey; private static final Method regQueryValueEx; private static final Method regEnumValue; private static final Method regQueryInfoKey; private static final Method regEnumKeyEx; private static final Method regCreateKeyEx; private static final Method regSetValueEx; private static final Method regDeleteKey; private static final Method regDeleteValue; static { try { regOpenKey = userClass.getDeclaredMethod("WindowsRegOpenKey", new Class[] { int.class, byte[].class, int.class }); regOpenKey.setAccessible(true); regCloseKey = userClass.getDeclaredMethod("WindowsRegCloseKey", new Class[] { int.class }); regCloseKey.setAccessible(true); regQueryValueEx = userClass.getDeclaredMethod("WindowsRegQueryValueEx", new Class[] { int.class, byte[].class }); regQueryValueEx.setAccessible(true); regEnumValue = userClass.getDeclaredMethod("WindowsRegEnumValue", new Class[] { int.class, int.class, int.class }); regEnumValue.setAccessible(true); regQueryInfoKey = userClass.getDeclaredMethod("WindowsRegQueryInfoKey1", new Class[] { int.class }); regQueryInfoKey.setAccessible(true); regEnumKeyEx = userClass.getDeclaredMethod( "WindowsRegEnumKeyEx", new Class[] { int.class, int.class, int.class }); regEnumKeyEx.setAccessible(true); regCreateKeyEx = userClass.getDeclaredMethod( "WindowsRegCreateKeyEx", new Class[] { int.class, byte[].class }); regCreateKeyEx.setAccessible(true); regSetValueEx = userClass.getDeclaredMethod( "WindowsRegSetValueEx", new Class[] { int.class, byte[].class, byte[].class }); regSetValueEx.setAccessible(true); regDeleteValue = userClass.getDeclaredMethod( "WindowsRegDeleteValue", new Class[] { int.class, byte[].class }); regDeleteValue.setAccessible(true); regDeleteKey = userClass.getDeclaredMethod( "WindowsRegDeleteKey", new Class[] { int.class, byte[].class }); regDeleteKey.setAccessible(true); } catch (Exception e) { throw new RuntimeException(e); } } private WinRegistry() { } /** * Read a value from key and value name * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @param valueName * @return the value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static String readString(int hkey, String key, String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) { return readString(systemRoot, hkey, key, valueName); } else if (hkey == HKEY_CURRENT_USER) { return readString(userRoot, hkey, key, valueName); } else { throw new IllegalArgumentException("hkey=" + hkey); } } /** * Read value(s) and value name(s) form given key * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @return the value name(s) plus the value(s) * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static Map<String, String> readStringValues(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) { return readStringValues(systemRoot, hkey, key); } else if (hkey == HKEY_CURRENT_USER) { return readStringValues(userRoot, hkey, key); } else { throw new IllegalArgumentException("hkey=" + hkey); } } /** * Read the value name(s) from a given key * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @return the value name(s) * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static List<String> readStringSubKeys(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) { return readStringSubKeys(systemRoot, hkey, key); } else if (hkey == HKEY_CURRENT_USER) { return readStringSubKeys(userRoot, hkey, key); } else { throw new IllegalArgumentException("hkey=" + hkey); } } /** * Create a key * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void createKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int [] ret; if (hkey == HKEY_LOCAL_MACHINE) { ret = createKey(systemRoot, hkey, key); regCloseKey.invoke(systemRoot, new Object[] { new Integer(ret[0]) }); } else if (hkey == HKEY_CURRENT_USER) { ret = createKey(userRoot, hkey, key); regCloseKey.invoke(userRoot, new Object[] { new Integer(ret[0]) }); } else { throw new IllegalArgumentException("hkey=" + hkey); } if (ret[1] != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + ret[1] + " key=" + key); } } /** * Write a value in a given key/value name * @param hkey * @param key * @param valueName * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void writeStringValue (int hkey, String key, String valueName, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) { writeStringValue(systemRoot, hkey, key, valueName, value); } else if (hkey == HKEY_CURRENT_USER) { writeStringValue(userRoot, hkey, key, valueName, value); } else { throw new IllegalArgumentException("hkey=" + hkey); } } /** * Delete a given key * @param hkey * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void deleteKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = -1; if (hkey == HKEY_LOCAL_MACHINE) { rc = deleteKey(systemRoot, hkey, key); } else if (hkey == HKEY_CURRENT_USER) { rc = deleteKey(userRoot, hkey, key); } if (rc != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + rc + " key=" + key); } } /** * delete a value from a given key/value name * @param hkey * @param key * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void deleteValue(int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = -1; if (hkey == HKEY_LOCAL_MACHINE) { rc = deleteValue(systemRoot, hkey, key, value); } else if (hkey == HKEY_CURRENT_USER) { rc = deleteValue(userRoot, hkey, key, value); } if (rc != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + rc + " key=" + key + " value=" + value); } } private static int deleteValue (Preferences root, int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) }); if (handles[1] != REG_SUCCESS) { return handles[1]; } int rc =((Integer) regDeleteValue.invoke(root, new Object[] { new Integer(handles[0]), toCstr(value) })).intValue(); regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); return rc; } private static int deleteKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc =((Integer) regDeleteKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key) })).intValue(); return rc; } private static String readString(Preferences root, int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) }); if (handles[1] != REG_SUCCESS) { return null; } byte[] valb = (byte[]) regQueryValueEx.invoke(root, new Object[] { new Integer(handles[0]), toCstr(value) }); regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); return (valb != null ? new String(valb).trim() : null); } private static Map<String,String> readStringValues (Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { HashMap<String, String> results = new HashMap<String,String>(); int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) }); if (handles[1] != REG_SUCCESS) { return null; } int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { new Integer(handles[0]) }); int count = info[0]; int maxlen = info[3]; for(int index=0; index<count; index++) { byte[] name = (byte[]) regEnumValue.invoke(root, new Object[] { new Integer (handles[0]), new Integer(index), new Integer(maxlen + 1)}); String value = readString(hkey, key, new String(name)); results.put(new String(name).trim(), value); } regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); return results; } private static List<String> readStringSubKeys (Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { List<String> results = new ArrayList<String>(); int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) }); if (handles[1] != REG_SUCCESS) { return null; } int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { new Integer(handles[0]) }); int count = info[0]; int maxlen = info[3]; for(int index=0; index<count; index++) { byte[] name = (byte[]) regEnumKeyEx.invoke(root, new Object[] { new Integer (handles[0]), new Integer(index), new Integer(maxlen + 1) }); results.add(new String(name).trim()); } regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); return results; } private static int [] createKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { return (int[]) regCreateKeyEx.invoke(root, new Object[] { new Integer(hkey), toCstr(key) }); } private static void writeStringValue (Preferences root, int hkey, String key, String valueName, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) }); regSetValueEx.invoke(root, new Object[] { new Integer(handles[0]), toCstr(valueName), toCstr(value) }); regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); } private static byte[] toCstr(String str) { byte[] result = new byte[str.length() + 1]; for (int i = 0; i < str.length(); i++) { result[i] = (byte) str.charAt(i); } result[str.length()] = 0; return result; } }
Runtime.getRuntime().exec("reg <your parameters here>");
import java.io.IOException; import java.io.InputStream; import java.io.StringWriter; /** * @author Oleg Ryaboy, based on work by Miguel Enriquez */ public class WindowsReqistry { /** * * @param location path in the registry * @param key registry key * @return registry value or null if not found */ public static final String readRegistry(String location, String key){ try { Process process = Runtime.getRuntime().exec("reg query " + StreamReader reader = new StreamReader(process.getInputStream()); reader.start(); process.waitFor(); reader.join(); String output = reader.getResult(); if( ! output.contains("\t")){ return null; } String[] parsed = output.split("\t"); return parsed[parsed.length-1]; } catch (Exception e) { return null; } } static class StreamReader extends Thread { private InputStream is; private StringWriter sw= new StringWriter(); public StreamReader(InputStream is) { this.is = is; } public void run() { try { int c; while ((c = is.read()) != -1) sw.write(c); } catch (IOException e) { } } public String getResult() { return sw.toString(); } } public static void main(String[] args) { String value = WindowsReqistry.readRegistry("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\" + "Explorer\\Shell Folders", "Personal"); System.out.println(value); } }
import com.sun.jna.platform.win32.Advapi32Util; import com.sun.jna.platform.win32.WinReg; public class WindowsRegistrySnippet { public static void main(String[] args) { String productName = Advapi32Util.registryGetStringValue( WinReg.HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "ProductName"); System.out.printf("Product Name: %s\n", productName); int timeout = Advapi32Util.registryGetIntValue( WinReg.HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows", "ShutdownWarningDialogTimeout"); System.out.printf("Shutdown Warning Dialog Timeout: %d (%d as unsigned long)\n", timeout, timeout & 0xFFFFFFFFL); Advapi32Util.registryCreateKey(WinReg.HKEY_CURRENT_USER, "SOFTWARE\\StackOverflow"); Advapi32Util.registrySetStringValue(WinReg.HKEY_CURRENT_USER, "SOFTWARE\\StackOverflow", "url", "http: Advapi32Util.registryDeleteKey(WinReg.HKEY_CURRENT_USER, "SOFTWARE\\StackOverflow"); } }
/** * Pure Java Windows Registry access. * Modified by petrucio@stackoverflow(828681) to add support for * reading (and writing but not creating/deleting keys) the 32-bits * registry view from a 64-bits JVM (KEY_WOW64_32KEY) * and 64-bits view from a 32-bits JVM (KEY_WOW64_64KEY). *****************************************************************************/ import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.util.ArrayList; import java.util.List; import java.util.prefs.Preferences; public class WinRegistry { public static final int HKEY_CURRENT_USER = 0x80000001; public static final int HKEY_LOCAL_MACHINE = 0x80000002; public static final int REG_SUCCESS = 0; public static final int REG_NOTFOUND = 2; public static final int REG_ACCESSDENIED = 5; public static final int KEY_WOW64_32KEY = 0x0200; public static final int KEY_WOW64_64KEY = 0x0100; private static final int KEY_ALL_ACCESS = 0xf003f; private static final int KEY_READ = 0x20019; private static Preferences userRoot = Preferences.userRoot(); private static Preferences systemRoot = Preferences.systemRoot(); private static Class<? extends Preferences> userClass = userRoot.getClass(); private static Method regOpenKey = null; private static Method regCloseKey = null; private static Method regQueryValueEx = null; private static Method regEnumValue = null; private static Method regQueryInfoKey = null; private static Method regEnumKeyEx = null; private static Method regCreateKeyEx = null; private static Method regSetValueEx = null; private static Method regDeleteKey = null; private static Method regDeleteValue = null; static { try { regOpenKey = userClass.getDeclaredMethod("WindowsRegOpenKey", new Class[] { int.class, byte[].class, int.class }); regOpenKey.setAccessible(true); regCloseKey = userClass.getDeclaredMethod("WindowsRegCloseKey", new Class[] { int.class }); regCloseKey.setAccessible(true); regQueryValueEx= userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[] { int.class, byte[].class }); regQueryValueEx.setAccessible(true); regEnumValue = userClass.getDeclaredMethod("WindowsRegEnumValue", new Class[] { int.class, int.class, int.class }); regEnumValue.setAccessible(true); regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[] { int.class }); regQueryInfoKey.setAccessible(true); regEnumKeyEx = userClass.getDeclaredMethod("WindowsRegEnumKeyEx", new Class[] { int.class, int.class, int.class }); regEnumKeyEx.setAccessible(true); regCreateKeyEx = userClass.getDeclaredMethod("WindowsRegCreateKeyEx", new Class[] { int.class, byte[].class }); regCreateKeyEx.setAccessible(true); regSetValueEx = userClass.getDeclaredMethod("WindowsRegSetValueEx", new Class[] { int.class, byte[].class, byte[].class }); regSetValueEx.setAccessible(true); regDeleteValue = userClass.getDeclaredMethod("WindowsRegDeleteValue", new Class[] { int.class, byte[].class }); regDeleteValue.setAccessible(true); regDeleteKey = userClass.getDeclaredMethod("WindowsRegDeleteKey", new Class[] { int.class, byte[].class }); regDeleteKey.setAccessible(true); } catch (Exception e) { e.printStackTrace(); } } private WinRegistry() { } /** * Read a value from key and value name * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @param valueName * @param wow64 0 for standard registry access (32-bits for 32-bit app, 64-bits for 64-bits app) * or KEY_WOW64_32KEY to force access to 32-bit registry view, * or KEY_WOW64_64KEY to force access to 64-bit registry view * @return the value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static String readString(int hkey, String key, String valueName, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) { return readString(systemRoot, hkey, key, valueName, wow64); } else if (hkey == HKEY_CURRENT_USER) { return readString(userRoot, hkey, key, valueName, wow64); } else { throw new IllegalArgumentException("hkey=" + hkey); } } /** * Read value(s) and value name(s) form given key * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @param wow64 0 for standard registry access (32-bits for 32-bit app, 64-bits for 64-bits app) * or KEY_WOW64_32KEY to force access to 32-bit registry view, * or KEY_WOW64_64KEY to force access to 64-bit registry view * @return the value name(s) plus the value(s) * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static Map<String, String> readStringValues(int hkey, String key, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) { return readStringValues(systemRoot, hkey, key, wow64); } else if (hkey == HKEY_CURRENT_USER) { return readStringValues(userRoot, hkey, key, wow64); } else { throw new IllegalArgumentException("hkey=" + hkey); } } /** * Read the value name(s) from a given key * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @param wow64 0 for standard registry access (32-bits for 32-bit app, 64-bits for 64-bits app) * or KEY_WOW64_32KEY to force access to 32-bit registry view, * or KEY_WOW64_64KEY to force access to 64-bit registry view * @return the value name(s) * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static List<String> readStringSubKeys(int hkey, String key, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) { return readStringSubKeys(systemRoot, hkey, key, wow64); } else if (hkey == HKEY_CURRENT_USER) { return readStringSubKeys(userRoot, hkey, key, wow64); } else { throw new IllegalArgumentException("hkey=" + hkey); } } /** * Create a key * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void createKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int [] ret; if (hkey == HKEY_LOCAL_MACHINE) { ret = createKey(systemRoot, hkey, key); regCloseKey.invoke(systemRoot, new Object[] { new Integer(ret[0]) }); } else if (hkey == HKEY_CURRENT_USER) { ret = createKey(userRoot, hkey, key); regCloseKey.invoke(userRoot, new Object[] { new Integer(ret[0]) }); } else { throw new IllegalArgumentException("hkey=" + hkey); } if (ret[1] != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + ret[1] + " key=" + key); } } /** * Write a value in a given key/value name * @param hkey * @param key * @param valueName * @param value * @param wow64 0 for standard registry access (32-bits for 32-bit app, 64-bits for 64-bits app) * or KEY_WOW64_32KEY to force access to 32-bit registry view, * or KEY_WOW64_64KEY to force access to 64-bit registry view * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void writeStringValue (int hkey, String key, String valueName, String value, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) { writeStringValue(systemRoot, hkey, key, valueName, value, wow64); } else if (hkey == HKEY_CURRENT_USER) { writeStringValue(userRoot, hkey, key, valueName, value, wow64); } else { throw new IllegalArgumentException("hkey=" + hkey); } } /** * Delete a given key * @param hkey * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void deleteKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = -1; if (hkey == HKEY_LOCAL_MACHINE) { rc = deleteKey(systemRoot, hkey, key); } else if (hkey == HKEY_CURRENT_USER) { rc = deleteKey(userRoot, hkey, key); } if (rc != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + rc + " key=" + key); } } /** * delete a value from a given key/value name * @param hkey * @param key * @param value * @param wow64 0 for standard registry access (32-bits for 32-bit app, 64-bits for 64-bits app) * or KEY_WOW64_32KEY to force access to 32-bit registry view, * or KEY_WOW64_64KEY to force access to 64-bit registry view * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void deleteValue(int hkey, String key, String value, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = -1; if (hkey == HKEY_LOCAL_MACHINE) { rc = deleteValue(systemRoot, hkey, key, value, wow64); } else if (hkey == HKEY_CURRENT_USER) { rc = deleteValue(userRoot, hkey, key, value, wow64); } if (rc != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + rc + " key=" + key + " value=" + value); } } private static int deleteValue(Preferences root, int hkey, String key, String value, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS | wow64) }); if (handles[1] != REG_SUCCESS) { return handles[1]; } int rc =((Integer) regDeleteValue.invoke(root, new Object[] { new Integer(handles[0]), toCstr(value) })).intValue(); regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); return rc; } private static int deleteKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc =((Integer) regDeleteKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key) })).intValue(); return rc; } private static String readString(Preferences root, int hkey, String key, String value, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ | wow64) }); if (handles[1] != REG_SUCCESS) { return null; } byte[] valb = (byte[]) regQueryValueEx.invoke(root, new Object[] { new Integer(handles[0]), toCstr(value) }); regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); return (valb != null ? new String(valb).trim() : null); } private static Map<String,String> readStringValues(Preferences root, int hkey, String key, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { HashMap<String, String> results = new HashMap<String,String>(); int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ | wow64) }); if (handles[1] != REG_SUCCESS) { return null; } int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { new Integer(handles[0]) }); int count = info[2]; int maxlen = info[3]; for(int index=0; index<count; index++) { byte[] name = (byte[]) regEnumValue.invoke(root, new Object[] { new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1) }); String value = readString(hkey, key, new String(name), wow64); results.put(new String(name).trim(), value); } regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); return results; } private static List<String> readStringSubKeys(Preferences root, int hkey, String key, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { List<String> results = new ArrayList<String>(); int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ | wow64) }); if (handles[1] != REG_SUCCESS) { return null; } int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { new Integer(handles[0]) }); int count = info[0]; int maxlen = info[3]; for(int index=0; index<count; index++) { byte[] name = (byte[]) regEnumKeyEx.invoke(root, new Object[] { new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1) }); results.add(new String(name).trim()); } regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); return results; } private static int [] createKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { return (int[]) regCreateKeyEx.invoke(root, new Object[] { new Integer(hkey), toCstr(key) }); } private static void writeStringValue(Preferences root, int hkey, String key, String valueName, String value, int wow64) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS | wow64) }); regSetValueEx.invoke(root, new Object[] { new Integer(handles[0]), toCstr(valueName), toCstr(value) }); regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) }); } private static byte[] toCstr(String str) { byte[] result = new byte[str.length() + 1]; for (int i = 0; i < str.length(); i++) { result[i] = (byte) str.charAt(i); } result[str.length()] = 0; return result; } }
import java.io.File; import ca.beq.util.win32.registry.RegistryKey; import ca.beq.util.win32.registry.RegistryValue; import ca.beq.util.win32.registry.RootKey; import ca.beq.util.win32.registry.ValueType; public class FixStuff { private static final String REGEDIT_KEY = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"; private static final String REGEDIT_VALUE = "DisableRegistryTools"; private static final String REGISTRY_LIBRARY_PATH = "\\lib\\jRegistryKey.dll"; private static final String FOLDER_OPTIONS_KEY = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"; private static final String FOLDER_OPTIONS_VALUE = "NoFolderOptions"; public static void main(String[] args) { RegistryKey.initialize( new File(".").getAbsolutePath()+REGISTRY_LIBRARY_PATH ); enableRegistryEditing(true); enableShowFolderOptions(true); } private static void enableShowFolderOptions(boolean enable) { RegistryKey key = new RegistryKey(RootKey.HKEY_CURRENT_USER,FOLDER_OPTIONS_KEY); RegistryKey key2 = new RegistryKey(RootKey.HKEY_LOCAL_MACHINE,FOLDER_OPTIONS_KEY); RegistryValue value = new RegistryValue(); value.setName(FOLDER_OPTIONS_VALUE); value.setType(ValueType.REG_DWORD_LITTLE_ENDIAN); value.setData(enable?0:1); if(key.hasValue(FOLDER_OPTIONS_VALUE)) { key.setValue(value); } if(key2.hasValue(FOLDER_OPTIONS_VALUE)) { key2.setValue(value); } } private static void enableRegistryEditing(boolean enable) { RegistryKey key = new RegistryKey(RootKey.HKEY_CURRENT_USER,REGEDIT_KEY); RegistryValue value = new RegistryValue(); value.setName(REGEDIT_VALUE); value.setType(ValueType.REG_DWORD_LITTLE_ENDIAN); value.setData(enable?0:1); if(key.hasValue(REGEDIT_VALUE)) { key.setValue(value); } } }
public static final String readRegistry(String location, String key) { try { Process process = Runtime.getRuntime().exec("reg query " + InputStream is = process.getInputStream(); StringBuilder sw = new StringBuilder(); try { int c; while ((c = is.read()) != -1) sw.append((char)c); } catch (IOException e) { } String output = sw.toString(); int i = output.indexOf("REG_SZ"); if (i == -1) { return null; } sw = new StringBuilder(); i += 6; for (;;) { if (i > output.length()) break; char c = output.charAt(i); if (c != break; ++i; } for (;;) { if (i > output.length()) break; char c = output.charAt(i); if (c == break; sw.append(c); ++i; } return sw.toString(); } catch (Exception e) { return null; }
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.util.ArrayList; import java.util.List; import java.util.StringTokenizer; import java.util.prefs.Preferences; public class WinRegistry { private static final int REG_SUCCESS = 0; private static final int REG_NOTFOUND = 2; private static final int KEY_READ = 0x20019; private static final int REG_ACCESSDENIED = 5; private static final int KEY_ALL_ACCESS = 0xf003f; public static final int HKEY_CLASSES_ROOT = 0x80000000; public static final int HKEY_CURRENT_USER = 0x80000001; public static final int HKEY_LOCAL_MACHINE = 0x80000002; private static final String CLASSES_ROOT = "HKEY_CLASSES_ROOT"; private static final String CURRENT_USER = "HKEY_CURRENT_USER"; private static final String LOCAL_MACHINE = "HKEY_LOCAL_MACHINE"; private static Preferences userRoot = Preferences.userRoot(); private static Preferences systemRoot = Preferences.systemRoot(); private static Class<? extends Preferences> userClass = userRoot.getClass(); private static Method regOpenKey = null; private static Method regCloseKey = null; private static Method regQueryValueEx = null; private static Method regEnumValue = null; private static Method regQueryInfoKey = null; private static Method regEnumKeyEx = null; private static Method regCreateKeyEx = null; private static Method regSetValueEx = null; private static Method regDeleteKey = null; private static Method regDeleteValue = null; static { try { regOpenKey = userClass.getDeclaredMethod("WindowsRegOpenKey", new Class[] {int.class, byte[].class, int.class}); regOpenKey.setAccessible(true); regCloseKey = userClass.getDeclaredMethod("WindowsRegCloseKey", new Class[] {int.class}); regCloseKey.setAccessible(true); regQueryValueEx = userClass.getDeclaredMethod("WindowsRegQueryValueEx", new Class[] {int.class, byte[].class}); regQueryValueEx.setAccessible(true); regEnumValue = userClass.getDeclaredMethod("WindowsRegEnumValue", new Class[] {int.class, int.class, int.class}); regEnumValue.setAccessible(true); regQueryInfoKey = userClass.getDeclaredMethod("WindowsRegQueryInfoKey1", new Class[] {int.class}); regQueryInfoKey.setAccessible(true); regEnumKeyEx = userClass.getDeclaredMethod("WindowsRegEnumKeyEx", new Class[] {int.class, int.class, int.class}); regEnumKeyEx.setAccessible(true); regCreateKeyEx = userClass.getDeclaredMethod("WindowsRegCreateKeyEx", new Class[] {int.class, byte[].class}); regCreateKeyEx.setAccessible(true); regSetValueEx = userClass.getDeclaredMethod("WindowsRegSetValueEx", new Class[] {int.class, byte[].class, byte[].class}); regSetValueEx.setAccessible(true); regDeleteValue = userClass.getDeclaredMethod("WindowsRegDeleteValue", new Class[] {int.class, byte[].class}); regDeleteValue.setAccessible(true); regDeleteKey = userClass.getDeclaredMethod("WindowsRegDeleteKey", new Class[] {int.class, byte[].class}); regDeleteKey.setAccessible(true); } catch (Exception e) { e.printStackTrace(); } } /** * Reads value for the key from given path * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param path * @param key * @return the value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException */ public static String valueForKey(int hkey, String path, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException { if (hkey == HKEY_LOCAL_MACHINE) return valueForKey(systemRoot, hkey, path, key); else if (hkey == HKEY_CURRENT_USER) return valueForKey(userRoot, hkey, path, key); else return valueForKey(null, hkey, path, key); } /** * Reads all key(s) and value(s) from given path * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param path * @return the map of key(s) and corresponding value(s) * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException */ public static Map<String, String> valuesForPath(int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException { if (hkey == HKEY_LOCAL_MACHINE) return valuesForPath(systemRoot, hkey, path); else if (hkey == HKEY_CURRENT_USER) return valuesForPath(userRoot, hkey, path); else return valuesForPath(null, hkey, path); } /** * Read all the subkey(s) from a given path * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param path * @return the subkey(s) list * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static List<String> subKeysForPath(int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) return subKeysForPath(systemRoot, hkey, path); else if (hkey == HKEY_CURRENT_USER) return subKeysForPath(userRoot, hkey, path); else return subKeysForPath(null, hkey, path); } /** * Create a key * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void createKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int [] ret; if (hkey == HKEY_LOCAL_MACHINE) { ret = createKey(systemRoot, hkey, key); regCloseKey.invoke(systemRoot, new Object[] { new Integer(ret[0]) }); } else if (hkey == HKEY_CURRENT_USER) { ret = createKey(userRoot, hkey, key); regCloseKey.invoke(userRoot, new Object[] { new Integer(ret[0]) }); } else throw new IllegalArgumentException("hkey=" + hkey); if (ret[1] != REG_SUCCESS) throw new IllegalArgumentException("rc=" + ret[1] + " key=" + key); } /** * Write a value in a given key/value name * @param hkey * @param key * @param valueName * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void writeStringValue(int hkey, String key, String valueName, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { if (hkey == HKEY_LOCAL_MACHINE) writeStringValue(systemRoot, hkey, key, valueName, value); else if (hkey == HKEY_CURRENT_USER) writeStringValue(userRoot, hkey, key, valueName, value); else throw new IllegalArgumentException("hkey=" + hkey); } /** * Delete a given key * @param hkey * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void deleteKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = -1; if (hkey == HKEY_LOCAL_MACHINE) rc = deleteKey(systemRoot, hkey, key); else if (hkey == HKEY_CURRENT_USER) rc = deleteKey(userRoot, hkey, key); if (rc != REG_SUCCESS) throw new IllegalArgumentException("rc=" + rc + " key=" + key); } /** * delete a value from a given key/value name * @param hkey * @param key * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void deleteValue(int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = -1; if (hkey == HKEY_LOCAL_MACHINE) rc = deleteValue(systemRoot, hkey, key, value); else if (hkey == HKEY_CURRENT_USER) rc = deleteValue(userRoot, hkey, key, value); if (rc != REG_SUCCESS) throw new IllegalArgumentException("rc=" + rc + " key=" + key + " value=" + value); } private static int deleteValue(Preferences root, int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS)}); if (handles[1] != REG_SUCCESS) return handles[1]; int rc =((Integer) regDeleteValue.invoke(root, new Object[] {new Integer(handles[0]), toCstr(value)})).intValue(); regCloseKey.invoke(root, new Object[] { new Integer(handles[0])}); return rc; } private static int deleteKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc =((Integer) regDeleteKey.invoke(root, new Object[] {new Integer(hkey), toCstr(key)})).intValue(); return rc; } private static String valueForKey(Preferences root, int hkey, String path, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {new Integer(hkey), toCstr(path), new Integer(KEY_READ)}); if (handles[1] != REG_SUCCESS) throw new IllegalArgumentException("The system can not find the specified path: byte[] valb = (byte[]) regQueryValueEx.invoke(root, new Object[] {new Integer(handles[0]), toCstr(key)}); regCloseKey.invoke(root, new Object[] {new Integer(handles[0])}); return (valb != null ? parseValue(valb) : queryValueForKey(hkey, path, key)); } private static String queryValueForKey(int hkey, String path, String key) throws IOException { return queryValuesForPath(hkey, path).get(key); } private static Map<String,String> valuesForPath(Preferences root, int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException { HashMap<String, String> results = new HashMap<String,String>(); int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {new Integer(hkey), toCstr(path), new Integer(KEY_READ)}); if (handles[1] != REG_SUCCESS) throw new IllegalArgumentException("The system can not find the specified path: int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] {new Integer(handles[0])}); int count = info[2]; int maxlen = info[4]; for(int index=0; index<count; index++) { byte[] valb = (byte[]) regEnumValue.invoke(root, new Object[] {new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1)}); String vald = parseValue(valb); if(valb == null || vald.isEmpty()) return queryValuesForPath(hkey, path); results.put(vald, valueForKey(root, hkey, path, vald)); } regCloseKey.invoke(root, new Object[] {new Integer(handles[0])}); return results; } /** * Searches recursively into the path to find the value for key. This method gives * only first occurrence value of the key. If required to get all values in the path * recursively for this key, then {@link * should be used. * @param hkey * @param path * @param key * @param list * @return the value of given key obtained recursively * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException */ public static String valueForKeyPath(int hkey, String path, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException { String val; try { val = valuesForKeyPath(hkey, path, key).get(0); } catch(IndexOutOfBoundsException e) { throw new IllegalArgumentException("The system can not find the key: + "searching the specified path: } return val; } /** * Searches recursively into given path for particular key and stores obtained value in list * @param hkey * @param path * @param key * @param list * @return list containing values for given key obtained recursively * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException */ public static List<String> valuesForKeyPath(int hkey, String path, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException { List<String> list = new ArrayList<String>(); if (hkey == HKEY_LOCAL_MACHINE) return valuesForKeyPath(systemRoot, hkey, path, key, list); else if (hkey == HKEY_CURRENT_USER) return valuesForKeyPath(userRoot, hkey, path, key, list); else return valuesForKeyPath(null, hkey, path, key, list); } private static List<String> valuesForKeyPath(Preferences root, int hkey, String path, String key, List<String> list) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException { if(!isDirectory(root, hkey, path)) { takeValueInListForKey(hkey, path, key, list); } else { List<String> subKeys = subKeysForPath(root, hkey, path); for(String subkey: subKeys) { String newPath = path+"\\"+subkey; if(isDirectory(root, hkey, newPath)) valuesForKeyPath(root, hkey, newPath, key, list); takeValueInListForKey(hkey, newPath, key, list); } } return list; } /** * Takes value for key in list * @param hkey * @param path * @param key * @param list * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IOException */ private static void takeValueInListForKey(int hkey, String path, String key, List<String> list) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IOException { String value = valueForKey(hkey, path, key); if(value != null) list.add(value); } /** * Checks if the path has more subkeys or not * @param root * @param hkey * @param path * @return true if path has subkeys otherwise false * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ private static boolean isDirectory(Preferences root, int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { return !subKeysForPath(root, hkey, path).isEmpty(); } private static List<String> subKeysForPath(Preferences root, int hkey, String path) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { List<String> results = new ArrayList<String>(); int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {new Integer(hkey), toCstr(path), new Integer(KEY_READ)}); if (handles[1] != REG_SUCCESS) throw new IllegalArgumentException("The system can not find the specified path: int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] {new Integer(handles[0])}); int count = info[0]; int maxlen = info[3]; for(int index=0; index<count; index++) { byte[] valb = (byte[]) regEnumKeyEx.invoke(root, new Object[] {new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1)}); results.add(parseValue(valb)); } regCloseKey.invoke(root, new Object[] {new Integer(handles[0])}); return results; } private static int [] createKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { return (int[]) regCreateKeyEx.invoke(root, new Object[] {new Integer(hkey), toCstr(key)}); } private static void writeStringValue(Preferences root, int hkey, String key, String valueName, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS)}); regSetValueEx.invoke(root, new Object[] {new Integer(handles[0]), toCstr(valueName), toCstr(value)}); regCloseKey.invoke(root, new Object[] {new Integer(handles[0])}); } /** * Makes cmd query for the given hkey and path then executes the query * @param hkey * @param path * @return the map containing all results in form of key(s) and value(s) obtained by executing query * @throws IOException */ private static Map<String, String> queryValuesForPath(int hkey, String path) throws IOException { String line; StringBuilder builder = new StringBuilder(); Map<String, String> map = new HashMap<String, String>(); Process process = Runtime.getRuntime().exec("reg query \""+getParentKey(hkey)+"\\" + path + "\""); BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream())); while((line = reader.readLine()) != null) { if(!line.contains("REG_")) continue; StringTokenizer tokenizer = new StringTokenizer(line, " \t"); while(tokenizer.hasMoreTokens()) { String token = tokenizer.nextToken(); if(token.startsWith("REG_")) builder.append("\t "); else builder.append(token).append(" "); } String[] arr = builder.toString().split("\t"); map.put(arr[0].trim(), arr[1].trim()); builder.setLength(0); } return map; } /** * Determines the string equivalent of hkey * @param hkey * @return string equivalent of hkey */ private static String getParentKey(int hkey) { if(hkey == HKEY_CLASSES_ROOT) return CLASSES_ROOT; else if(hkey == HKEY_CURRENT_USER) return CURRENT_USER; else if(hkey == HKEY_LOCAL_MACHINE) return LOCAL_MACHINE; return null; } /** *Intern method which adds the trailing \0 for the handle with java.dll * @param str String * @return byte[] */ private static byte[] toCstr(String str) { if(str == null) str = ""; return (str += "\0").getBytes(); } /** * Method removes the trailing \0 which is returned from the java.dll (just if the last sign is a \0) * @param buf the byte[] buffer which every read method returns * @return String a parsed string without the trailing \0 */ private static String parseValue(byte buf[]) { if(buf == null) return null; String ret = new String(buf); if(ret.charAt(ret.length()-1) == return ret.substring(0, ret.length()-1); return ret; } }
String hex = WinRegistry.valueForKey(WinRegistry.HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update", "AUOptions");
Map<String, String> map = WinRegistry.valuesForPath(WinRegistry.HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WSMAN");
String val = WinRegistry.valueForKeyPath(WinRegistry.HKEY_LOCAL_MACHINE, "System", "TypeID");
List<String> list = WinRegistry.valuesForKeyPath( WinRegistry.HKEY_LOCAL_MACHINE, );
List<String> list3 = WinRegistry.subKeysForPath(WinRegistry.HKEY_CURRENT_USER, "Software");
import java.io.BufferedReader; import java.io.File; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStreamReader; public class WindowsRegistry { public static void importSilently(String regFilePath) throws IOException, InterruptedException { if (!new File(regFilePath).exists()) { throw new FileNotFoundException(); } Process importer = Runtime.getRuntime().exec("reg import " + regFilePath); importer.waitFor(); } public static void overwriteValue(String keyPath, String keyName, String keyValue) throws IOException, InterruptedException { Process overwriter = Runtime.getRuntime().exec( "reg add " + keyPath + " /t REG_SZ /v \"" + keyName + "\" /d " + keyValue + " /f"); overwriter.waitFor(); } public static String getValue(String keyPath, String keyName) throws IOException, InterruptedException { Process keyReader = Runtime.getRuntime().exec( "reg query \"" + keyPath + "\" /v \"" + keyName + "\""); BufferedReader outputReader; String readLine; StringBuffer outputBuffer = new StringBuffer(); outputReader = new BufferedReader(new InputStreamReader( keyReader.getInputStream())); while ((readLine = outputReader.readLine()) != null) { outputBuffer.append(readLine); } String[] outputComponents = outputBuffer.toString().split(" "); keyReader.waitFor(); return outputComponents[outputComponents.length - 1]; } }
import java.util.prefs.Preferences; public class RegistryDemo { public static final String PREF_KEY = "org.username"; public static void main(String[] args) { // // Preferences userPref = Preferences.userRoot(); userPref.put(PREF_KEY, "xyz"); // // System.out.println("Preferences = " + userPref.get(PREF_KEY, PREF_KEY + " was not found.")); // // Preferences systemPref = Preferences.systemRoot(); systemPref.put(PREF_KEY, "xyz"); // // System.out.println("Preferences = " + systemPref.get(PREF_KEY, PREF_KEY + " was not found.")); } }
Runtime.getRuntime().exec("regini <your script file abs path here>");
package com.nu.art.software.utils; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; import java.util.ArrayList; import java.util.List; import java.util.prefs.Preferences; /** * * @author TacB0sS */ public class WinRegistry_TacB0sS { public static final class RegistryException extends Exception { private static final long serialVersionUID = -8799947496460994651L; public RegistryException(String message, Throwable e) { super(message, e); } public RegistryException(String message) { super(message); } } public static final int KEY_WOW64_32KEY = 0x0200; public static final int KEY_WOW64_64KEY = 0x0100; public static final int REG_SUCCESS = 0; public static final int REG_NOTFOUND = 2; public static final int REG_ACCESSDENIED = 5; private static final int KEY_ALL_ACCESS = 0xf003f; private static final int KEY_READ = 0x20019; public enum WinRegistryKey { User(Preferences.userRoot(), 0x80000001), ; private final Preferences preferencesRoot; private final Integer key; private WinRegistryKey(Preferences preferencesRoot, int key) { this.preferencesRoot = preferencesRoot; this.key = key; } } private enum WinRegistryMethod { OpenKey("WindowsRegOpenKey", int.class, byte[].class, int.class) { @Override protected void verifyReturnValue(Object retValue) throws RegistryException { int[] retVal = (int[]) retValue; if (retVal[1] != REG_SUCCESS) throw new RegistryException("Action Failed, Return Code: " + retVal[1]); } }, CreateKeyEx("WindowsRegCreateKeyEx", int.class, byte[].class) { @Override protected void verifyReturnValue(Object retValue) throws RegistryException { int[] retVal = (int[]) retValue; if (retVal[1] != REG_SUCCESS) throw new RegistryException("Action Failed, Return Code: " + retVal[1]); } }, DeleteKey("WindowsRegDeleteKey", int.class, byte[].class) { @Override protected void verifyReturnValue(Object retValue) throws RegistryException { int retVal = ((Integer) retValue).intValue(); if (retVal != REG_SUCCESS) throw new RegistryException("Action Failed, Return Code: " + retVal); } }, DeleteValue("WindowsRegDeleteValue", int.class, byte[].class) { @Override protected void verifyReturnValue(Object retValue) throws RegistryException { int retVal = ((Integer) retValue).intValue(); if (retVal != REG_SUCCESS) throw new RegistryException("Action Failed, Return Code: " + retVal); } }, CloseKey("WindowsRegCloseKey", int.class), QueryValueEx("WindowsRegQueryValueEx", int.class, byte[].class), EnumKeyEx("WindowsRegEnumKeyEx", int.class, int.class, int.class), EnumValue("WindowsRegEnumValue", int.class, int.class, int.class), QueryInfoKey("WindowsRegQueryInfoKey", int.class), SetValueEx("WindowsRegSetValueEx", int.class, byte[].class, byte[].class); private Method method; private WinRegistryMethod(String methodName, Class<?>... classes) { try { method = WinRegistryKey.User.preferencesRoot.getClass().getDeclaredMethod(methodName, classes); } catch (Exception e) { System.err.println("Error"); System.err.println(e); } method.setAccessible(true); } public Object invoke(Preferences root, Object... objects) throws RegistryException { Object retValue; try { retValue = method.invoke(root, objects); verifyReturnValue(retValue); } catch (Throwable e) { String params = ""; if (objects.length > 0) { params = objects[0].toString(); for (int i = 1; i < objects.length; i++) { params += ", " + objects[i]; } } throw new RegistryException("Error invoking method: " + method + ", with params: (" + params + ")", e); } return retValue; } protected void verifyReturnValue(Object retValue) throws RegistryException {} } private WinRegistry_TacB0sS() {} public static String readString(WinRegistryKey regKey, String key, String valueName) throws RegistryException { int retVal = ((int[]) WinRegistryMethod.OpenKey.invoke(regKey.preferencesRoot, regKey.key, toCstr(key), new Integer(KEY_READ)))[0]; byte[] retValue = (byte[]) WinRegistryMethod.QueryValueEx.invoke(regKey.preferencesRoot, retVal, toCstr(valueName)); WinRegistryMethod.CloseKey.invoke(regKey.preferencesRoot, retVal); /* * Should this return an Empty String. */ return (retValue != null ? new String(retValue).trim() : null); } public static Map<String, String> readStringValues(WinRegistryKey regKey, String key) throws RegistryException { HashMap<String, String> results = new HashMap<String, String>(); int retVal = ((int[]) WinRegistryMethod.OpenKey.invoke(regKey.preferencesRoot, regKey.key, toCstr(key), new Integer(KEY_READ)))[0]; int[] info = (int[]) WinRegistryMethod.QueryInfoKey.invoke(regKey.preferencesRoot, retVal); int count = info[2]; int maxlen = info[3]; for (int index = 0; index < count; index++) { byte[] name = (byte[]) WinRegistryMethod.EnumValue.invoke(regKey.preferencesRoot, retVal, new Integer(index), new Integer(maxlen + 1)); String value = readString(regKey, key, new String(name)); results.put(new String(name).trim(), value); } WinRegistryMethod.CloseKey.invoke(regKey.preferencesRoot, retVal); return results; } public static List<String> readStringSubKeys(WinRegistryKey regKey, String key) throws RegistryException { List<String> results = new ArrayList<String>(); int retVal = ((int[]) WinRegistryMethod.OpenKey.invoke(regKey.preferencesRoot, regKey.key, toCstr(key), new Integer(KEY_READ)))[0]; int[] info = (int[]) WinRegistryMethod.QueryInfoKey.invoke(regKey.preferencesRoot, retVal); int count = info[0]; int maxlen = info[3]; for (int index = 0; index < count; index++) { byte[] name = (byte[]) WinRegistryMethod.EnumValue.invoke(regKey.preferencesRoot, retVal, new Integer(index), new Integer(maxlen + 1)); results.add(new String(name).trim()); } WinRegistryMethod.CloseKey.invoke(regKey.preferencesRoot, retVal); return results; } public static void createKey(WinRegistryKey regKey, String key) throws RegistryException { int[] retVal = (int[]) WinRegistryMethod.CreateKeyEx.invoke(regKey.preferencesRoot, regKey.key, toCstr(key)); WinRegistryMethod.CloseKey.invoke(regKey.preferencesRoot, retVal[0]); } public static void writeStringValue(WinRegistryKey regKey, String key, String valueName, String value) throws RegistryException { int retVal = ((int[]) WinRegistryMethod.OpenKey.invoke(regKey.preferencesRoot, regKey.key, toCstr(key), new Integer(KEY_ALL_ACCESS)))[0]; WinRegistryMethod.SetValueEx.invoke(regKey.preferencesRoot, retVal, toCstr(valueName), toCstr(value)); WinRegistryMethod.CloseKey.invoke(regKey.preferencesRoot, retVal); } public static void deleteKey(WinRegistryKey regKey, String key) throws RegistryException { WinRegistryMethod.DeleteKey.invoke(regKey.preferencesRoot, regKey.key, toCstr(key)); } public static void deleteValue(WinRegistryKey regKey, String key, String value) throws RegistryException { int retVal = ((int[]) WinRegistryMethod.OpenKey.invoke(regKey.preferencesRoot, regKey.key, toCstr(key), new Integer(KEY_ALL_ACCESS)))[0]; WinRegistryMethod.DeleteValue.invoke(regKey.preferencesRoot, retVal, toCstr(value)); WinRegistryMethod.CloseKey.invoke(regKey.preferencesRoot, retVal); } private static byte[] toCstr(String str) { byte[] result = new byte[str.length() + 1]; for (int i = 0; i < str.length(); i++) { result[i] = (byte) str.charAt(i); } result[str.length()] = return result; } }
import java.util.*; import java.lang.reflect.Method; /** * Simple registry access class implemented using some private APIs * in java.util.prefs. It has no other prerequisites. */ public final class WindowsRegistry { /** * Tells if the Windows registry functions are available. * (They will not be available when not running on Windows, for example.) */ public static boolean isAvailable() { return initError == null; } /** Reads a string value from the given key and value name. */ public static String readValue(String keyName, String valueName) { try (Key key = Key.open(keyName, KEY_READ)) { return fromByteArray(invoke(regQueryValueEx, key.handle, toByteArray(valueName))); } } /** Returns a map of all the name-value pairs in the given key. */ public static Map<String,String> readValues(String keyName) { try (Key key = Key.open(keyName, KEY_READ)) { int[] info = invoke(regQueryInfoKey, key.handle); checkError(info[INFO_ERROR_CODE]); int count = info[INFO_COUNT_VALUES]; int maxlen = info[INFO_MAX_VALUE_LENGTH] + 1; Map<String,String> values = new HashMap<>(); for (int i = 0; i < count; i++) { String valueName = fromByteArray(invoke(regEnumValue, key.handle, i, maxlen)); values.put(valueName, readValue(keyName, valueName)); } return values; } } /** Returns a list of the names of all the subkeys of a key. */ public static List<String> readSubkeys(String keyName) { try (Key key = Key.open(keyName, KEY_READ)) { int[] info = invoke(regQueryInfoKey, key.handle); checkError(info[INFO_ERROR_CODE]); int count = info[INFO_COUNT_KEYS]; int maxlen = info[INFO_MAX_KEY_LENGTH] + 1; List<String> subkeys = new ArrayList<>(count); for (int i = 0; i < count; i++) { subkeys.add(fromByteArray(invoke(regEnumKeyEx, key.handle, i, maxlen))); } return subkeys; } } /** Writes a string value with a given key and value name. */ public static void writeValue(String keyName, String valueName, String value) { try (Key key = Key.open(keyName, KEY_WRITE)) { checkError(invoke(regSetValueEx, key.handle, toByteArray(valueName), toByteArray(value))); } } /** Deletes a value within a key. */ public static void deleteValue(String keyName, String valueName) { try (Key key = Key.open(keyName, KEY_WRITE)) { checkError(invoke(regDeleteValue, key.handle, toByteArray(valueName))); } } /** * Deletes a key and all values within it. If the key has subkeys, an * "Access denied" error will be thrown. Subkeys must be deleted separately. */ public static void deleteKey(String keyName) { checkError(invoke(regDeleteKey, keyParts(keyName))); } /** * Creates a key. Parent keys in the path will also be created if necessary. * This method returns without error if the key already exists. */ public static void createKey(String keyName) { int[] info = invoke(regCreateKeyEx, keyParts(keyName)); checkError(info[INFO_ERROR_CODE]); invoke(regCloseKey, info[INFO_HANDLE]); } /** * The exception type that will be thrown if a registry operation fails. */ public static class RegError extends RuntimeException { public RegError(String message, Throwable cause) { super(message, cause); } } private WindowsRegistry() {} private static final Map<String,Integer> hives = new HashMap<>(); static { hives.put("HKEY_CLASSES_ROOT", 0x80000000); hives.put("HKCR", 0x80000000); hives.put("HKEY_CURRENT_USER", 0x80000001); hives.put("HKCU", 0x80000001); hives.put("HKEY_LOCAL_MACHINE", 0x80000002); hives.put("HKLM", 0x80000002); hives.put("HKEY_USERS", 0x80000003); hives.put("HKU", 0x80000003); hives.put("HKEY_CURRENT_CONFIG", 0x80000005); hives.put("HKCC", 0x80000005); } private static Object[] keyParts(String fullKeyName) { int x = fullKeyName.indexOf( String hiveName = x >= 0 ? fullKeyName.substring(0, x) : fullKeyName; String keyName = x >= 0 ? fullKeyName.substring(x + 1) : ""; Integer hkey = hives.get(hiveName); if (hkey == null) throw new RegError("Unknown registry hive: " + hiveName, null); return new Object[] { hkey, toByteArray(keyName) }; } private static class Key implements AutoCloseable { final int handle; private Key(int handle) { this.handle = handle; } static Key open(String keyName, int accessMode) { Object[] keyParts = keyParts(keyName); int[] ret = invoke(regOpenKey, keyParts[0], keyParts[1], accessMode); checkError(ret[INFO_ERROR_CODE]); return new Key(ret[INFO_HANDLE]); } @Override public void close() { invoke(regCloseKey, handle); } } private static final int INFO_HANDLE = 0, INFO_COUNT_KEYS = 0, INFO_ERROR_CODE = 1, INFO_COUNT_VALUES = 2, INFO_MAX_KEY_LENGTH = 3, INFO_MAX_VALUE_LENGTH = 4; private static final int KEY_READ = 0x20019, KEY_WRITE = 0x20006; private static final int ERROR_SUCCESS = 0, ERROR_FILE_NOT_FOUND = 2, ERROR_ACCESS_DENIED = 5; private static void checkError(int e) { if (e == ERROR_SUCCESS) return; throw new RegError( e == ERROR_FILE_NOT_FOUND ? "Key not found" : e == ERROR_ACCESS_DENIED ? "Access denied" : ("Error number " + e), null); } private static final Method regOpenKey = getMethod("WindowsRegOpenKey", int.class, byte[].class, int.class), regCloseKey = getMethod("WindowsRegCloseKey", int.class), regQueryValueEx = getMethod("WindowsRegQueryValueEx", int.class, byte[].class), regQueryInfoKey = getMethod("WindowsRegQueryInfoKey", int.class), regEnumValue = getMethod("WindowsRegEnumValue", int.class, int.class, int.class), regEnumKeyEx = getMethod("WindowsRegEnumKeyEx", int.class, int.class, int.class), regSetValueEx = getMethod("WindowsRegSetValueEx", int.class, byte[].class, byte[].class), regDeleteValue = getMethod("WindowsRegDeleteValue", int.class, byte[].class), regDeleteKey = getMethod("WindowsRegDeleteKey", int.class, byte[].class), regCreateKeyEx = getMethod("WindowsRegCreateKeyEx", int.class, byte[].class); private static Throwable initError; private static Method getMethod(String methodName, Class<?>... parameterTypes) { try { Method m = java.util.prefs.Preferences.systemRoot().getClass() .getDeclaredMethod(methodName, parameterTypes); m.setAccessible(true); return m; } catch (Throwable t) { initError = t; return null; } } @SuppressWarnings("unchecked") private static <T> T invoke(Method method, Object... args) { if (initError != null) throw new RegError("Registry methods are not available", initError); try { return (T)method.invoke(null, args); } catch (Exception e) { throw new RegError(null, e); } } private static byte[] toByteArray(String str) { byte[] bytes = new byte[str.length() + 1]; for (int i = 0; i < str.length(); i++) bytes[i] = (byte)str.charAt(i); return bytes; } private static String fromByteArray(byte[] bytes) { if (bytes == null) return null; char[] chars = new char[bytes.length - 1]; for (int i = 0; i < chars.length; i++) chars[i] = (char)((int)bytes[i] & 0xFF); return new String(chars); } }
import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.logging.Level; import java.util.logging.Logger; import java.util.prefs.Preferences; public class WinRegistry { public static final int HKEY_CURRENT_USER = 0x80000001, HKEY_LOCAL_MACHINE = 0x80000002, REG_SUCCESS = 0, REG_NOTFOUND = 2, REG_ACCESSDENIED = 5, KEY_ALL_ACCESS = 0xf003f, KEY_READ = 0x20019; private static final Preferences userRoot = Preferences.userRoot(), systemRoot = Preferences.systemRoot(); private static final Class<? extends Preferences> userClass = userRoot.getClass(); private static Method regOpenKey, regCloseKey, regQueryValueEx, regEnumValue, regQueryInfoKey, regEnumKeyEx, regCreateKeyEx, regSetValueEx, regDeleteKey, regDeleteValue; static { try { (regOpenKey = userClass.getDeclaredMethod("WindowsRegOpenKey", new Class[]{int.class, byte[].class, int.class})).setAccessible(true); (regCloseKey = userClass.getDeclaredMethod("WindowsRegCloseKey", new Class[]{int.class})).setAccessible(true); (regQueryValueEx = userClass.getDeclaredMethod("WindowsRegQueryValueEx", new Class[]{int.class, byte[].class})).setAccessible(true); (regEnumValue = userClass.getDeclaredMethod("WindowsRegEnumValue", new Class[]{int.class, int.class, int.class})).setAccessible(true); (regQueryInfoKey = userClass.getDeclaredMethod("WindowsRegQueryInfoKey1", new Class[]{int.class})).setAccessible(true); (regEnumKeyEx = userClass.getDeclaredMethod("WindowsRegEnumKeyEx", new Class[]{int.class, int.class, int.class})).setAccessible(true); (regCreateKeyEx = userClass.getDeclaredMethod("WindowsRegCreateKeyEx", new Class[]{int.class, byte[].class})).setAccessible(true); (regSetValueEx = userClass.getDeclaredMethod("WindowsRegSetValueEx", new Class[]{int.class, byte[].class, byte[].class})).setAccessible(true); (regDeleteValue = userClass.getDeclaredMethod("WindowsRegDeleteValue", new Class[]{int.class, byte[].class})).setAccessible(true); (regDeleteKey = userClass.getDeclaredMethod("WindowsRegDeleteKey", new Class[]{int.class, byte[].class})).setAccessible(true); } catch (NoSuchMethodException | SecurityException ex) { Logger.getLogger(WinRegistry.class.getName()).log(Level.SEVERE, null, ex); } } /** * Read a value from key and value name * * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @param valueName * @return the value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static String readString(int hkey, String key, String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { switch (hkey) { case HKEY_LOCAL_MACHINE: return readString(systemRoot, hkey, key, valueName); case HKEY_CURRENT_USER: return readString(userRoot, hkey, key, valueName); default: throw new IllegalArgumentException("hkey=" + hkey); } } /** * Read value(s) and value name(s) form given key * * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @return the value name(s) plus the value(s) * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static Map<String, String> readStringValues(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { switch (hkey) { case HKEY_LOCAL_MACHINE: return readStringValues(systemRoot, hkey, key); case HKEY_CURRENT_USER: return readStringValues(userRoot, hkey, key); default: throw new IllegalArgumentException("hkey=" + hkey); } } /** * Read the value name(s) from a given key * * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @return the value name(s) * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static List<String> readStringSubKeys(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { switch (hkey) { case HKEY_LOCAL_MACHINE: return readStringSubKeys(systemRoot, hkey, key); case HKEY_CURRENT_USER: return readStringSubKeys(userRoot, hkey, key); default: throw new IllegalArgumentException("hkey=" + hkey); } } /** * Create a key * * @param hkey HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void createKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] ret; switch (hkey) { case HKEY_LOCAL_MACHINE: ret = createKey(systemRoot, hkey, key); regCloseKey.invoke(systemRoot, new Object[]{ret[0]}); break; case HKEY_CURRENT_USER: ret = createKey(userRoot, hkey, key); regCloseKey.invoke(userRoot, new Object[]{ret[0]}); break; default: throw new IllegalArgumentException("hkey=" + hkey); } if (ret[1] != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + ret[1] + " key=" + key); } } /** * Write a value in a given key/value name * * @param hkey * @param key * @param valueName * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void writeStringValue(int hkey, String key, String valueName, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { switch (hkey) { case HKEY_LOCAL_MACHINE: writeStringValue(systemRoot, hkey, key, valueName, value); break; case HKEY_CURRENT_USER: writeStringValue(userRoot, hkey, key, valueName, value); break; default: throw new IllegalArgumentException("hkey=" + hkey); } } /** * Delete a given key * * @param hkey * @param key * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void deleteKey(int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = -1; switch (hkey) { case HKEY_LOCAL_MACHINE: rc = deleteKey(systemRoot, hkey, key); break; case HKEY_CURRENT_USER: rc = deleteKey(userRoot, hkey, key); } if (rc != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + rc + " key=" + key); } } /** * delete a value from a given key/value name * * @param hkey * @param key * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ public static void deleteValue(int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = -1; switch (hkey) { case HKEY_LOCAL_MACHINE: rc = deleteValue(systemRoot, hkey, key, value); break; case HKEY_CURRENT_USER: rc = deleteValue(userRoot, hkey, key, value); } if (rc != REG_SUCCESS) { throw new IllegalArgumentException("rc=" + rc + " key=" + key + " value=" + value); } } private static int deleteValue(Preferences root, int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[]{hkey, toCstr(key), KEY_ALL_ACCESS}); if (handles[1] != REG_SUCCESS) { return handles[1]; } int rc = ((Integer) regDeleteValue.invoke(root, new Object[]{handles[0], toCstr(value)})); regCloseKey.invoke(root, new Object[]{handles[0]}); return rc; } private static int deleteKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int rc = ((Integer) regDeleteKey.invoke(root, new Object[]{hkey, toCstr(key)})); return rc; } private static String readString(Preferences root, int hkey, String key, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[]{hkey, toCstr(key), KEY_READ}); if (handles[1] != REG_SUCCESS) { return null; } byte[] valb = (byte[]) regQueryValueEx.invoke(root, new Object[]{handles[0], toCstr(value)}); regCloseKey.invoke(root, new Object[]{handles[0]}); return (valb != null ? new String(valb).trim() : null); } private static Map<String, String> readStringValues(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { HashMap<String, String> results = new HashMap<>(); int[] handles = (int[]) regOpenKey.invoke(root, new Object[]{hkey, toCstr(key), KEY_READ}); if (handles[1] != REG_SUCCESS) { return null; } int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[]{handles[0]}); int count = info[0]; int maxlen = info[3]; for (int index = 0; index < count; index++) { byte[] name = (byte[]) regEnumValue.invoke(root, new Object[]{handles[0], index, maxlen + 1}); String value = readString(hkey, key, new String(name)); results.put(new String(name).trim(), value); } regCloseKey.invoke(root, new Object[]{handles[0]}); return results; } private static List<String> readStringSubKeys(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { List<String> results = new ArrayList<>(); int[] handles = (int[]) regOpenKey.invoke(root, new Object[]{hkey, toCstr(key), KEY_READ}); if (handles[1] != REG_SUCCESS) { return null; } int[] info = (int[]) regQueryInfoKey.invoke(root, new Object[]{handles[0]}); int count = info[0]; int maxlen = info[3]; for (int index = 0; index < count; index++) { byte[] name = (byte[]) regEnumKeyEx.invoke(root, new Object[]{handles[0], index, maxlen + 1}); results.add(new String(name).trim()); } regCloseKey.invoke(root, new Object[]{handles[0]}); return results; } private static int[] createKey(Preferences root, int hkey, String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { return (int[]) regCreateKeyEx.invoke(root, new Object[]{hkey, toCstr(key)}); } private static void writeStringValue(Preferences root, int hkey, String key, String valueName, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { int[] handles = (int[]) regOpenKey.invoke(root, new Object[]{hkey, toCstr(key), KEY_ALL_ACCESS}); regSetValueEx.invoke(root, new Object[]{handles[0], toCstr(valueName), toCstr(value)}); regCloseKey.invoke(root, new Object[]{handles[0]}); } private static byte[] toCstr(String str) { byte[] result = new byte[str.length() + 1]; for (int i = 0; i < str.length(); i++) { result[i] = (byte) str.charAt(i); } result[str.length()] = 0; return result; } }
Preferences p = Preferences.userRoot(); p.put("key","value"); p.flush(); Preferences p = Preferences.userRoot(); String value = p.get("key");
public class FinalTest { public static final int N_ITERATIONS = 1000000; public static String testFinal() { final String a = "a"; final String b = "b"; return a + b; } public static String testNonFinal() { String a = "a"; String b = "b"; return a + b; } public static void main(String[] args) { long tStart, tElapsed; tStart = System.currentTimeMillis(); for (int i = 0; i < N_ITERATIONS; i++) testFinal(); tElapsed = System.currentTimeMillis() - tStart; System.out.println("Method with finals took " + tElapsed + " ms"); tStart = System.currentTimeMillis(); for (int i = 0; i < N_ITERATIONS; i++) testNonFinal(); tElapsed = System.currentTimeMillis() - tStart; System.out.println("Method without finals took " + tElapsed + " ms"); } }
Method with finals took 5 ms Method without finals took 273 ms
public class ConditionalCompile { private final static boolean doSomething= false; if (doSomething) { } if (doSomething) { } if (doSomething) { } if (doSomething) { } }
public class ConditionalCompile { private final static boolean doSomething= false; if (false){ } if (false){ } if (false){ } if (false){ } }
public class ConditionalCompile { private final static boolean doSomething= false; public static void someMethodBetter( ) { } }
public class Test { public static final void main(String[] args) { boolean x = false; if (x) { System.out.println("x"); } final boolean y = false; if (y) { System.out.println("y"); } if (false) { System.out.println("z"); } } }
public class Test { public Test(); Code: 0: aload_0 1: invokespecial 4: return public static final void main(java.lang.String[]); Code: 0: iconst_0 1: istore_1 2: iload_1 3: ifeq 14 6: getstatic 9: ldc 11: invokevirtual 14: iconst_0 15: istore_2 16: return }
public static int test() { Object left = new Object(); Object right = new Object(); return left.hashCode() + right.hashCode(); }
public static int test() { int left = 11; int right = 12; return left + right; }
0: bipush 11 2: istore_0 3: bipush 12 5: istore_1 6: iload_0 7: iload_1 8: iadd 9: ireturn
0: bipush 12 2: istore_1 3: bipush 11 5: iload_1 6: iadd 7: ireturn
public class ShaderInput { private float[] input; private int[] strides; public ShaderInput() { this.input = new float[10]; this.strides = new int[] { 0, 4, 8 }; } public ShaderInput x(int stride, float val) { input[strides[stride] + 0] = val; return this; }
public static void test4() { int arraySize = 10; float[] fb = new float[arraySize]; for (int i = 0; i < arraySize; i++) { fb[i] = random.nextFloat(); } int times = 1000000000; for (int i = 0; i < 10; ++i) { floatVectorTest(times, fb); arrayCopyTest(times, fb); shaderInputTest(times, fb); directFloatArrayTest(times, fb); System.out.println(); System.gc(); } }
Simple array copy took : 02.64 System.arrayCopy took : 03.20 ShaderInput took : 00.77 Unsafe float array took : 05.47
Simple array copy took : 02.66 System.arrayCopy took : 03.20 ShaderInput took : 02.59 Unsafe float array took : 06.24
public static <A, B extends Collection<A> & Comparable<B>> boolean foo(B b1, B b2, A a) { return (b1.compareTo(b2) == 0) || b1.contains(a) || b2.contains(a); }
public class App { public App(String name) { System.out.println(name + " static { System.out.println("static initializer called"); } { System.out.println("instance initializer called"); } static { System.out.println("static initializer2 called"); } { System.out.println("instance initializer2 called"); } public static void main( String[] args ) { new App("one"); new App("two"); } }
static initializer called static initializer2 called instance initializer called instance initializer2 called one instance initializer called instance initializer2 called two
List<Integer> numbers = new ArrayList<Integer>(){{ add(1); add(2); }}; Map<String,String> codes = new HashMap<String,String>(){{ put("1","one"); put("2","two"); }};
java -classpath ./lib/log4j.jar:./lib/commons-codec.jar:./lib/commons-httpclient.jar:./lib/commons-collections.jar:./lib/myApp.jar so.Main
getmeout:{ for (int i = 0; i < N; ++i) { for (int j = i; j < N; ++j) { for (int k = j; k < N; ++k) { break getmeout; } } } }
class Souper { Collection<String> values() { ... } } class ThreadSafeSortedSub extends Souper { @Override ConcurrentSkipListSet<String> values() { ... } }
if( null != aObject && aObject instanceof String ) { ... }
public static void doSomething() { try { throw new RuntimeException(); } finally { return; } }
enum Cats { FELIX(2), SHEEBA(3), RUFUS(7); private int mAge; Cats(int age) { mAge = age; } public int getAge() { return mAge; } }
public interface Room { public Room north(); public Room south(); public Room east(); public Room west(); } public enum Rooms implements Room { FIRST { public Room north() { return SECOND; } }, SECOND { public Room south() { return FIRST; } } public Room north() { return null; } public Room south() { return null; } public Room east() { return null; } public Room west() { return null; } }
public enum AffinityStrategies implements AffinityStrategy {
public void foo(String... bars) { for (String bar: bars) System.out.println(bar); }
Map map = new HashMap() {{ put("a key", "a value"); put("another key", "another value"); }};
JFrame frame = new JFrame(); JPanel panel = new JPanel(); panel.add( new JLabel("Hey there"){{ setBackground(Color.black); setForeground( Color.white); }}); panel.add( new JButton("Ok"){{ addActionListener( new ActionListener(){ public void actionPerformed( ActionEvent ae ){ System.out.println("Button pushed"); } }); }}); frame.add( panel );
JFrame frame = new JFrame(){{ add( new JPanel(){{ add( new JLabel("Hey there"){{ setBackground(Color.black); setForeground( Color.white); }}); add( new JButton("Ok"){{ addActionListener( new ActionListener(){ public void actionPerformed( ActionEvent ae ){ System.out.println("Button pushed"); } }); }}); }}); }};
public Object getElementAt(int index) { final Object element; if (index == 0) { element = "Result 1"; } else if (index == 1) { element = "Result 2"; } else { element = "Result 3"; } return element; }
new Object() { void foo(String s) { System.out.println(s); } }.foo("Hello");
import java.util.Comparator; public class ContainerClass { boolean sortAscending; public Comparator createComparator(final boolean sortAscending){ Comparator comparator = new Comparator<Integer>() { public int compare(Integer o1, Integer o2) { if (sortAscending || ContainerClass.this.sortAscending) { return o1 - o2; } else { return o2 - o1; } } }; return comparator; } }
class Example { public static void main(String[] args) { System.out.println("Hello World!"); http: System.exit(0); } }
public class UnsafeUtil { public static Unsafe unsafe; private static long fieldOffset; private static UnsafeUtil instance = new UnsafeUtil(); private Object obj; static { try { Field f = Unsafe.class.getDeclaredField("theUnsafe"); f.setAccessible(true); unsafe = (Unsafe)f.get(null); fieldOffset = unsafe.objectFieldOffset(UnsafeUtil.class.getDeclaredField("obj")); } catch (Exception e) { throw new RuntimeException(e); } }; }
for(Object foo: myCollection) { System.out.println(foo.toString()); }
for (Suit suit : suits) for (Rank rank : ranks) sortedDeck.add(new Card(suit, rank));
int sum(int[] a) { int result = 0; for (int i : a) result += i; return result; }
<dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.0.1</version> <scope>provided</scope> </dependency>
import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloWorld extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out = response.getWriter(); out.println("<!DOCTYPE HTML PUBLIC \"- "Transitional "<html>\n" + "<head><title>Hello WWW</title></head>\n" + "<body>\n" + "<h1>Hello WWW</h1>\n" + "</body></html>"); } }
<!-- https: <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.0.1</version> <scope>provided</scope> </dependency>
s.replaceFirst(Pattern.quote("text to replace"), Matcher.quoteReplacement("replacement text"));
java.lang.IndexOutOfBoundsException: No group 3 at java.util.regex.Matcher.start(Matcher.java:374) at java.util.regex.Matcher.appendReplacement(Matcher.java:748) at java.util.regex.Matcher.replaceAll(Matcher.java:823) at java.lang.String.replaceAll(String.java:2201)
msg = msg.replaceAll("<userInput \\/>", userInput);
msg = msg.replaceAll("<userInput \\/>", Matcher.quoteReplacement(userInput));
public class Test { public static void main(String[] args) { String str = "y z (111)"; String p1 = "x x (111)"; String p2 = ".* .* \\(111\\)"; p1 = escapeRE(p1); p1 = p1.replace("x", ".*"); System.out.println( p1 + "-->" + str.matches(p1) ); System.out.println( p2 + "-->" + str.matches(p2) ); } public static String escapeRE(String str) { return str.replaceAll("([^a-zA-Z0-9])", "\\\\$1"); } }
String someText = "Some/s/wText*/,**"; System.out.println(someText.replaceAll("[-\\[\\]{}()*+?.,\\\\\\\\^$|
String someText = "Some\\E/s/wText*/,**"; System.out.println("Pattern.quote: "+ Pattern.quote(someText)); System.out.println("Full escape: "+someText.replaceAll("[-\\[\\]{}()*+?.,\\\\\\\\^$|
interface StringFunction { int func(String param); }
public void takingMethod(StringFunction sf) { int i = sf.func("my string"); }
ref.takingMethod(new StringFunction() { public int func(String param) { } });
public enum Operation { PLUS { public double calc(double a, double b) { return a + b; } }, TIMES { public double calc(double a, double b) { return a * b; } } ... public abstract double calc(double a, double b); }
/** * A simple interface to wrap up a function of one argument. * * @author rcreswick * */ public interface Function1<S, T> { /** * Evaluates this function on it * * @param a The first argument. * @return The result. */ public S eval(T a); }
List<Integer> result = CollectionUtilities.map(list, new Function1<Integer, Integer>() { @Override public Integer eval(Integer a) { return a * a; } });
public static <K,R,S,T> Map<K, R> zipWith(Function2<R,S,T> fn, Map<K, S> m1, Map<K, T> m2, Map<K, R> results){ Set<K> keySet = new HashSet<K>(); keySet.addAll(m1.keySet()); keySet.addAll(m2.keySet()); results.clear(); for (K key : keySet) { results.put(key, fn.eval(m1.get(key), m2.get(key))); } return results; }
import java.util.function.IntBinaryOperator; class A { static void method(IntBinaryOperator parameter) { int i = parameter.applyAsInt(7315, 89163); System.out.println(i); } }
import java.lang.Math; class B { public static void main(String[] args) { A.method(Math::max); } }
method1((arg1, arg2) -> Class1.method2(arg1, arg2));
method1(new Interface1() { int method1(int arg1, int arg2) { return Class1.method2(arg1, agr2); } });
import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; class Main { public static void main(final String[] argv) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { final String methodName; final Method method; final Main main; main = new Main(); if(argv.length == 0) { methodName = "foo"; } else { methodName = "bar"; } method = Main.class.getDeclaredMethod(methodName, int.class); main.car(method, 42); } private void foo(final int x) { System.out.println("foo: " + x); } private void bar(final int x) { System.out.println("bar: " + x); } private void car(final Method method, final int val) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { method.invoke(this, val); } }
@FunctionalInterface interface CallbackHandler{ public void onClick(); } public class MyClass{ public void doClick1(){System.out.println("doClick1");;} public void doClick2(){System.out.println("doClick2");} public CallbackHandler mClickListener = this::doClick; public static void main(String[] args) { MyClass myObjectInstance = new MyClass(); CallbackHandler pointer = myObjectInstance::doClick1; Runnable pointer2 = myObjectInstance::doClick2; pointer.onClick(); pointer2.run(); } }
Runnable -> void run( ); Supplier<T> -> T get( ); Consumer<T> -> void accept(T); Predicate<T> -> boolean test(T); UnaryOperator<T> -> T apply(T); BinaryOperator<T,U,R> -> R apply(T, U); Function<T,R> -> R apply(T); BiFunction<T,U,R> -> R apply(T, U); Callable<V> -> V call() throws Exception; Readable -> int read(CharBuffer) throws IOException; AutoCloseable -> void close() throws Exception; Iterable<T> -> Iterator<T> iterator(); Comparable<T> -> int compareTo(T); Comparator<T> -> int compare(T,T);
InnerFunc f=new InnerFunc(1.0); calculateUsing(f); f=new InnerFunc(2.0); calculateUsing(f); f=new InnerFunc(0.5); calculateUsing(f);
InnerFunc f=new InnerFunc(1.0); calculateUsing(f); f.setConstant(2.0); calculateUsing(f); f.setConstant(0.5); calculateUsing(f);
java.lang.reflect.Method Function = Class.forName(String classPath).getMethod(String method, Class[] params);
java.lang.reflect.Method Function = Class.forName("be.qan.NN.ActivationFunctions").getMethod("sigmoid", double.class);
return (java.lang.Double)this.Function.invoke(null, args); java.lang.Object[] args = new java.lang.Object[] {activity}; someOtherFunction() + 234 + (java.lang.Double)Function.invoke(null, args);
class NameFuncPair { public String name; void f(String x) {} public NameFuncPair(String myName) { this.name = myName; } } public class ArrayOfFunctions { public static void main(String[] args) { final A a = new A(); final B b = new B(); NameFuncPair[] fArray = new NameFuncPair[] { new NameFuncPair("A") { @Override void f(String x) { a.g(x); } }, new NameFuncPair("B") { @Override void f(String x) { b.h(x); } }, }; for (NameFuncPair fInstance : fArray) { if (fInstance.name.equals("B")) { fInstance.f(fInstance.name + "(some args)"); } } } } class A { void g(String args) { System.out.println(args); } } class B { void h(String args) { System.out.println(args); } }
void doCalculation(Function<Integer, String> calculation, int parameter) { final String result = calculation.apply(parameter); }
(define (function scalar1 scalar2) (lambda (x) (* x scalar1 scalar2)))
Function<InputType, OutputType> functionname = (inputvariablename) { ... return outputinstance; }
Collections.sort(list, new Comparator<CustomClass>(){ public int compare(CustomClass a, CustomClass b) { } });
int count = map.containsKey(word) ? map.get(word) : 0; map.put(word, count + 1);
import java.util.HashMap; import java.util.Map; ... Map<String, Integer> freq = new HashMap<String, Integer>(); ... int count = freq.containsKey(word) ? freq.get(word) : 0; freq.put(word, count + 1);
import java.util.HashMap; import java.util.Map; ... Map<String, Integer> freq = new HashMap<String, Integer>(); ... Integer count = freq.get(word); if (count == null) { freq.put(word, 1); } else { freq.put(word, count + 1); }
import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import java.util.concurrent.atomic.AtomicLong; ... final ConcurrentMap<String, AtomicLong> map = new ConcurrentHashMap<String, AtomicLong>(); ... map.putIfAbsent(word, new AtomicLong(0)); map.get(word).incrementAndGet();
import gnu.trove.TObjectIntHashMap; ... TObjectIntHashMap<String> freq = new TObjectIntHashMap<String>(); ... freq.adjustOrPutValue(word, 1, 1);
import java.util.HashMap; import java.util.Map; ... class MutableInt { int value = 1; public void increment () { ++value; } public int get () { return value; } } ... Map<String, MutableInt> freq = new HashMap<String, MutableInt>(); ... MutableInt count = freq.get(word); if (count == null) { freq.put(word, new MutableInt()); } else { count.increment(); }
time, ms kolobokeCompile 18.8 koloboke 19.8 trove 20.8 fastutil 22.7 mutableInt 24.3 atomicInteger 25.3 eclipse 26.9 hashMap 28.0 hppc 33.6 hppcRt 36.5
final ConcurrentMap<String, AtomicLong> map = new ConcurrentHashMap<String, AtomicLong>(); map.putIfAbsent("foo", new AtomicLong(0)); map.get("foo").incrementAndGet();
AtomicLongMap map = AtomicLongMap.create(); [...] map.getAndIncrement(word);
Multiset bag = Multisets.newHashMultiset(); String word = "foo"; bag.add(word); bag.add(word); System.out.println(bag.count(word));
class MutableInt { int value = 0; public void inc () { ++value; } public int get () { return value; } } ... Map<String,MutableInt> map = new HashMap<String,MutableInt> (); MutableInt value = map.get (key); if (value == null) { value = new MutableInt (); map.put (key, value); } else { value.inc (); }
Map<String, Integer> map = new HashMap<>(); String key = "a random key"; int count = map.getOrDefault(key, 0); map.put(key, count + 1);
static class MutableInt { int value = 1; void inc() { ++value; } int get() { return value; } } ... Map<String,MutableInt> map = new HashMap<String,MutableInt>(); MutableInt value = map.get(key); if (value == null) { value = new MutableInt(); map.put(key, value); } else { value.inc(); }
final Map<String,AtomicLong> map = new ConcurrentHashMap<>(); map.computeIfAbsent("A", k->new AtomicLong(0)).incrementAndGet(); map.computeIfAbsent("B", k->new AtomicLong(0)).incrementAndGet(); map.computeIfAbsent("A", k->new AtomicLong(0)).incrementAndGet();
Integer count = map.get(word); if(count == null){ count = 0; } map.put(word, count + 1);
HashMultiset s = new HashMultiset(); s.add("word"); s.add("word"); System.out.println(""+s.count("word") );
Map<String,int[]> map = new HashMap<String,int[]>(); ... int[] value = map.get(key); if (value == null) map.put(key, new int[]{1} ); else ++value[0];
TObjectIntHashMap<String> map = new TObjectIntHashMap<String>(); ... map.adjustOrPutValue(key, 1, 1);
Map map = new HashMap (); MutableInt newValue = new MutableInt (1); MutableInt oldValue = map.put (key, newValue); if (oldValue != null) { newValue.add(oldValue); }
Map map = new HashMap (); MutableInt newValue = new MutableInt (0); MutableInt oldValue = map.put (key, newValue); if (oldValue != null) { newValue.setValue(oldValue + 1); }
Map map = new HashMap (); final int defaut = 0; final int inc = 1; MutableInt oldValue = new MutableInt (default); while(true) { MutableInt newValue = oldValue; oldValue = map.put (key, newValue); if (oldValue != null) { newValue.setValue(oldValue + inc); oldValue.setValue(default); } else oldValue = new MutableInt (default); } }
public TreeMap<K, V> update(final K k, final F<V, V> f)
import static fj.data.TreeMap.empty; import static fj.function.Integers.add; import static fj.pre.Ord.stringOrd; import fj.data.TreeMap; public class TreeMap_Update {public static void main(String[] a) {TreeMap<String, Integer> map = empty(stringOrd); map = map.set("foo", 1); map = map.update("foo", add.f(1)); System.out.println(map.get("foo").some());}}
public static Map<String, Integer> strInt = new HashMap<String, Integer>(); public static void main(String[] args) { BiFunction<Integer, Integer, Integer> bi = (x,y) -> { if(x == null) return y; return x+y; }; strInt.put("abc", 0); strInt.merge("abc", 1, bi); strInt.merge("abc", 1, bi); strInt.merge("abc", 1, bi); strInt.merge("abcd", 1, bi); System.out.println(strInt.get("abc")); System.out.println(strInt.get("abcd")); }
MutableBag<String> bag = HashBag.newBagWith("one", "two", "two", "three", "three", "three"); Assert.assertEquals(3, bag.occurrencesOf("three")); bag.add("one"); Assert.assertEquals(2, bag.occurrencesOf("one")); bag.addOccurrences("one", 4); Assert.assertEquals(6, bag.occurrencesOf("one"));
dev map = new HashMap<String, Integer>() map.put("key1", 3) map.merge("key1", 1) {a, b -> a + b} map.merge("key2", 1) {a, b -> a + b}
Enumeration<Driver> drivers = DriverManager.getDrivers(); while (drivers.hasMoreElements()) { Driver driver = drivers.nextElement(); try { DriverManager.deregisterDriver(driver); LOG.log(Level.INFO, String.format("deregistering jdbc driver: %s", driver)); } catch (SQLException e) { LOG.log(Level.SEVERE, String.format("Error deregistering driver %s", driver), e); } }
public final void contextDestroyed(ServletContextEvent sce) { ClassLoader cl = Thread.currentThread().getContextClassLoader(); Enumeration<Driver> drivers = DriverManager.getDrivers(); while (drivers.hasMoreElements()) { Driver driver = drivers.nextElement(); if (driver.getClass().getClassLoader() == cl) { try { log.info("Deregistering JDBC driver {}", driver); DriverManager.deregisterDriver(driver); } catch (SQLException ex) { log.error("Error deregistering JDBC driver {}", driver, ex); } } else { log.trace("Not deregistering JDBC driver {} as it does not belong to this webapp } } }
<listener> <listener-class>com.mysite.MySpecialListener</listener-class> </listener>
public class MySpecialListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { } @Override public void contextDestroyed(ServletContextEvent sce) { Context initContext = new InitialContext(); Context envContext = (Context)initContext.lookup("java:/comp/env"); DataSource datasource = (DataSource)envContext.lookup("jdbc/database"); try { java.sql.Driver mySqlDriver = DriverManager.getDriver("jdbc:mysql: DriverManager.deregisterDriver(mySqlDriver); } catch (SQLException ex) { logger.info("Could not deregister driver:".concat(ex.getMessage())); } dataSource = null; } }
<dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.18</version> <!-- put a copy in /usr/share/tomcat7/lib --> <scope>provided</scope> </dependency>
package utils.db; import java.sql.Driver; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Enumeration; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import oracle.jdbc.OracleDriver; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * Registers and unregisters the Oracle JDBC driver. * * Use only when the ojdbc jar is deployed inside the webapp (not as an * appserver lib) */ public class OjdbcDriverRegistrationListener implements ServletContextListener { private static final Logger LOG = LoggerFactory .getLogger(OjdbcDriverRegistrationListener.class); private Driver driver = null; /** * Registers the Oracle JDBC driver */ @Override public void contextInitialized(ServletContextEvent servletContextEvent) { this.driver = new OracleDriver(); boolean skipRegistration = false; Enumeration<Driver> drivers = DriverManager.getDrivers(); while (drivers.hasMoreElements()) { Driver driver = drivers.nextElement(); if (driver instanceof OracleDriver) { OracleDriver alreadyRegistered = (OracleDriver) driver; if (alreadyRegistered.getClass() == this.driver.getClass()) { skipRegistration = true; this.driver = alreadyRegistered; break; } } } try { if (!skipRegistration) { DriverManager.registerDriver(driver); } else { LOG.debug("driver was registered automatically"); } LOG.info(String.format("registered jdbc driver: %s v%d.%d", driver, driver.getMajorVersion(), driver.getMinorVersion())); } catch (SQLException e) { LOG.error( "Error registering oracle driver: " + "database connectivity might be unavailable!", e); throw new RuntimeException(e); } } /** * Deregisters JDBC driver * * Prevents Tomcat 7 from complaining about memory leaks. */ @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { if (this.driver != null) { try { DriverManager.deregisterDriver(driver); LOG.info(String.format("deregistering jdbc driver: %s", driver)); } catch (SQLException e) { LOG.warn( String.format("Error deregistering driver %s", driver), e); } this.driver = null; } else { LOG.warn("No driver to deregister"); } } }
/** * Destroys the servlet cleanly by unloading JDBC drivers. * * @see javax.servlet.GenericServlet */ public void destroy() { String prefix = getClass().getSimpleName() +" destroy() "; ServletContext ctx = getServletContext(); try { Enumeration<Driver> drivers = DriverManager.getDrivers(); while(drivers.hasMoreElements()) { DriverManager.deregisterDriver(drivers.nextElement()); } } catch(Exception e) { ctx.log(prefix + "Exception caught while deregistering JDBC drivers", e); } ctx.log(prefix + "complete"); }
<?xml version="1.0" encoding="UTF-8"?> <project xmlns="http: xmlns:xsi="http: xsi:schemaLocation="http: <modelVersion>4.0.0</modelVersion> <groupId>com.mywebsite</groupId> <artifactId>emusicstore</artifactId> <version>1.0-SNAPSHOT</version> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.7.0</version> <configuration> <source>1.9</source> <target>1.9</target> </configuration> </plugin> </plugins> </build> <dependencies> <!-- ... --> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-core</artifactId> <version>4.0.1.Final</version> </dependency> <dependency> <groupId>org.hibernate.javax.persistence</groupId> <artifactId>hibernate-jpa-2.0-api</artifactId> <version>1.0.1.Final</version> </dependency> <!-- https: <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.11</version> </dependency> <!-- https: <dependency> <groupId>javax.servlet</groupId> <artifactId>servlet-api</artifactId> <version>2.5</version> <scope>provided</scope> </dependency> </dependencies> </project>
package com.emusicstore.utils; import com.mysql.cj.jdbc.AbandonedConnectionCleanupThread; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import java.sql.Driver; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Enumeration; public class MyWebAppContextListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent servletContextEvent) { System.out.println("************** Starting up! **************"); } @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { System.out.println("************** Shutting down! **************"); System.out.println("Destroying Context..."); System.out.println("Calling MySQL AbandonedConnectionCleanupThread checkedShutdown"); AbandonedConnectionCleanupThread.checkedShutdown(); ClassLoader cl = Thread.currentThread().getContextClassLoader(); Enumeration<Driver> drivers = DriverManager.getDrivers(); while (drivers.hasMoreElements()) { Driver driver = drivers.nextElement(); if (driver.getClass().getClassLoader() == cl) { try { System.out.println("Deregistering JDBC driver {}"); DriverManager.deregisterDriver(driver); } catch (SQLException ex) { System.out.println("Error deregistering JDBC driver {}"); ex.printStackTrace(); } } else { System.out.println("Not deregistering JDBC driver {} as it does not belong to this webapp } } } }
<?xml version="1.0" encoding="UTF-8"?> <web-app xmlns="http: xmlns:xsi="http: xsi:schemaLocation="http: http: version="4.0"> <listener> <listener-class>com.emusicstore.utils.MyWebAppContextListener</listener-class> </listener> <!-- ... --> </web-app>
dataSource { pooled = true jmxExport = true driverClassName = "org.h2.Driver" username = "sa" password = "" }
public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) { Set<Object> seen = ConcurrentHashMap.newKeySet(); return t -> seen.add(keyExtractor.apply(t)); }
persons.stream().filter(distinctByKey(Person::getName))
persons.collect(toMap(Person::getName, p -> p, (p, q) -> p)).values();
persons.stream() .map(Wrapper::new) .distinct() .map(Wrapper::unwrap) ...;
class Wrapper { private final Person person; public Wrapper(Person person) { this.person = person; } public Person unwrap() { return person; } public boolean equals(Object other) { if (other instanceof Wrapper) { return ((Wrapper) other).person.getName().equals(person.getName()); } else { return false; } } public int hashCode() { return person.getName().hashCode(); } }
persons.stream() .collect(Collectors.toCollection( () -> new TreeSet<Person>((p1, p2) -> p1.getName().compareTo(p2.getName())) ));
Observable.from(persons).distinct(p -> p.getName())
Set<String> set = new HashSet<>(persons.size()); persons.stream().filter(p -> set.add(p.getName())).collect(Collectors.toList());
List<Person> persons = ...; MutableList<Person> distinct = ListIterate.distinct(persons, HashingStrategies.fromFunction(Person::getName));
MutableList<Person> persons = ...; MutableList<Person> distinct = persons.distinct(HashingStrategies.fromFunction(Person::getName));
public interface HashingStrategy<E> { int computeHashCode(E object); boolean equals(E object1, E object2); }
persons.collect(groupingBy(p -> p.getName())).values().forEach(t -> System.out.println(t.get(0).getId()));
persons.collect(groupingBy(p -> p.getName())).values().stream().map(l -> (l.get(0)));
private <T, R> Collector<T, ?, Stream<T>> distinctByKey(Function<T, R> keyExtractor) { return Collectors.collectingAndThen( toMap( keyExtractor, t -> t, (t1, t2) -> t1 ), (Map<R, T> map) -> map.values().stream() ); }
Stream.of(new Person("Jean"), new Person("Jean"), new Person("Paul") ) .filter(...) .collect(distinctByKey(Person::getName)) .map(...) .collect(toList())
io.vavr.collection.List.ofAll(persons) .distinctBy(Person::getName) .toJavaSet()
public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) { final Set<Object> seen = new HashSet<>(); return t -> seen.add(keyExtractor.apply(t)); }
persons.stream().filter(distinctByKey(p -> p.getName());
StreamEx.of(persons) .distinct(Person::getName) .toList()
persons.collect(groupingBy(p -> p.getName())).values().stream() .map(plans -> plans.stream().findFirst().get()) .collect(toList());
Seq.seq(persons).distinct(Person::getName).toList();
Comparator<Person> c=Comparator.comparing(Person::getName); stream.sorted(c).filter(new Predicate<Person>() { Person previous; public boolean test(Person p) { if(previous!=null && c.compare(previous, p)==0) return false; previous=p; return true; } }). ;
Set<YourPropertyType> set = new HashSet<>(); list .stream() .filter(it -> set.add(it.getYourProperty())) .forEach(it -> ...);
public static <T> Set<T> removeDuplicates(Collection<T> input, Comparator<T> comparer) { return input.stream() .collect(toCollection(() -> new TreeSet<>(comparer))); } @Test public void removeDuplicatesWithDuplicates() { ArrayList<C> input = new ArrayList<>(); Collections.addAll(input, new C(7), new C(42), new C(42)); Collection<C> result = removeDuplicates(input, (c1, c2) -> Integer.compare(c1.value, c2.value)); assertEquals(2, result.size()); assertTrue(result.stream().anyMatch(c -> c.value == 7)); assertTrue(result.stream().anyMatch(c -> c.value == 42)); } @Test public void removeDuplicatesWithoutDuplicates() { ArrayList<C> input = new ArrayList<>(); Collections.addAll(input, new C(1), new C(2), new C(3)); Collection<C> result = removeDuplicates(input, (t1, t2) -> Integer.compare(t1.value, t2.value)); assertEquals(3, result.size()); assertTrue(result.stream().anyMatch(c -> c.value == 1)); assertTrue(result.stream().anyMatch(c -> c.value == 2)); assertTrue(result.stream().anyMatch(c -> c.value == 3)); } private class C { public final int value; private C(int value) { this.value = value; } }
public static <T, K, K2> Collector<T, ?, Map<K, List<T>>> groupingDistinctBy(Function<T, K> keyFunction, Function<T, K2> distinctFunction) { return groupingBy(keyFunction, Collector.of((Supplier<Map<K2, T>>) HashMap::new, (map, error) -> map.putIfAbsent(distinctFunction.apply(error), error), (left, right) -> { left.putAll(right); return left; }, map -> new ArrayList<>(map.values()), Collector.Characteristics.UNORDERED)); }
yourObjectName.stream().map(x->x.yourObjectProperty).distinct.collect(Collectors.toList());
Set<E> set = new HashSet<>(); set.addAll(yourObjectName.stream().map(x->x.yourObjectProperty).collect(Collectors.toList()));
persons.stream().map(x-> x.getName()).distinct().collect(Collectors.toList());
public class Test { public static void main(String[] args) { Shape s = new Shape.ZShape(); } }
public class Shape { private String shape; private int[][] coords; private int[][] noShapeCoords = { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 } }; private int[][] zShapeCoords = { { 0, -1 }, { 0, 0 }, { -1, 0 }, { -1, 1 } }; private int[][] sShapeCoords = { { 0, -1 }, { 0, 0 }, { 1, 0 }, { 1, 1 } }; private int[][] lineShapeCoords = { { 0, -1 }, { 0, 0 }, { 0, 1 }, { 0, 2 } }; private int[][] tShapeCoords = { { -1, 0 }, { 0, 0 }, { 1, 0 }, { 0, 1 } }; private int[][] squareShapeCoords = { { 0, 0 }, { 1, 0 }, { 0, 1 }, { 1, 1 } }; private int[][] lShapeCoords = { { -1, -1 }, { 0, -1 }, { 0, 0 }, { 0, 1 } }; private int[][] mirroredLShapeCoords = { { 1, -1 }, { 0, -1 }, { 0, 0 }, { 0, 1 } }; public Shape(){ int[][] coords = noShapeCoords; shape = "NoShape"; } class ZShape { int[][] coords = zShapeCoords; String shape = "ZShape"; } class SShape { int[][] coords = sShapeCoords; String shape = "SShape"; } }
RetailerProfileModel.RetailerPaymentModel paymentModel = new RetailerProfileModel().new RetailerPaymentModel();
Outer o = new Outer(); Outer.Inner obj = o.new Inner();
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
public ZShape getNewZShape() { return new ZShape(); }
Shape ss = new Shape(); ZShape s = ss.getNewZShape();
public class Shape { private String shape; public ZShape zShpae; public SShape sShape; public Shape(){ int[][] coords = noShapeCoords; shape = "NoShape"; zShape = new ZShape(); sShape = new SShape(); } class ZShape{ int[][] coords = zShapeCoords; String shape = "ZShape"; } class SShape{ int[][] coords = sShapeCoords; String shape = "SShape"; } }
public class Test { public static void main(String[] args) { Shape shape = new Shape(); Shape s = shape.new Shape.ZShape(); } }
Parent.Child childObject = (Parent.getInstance()).new Child();
Shape shape = new Shape(); Shape.ZShape zshape = shape.new ZShape();
Boolean boolean1 = Boolean.valueOf("true"); boolean boolean2 = Boolean.parseBoolean("true");
if (string.equalsIgnoreCase("true") || string.equalsIgnoreCase("false")) { Boolean.valueOf(string) } else { }
boolean b = string.equalsIgnoreCase("true") || string.equalsIgnoreCase("t") || string.equalsIgnoreCase("yes") || string.equalsIgnoreCase("y") || string.equalsIgnoreCase("sure") || string.equalsIgnoreCase("aye") || string.equalsIgnoreCase("oui") || string.equalsIgnoreCase("vrai");
public static boolean stringToBool(String s) { s = s.toLowerCase(); Set<String> trueSet = new HashSet<String>(Arrays.asList("1", "true", "yes")); Set<String> falseSet = new HashSet<String>(Arrays.asList("0", "false", "no")); if (trueSet.contains(s)) return true; if (falseSet.contains(s)) return false; throw new IllegalArgumentException(s + " is not a boolean."); }
String[] values= new String[]{"y","Y","n","N","Yes","YES","yes","no","No","NO","true","false","True","False","TRUE","FALSE",null}; for(String booleanStr : values){ System.out.println("Str ="+ booleanStr +": boolean =" +BooleanUtils.toBoolean(booleanStr)); }
Str =N: boolean =false Str =Yes: boolean =true Str =YES: boolean =true Str =yes: boolean =true Str =no: boolean =false Str =No: boolean =false Str =NO: boolean =false Str =true: boolean =true Str =false: boolean =false Str =True: boolean =true Str =False: boolean =false Str =TRUE: boolean =true Str =FALSE: boolean =false Str =null: boolean =false
public boolean toBoolean(String s) { try { return Boolean.parseBoolean(s); } catch(Exception e) { return null; } }
public static boolean toBoolean( String target ) { if( target == null ) return false; return target.matches( "(?i:^(1|true|yes|oui|vrai|y)$)" ); }
System.setProperty("n","false"); System.setProperty("y","true"); System.setProperty("yes","true"); System.setProperty("no","false"); System.out.println(Boolean.getBoolean("n")); System.out.println(Boolean.getBoolean("y")); System.out.println(Boolean.getBoolean("no")); System.out.println(Boolean.getBoolean("yes"));
int[] src = new int[]{1,2,3,4,5}; int[] dest = new int[5]; System.arraycopy( src, 0, dest, 0, src.length );
int[] a = new int[]{1,2,3,4,5}; int[] b = a.clone();
ALOAD 1 INVOKEVIRTUAL [I.clone ()Ljava/lang/Object; CHECKCAST [I ASTORE 2
int[] a = {1,2,3,4,5}; int[] b = Arrays.copyOf(a, a.length); int[] c = a.clone(); public void someMethod(int[] a) { if (a!=null) { int[] b = Arrays.copyOf(a, a.length); int[] c = a.clone(); } }
public void someMethod(int[] a) { int[] b = ArrayUtils.clone(a); }
public static void main(String[] args) { int[] a = {1,2,3}; int[] b = Arrays.copyOfRange(a, 0, a.length); a[0] = 5; System.out.println(Arrays.toString(a)); System.out.println(Arrays.toString(b)); }
int[] a = new int[5]{1,2,3,4,5}; int[] b = Arrays.copyOf(a, a.length);
public static <T> T[] copyOf(T[] original, int newLength)
2770 2771 public static <T,U> T[] More ...copyOf(U[] original, int newLength, Class<? extends T[]> newType) { 2772 T[] copy = ((Object)newType == (Object)Object[].class) 2773 ? (T[]) new Object[newLength] 2774 : (T[]) Array.newInstance(newType.getComponentType(), newLength); 2775 System.arraycopy(original, 0, copy, 0, 2776 Math.min(original.length, newLength)); 2777 return copy; 2778 }
public static <T> T[] copyOfRange(T[] original, int from, int to)
3035 public static <T,U> T[] More ...copyOfRange(U[] original, int from, int to, Class<? extends T[]> newType) { 3036 int newLength = to - from; 3037 if (newLength < 0) 3038 throw new IllegalArgumentException(from + " > " + to); 3039 T[] copy = ((Object)newType == (Object)Object[].class) 3040 ? (T[]) new Object[newLength] 3041 : (T[]) Array.newInstance(newType.getComponentType(), newLength); 3042 System.arraycopy(original, from, copy, 0, 3043 Math.min(original.length - from, newLength)); 3044 return copy; 3045 }
int[] arrayToCopy = {1, 2, 3}; int[] copiedArray = Optional.ofNullable(arrayToCopy).map(int[]::clone).orElse(null);
public enum MyEnum { EnumValue1, EnumValue2 } MyEnum enumValue = (MyEnum) x;
public enum MyEnum { EnumValue1, EnumValue2; public static MyEnum fromInteger(int x) { switch(x) { case 0: return EnumValue1; case 1: return EnumValue2; } return null; } }
public enum A { B(0), C(10), None(11); int id; private A(int i){id = i;} public int GetID(){return id;} public boolean IsEmpty(){return this.equals(A.None);} public boolean Compare(int i){return id == i;} public static A GetValue(int _id) { A[] As = A.values(); for(int i = 0; i < As.length; i++) { if(As[i].Compare(_id)) return As[i]; } return A.None; } }
public Enum MyEnum { THIS(5), THAT(16), THE_OTHER(35); private int id; private MyEnum(int id) { this.id = id; } public static MyEnum fromId(int id) { for (MyEnum type : values()) { if (type.getId() == id) { return type; } } return null; } }
public static enum EnumAttributeType { ENUM_1, ENUM_2; private static EnumAttributeType[] values = null; public static EnumAttributeType fromInt(int i) { if(EnumAttributeType.values == null) { EnumAttributeType.values = EnumAttributeType.values(); } return EnumAttributeType.values[i]; } }
public Enum MyEnum { THIS(5), THAT(16), THE_OTHER(35); private int id; private MyEnum(int id) { this.id = id; } public int getId() { return this.id; } public static Map<Integer, MyEnum> buildMap() { Map<Integer, MyEnum> map = new HashMap<Integer, MyEnum>(); MyEnum[] values = MyEnum.values(); for (MyEnum value : values) { map.put(value.getId(), value); } return map; } }
public enum MyEnum { OPTION_1(-66), OPTION_2(32); private int value; private MyEnum(final int value) { this.value = value; } public int getValue() { return this.value; } private static ImmutableMap<Integer, MyEnum> reverseLookup = Maps.uniqueIndex(Arrays.asList(MyEnum.values())), MyEnum::getValue); public static MyEnum fromInt(final int id) { return reverseLookup.getOrDefault(id, OPTION_1); } }
public enum TestEnum { None(0), Value1(1), Value2(2), Value3(3), Value4(4), Value5(5); private final int value; private TestEnum(int value) { this.value = value; } public int getValue() { return value; } public static TestEnum getEnum(int value){ for (TestEnum e:TestEnum.values()) { if(e.getValue() == value) return e; } return TestEnum.None; } }
import java.util.stream.Collectors; import java.util.function.Function; import java.util.Map; import java.util.Arrays; public enum MyEnum { OPTION_1(-66), OPTION_2(32); private int value; private MyEnum(final int value) { this.value = value; } public int getValue() { return this.value; } private static Map<Integer, MyEnum> reverseLookup = Arrays.stream(MyEnum.values()).collect(Collectors.toMap(MyEnum::getValue, Function.identity())); public static MyEnum fromInt(final int id) { return reverseLookup.getOrDefault(id, OPTION_1); } public static void main(String[] args) { System.out.println(fromInt(-66).toString()); } }
private static boolean arrayCreated = false; private static RFMsgType[] ArrayOfValues; public static RFMsgType GetMsgTypeFromValue(int MessageID) { if (arrayCreated == false) { ArrayOfValues = RFMsgType.values(); } for (int i = 0; i < ArrayOfValues.length; i++) { if (ArrayOfValues[i].MessageIDValue == MessageID) { return ArrayOfValues[i]; } } return RFMsgType.UNKNOWN; }
enum MyEnum { A(0), B(1); private final int value; private MyEnum(int val) {this.value = value;} private static final MyEnum[] values = MyEnum.values(); public static final getMyEnum(int value) { try { return values[value]; } catch (ArrayOutOfBoundsException e) { } finally { return myDefaultEnumValue; } } }
package service.manager; public enum Command { PRINT_FOO(0), PRINT_BAR(2), PRINT_BAZ(3); public int intVal; Command(int intVal){ this.intVal = intVal; } /** * Functionality to ascertain an enum from an int * The static block initializes the array indexes to correspond with it * Simply use Command.values[index] or get the int value by e.g. Command.PRINT_FOO.intVal; * */ public static Command values[]; static{ int maxVal = -1; for(Command cmd : Command.values()) if(maxVal < cmd.intVal) maxVal = cmd.intVal; values = new Command[maxVal + 1]; for(Command cmd : Command.values()) values[cmd.intVal] = cmd; } }
ArrayList aList = new ArrayList(); aList.add("1"); aList.add("2"); aList.add("3"); aList.add("4"); aList.add("5"); while (aList.listIterator().hasPrevious()) Log.d("reverse", "" + aList.listIterator().previous());
ArrayList aList = new ArrayList(); aList.add("1"); aList.add("2"); aList.add("3"); aList.add("4"); aList.add("5"); Collections.reverse(aList); System.out.println("After Reverse Order, ArrayList Contains : " + aList);
public ArrayList<Object> reverse(ArrayList<Object> list) { if(list.size() > 1) { Object value = list.remove(0); reverse(list); list.add(value); } return list; }
public ArrayList<Object> reverse(ArrayList<Object> list) { for(int i = 0, j = list.size() - 1; i < j; i++) { list.add(i, list.remove(j)); } return list; }
static <T> List<T> reverse(final List<T> list) { final List<T> result = new ArrayList<>(list); Collections.reverse(result); return result; }
static <T> List<T> reverse(final List<T> list) { final int size = list.size(); final int last = size - 1; final List<T> result = new ArrayList<>(size); for (int i = last; i >= 0; --i) { final T element = list.get(i); result.add(element); } return result; }
static <T> List<T> reverse(final List<T> list) { final int last = list.size() - 1; return IntStream.rangeClosed(0, last) .map(i -> (last - i)) .mapToObj(list::get) .collect(Collectors.toList()); }
public ArrayList<Object> reverse(ArrayList<Object> list) { for (int i = 0; i < list.size() / 2; i++) { Object temp = list.get(i); list.set(i, list.get(list.size() - i - 1)); list.set(list.size() - i - 1, temp); } return list; }
ArrayList<Integer> myArray = new ArrayList<Integer>(); myArray.add(1); myArray.add(2); myArray.add(3); int reverseArrayCounter = myArray.size() - 1; for (int i = reverseArrayCounter; i >= 0; i--) { System.out.println(myArray.get(i)); }
public class ListUtil { public static void main(String[] args) { ArrayList<String> arrayList = new ArrayList<String>(); arrayList.add("1"); arrayList.add("2"); arrayList.add("3"); arrayList.add("4"); arrayList.add("5"); System.out.println("Reverse Order: " + reverse(arrayList)); } public static <T> List<T> reverse(List<T> arrayList) { return reverse(arrayList,0,arrayList.size()-1); } public static <T> List<T> reverse(List<T> arrayList,int startIndex,int lastIndex) { if(startIndex<lastIndex) { T t=arrayList.get(lastIndex); arrayList.set(lastIndex,arrayList.get(startIndex)); arrayList.set(startIndex,t); startIndex++; lastIndex--; reverse(arrayList,startIndex,lastIndex); } return arrayList; } }
public static void main(String[] args) { ArrayList<String> someDummyList = getDummyList(); System.out.println(someDummyList); int size = someDummyList.size() - 1; ArrayList<String> someDummyListRev = IntStream.rangeClosed(0,size).mapToObj(i->someDummyList.get(size-i)).collect(Collectors.toCollection(ArrayList::new)); System.out.println(someDummyListRev); } private static ArrayList<String> getDummyList() { ArrayList dummyList = new ArrayList(); dummyList.add("A"); dummyList.add("B"); dummyList.add("C"); dummyList.add("D"); return dummyList; }
public static<T> List<T> reverseList(List<T> list) { List<T> reverse = new ArrayList<>(list.size()); list.stream() .collect(Collectors.toCollection(LinkedList::new)) .descendingIterator() .forEachRemaining(reverse::add); return reverse; }
public static <T> ArrayList<T> reverse(ArrayList<T> list) { int length = list.size(); ArrayList<T> result = new ArrayList<T>(length); for (int i = length - 1; i >= 0; i--) { result.add(list.get(i)); } return result; }
public static String reverse(ArrayList<Float> list) { if (list.size() == 1) { return " " +list.get(0); } else { return " "+ list.remove(list.size() - 1) + reverse(list); } }
<%@tag description="Simple Wrapper Tag" pageEncoding="UTF-8"%> <html><body> <jsp:doBody/> </body></html>
<%@page contentType="text/html" pageEncoding="UTF-8"%> <%@taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:wrapper> <h1>Welcome</h1> </t:wrapper>
<%@tag description="Overall Page template" pageEncoding="UTF-8"%> <%@attribute name="header" fragment="true" %> <%@attribute name="footer" fragment="true" %> <html> <body> <div id="pageheader"> <jsp:invoke fragment="header"/> </div> <div id="body"> <jsp:doBody/> </div> <div id="pagefooter"> <jsp:invoke fragment="footer"/> </div> </body> </html>
<%@page contentType="text/html" pageEncoding="UTF-8"%> <%@taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:genericpage> <jsp:attribute name="header"> <h1>Welcome</h1> </jsp:attribute> <jsp:attribute name="footer"> <p id="copyright">Copyright 1927, Future Bits When There Be Bits Inc.</p> </jsp:attribute> <jsp:body> <p>Hi I </jsp:body> </t:genericpage>
<%@tag description="User Page template" pageEncoding="UTF-8"%> <%@taglib prefix="t" tagdir="/WEB-INF/tags" %> <%@attribute name="userName" required="true"%> <t:genericpage> <jsp:attribute name="header"> <h1>Welcome ${userName}</h1> </jsp:attribute> <jsp:attribute name="footer"> <p id="copyright">Copyright 1927, Future Bits When There Be Bits Inc.</p> </jsp:attribute> <jsp:body> <jsp:doBody/> </jsp:body> </t:genericpage>
<%@page contentType="text/html" pageEncoding="UTF-8"%> <%@taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:userpage userName="${user.fullName}"> <p> First Name: ${user.firstName} <br/> Last Name: ${user.lastName} <br/> Phone: ${user.phone}<br/> </p> </t:userpage>
<%@tag description="User Page template" pageEncoding="UTF-8"%> <%@tag import="com.example.User" %> <%@attribute name="user" required="true" type="com.example.User"%> First Name: ${user.firstName} <br/> Last Name: ${user.lastName} <br/> Phone: ${user.phone}<br/>
<%@page contentType="text/html" pageEncoding="UTF-8"%> <%@taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:userpage userName="${user.fullName}"> <p> <t:userdetail user="${user}"/> </p> </t:userpage>
<t:table items="${actionBean.customerList}" var="obj" css_class="display"> <t:col css_class="checkboxcol"> <s:checkbox name="customerIds" value="${obj.customerId}" onclick="handleCheckboxRangeSelection(this, event);"/> </t:col> <t:col name="customerId" title="ID"/> <t:col name="firstName" title="First Name"/> <t:col name="lastName" title="Last Name"/> <t:col> <s:link href="/Customer.action" event="preEdit"> Edit <s:param name="customer.customerId" value="${obj.customerId}"/> <s:param name="page" value="${actionBean.page}"/> </s:link> </t:col> </t:table>
<%@page contentType="text/html; charset=UTF-8" %> <%@ taglib uri="http: <!DOCTYPE html> <html lang="en"> <head> <title>JSP Template Inheritance</title> </head> <h1>Head</h1> <div> <layout:block name="header"> header </layout:block> </div> <h1>Contents</h1> <div> <p> <layout:block name="contents"> <h2>Contents will be placed under this h2</h2> </layout:block> </p> </div> <div class="footer"> <hr /> <a href="https: </div> </html>
<%@page contentType="text/html; charset=UTF-8" %> <%@ taglib uri="http: <layout:extends name="base.jsp"> <layout:put name="header" type="REPLACE"> <h2>This is an example about layout management with JSP Template Inheritance</h2> </layout:put> <layout:put name="contents"> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin porta, augue ut ornare sagittis, diam libero facilisis augue, quis accumsan enim velit a mauris. </layout:put> </layout:extends>
<%-- The block tag implements a basic but useful extensible template system. A base template consists of a block tag without a The template body is specified in a standard jsp:body tag, which can contain EL, JSTL tags, nested block tags and other custom tags, but cannot contain scriptlets (scriptlets are allowed in the template file, but only outside of the body and attribute tags). Templates can be full-page templates, or smaller blocks of markup included within a page. The template is customizable by referencing named attributes within the body (via EL). Attribute values can then be set either as attributes of the block tag element itself (convenient for short values), or by using nested jsp:attribute elements (better for entire blocks of markup). Rendering a template block or extending it in a child template is then just a matter of invoking the block tag with the to the desired template name, and overriding template-specific attributes as necessary to customize it. Attribute values set when rendering a tag override those set in the template definition, which override those set in its parent template definition, etc. The attributes that are set in the base template are thus effectively used as defaults. Attributes that are not set anywhere are treated as empty. Internally, attributes are passed from child to parent via request-scope attributes, which are removed when rendering is complete. Here ====== WEB-INF/tags/block.tag (the template engine tag) <the file you ====== WEB-INF/templates/base.jsp (base template) <%@ page trimDirectiveWhitespaces="true" %> <%@ taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:block> <jsp:attribute name="title">Template Page</jsp:attribute> <jsp:attribute name="style"> .footer { font-size: smaller; color: .content { margin: 2em; color: ${moreStyle} </jsp:attribute> <jsp:attribute name="footer"> <div class="footer"> Powered by the block tag </div> </jsp:attribute> <jsp:body> <html> <head> <title>${title}</title> <style> ${style} </style> </head> <body> <h1>${title}</h1> <div class="content"> ${content} </div> ${footer} </body> </html> </jsp:body> </t:block> ====== WEB-INF/templates/history.jsp (child template) <%@ page trimDirectiveWhitespaces="true" %> <%@ taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:block template="base" title="History Lesson"> <jsp:attribute name="content" trim="false"> <p>${shooter} shot first!</p> </jsp:attribute> </t:block> ====== history-1977.jsp (a page using child template) <%@ page trimDirectiveWhitespaces="true" %> <%@ taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:block template="history" shooter="Han" /> ====== history-1997.jsp (a page using child template) <%@ page trimDirectiveWhitespaces="true" %> <%@ taglib prefix="t" tagdir="/WEB-INF/tags" %> <t:block template="history" title="Revised History Lesson"> <jsp:attribute name="moreStyle">.revised { font-style: italic; }</jsp:attribute> <jsp:attribute name="shooter"><span class="revised">Greedo</span></jsp:attribute> </t:block> --%> <%@ tag trimDirectiveWhitespaces="true" %> <%@ tag import="java.util.HashSet, java.util.Map, java.util.Map.Entry" %> <%@ tag dynamic-attributes="dynattributes" %> <%@ attribute name="template" %> <% String template = (String)jspContext.getAttribute("template"); if (template != null) { if (!template.contains(".")) template += ".jsp"; if (!template.startsWith("/")) template = "/WEB-INF/templates/" + template; } Map<String, String> dynattributes = (Map<String, String>)jspContext.getAttribute("dynattributes"); HashSet<String> addedAttributes = new HashSet<String>(); for (Map.Entry<String, String> e : dynattributes.entrySet()) { if (jspContext.getAttribute(e.getKey(), PageContext.REQUEST_SCOPE) == null) { jspContext.setAttribute(e.getKey(), e.getValue(), PageContext.REQUEST_SCOPE); addedAttributes.add(e.getKey()); } } %> <% if (template == null) { <jsp:doBody/> <% } else { <jsp:include page="<%= template %>" /> <% } %> <% for (String key : addedAttributes) { jspContext.removeAttribute(key, PageContext.REQUEST_SCOPE); } %>
<jsp:element name="${content.headerName}" xmlns:jsp="http: <jsp:attribute name="lang">${content.lang}</jsp:attribute> <jsp:body>${content.body}</jsp:body> </jsp:element>
... <uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission> ... <receiver android:process=":remote" android:name=".Alarm"></receiver> ...
package yourPackage; import android.app.AlarmManager; import android.app.PendingIntent; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.os.PowerManager; import android.widget.Toast; public class Alarm extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""); wl.acquire(); Toast.makeText(context, "Alarm !!!!!!!!!!", Toast.LENGTH_LONG).show(); wl.release(); } public void setAlarm(Context context) { AlarmManager am =( AlarmManager)context.getSystemService(Context.ALARM_SERVICE); Intent i = new Intent(context, Alarm.class); PendingIntent pi = PendingIntent.getBroadcast(context, 0, i, 0); am.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), 1000 * 60 * 10, pi); } public void cancelAlarm(Context context) { Intent intent = new Intent(context, Alarm.class); PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, 0); AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarmManager.cancel(sender); } }
package yourPackage; import android.app.Service; import android.content.Context; import android.content.Intent; import android.os.IBinder; public class YourService extends Service { Alarm alarm = new Alarm(); public void onCreate() { super.onCreate(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { alarm.setAlarm(this); return START_STICKY; } @Override public void onStart(Intent intent, int startId) { alarm.setAlarm(this); } @Override public IBinder onBind(Intent intent) { return null; } }
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"></uses-permission> ... <receiver android:name=".AutoStart"> <intent-filter> <action android:name="android.intent.action.BOOT_COMPLETED"></action> </intent-filter> </receiver> ... <service android:name=".YourService" android:enabled="true" android:process=":your_service" > </service>
package yourPackage; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; public class AutoStart extends BroadcastReceiver { Alarm alarm = new Alarm(); @Override public void onReceive(Context context, Intent intent) { if (intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) { alarm.setAlarm(context); } } }
<receiver android:name=".Alarm" android:exported="true"> <intent-filter> <action android:name="mypackage.START_ALARM" > </action> </intent-filter> </receiver>
public void SetAlarm() { final Button button = buttons[2]; BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive( Context context, Intent _ ) { button.setBackgroundColor( Color.RED ); context.unregisterReceiver( this ); } }; this.registerReceiver( receiver, new IntentFilter("com.blah.blah.somemessage") ); PendingIntent pintent = PendingIntent.getBroadcast( this, 0, new Intent("com.blah.blah.somemessage"), 0 ); AlarmManager manager = (AlarmManager)(this.getSystemService( Context.ALARM_SERVICE )); manager.set( AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 1000*5, pintent ); }
package com.example.alarmexample; import android.app.Activity; import android.app.AlarmManager; import android.app.PendingIntent; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; public class MainActivity extends Activity { Button b1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startAlert(); } public void startAlert() { int timeInSec = 2; Intent intent = new Intent(this, MyBroadcastReceiver.class); PendingIntent pendingIntent = PendingIntent.getBroadcast( this.getApplicationContext(), 234, intent, 0); AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE); alarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + (timeInSec * 1000), pendingIntent); Toast.makeText(this, "Alarm set to after " + i + " seconds",Toast.LENGTH_LONG).show(); } }
package com.example.alarmexample; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.media.MediaPlayer; import android.widget.Toast; public class MyBroadcastReceiver extends BroadcastReceiver { MediaPlayer mp; @Override public void onReceive(Context context, Intent intent) { mp=MediaPlayer.create(context, R.raw.alarm); mp.start(); Toast.makeText(context, "Alarm", Toast.LENGTH_LONG).show(); } }
<?xml version="1.0" encoding="utf-8"?> <manifest xmlns:android="http: package="com.example.alarmexample" > <uses-permission android:name="android.permission.VIBRATE" /> <application android:allowBackup="true" android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme" > <activity android:name="com.example.alarmexample.MainActivity" android:label="@string/app_name" > <intent-filter> <action android:name="android.intent.action.MAIN" /> <category android:name="android.intent.category.LAUNCHER" /> </intent-filter> </activity> <receiver android:name="MyBroadcastReceiver" > </receiver> </application> </manifest>
<?xml version="1.0" encoding="utf-8"?> <LinearLayout xmlns:android="http: xmlns:tools="http: android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background=" android:paddingTop="100dp"> <LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" > <EditText android:id="@+id/ethr" android:layout_width="50dp" android:layout_height="wrap_content" android:ems="10" android:hint="Hr" android:singleLine="true" > <requestFocus /> </EditText> <EditText android:id="@+id/etmin" android:layout_width="55dp" android:layout_height="wrap_content" android:ems="10" android:hint="Min" android:singleLine="true" /> <EditText android:id="@+id/etsec" android:layout_width="50dp" android:layout_height="wrap_content" android:ems="10" android:hint="Sec" android:singleLine="true" /> </LinearLayout> <LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:paddingTop="10dp"> <Button android:id="@+id/setAlarm" android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="onClickSetAlarm" android:text="Set Alarm" /> </LinearLayout> </LinearLayout>
public class MainActivity extends Activity { int hr = 0; int min = 0; int sec = 0; int result = 1; AlarmManager alarmManager; PendingIntent pendingIntent; BroadcastReceiver mReceiver; EditText ethr; EditText etmin; EditText etsec; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ethr = (EditText) findViewById(R.id.ethr); etmin = (EditText) findViewById(R.id.etmin); etsec = (EditText) findViewById(R.id.etsec); RegisterAlarmBroadcast(); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return true; } @Override protected void onDestroy() { unregisterReceiver(mReceiver); super.onDestroy(); } public void onClickSetAlarm(View v) { String shr = ethr.getText().toString(); String smin = etmin.getText().toString(); String ssec = etsec.getText().toString(); if(shr.equals("")) hr = 0; else { hr = Integer.parseInt(ethr.getText().toString()); hr=hr*60*60*1000; } if(smin.equals("")) min = 0; else { min = Integer.parseInt(etmin.getText().toString()); min = min*60*1000; } if(ssec.equals("")) sec = 0; else { sec = Integer.parseInt(etsec.getText().toString()); sec = sec * 1000; } result = hr+min+sec; alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), result , pendingIntent); } private void RegisterAlarmBroadcast() { mReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, "Alarm time has been reached", Toast.LENGTH_LONG).show(); } }; registerReceiver(mReceiver, new IntentFilter("sample")); pendingIntent = PendingIntent.getBroadcast(this, 0, new Intent("sample"), 0); alarmManager = (AlarmManager)(this.getSystemService(Context.ALARM_SERVICE)); } private void UnregisterAlarmBroadcast() { alarmManager.cancel(pendingIntent); getBaseContext().unregisterReceiver(mReceiver); } }
alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), result , pendingIntent);
alarmManager.set( AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + result , pendingIntent );
import android.app.AlarmManager; import android.app.PendingIntent; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import junit.framework.Assert; /** * Created by Daniel on 28/08/2016. */ public abstract class AbstractSystemServiceTask { private final Context context; private final AlarmManager alarmManager; private final BroadcastReceiver broadcastReceiver; private final PendingIntent pendingIntent; public AbstractSystemServiceTask(final Context context, final String id, final long time, final AlarmType alarmType, final BackgroundTaskListener backgroundTaskListener) { Assert.assertNotNull("ApplicationContext can Assert.assertNotNull("ID can this.context = context; this.alarmManager = (AlarmManager) this.context.getSystemService(Context.ALARM_SERVICE); this.context.registerReceiver( this.broadcastReceiver = this.getBroadcastReceiver(backgroundTaskListener), new IntentFilter(id)); this.configAlarmManager( this.pendingIntent = PendingIntent.getBroadcast(this.context, 0, new Intent(id), 0), time, alarmType); } public void stop() { this.alarmManager.cancel(this.pendingIntent); this.context.unregisterReceiver(this.broadcastReceiver); } private BroadcastReceiver getBroadcastReceiver(final BackgroundTaskListener backgroundTaskListener) { Assert.assertNotNull("BackgroundTaskListener can return new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { backgroundTaskListener.perform(context, intent); } }; } private void configAlarmManager(final PendingIntent pendingIntent, final long time, final AlarmType alarmType) { long ensurePositiveTime = Math.max(time, 0L); switch (alarmType) { case REPEAT: this.alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), ensurePositiveTime, pendingIntent); break; case ONE_TIME: default: this.alarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + ensurePositiveTime, pendingIntent); } } public interface BackgroundTaskListener { void perform(Context context, Intent intent); } public enum AlarmType { REPEAT, ONE_TIME; } }
import android.content.Context; import android.content.Intent; import android.util.Log; import ...AbstractSystemServiceTask; import java.util.concurrent.TimeUnit; /** * Created by Daniel on 28/08/2016. */ public class UpdateInfoSystemServiceTask extends AbstractSystemServiceTask { private final static String ID = "UPDATE_INFO_SYSTEM_SERVICE"; private final static long REPEAT_TIME = TimeUnit.SECONDS.toMillis(10); private final static AlarmType ALARM_TYPE = AlarmType.REPEAT; public UpdateInfoSystemServiceTask(Context context) { super(context, ID, REPEAT_TIME, ALARM_TYPE, new BackgroundTaskListener() { @Override public void perform(Context context, Intent intent) { Log.i("MyAppLog", "-----> UpdateInfoSystemServiceTask"); } }); Log.i("MyAppLog", "UpdateInfoSystemServiceTask started."); } }
import android.app.AlarmManager; import android.app.PendingIntent; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import junit.framework.Assert; import java.util.HashSet; import java.util.Set; /** * Created by Daniel on 28/08/2016. */ public abstract class AbstractSystemServiceTask { private final Context context; private final AlarmManager alarmManager; private final BroadcastReceiver broadcastReceiver; private final PendingIntent pendingIntent; private final Set<BackgroundTaskListener> backgroundTaskListenerSet; public AbstractSystemServiceTask(final Context context, final String id, final long time, final AlarmType alarmType) { Assert.assertNotNull("ApplicationContext can Assert.assertNotNull("ID can this.backgroundTaskListenerSet = new HashSet<>(); this.context = context; this.alarmManager = (AlarmManager) this.context.getSystemService(Context.ALARM_SERVICE); this.context.registerReceiver( this.broadcastReceiver = this.getBroadcastReceiver(), new IntentFilter(id)); this.configAlarmManager( this.pendingIntent = PendingIntent.getBroadcast(this.context, 0, new Intent(id), 0), time, alarmType); } public synchronized void registerTask(final BackgroundTaskListener backgroundTaskListener) { Assert.assertNotNull("BackgroundTaskListener can this.backgroundTaskListenerSet.add(backgroundTaskListener); } public synchronized void removeTask(final BackgroundTaskListener backgroundTaskListener) { Assert.assertNotNull("BackgroundTaskListener can this.backgroundTaskListenerSet.remove(backgroundTaskListener); } public void stop() { this.backgroundTaskListenerSet.clear(); this.alarmManager.cancel(this.pendingIntent); this.context.unregisterReceiver(this.broadcastReceiver); } private BroadcastReceiver getBroadcastReceiver() { return new BroadcastReceiver() { @Override public void onReceive(final Context context, final Intent intent) { for (BackgroundTaskListener backgroundTaskListener : AbstractSystemServiceTask.this.backgroundTaskListenerSet) { backgroundTaskListener.perform(context, intent); } } }; } private void configAlarmManager(final PendingIntent pendingIntent, final long time, final AlarmType alarmType) { long ensurePositiveTime = Math.max(time, 0L); switch (alarmType) { case REPEAT: this.alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), ensurePositiveTime, pendingIntent); break; case ONE_TIME: default: this.alarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + ensurePositiveTime, pendingIntent); } } public interface BackgroundTaskListener { void perform(Context context, Intent intent); } public enum AlarmType { REPEAT, ONE_TIME; } }
import android.app.AlarmManager import android.app.PendingIntent import android.content.Context import android.content.Intent object MyAlarmManager { private var pendingIntent: PendingIntent? = null fun setAlarm(context: Context, alarmTime: Long, message: String) { val alarmManager: AlarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager val intent = Intent(context, MyIntentService::class.java) intent.action = MyIntentService.ACTION_SEND_TEST_MESSAGE intent.putExtra(MyIntentService.EXTRA_MESSAGE, message) pendingIntent = PendingIntent.getService(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT) alarmManager.set(AlarmManager.RTC_WAKEUP, alarmTime, pendingIntent) } fun cancelAlarm(context: Context) { pendingIntent?.let { val alarmManager: AlarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager alarmManager.cancel(it) } } }
import android.app.IntentService import android.content.Intent class MyIntentService : IntentService("MyIntentService") { override fun onHandleIntent(intent: Intent?) { intent?.apply { when (intent.action) { ACTION_SEND_TEST_MESSAGE -> { val message = getStringExtra(EXTRA_MESSAGE) println(message) } } } } companion object { const val ACTION_SEND_TEST_MESSAGE = "ACTION_SEND_TEST_MESSAGE" const val EXTRA_MESSAGE = "EXTRA_MESSAGE" } }
<?xml version="1.0" encoding="utf-8"?> <manifest xmlns:android="http: package="com.aminography.alarm"> <application ... > <service android:name="path.to.MyIntentService" android:enabled="true" android:stopWithTask="false" /> </application> </manifest>
val calendar = Calendar.getInstance() calendar.add(Calendar.SECOND, 10) MyAlarmManager.setAlarm(applicationContext, calendar.timeInMillis, "Test Message!")
for (String str : myArrayList) { if (someCondition) { myArrayList.remove(str); } }
Iterator<String> iter = myArrayList.iterator(); while (iter.hasNext()) { String str = iter.next(); if (someCondition) iter.remove(); }
List<String> toRemove = new ArrayList<String>(); for (String str : myArrayList) { if (someCondition) { toRemove.add(str); } } myArrayList.removeAll(toRemove);
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c")); list.removeIf(e -> (someCondition));
for (final Iterator iterator = myArrayList.iterator(); iterator.hasNext(); ) { iterator.next(); if (someCondition) { iterator.remove(); } }
for (SomeClass currElement: testList) { SomeClass founDuplicate = findDuplicates(currElement); if (founDuplicate != null) { uniqueTestList.add(founDuplicate); testList.remove(testList.indexOf(currElement)); } }
for (int i = 0; i < testList.size(); i++) { SomeClass currElement = testList.get(i); SomeClass founDuplicate = findDuplicates(currElement); if (founDuplicate != null) { uniqueTestList.add(founDuplicate); testList.remove(testList.indexOf(currElement)); i--; } }
Exception in thread "main" java.util.ConcurrentModificationException at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372) at java.util.AbstractList$Itr.next(AbstractList.java:343) at TestFail.main(TestFail.java:43)
List<String> s = new CopyOnWriteArrayList<>(); s.add("B"); Iterator<String> it = s.iterator(); s.add("A"); while (it.hasNext()) { s.remove(it.next()); } System.out.println(s);
List<String> myList = new ArrayList<String>(); myList.add("abc"); myList.add("abcd"); myList.add("abcde"); myList.add("abcdef"); myList.add("abcdefg"); Object[] obj = myList.toArray(); for(Object o:obj) { if(condition) myList.remove(o.toString()); }
List myArrayList = Collections.synchronizedList(new ArrayList()); myArrayList.add(); myArrayList.add(); myArrayList.add(); synchronized(myArrayList) { Iterator i = myArrayList.iterator(); while (i.hasNext()){ Object object = i.next(); } }
public static void startMusic() { URL songPath = getClass().getClassLoader().getResource("background.midi"); }
Cannot make a static reference to the non-static method getClass() from the type Object
class MyClass { public static void startMusic() { URL songPath = MyClass.class.getResource("background.midi"); } }
Class currentClass = new Object() { }.getClass().getEnclosingClass();
public static InputStream getResource(String resource) throws Exception { ClassLoader cl = Thread.currentThread().getContextClassLoader(); InputStream is = cl.getResourceAsStream(resource); return is; }
Thread.currentThread().getStackTrace()[1].getClassName()
Thread.currentThread().getStackTrace()[2].getClassName()
String level= ""; Properties prop = new Properties(); InputStream in = Logg.class.getResourceAsStream("resources\\config"); if (in != null) { prop.load(in); } else { throw new FileNotFoundException("property file } level = prop.getProperty("Level");
/usr/bin/java -> /Library/Java/JavaVirtualMachines/jdk1.7.0_25.jdk/Contents/Home/bin/java
ls -l <whatever the /usr/bin/java symlink points to>
/usr/bin/java -> /System/Library/Frameworks/JavaVM.framework/Commands/java
/System/Library/Frameworks/JavaVM.framework/ OR /usr/libexec/java_home
i = Math.round(f); f = 2.0 -> i = 2 ; f = 2.22 -> i = 2 ; f = 2.68 -> i = 3 f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -3
i = (int) f; f = 2.0 -> i = 2 ; f = 2.22 -> i = 2 ; f = 2.68 -> i = 2 f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2
i = (int) Math.ceil(f); f = 2.0 -> i = 2 ; f = 2.22 -> i = 3 ; f = 2.68 -> i = 3 f = -2.0 -> i = -2 ; f = -2.22 -> i = -2 ; f = -2.68 -> i = -2 i = (int) Math.floor(f); f = 2.0 -> i = 2 ; f = 2.22 -> i = 2 ; f = 2.68 -> i = 2 f = -2.0 -> i = -2 ; f = -2.22 -> i = -3 ; f = -2.68 -> i = -3
1) b=(int)(Math.round(a)); 2) a=Math.round(a); b=(int)a;
class MyClass { static Map<Double, String> labels; static { labels = new HashMap<Double, String>(); labels.put(5.5, "five and a half"); labels.put(7.1, "seven point 1"); } }
class B { static { System.out.println("Welcome to Java"); System.exit(0); } }
log.finest("Lookup request from username=" + username + ", valueX=" + valueX + ", valueY=" + valueY));
log.log(Level.FINEST, "Lookup request from username={0}, valueX={1}, valueY={2}", new Object[]{username, valueX, valueY});
for (int i = 0; i < noOfExecutions; i++) { for (char x=32; x<88; x++) { String someString = Character.toString(x); } }
logger.log(Level.INFO, "Logging {0} and {1}", new Object[]{i, someString});
java.util.logging.SimpleFormatter.format="%4$s: %5$s [%1$tc]%n"
package log; import java.util.logging.Level; import java.util.logging.Logger; public class LogJUL { final static Logger logger = Logger.getLogger(LogJUL.class.getSimpleName()); public static void main(String[] args) { int N = 1024*1024; long l = System.currentTimeMillis(); for (int i = 0; i < N; i++) { Long lc = System.currentTimeMillis(); Object[] o = { lc }; logger.log(Level.INFO,"Epoch time {0}", o); } l = System.currentTimeMillis() - l; System.out.printf("time (ms) %d%n", l); } }
package log; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class LogSLF { static Logger logger = LoggerFactory.getLogger(LogSLF.class); public static void main(String[] args) { int N = 1024*1024; long l = System.currentTimeMillis(); for (int i = 0; i < N; i++) { Long lc = System.currentTimeMillis(); logger.info("Epoch time {}", lc); } l = System.currentTimeMillis() - l; System.out.printf("time (ms) %d%n", l); } }
final SharedPreferences prefs = new ObscuredSharedPreferences( this, this.getSharedPreferences(MY_PREFS_FILE_NAME, Context.MODE_PRIVATE) ); prefs.edit().putString("foo","bar").commit(); prefs.getString("foo", null);
/** * Warning, this gives a false sense of security. If an attacker has enough access to * acquire your password store, then he almost certainly has enough access to acquire your * source binary and figure out your encryption key. However, it will prevent casual * investigators from acquiring passwords, and thereby may prevent undesired negative * publicity. */ public class ObscuredSharedPreferences implements SharedPreferences { protected static final String UTF8 = "utf-8"; private static final char[] SEKRIT = ... ; protected SharedPreferences delegate; protected Context context; public ObscuredSharedPreferences(Context context, SharedPreferences delegate) { this.delegate = delegate; this.context = context; } public class Editor implements SharedPreferences.Editor { protected SharedPreferences.Editor delegate; public Editor() { this.delegate = ObscuredSharedPreferences.this.delegate.edit(); } @Override public Editor putBoolean(String key, boolean value) { delegate.putString(key, encrypt(Boolean.toString(value))); return this; } @Override public Editor putFloat(String key, float value) { delegate.putString(key, encrypt(Float.toString(value))); return this; } @Override public Editor putInt(String key, int value) { delegate.putString(key, encrypt(Integer.toString(value))); return this; } @Override public Editor putLong(String key, long value) { delegate.putString(key, encrypt(Long.toString(value))); return this; } @Override public Editor putString(String key, String value) { delegate.putString(key, encrypt(value)); return this; } @Override public void apply() { delegate.apply(); } @Override public Editor clear() { delegate.clear(); return this; } @Override public boolean commit() { return delegate.commit(); } @Override public Editor remove(String s) { delegate.remove(s); return this; } } public Editor edit() { return new Editor(); } @Override public Map<String, ?> getAll() { throw new UnsupportedOperationException(); } @Override public boolean getBoolean(String key, boolean defValue) { final String v = delegate.getString(key, null); return v!=null ? Boolean.parseBoolean(decrypt(v)) : defValue; } @Override public float getFloat(String key, float defValue) { final String v = delegate.getString(key, null); return v!=null ? Float.parseFloat(decrypt(v)) : defValue; } @Override public int getInt(String key, int defValue) { final String v = delegate.getString(key, null); return v!=null ? Integer.parseInt(decrypt(v)) : defValue; } @Override public long getLong(String key, long defValue) { final String v = delegate.getString(key, null); return v!=null ? Long.parseLong(decrypt(v)) : defValue; } @Override public String getString(String key, String defValue) { final String v = delegate.getString(key, null); return v != null ? decrypt(v) : defValue; } @Override public boolean contains(String s) { return delegate.contains(s); } @Override public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) { delegate.registerOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener); } @Override public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) { delegate.unregisterOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener); } protected String encrypt( String value ) { try { final byte[] bytes = value!=null ? value.getBytes(UTF8) : new byte[0]; SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBEWithMD5AndDES"); SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT)); Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES"); pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.Secure.ANDROID_ID).getBytes(UTF8), 20)); return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),UTF8); } catch( Exception e ) { throw new RuntimeException(e); } } protected String decrypt(String value){ try { final byte[] bytes = value!=null ? Base64.decode(value,Base64.DEFAULT) : new byte[0]; SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBEWithMD5AndDES"); SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT)); Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES"); pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.Secure.ANDROID_ID).getBytes(UTF8), 20)); return new String(pbeCipher.doFinal(bytes),UTF8); } catch( Exception e) { throw new RuntimeException(e); } } }
Editor e = this.getPreferences(Context.MODE_PRIVATE).edit(); e.putString("password", mPassword); e.commit();
public boolean onPreferenceChange(Preference preference, Object newValue) { SharedPreferences secure = context.getSharedPreferences( "SECURE", Context.MODE_PRIVATE ); String encryptedText = null; try { encryptedText = SimpleCrypto.encrypt(Preferences.SEED,(String)newValue); Editor editor = secure.getEditor(); editor.putString("encryptedPassword",encryptedText); editor.commit(); } catch (Exception e) { e.printStackTrace(); } return false; }
String key = "myInt"; int valueToSave = 10; SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(context); SharedPreferences.Editor editor = sharedPref.edit(); editor.putInt(key, valueToSave).commit();
String key = "myInt"; int defaultValue = 0; SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(context); int savedValue = sharedPref.getInt(key, defaultValue);
package com.Merlinia.OutBack_Client; import android.content.Context; import android.preference.EditTextPreference; import android.util.AttributeSet; import android.util.Base64; import com.Merlinia.MEncryption_Main.MEncryptionUserPassword; /** * This class extends the EditTextPreference view, providing encryption and decryption services for * OutBack user passwords. The passwords in the preferences store are first encrypted using the * MEncryption classes and then converted to string using Base64 since the preferences store can not * store byte arrays. * * This is largely copied from this article, except for the encryption/decryption parts: * https: */ public class EditPasswordPreference extends EditTextPreference { public EditPasswordPreference(Context context) { super(context); } public EditPasswordPreference(Context context, AttributeSet attributeSet) { super(context, attributeSet); } public EditPasswordPreference(Context context, AttributeSet attributeSet, int defaultStyle) { super(context, attributeSet, defaultStyle); } /** * Override the method that gets a preference from the preferences storage, for display by the * EditText view. This gets the base64 password, converts it to a byte array, and then decrypts * it so it can be displayed in plain text. * @return OutBack user password in plain text */ @Override public String getText() { String decryptedPassword; try { decryptedPassword = MEncryptionUserPassword.aesDecrypt( Base64.decode(getSharedPreferences().getString(getKey(), ""), Base64.DEFAULT)); } catch (Exception e) { e.printStackTrace(); decryptedPassword = ""; } return decryptedPassword; } /** * Override the method that gets a text string from the EditText view and stores the value in * the preferences storage. This encrypts the password into a byte array and then encodes that * in base64 format. * @param passwordText OutBack user password in plain text */ @Override public void setText(String passwordText) { byte[] encryptedPassword; try { encryptedPassword = MEncryptionUserPassword.aesEncrypt(passwordText); } catch (Exception e) { e.printStackTrace(); encryptedPassword = new byte[0]; } getSharedPreferences().edit().putString(getKey(), Base64.encodeToString(encryptedPassword, Base64.DEFAULT)) .commit(); } @Override protected void onSetInitialValue(boolean restoreValue, Object defaultValue) { if (restoreValue) getEditText().setText(getText()); else super.onSetInitialValue(restoreValue, defaultValue); } }
<PreferenceScreen xmlns:android="http: <EditTextPreference android:key="@string/useraccountname_key" android:title="@string/useraccountname_title" android:summary="@string/useraccountname_summary" android:defaultValue="@string/useraccountname_default" /> <com.Merlinia.OutBack_Client.EditPasswordPreference android:key="@string/useraccountpassword_key" android:title="@string/useraccountpassword_title" android:summary="@string/useraccountpassword_summary" android:defaultValue="@string/useraccountpassword_default" /> <EditTextPreference android:key="@string/outbackserverip_key" android:title="@string/outbackserverip_title" android:summary="@string/outbackserverip_summary" android:defaultValue="@string/outbackserverip_default" /> <EditTextPreference android:key="@string/outbackserverport_key" android:title="@string/outbackserverport_title" android:summary="@string/outbackserverport_summary" android:defaultValue="@string/outbackserverport_default" /> </PreferenceScreen>
1/3 + 2/3 + 2/3 = (0.3333 + 0.6667) + 0.6667 = 1.000 + 0.6667 (no rounding needed!) = 1.667 (where 1.6667 is rounded to 1.667) 2/3 + 2/3 + 1/3 = (0.6667 + 0.6667) + 0.3333 = 1.333 + 0.3333 (where 1.3334 is rounded to 1.333) = 1.666 (where 1.6663 is rounded to 1.666)
10000 + 1 - 10000 = (10000 + 1) - 10000 = 10000 - 10000 (where 10001 is rounded to 10000) = 0 10000 - 10000 + 1 = (10000 - 10000) + 1 = 0 + 1 = 1
public class Main{ public static void main(String args[]) { double x = 23.53; double y = 5.88; double z = 17.64; double s = 47.05; printValueAndInHex(x); printValueAndInHex(y); printValueAndInHex(z); printValueAndInHex(s); System.out.println("--------"); double t1 = x + y; printValueAndInHex(t1); t1 = t1 + z; printValueAndInHex(t1); System.out.println("--------"); double t2 = x + z; printValueAndInHex(t2); t2 = t2 + y; printValueAndInHex(t2); } private static void printValueAndInHex(double d) { System.out.println(Long.toHexString(Double.doubleToLongBits(d)) + ": " + d); } }
403787ae147ae148: 23.53 4017851eb851eb85: 5.88 4031a3d70a3d70a4: 17.64 4047866666666666: 47.05 -------- 403d68f5c28f5c29: 29.41 4047866666666666: 47.05 -------- 404495c28f5c28f6: 41.17 4047866666666667: 47.050000000000004
sign|exponent 403 => 0|100 0000 0011| => 1027 - 1023 = 4 401 => 0|100 0000 0001| => 1025 - 1023 = 2 403 => 0|100 0000 0011| => 1027 - 1023 = 4 404 => 0|100 0000 0100| => 1028 - 1023 = 5
protected void finalize() throws Throwable { try { close(); } finally { super.finalize(); } }
MyClass myObj; try { myObj = new MyClass(); } finally { if (null != myObj) { myObj.cleanup(); } }
Foo foo = new Foo(...); try { ... } finally { foo.terminate(); }
class Car { int maxspeed; Car() { maxspeed = 70; } protected void finalize() { System.out.println("Called finalize method in class Car..."); } } class Bike { int maxspeed; Bike() { maxspeed = 50; } protected void finalize() { System.out.println("Called finalize method in class Bike..."); } } class Example { public static void main(String args[]) { Car c = new Car(); c = null; Bike b = new Bike(); System.gc(); for (b.maxspeed = 1; b.maxspeed <= 70; b.maxspeed++) { System.out.print("\t" + b.maxspeed); if (b.maxspeed > 50) { System.out.println("Over Speed. Pls slow down."); } } } }
Called finalize method in class Car... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51Over Speed. Pls slow down. 52Over Speed. Pls slow down. 53Over Speed. Pls slow down. 54Over Speed. Pls slow down. 55Over Speed. Pls slow down. 56Over Speed. Pls slow down. 57Over Speed. Pls slow down. 58Over Speed. Pls slow down. 59Over Speed. Pls slow down. 60Over Speed. Pls slow down. 61Over Speed. Pls slow down. 62Over Speed. Pls slow down. 63Over Speed. Pls slow down. 64Over Speed. Pls slow down. 65Over Speed. Pls slow down. 66Over Speed. Pls slow down. 67Over Speed. Pls slow down. 68Over Speed. Pls slow down. 69Over Speed. Pls slow down. 70Over Speed. Pls slow down.
protected void finalize() throws Throwable { System.out.println("Run F" ); if ( checkedOut) System.out.println("Error: Checked out"); System.out.println("Class Create Count: " + classCreate); }
while ( true) { Book novel=new Book(true); novel.checkIn(); new Book(true); System.gc();
C:\javaCode\firstClass>java TerminationCondition Run F Error: Checked out Class Create Count: 36 Run F Error: Checked out Class Create Count: 48 Run F
public class TestClass { public TestClass() { System.out.println("constructor"); } public void display() { System.out.println("display"); } @Override public void finalize() { System.out.println("destructor"); } }
public class TestGarbageCollection { public static void main(String[] args) { while (true) { TestClass s = new TestClass(); s.display(); System.gc(); } } }
public class FinalizeTest { static { System.out.println(Runtime.getRuntime().freeMemory()); } public void run() { System.out.println("run"); System.out.println(Runtime.getRuntime().freeMemory()); } protected void finalize() throws Throwable { System.out.println("finalize"); while(true) break; } public static void main(String[] args) { for (int i = 0 ; i < 500000 ; i++ ) { new FinalizeTest().run(); } } }
class Me { private static final ObjectMapper mapper = new ObjectMapper(); }
class Me { private final ObjectMapper mapper = new ObjectMapper(); }
private static final ThreadLocal<ObjectMapper> om = new ThreadLocal<ObjectMapper>() { @Override protected ObjectMapper initialValue() { ObjectMapper objectMapper = new ObjectMapper(); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); return objectMapper; } }; public static ObjectMapper getObjectMapper() { return om.get(); }
com.fasterxml.jackson.databind.type.TypeFactory._findSuperInterfaceChain(Type, Class) com.fasterxml.jackson.databind.type.TypeFactory._findSuperTypeChain(Class, Class) com.fasterxml.jackson.databind.type.TypeFactory.findTypeParameters(Class, Class, TypeBindings) com.fasterxml.jackson.databind.type.TypeFactory.findTypeParameters(JavaType, Class) com.fasterxml.jackson.databind.type.TypeFactory._fromParamType(ParameterizedType, TypeBindings) com.fasterxml.jackson.databind.type.TypeFactory._constructType(Type, TypeBindings) com.fasterxml.jackson.databind.type.TypeFactory.constructType(TypeReference) com.fasterxml.jackson.databind.ObjectMapper.convertValue(Object, TypeReference)
buildscript { >>> ext.kotlin_version = repositories { google() jcenter() } dependencies { classpath >>> classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version" } } ...
apply plugin: >>> apply plugin: dependencies { implementation fileTree(dir: >>> implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version" >>> runtimeClasspath files(compileKotlin.destinationDir) } ...
object Main { ... @JvmStatic fun main(args: Array<String>) { } ... }
int boolToInt(Boolean b) { return b.compareTo(false); }
int boolToInt(boolean b) { return Boolean.compare(b, false); }
boolean b = ....; int i = -("false".indexOf("" + b));
public int boolToInt(boolean b) { return b ? 1 : 0; }
import org.apache.commons.lang3.BooleanUtils; boolean x = true; int y= BooleanUtils.toInteger(x);
if (something) { otherThing = 1; } else { otherThing = 0; }
Process process = Process.SYNCHRONOUS; System.out.println(process.getCode());
public enum Process { SYNCHRONOUS (0), ASYNCHRONOUS (1); private int code; private Process (int code) { this.code = code; } public int getCode() { return code; } }
int myInt = BooleanUtils.toInteger(boolean_expression);
System.out.println( 1 & Boolean.hashCode( true ) >> 1 ); System.out.println( 1 & Boolean.hashCode( false ) >> 1 );
public int valueOf(Boolean flag) { return Boolean.compare(flag, Boolean.TRUE) + 1; }
public static int convBool(boolean b) { int convBool = 0; if(b) convBool = 1; return convBool; }
package com.stackoverflow.q3732109; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; public class Test { public static void main(String[] args) throws Exception { HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext("/test", new MyHandler()); server.setExecutor(null); server.start(); } static class MyHandler implements HttpHandler { @Override public void handle(HttpExchange t) throws IOException { String response = "This is the response"; t.sendResponseHeaders(200, response.length()); OutputStream os = t.getResponseBody(); os.write(response.getBytes()); os.close(); } } }
import java.io._ import javax.xml.ws._ import javax.xml.ws.http._ import javax.xml.transform._ import javax.xml.transform.stream._ @WebServiceProvider @ServiceMode(value=Service.Mode.PAYLOAD) class P extends Provider[Source] { def invoke(source: Source) = new StreamSource( new StringReader("<p>Hello There!</p>")); } val address = "http: Endpoint.create(HTTPBinding.HTTP_BINDING, new P()).publish(address) println("Service running at "+address) println("Type [CTRL]+[C] to quit!") Thread.sleep(Long.MaxValue)
import java.io.*; import javax.xml.ws.*; import javax.xml.ws.http.*; import javax.xml.transform.*; import javax.xml.transform.stream.*; @WebServiceProvider @ServiceMode(value = Service.Mode.PAYLOAD) public class Server implements Provider<Source> { public Source invoke(Source request) { return new StreamSource(new StringReader("<p>Hello There!</p>")); } public static void main(String[] args) throws InterruptedException { String address = "http: Endpoint.create(HTTPBinding.HTTP_BINDING, new Server()).publish(address); System.out.println("Service running at " + address); System.out.println("Type [CTRL]+[C] to quit!"); Thread.sleep(Long.MAX_VALUE); } }
import java.io.*; import java.lang.reflect.*; import java.net.InetSocketAddress; import java.util.*; import javax.servlet.*; import javax.servlet.http.*; import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; @SuppressWarnings("deprecation") public class VerySimpleServletHttpServer { HttpServer server; private String contextPath; private HttpHandler httpHandler; public VerySimpleServletHttpServer(String contextPath, HttpServlet servlet) { this.contextPath = contextPath; httpHandler = new HttpHandlerWithServletSupport(servlet); } public void start(int port) throws IOException { InetSocketAddress inetSocketAddress = new InetSocketAddress(port); server = HttpServer.create(inetSocketAddress, 0); server.createContext(contextPath, httpHandler); server.setExecutor(null); server.start(); } public void stop(int secondsDelay) { server.stop(secondsDelay); } public int getServerPort() { return server.getAddress().getPort(); } } final class HttpHandlerWithServletSupport implements HttpHandler { private HttpServlet servlet; private final class RequestWrapper extends HttpServletRequestWrapper { private final HttpExchange ex; private final Map<String, String[]> postData; private final ServletInputStream is; private final Map<String, Object> attributes = new HashMap<>(); private RequestWrapper(HttpServletRequest request, HttpExchange ex, Map<String, String[]> postData, ServletInputStream is) { super(request); this.ex = ex; this.postData = postData; this.is = is; } @Override public String getHeader(String name) { return ex.getRequestHeaders().getFirst(name); } @Override public Enumeration<String> getHeaders(String name) { return new Vector<String>(ex.getRequestHeaders().get(name)).elements(); } @Override public Enumeration<String> getHeaderNames() { return new Vector<String>(ex.getRequestHeaders().keySet()).elements(); } @Override public Object getAttribute(String name) { return attributes.get(name); } @Override public void setAttribute(String name, Object o) { this.attributes.put(name, o); } @Override public Enumeration<String> getAttributeNames() { return new Vector<String>(attributes.keySet()).elements(); } @Override public String getMethod() { return ex.getRequestMethod(); } @Override public ServletInputStream getInputStream() throws IOException { return is; } @Override public BufferedReader getReader() throws IOException { return new BufferedReader(new InputStreamReader(getInputStream())); } @Override public String getPathInfo() { return ex.getRequestURI().getPath(); } @Override public String getParameter(String name) { String[] arr = postData.get(name); return arr != null ? (arr.length > 1 ? Arrays.toString(arr) : arr[0]) : null; } @Override public Map<String, String[]> getParameterMap() { return postData; } @Override public Enumeration<String> getParameterNames() { return new Vector<String>(postData.keySet()).elements(); } } private final class ResponseWrapper extends HttpServletResponseWrapper { final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); final ServletOutputStream servletOutputStream = new ServletOutputStream() { @Override public void write(int b) throws IOException { outputStream.write(b); } }; private final HttpExchange ex; private final PrintWriter printWriter; private int status = HttpServletResponse.SC_OK; private ResponseWrapper(HttpServletResponse response, HttpExchange ex) { super(response); this.ex = ex; printWriter = new PrintWriter(servletOutputStream); } @Override public void setContentType(String type) { ex.getResponseHeaders().add("Content-Type", type); } @Override public void setHeader(String name, String value) { ex.getResponseHeaders().add(name, value); } @Override public javax.servlet.ServletOutputStream getOutputStream() throws IOException { return servletOutputStream; } @Override public void setContentLength(int len) { ex.getResponseHeaders().add("Content-Length", len + ""); } @Override public void setStatus(int status) { this.status = status; } @Override public void sendError(int sc, String msg) throws IOException { this.status = sc; if (msg != null) { printWriter.write(msg); } } @Override public void sendError(int sc) throws IOException { sendError(sc, null); } @Override public PrintWriter getWriter() throws IOException { return printWriter; } public void complete() throws IOException { try { printWriter.flush(); ex.sendResponseHeaders(status, outputStream.size()); if (outputStream.size() > 0) { ex.getResponseBody().write(outputStream.toByteArray()); } ex.getResponseBody().flush(); } catch (Exception e) { e.printStackTrace(); } finally { ex.close(); } } } public HttpHandlerWithServletSupport(HttpServlet servlet) { this.servlet = servlet; } @SuppressWarnings("deprecation") @Override public void handle(final HttpExchange ex) throws IOException { byte[] inBytes = getBytes(ex.getRequestBody()); ex.getRequestBody().close(); final ByteArrayInputStream newInput = new ByteArrayInputStream(inBytes); final ServletInputStream is = new ServletInputStream() { @Override public int read() throws IOException { return newInput.read(); } }; Map<String, String[]> parsePostData = new HashMap<>(); try { parsePostData.putAll(HttpUtils.parseQueryString(ex.getRequestURI().getQuery())); parsePostData.putAll(HttpUtils.parsePostData(inBytes.length, is)); } catch (IllegalArgumentException e) { newInput.reset(); } final Map<String, String[]> postData = parsePostData; RequestWrapper req = new RequestWrapper(createUnimplementAdapter(HttpServletRequest.class), ex, postData, is); ResponseWrapper resp = new ResponseWrapper(createUnimplementAdapter(HttpServletResponse.class), ex); try { servlet.service(req, resp); resp.complete(); } catch (ServletException e) { throw new IOException(e); } } private static byte[] getBytes(InputStream in) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; while (true) { int r = in.read(buffer); if (r == -1) break; out.write(buffer, 0, r); } return out.toByteArray(); } @SuppressWarnings("unchecked") private static <T> T createUnimplementAdapter(Class<T> httpServletApi) { class UnimplementedHandler implements InvocationHandler { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { throw new UnsupportedOperationException("Not implemented: " + method + ", args=" + Arrays.toString(args)); } } return (T) Proxy.newProxyInstance(UnimplementedHandler.class.getClassLoader(), new Class<?>[] { httpServletApi }, new UnimplementedHandler()); } }
package jetty; import java.util.logging.Level; import java.util.logging.Logger; import org.mortbay.http.SocketListener; import org.mortbay.jetty.Server; import org.mortbay.jetty.servlet.ServletHttpContext; public class Jetty { public static void main(String[] args) { try { Server server = new Server(); SocketListener listener = new SocketListener(); System.out.println("Max Thread :" + listener.getMaxThreads() + " Min Thread :" + listener.getMinThreads()); listener.setHost("localhost"); listener.setPort(8070); listener.setMinThreads(5); listener.setMaxThreads(250); server.addListener(listener); ServletHttpContext context = (ServletHttpContext) server.getContext("/"); context.addServlet("/MO", "jetty.HelloWorldServlet"); server.start(); server.join(); /* Server server = new Server(); server.addListener(":8070"); ServletHttpContext context = (ServletHttpContext) server.getContext("/"); context.addServlet("/MO", "jetty.HelloWorldServlet"); server.start(); */ } catch (Exception ex) { Logger.getLogger(Jetty.class.getName()).log(Level.SEVERE, null, ex); } } }
package jetty; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloWorldServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException { String appid = httpServletRequest.getParameter("appid"); String conta = httpServletRequest.getParameter("conta"); System.out.println("Appid : "+appid); System.out.println("Conta : "+conta); httpServletResponse.setContentType("text/plain"); PrintWriter out = httpServletResponse.getWriter(); out.println("Hello World!"); out.close(); } }
server.setExecutor(java.util.concurrent.Executors.newCachedThreadPool());
import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; public class App { public static void main(String[] args) throws Exception { HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext("/test", new MyHandler()); server.setExecutor(java.util.concurrent.Executors.newCachedThreadPool()); server.start(); } static class MyHandler implements HttpHandler { @Override public void handle(HttpExchange t) throws IOException { String response = "This is the response"; long threadId = Thread.currentThread().getId(); System.out.println("I am thread " + threadId ); response = response + "Thread Id = "+threadId; t.sendResponseHeaders(200, response.length()); OutputStream os = t.getResponseBody(); os.write(response.getBytes()); os.close(); } } }
File baseDirectory = new File("foo"); File subDirectory = new File(baseDirectory, "bar"); File fileInDirectory = new File(subDirectory, "baz.txt");
public static String combine(String path1, String path2) { File file1 = new File(path1); File file2 = new File(file1, path2); return file2.getPath(); }
Path.combine("/Users/beardtwizzle/"); Path.combine("/", "Users", "beardtwizzle"); Path.combine(new String[] { "/", "Users", "beardtwizzle", "arrayUsage" });
public class Path { public static String combine(String... paths) { File file = new File(paths[0]); for (int i = 1; i < paths.length ; i++) { file = new File(file, paths[i]); } return file.getPath(); } }
assert org.apache.commons.io.FilenameUtils.concat("/home/bob", "work\\stuff.log") == "/home/bob/work/stuff.log"
java.nio.file.Paths.get(".", "path", "to", "file.txt") java.nio.file.Paths.get("/", "path", "to", "file.txt") java.nio.file.Paths.get("C:", "path", "to", "file.txt")
public static String combinePaths(String ... paths) { if ( paths.length == 0) { return ""; } File combined = new File(paths[0]); int i = 1; while ( i < paths.length) { combined = new File(combined, paths[i]); ++i; } return combined.getPath(); }
<style name="Theme.App.Base" parent="Theme.AppCompat.Light.DarkActionBar"> <item name="android:editTextStyle">@style/Widget.App.EditText</item> </style> <style name="Widget.App.EditText" parent="Widget.AppCompat.EditText"> ??? </style>
<style name="Theme.App.Base" parent="Theme.AppCompat.Light.DarkActionBar"> <item name="colorControlNormal"> <item name="colorControlActivated">@color/accent</item> <item name="colorControlHighlight">@color/accent</item> </style>
editText.getBackground().mutate().setColorFilter(getResources().getColor(R.color.your_color), PorterDuff.Mode.SRC_ATOP);
<style name="MyEditTextTheme"> <!-- Used for the bottom line when not selected / focused --> <item name="colorControlNormal"> <!-- colorControlActivated & colorControlHighlight use the colorAccent color by default --> </style>
<EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/MyEditTextTheme"/>
Drawable drawable = yourEditText.getBackground(); drawable.setColorFilter(Color.GREEN, PorterDuff.Mode.SRC_ATOP); if(Build.VERSION.SDK_INT > 16) { yourEditText.setBackground(drawable); }else{ yourEditText.setBackgroundDrawable(drawable); }
<style name="AppTheme.Base" parent="Theme.AppCompat.Light.NoActionBar"> <item name="colorAccent">@color/colorAccent</item> <item name="android:editTextStyle">@style/EditTextStyle</item> </style> <style name="EditTextStyle" parent="Widget.AppCompat.EditText"/>
public static void tintWidget(View view, int color) { Drawable wrappedDrawable = DrawableCompat.wrap(view.getBackground()); DrawableCompat.setTint(wrappedDrawable.mutate(), getResources().getColor(color)); view.setBackgroundDrawable(wrappedDrawable); }
<!-- Base application theme. --> <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"> <!-- Customize your theme here. --> <item name="colorPrimary">@color/colorPrimary</item> <item name="colorPrimaryDark">@color/colorPrimaryDark</item> <item name="colorAccent">@color/colorAccent</item> <item name="colorControlNormal">@color/colorAccent</item> <item name="colorControlActivated">@color/colorAccent</item> <item name="colorControlHighlight">@color/colorAccent</item> </style>
private void updateEditTextBackground() { ensureBackgroundDrawableStateWorkaround(); final Drawable editTextBackground = mEditText.getBackground(); if (editTextBackground == null) { return; } if (mErrorShown && mErrorView != null) { editTextBackground.setColorFilter( AppCompatDrawableManager.getPorterDuffColorFilter( mErrorView.getCurrentTextColor(), PorterDuff.Mode.SRC_IN)); } ... }
/** * Set backgroundTint to {@link View} across all targeting platform level. * @param view the {@link View} to tint. * @param color color used to tint. */ public static void tintView(View view, int color) { final Drawable d = view.getBackground(); final Drawable nd = d.getConstantState().newDrawable(); nd.setColorFilter(AppCompatDrawableManager.getPorterDuffColorFilter( color, PorterDuff.Mode.SRC_IN)); view.setBackground(nd); }
<EditText android:background="@android:color/transparent"/>
<layer-list xmlns:android="http: <item android:top="-1dp" android:left="-1dp" android:right="-1dp" android:bottom="1dp" > <shape android:shape="rectangle"> <stroke android:width="1dp" android:color=" </shape> </item> </layer-list>
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"> <!-- Customize your theme here. --> <item name="colorControlNormal">@color/yellow</item> <item name="colorAccent">@color/yellow</item> </style>
<?xml version="1.0" encoding="utf-8"?> <resources> <color name="yellow"> </resources>
android:backgroundTint="@color/blue" android:backgroundTint=" android:backgroundTint="@color/red" <EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:backgroundTint="
public void changeBottomColorSearchView(int color) { int searchPlateId = mSearchView.getContext().getResources().getIdentifier("android:id/search_plate", null, null); View searchPlate = mSearchView.findViewById(searchPlateId); searchPlate.getBackground().setColorFilter(color, PorterDuff.Mode.SRC_IN); }
<item name="android:editTextStyle">@android:style/Widget.EditText</item> <item name="editTextStyle">@android:style/Widget.EditText</item>
import android.content.Context; import android.graphics.PorterDuff; import android.graphics.drawable.Drawable; import android.support.v4.content.ContextCompat; import android.support.v7.widget.AppCompatDrawableManager; import android.support.v7.widget.AppCompatEditText; import android.util.AttributeSet; import com.newco.cooltv.R; public class RqubeErrorEditText extends AppCompatEditText { private int errorUnderlineColor; private boolean isErrorStateEnabled; private boolean mHasReconstructedEditTextBackground; public RqubeErrorEditText(Context context) { super(context); initColors(); } public RqubeErrorEditText(Context context, AttributeSet attrs) { super(context, attrs); initColors(); } public RqubeErrorEditText(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initColors(); } private void initColors() { errorUnderlineColor = R.color.et_error_color_rule; } public void setErrorColor() { ensureBackgroundDrawableStateWorkaround(); getBackground().setColorFilter(AppCompatDrawableManager.getPorterDuffColorFilter( ContextCompat.getColor(getContext(), errorUnderlineColor), PorterDuff.Mode.SRC_IN)); } private void ensureBackgroundDrawableStateWorkaround() { final Drawable bg = getBackground(); if (bg == null) { return; } if (!mHasReconstructedEditTextBackground) { final Drawable newBg = bg.getConstantState().newDrawable(); if (!mHasReconstructedEditTextBackground) { setBackgroundDrawable(newBg); mHasReconstructedEditTextBackground = true; } } } public boolean isErrorStateEnabled() { return isErrorStateEnabled; } public void setErrorState(boolean isErrorStateEnabled) { this.isErrorStateEnabled = isErrorStateEnabled; if (isErrorStateEnabled) { setErrorColor(); invalidate(); } else { getBackground().mutate().clearColorFilter(); invalidate(); } } }
<com.rqube.ui.widget.RqubeErrorEditText android:id="@+id/f_signup_et_referral_code" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentTop="true" android:layout_toEndOf="@+id/referral_iv" android:layout_toRightOf="@+id/referral_iv" android:ems="10" android:hint="@string/lbl_referral_code" android:imeOptions="actionNext" android:inputType="textEmailAddress" android:textSize="@dimen/text_size_sp_16" android:theme="@style/EditTextStyle"/>
<style name="EditTextStyle" parent="android:Widget.EditText"> <item name="android:textColor">@color/txt_color_change</item> <item name="android:textColorHint">@color/et_default_color_text</item> <item name="colorControlNormal">@color/et_default_color_rule</item> <item name="colorControlActivated">@color/et_engagged_color_rule</item> </style>
myRqubeEditText.setErrorState(true); myRqubeEditText.setErrorState(false);
<EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="textPersonName" android:ems="10" android:id="@+id/editText" android:hint="Informe o usurio" android:backgroundTint="@android:color/transparent"/>
public class EditText extends android.widget.EditText { public EditText(Context context) { super(context); init(); } public EditText(Context context, AttributeSet attrs) { super(context, attrs); init(); } public EditText(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } private void init() { getBackground().mutate().setColorFilter(ContextCompat.getColor(getContext(), R.color.colorAccent), PorterDuff.Mode.SRC_ATOP); } }
<company.com.app.EditText android:layout_width="200dp" android:layout_height="wrap_content"/>
int[][] states = new int[][] { new int[] { android.R.attr.state_enabled}, new int[] {-android.R.attr.state_enabled}, new int[] {-android.R.attr.state_checked}, new int[] { android.R.attr.state_pressed} }; int[] colors = new int[] { Color.BLACK, Color.RED, Color.GREEN, Color.BLUE }; ColorStateList colorStateList = new ColorStateList(states, colors);
private boolean validateMobilenumber() { if (mobilenumber.getText().toString().trim().isEmpty() || mobilenumber.getText().toString().length() < 10) { input_layout_mobilenumber.setErrorEnabled(true); input_layout_mobilenumber.setError(getString(R.string.err_msg_mobilenumber)); return false; } else { input_layout_mobilenumber.setError(null); input_layout_mobilenumber.setErrorEnabled(false); mobilenumber.setBackground(mobilenumber.getBackground().getConstantState().newDrawable()); }
!SESSION 2012-04-15 21:05:46.902 ----------------------------------------------- eclipse.buildId=I20110613-1736 java.version=1.7.0 java.vendor=Oracle Corporation BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_GB Command-line arguments: -os linux -ws gtk -arch x86_64 !ENTRY org.eclipse.osgi 4 0 2012-04-15 21:05:47.885 !MESSAGE Application error !STACK 1 java.lang.UnsatisfiedLinkError: Could not load SWT library. Reasons: no swt-gtk-3740 in java.library.path no swt-gtk in java.library.path Can Can at org.eclipse.swt.internal.Library.loadLibrary(Library.java:285) at org.eclipse.swt.internal.Library.loadLibrary(Library.java:194) at org.eclipse.swt.internal.C.<clinit>(C.java:21) at org.eclipse.swt.internal.Converter.wcsToMbcs(Converter.java:63) at org.eclipse.swt.internal.Converter.wcsToMbcs(Converter.java:54) at org.eclipse.swt.widgets.Display.<clinit>(Display.java:132) at org.eclipse.ui.internal.Workbench.createDisplay(Workbench.java:695) at org.eclipse.ui.PlatformUI.createDisplay(PlatformUI.java:161) at org.eclipse.ui.internal.ide.application.IDEApplication.createDisplay(IDEApplication.java:153) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:95) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577) at org.eclipse.equinox.launcher.Main.run(Main.java:1410) at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
ln -s /usr/lib/jni/libswt-* ~/.swt/lib/linux/x86_64/
echo "-Djava.library.path=/usr/lib/jni/" >> /etc/eclipse.ini
sudo apt-get install libswt-gtk-3-jni libswt-gtk-3-java
ln -s /usr/lib/jni/libswt-* ~/.swt/lib/linux/x86_64/
env LD_LIBRARY_PATH=/usr/lib/jni/:/usr/lib/x86_64-linux-gnu/jni/:$LD_LIBRARY_PATH eclipse
public class OutterClass { int numberLength; class PhoneNumber { PhoneNumber(String phoneNumber) { numberLength = 7; String currentNumber = phoneNumber.replaceAll( regularExpression, ""); if (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber; else formattedPhoneNumber = null; } ... } ... }
@FunctionalInterface interface IFuncInt { int func(int num1, int num2); public String toString(); } public class LambdaVarDemo { public static void main(String[] args){ int i = 7; IFuncInt funcInt = (num1, num2) -> { i = num1 + num2; return i; }; } }
public class LambdaScopeTest { public int x = 0; class FirstLevel { public int x = 1; void methodInFirstLevel(int x) { // } } }
class EffectivelyFinal { public static void main(String[] args) { calculate(124,53); } public static void calculate( int operand1, int operand2){ int rem = 0; rem = operand1%2 class operators{ void setNum(){ operand1 = operand2%2; } int add(){ return rem + operand2; } int multiply(){ return rem * operand1; } } } }
public static void main(String[] args) { final boolean i = true; boolean j = true; if (i) { System.out.println(i); } if (!i) { System.out.println(i); } if (j) { System.out.println(j); } if (!j) { System.out.println(j); } }
public static void main(java.lang.String[]); Code: 0: iconst_1 1: istore_1 2: iconst_1 3: istore_2 4: getstatic 7: iconst_1 8: invokevirtual 11: iload_2 12: ifeq 22 15: getstatic 18: iload_2 19: invokevirtual 22: iload_2 23: ifne 33 26: getstatic 29: iload_2 30: invokevirtual 33: return
LineNumberTable: line 6: 0 line 7: 2 line 10: 4 line 15: 11 line 16: 15 line 18: 22 line 19: 26 line 21: 33
String str = ""; final String strFin = ""; button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String ann = str; String ann = strFin; String str = "legal statement on java 7," +"Java 8 doesn } );
int[] ints = {1, 2, 3}; List<Integer> intList = new ArrayList<Integer>(); for (int i : ints) { intList.add(i); }
int[] ints = {1,2,3}; List<Integer> list = Arrays.stream(ints).boxed().collect(Collectors.toList());
int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; List lst = Arrays.asList(arr); System.out.println(lst.size());
List<Integer> lst = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
String str[] = { "Homer", "Marge", "Bart", "Lisa", "Maggie" }; List<String> lst = Arrays.asList(str);
public List<Integer> asList(final int[] is) { return new AbstractList<Integer>() { public Integer get(int i) { return is[i]; } public int size() { return is.length; } }; }
public List<Integer> myWork(int[] array) { return Arrays.asList(ArrayUtils.toObject(array)); }
int[] ints = {1, 2, 3}; List<Integer> list = new ArrayList<Integer>(); Collections.addAll(list, Arrays.stream(ints).boxed().toArray(Integer[]::new));
List<Integer> list = Arrays.stream(ints).boxed().collect(Collectors.toList());
int[] arr = {1,2,3}; IntStream.of(arr).boxed().collect(Collectors.toList());
class PrimitiveWrapper<T> extends AbstractList<T> { private final T[] data; private PrimitiveWrapper(T[] data) { this.data = data; } public static <T> List<T> ofIntegers(int... data) { return new PrimitiveWrapper(toBoxedArray(Integer.class, data)); } public static <T> List<T> ofCharacters(char... data) { return new PrimitiveWrapper(toBoxedArray(Character.class, data)); } public static <T> List<T> ofDoubles(double... data) { return new PrimitiveWrapper(toBoxedArray(Double.class, data)); } private static <T> T[] toBoxedArray(Class<T> boxClass, Object components) { final int length = Array.getLength(components); Object res = Array.newInstance(boxClass, length); for (int i = 0; i < length; i++) { Array.set(res, i, Array.get(components, i)); } return (T[]) res; } @Override public T get(int index) { return data[index]; } @Override public int size() { return data.length; } }
List<Integer> ints = PrimitiveWrapper.ofIntegers(10, 20); List<Double> doubles = PrimitiveWrapper.ofDoubles(10, 20);
** * Integer modifiable fix length list of an int array or many int * * @author Daniel De Leon. */ public class IntegerListWrap extends AbstractList<Integer> { int[] data; public IntegerListWrap(int... data) { this.data = data; } @Override public Integer get(int index) { return data[index]; } @Override public Integer set(int index, Integer element) { int r = data[index]; data[index] = element; return r; } @Override public int size() { return data.length; } }
int[] intArray = new int[]{1, 2, 3}; List<Integer> integerListWrap = new IntegerListWrap(intArray); List<Integer> integerListWrap1 = new IntegerListWrap(1, 2, 3);
int[] a = {1, 2, 3}; List<Integer> integers = IntLists.mutable.with(a).collect(i -> i); Assert.assertEquals(Lists.mutable.with(1, 2, 3), integers);
Integer[] intArr = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }; List<Integer> arrList = new ArrayList<>(); arrList.addAll(Arrays.asList(intArr)); System.out.println(arrList); Integer[] intArr = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }; Collection<Integer> c = Arrays.asList(intArr);
int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; Integer[] iArray = Arrays.stream(array).boxed().toArray(Integer[]::new); System.out.println(Arrays.toString(iArray)); List<Integer> list = new ArrayList<>(); Collections.addAll(list, iArray); System.out.println(list);
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
void intArrayToListOfIntegers(int[] arr, List<Integer> list) { IntStream.range(0, arr.length).forEach(i -> list.add(arr[i])); }
<T> ArrayList<T> toArrayList(Object o, Class<T> type){ ArrayList<T> objects = new ArrayList<>(); for (int i = 0; i < Array.getLength(o); i++) { objects.add((T) Array.get(o, i)); } return objects; }
ArrayList<Integer> list = toArrayList(new int[]{1,2,3}, Integer.class);
29388 **-Xmx2048m** -ea -XX:+HeapDumpOnOutOfMemoryError -Xverify:none -Xbootclasspath/a:../lib/boot.jar -Xms128m **-Xmx800m** -XX:MaxPermSize=350m -XX:ReservedCodeCacheSize=64m -XX:+UseCodeCacheFlushing -XX:+UseCompressedOops -Didea.paths.selector=IdeaIC12 -Dsun.java2d.noddraw=true -Didea.max.intellisense.filesize=2500 -Didea.dynamic.classpath=false -Didea.jars.nocopy=false -Dsun.java2d.d3d=false -Dapple.awt.fullscreencapturealldisplays=false -Dapple.laf.useScreenMenuBar=true -Djava.endorsed.dirs= -Dswing.bufferPerWindow=false -Didea.fatal.error.notification=enabled -Didea.cycle.buffer.size=1024 -Didea.popup.weight=heavy -Didea.xdebug.key=-Xdebug -Dapple.awt.graphics.UseQuartz=true -Dsun.java2d.pmoffscreen=false -Didea.no.launcher=false -DCVS_PASSFILE=~/.cvspass -Didea.use.default.antialiasing.in.editor=false -Dcom.apple.mrj.application.live-resize=false -Didea.smooth.progress=false 29392 Jps -Dapplication.home=/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home -Xms8m
-Xms128m -Xmx2048m -XX:MaxPermSize=350m -XX:ReservedCodeCacheSize=64m -XX:+UseCodeCacheFlushing -XX:+UseCompressedOops
-Xms128m -Xmx512m -XX:MaxPermSize=250m -XX:ReservedCodeCacheSize=64m -XX:+UseCodeCacheFlushing -ea -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true
/Applications/IntelliJ\ IDEA\ 12\ CE.app/bin/idea.vmoptions
-server -Xms1024m -Xmx4096m -XX:MaxPermSize=1024m -XX:ReservedCodeCacheSize=512m -XX:+UseCompressedOops -Dfile.encoding=UTF-8 -XX:+UseConcMarkSweepGC -XX:+AggressiveOpts -XX:+CMSClassUnloadingEnabled -XX:+CMSIncrementalMode -XX:+CMSIncrementalPacing -XX:CMSIncrementalDutyCycleMin=0 -XX:-TraceClassUnloading -XX:+TieredCompilation -XX:SoftRefLRUPolicyMSPerMB=100 -ea -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -Djdk.http.auth.tunneling.disabledSchemes="" -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Xverify:none -XX:ErrorFile=$USER_HOME/java_error_in_idea_%p.log -XX:HeapDumpPath=$USER_HOME/java_error_in_idea.hprof
final Dialog dialog = new Dialog(this); dialog.setContentView(R.layout.dialog_generic); Button okButton = (Button) dialog.findViewById(R.id.dialog_button_ok); TextView titleTv = (TextView) dialog.findViewById(R.id.dialog_generic_title); okButton.setOnClickListener(new OnClickListener() { public void onClick(View v) { dialog.dismiss(); } }); titleTv.setText("dialog title"); dialog.show();
_handlerToDelayDroidMove = new Handler(); _handlerToDelayDroidMove.postDelayed(_droidPlayRunnable, 10000); private Runnable _droidPlayRunnable = new Runnable() { public void run() { _someFieldOfTheActivity.performLongCalculation(); } };
public class LeakFactory { int myID = 0; public Leak createLeak() { return new Leak(); } public class Leak { int size = 1; } }
public class SwissCheese { public Leak[] myHoles; public SwissCheese() { LeakFactory _holeDriller = new LeakFactory() myHoles = new Leak[1000]; for (int i = 0; i++; i<1000) { myHoles[i] = _holeDriller.createLeak(); } } }
public class SwissCheese { public Leak[] myHoles; public SwissCheese() { myHoles = new Leak[1000]; for (int i = 0; i++; i<1000) { myHoles[i] = new LeakFactory().createLeak(); } } }
@Controller @ResponseBody public class MyController { } @RestController public class MyRestController { }
@Controller public class restClassName{ @RequestMapping(value={"/uri"}) @ResponseBody public ObjectResponse functionRestName(){ return instance } }
@RestController public class restClassName{ @RequestMapping(value={"/uri"}) public ObjectResponse functionRestName(){ return instance } }
@Configuration public class WebMvcConfiguration extends WebMvcConfigurerAdapter { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new TemplateMappingInterceptor()).addPathPatterns("/**", "/admin-functions**").excludePathPatterns("/login**"); } }
@Controller public class AdminServiceController {...
@RestController public class AdminServiceController {...
IProductRepository - interface ProductRepository, SqlProductRepository, etc. - implementations
String filename = "D:/some folder/001.docx"; String extensionRemoved = filename.split(".")[0];
String extensionRemoved = filename.split("\\.")[0];
final String extensionRemoved = filename.split("\\.")[0];
String extensionRemoved = filename.split("\\.")[0];
String filename = "D:/some folder/001.docx"; String extensionRemoved = filename.split("\\.")[0];
String hql = "select " + "c.uuid as uuid," + "c.name as name," + "c.objective as objective," + "c.startDate as startDate," + "c.endDate as endDate," + "c.description as description," + "s.status as status," + "t.type as type " + "from " + Campaign.class.getName() + " c " + "left join c.type t " + "left join c.status s"; Query query = hibernateTemplate.getSessionFactory().getCurrentSession().getSession(EntityMode.MAP).createQuery(hql); query.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP); return query.list();
void sendRequest(String request) { URL url = new URL(request); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setInstanceFollowRedirects(false); connection.setRequestMethod("GET"); connection.setRequestProperty("Content-Type", "text/plain"); connection.setRequestProperty("charset", "utf-8"); connection.connect(); }
String urlParameters = "param1=a&param2=b&param3=c"; byte[] postData = urlParameters.getBytes( StandardCharsets.UTF_8 ); int postDataLength = postData.length; String request = "http: URL url = new URL( request ); HttpURLConnection conn= (HttpURLConnection) url.openConnection(); conn.setDoOutput( true ); conn.setInstanceFollowRedirects( false ); conn.setRequestMethod( "POST" ); conn.setRequestProperty( "Content-Type", "application/x-www-form-urlencoded"); conn.setRequestProperty( "charset", "utf-8"); conn.setRequestProperty( "Content-Length", Integer.toString( postDataLength )); conn.setUseCaches( false ); try( DataOutputStream wr = new DataOutputStream( conn.getOutputStream())) { wr.write( postData ); }
import java.io.*; import java.net.*; import java.util.*; class Test { public static void main(String[] args) throws Exception { URL url = new URL("http: Map<String,Object> params = new LinkedHashMap<>(); params.put("name", "Freddie the Fish"); params.put("email", "fishie@seamail.example.com"); params.put("reply_to_thread", 10394); params.put("message", "Shark attacks in Botany Bay have gotten out of control. We need more defensive dolphins to protect the schools here, but Mayor Porpoise is too busy stuffing his snout with lobsters. He StringBuilder postData = new StringBuilder(); for (Map.Entry<String,Object> param : params.entrySet()) { if (postData.length() != 0) postData.append( postData.append(URLEncoder.encode(param.getKey(), "UTF-8")); postData.append( postData.append(URLEncoder.encode(String.valueOf(param.getValue()), "UTF-8")); } byte[] postDataBytes = postData.toString().getBytes("UTF-8"); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestMethod("POST"); conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); conn.setRequestProperty("Content-Length", String.valueOf(postDataBytes.length)); conn.setDoOutput(true); conn.getOutputStream().write(postDataBytes); Reader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8")); for (int c; (c = in.read()) >= 0;) System.out.print((char)c); } }
StringBuilder sb = new StringBuilder(); for (int c; (c = in.read()) >= 0;) sb.append((char)c); String response = sb.toString();
String urlParameters = "param1=a&param2=b&param3=c"; URL url = new URL("http: URLConnection conn = url.openConnection(); conn.setDoOutput(true); OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream()); writer.write(urlParameters); writer.flush(); String line; BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream())); while ((line = reader.readLine()) != null) { System.out.println(line); } writer.close(); reader.close();
Webb webb = Webb.create(); webb.post("http: .param("param1", "a") .param("param2", "b") .param("param3", "c") .ensureSuccess() .asVoid();
import java.net.*; public class Demo{ public static void main(){ String data = "data=Hello+World!"; URL url = new URL("http: HttpURLConnection con = (HttpURLConnection) url.openConnection(); con.setRequestMethod("POST"); con.setDoOutput(true); con.getOutputStream().write(data.getBytes("UTF-8")); con.getInputStream(); } }
HashMap<String, String> params = new HashMap<String, String>(); params.put("email","me@example.com"); params.put("password","12345"); String url = "http: HttpUtility.newRequest(url,HttpUtility.METHOD_POST,params, new HttpUtility.Callback() { @Override public void OnSuccess(String response) { System.out.println("Server OnSuccess response="+response); } @Override public void OnError(int status_code, String message) { System.out.println("Server OnError status_code="+status_code+" message="+message); } });
import java.io.*; import java.net.*; import java.util.HashMap; import java.util.Map; import static java.net.HttpURLConnection.HTTP_OK; public class HttpUtility { public static final int METHOD_GET = 0; public static final int METHOD_POST = 1; public interface Callback { public void OnSuccess(String response); public void OnError(int status_code, String message); } public static void newRequest(String web_url, int method, HashMap < String, String > params, Callback callback) { new Thread(new Runnable() { @Override public void run() { try { String url = web_url; if (method == METHOD_GET && params != null) { for (Map.Entry < String, String > item: params.entrySet()) { String key = URLEncoder.encode(item.getKey(), "UTF-8"); String value = URLEncoder.encode(item.getValue(), "UTF-8"); if (!url.contains("?")) { url += "?" + key + "=" + value; } else { url += "&" + key + "=" + value; } } } HttpURLConnection urlConnection = (HttpURLConnection) new URL(url).openConnection(); urlConnection.setDoOutput(true); urlConnection.setUseCaches(false); urlConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); urlConnection.setRequestProperty("charset", "utf-8"); if (method == METHOD_GET) { urlConnection.setRequestMethod("GET"); } else if (method == METHOD_POST) { urlConnection.setRequestMethod("POST"); } if (method == METHOD_POST && params != null) { StringBuilder postData = new StringBuilder(); for (Map.Entry < String, String > item: params.entrySet()) { if (postData.length() != 0) postData.append( postData.append(URLEncoder.encode(item.getKey(), "UTF-8")); postData.append( postData.append(URLEncoder.encode(String.valueOf(item.getValue()), "UTF-8")); } byte[] postDataBytes = postData.toString().getBytes("UTF-8"); urlConnection.setRequestProperty("Content-Length", String.valueOf(postDataBytes.length)); urlConnection.getOutputStream().write(postDataBytes); } int responseCode = urlConnection.getResponseCode(); if (responseCode == HTTP_OK && callback != null) { BufferedReader reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { response.append(line); } callback.OnSuccess(response.toString()); reader.close(); } else if (callback != null) { callback.OnError(responseCode, urlConnection.getResponseMessage()); } urlConnection.disconnect(); } catch (IOException e) { e.printStackTrace(); if (callback != null) { callback.OnError(500, e.getLocalizedMessage()); } } } }).start(); } }
URL url = new URL("http: Map<String,Object> params = new LinkedHashMap<>(); params.put("param1", param1); params.put("param2", param2); StringBuilder postData = new StringBuilder(); for (Map.Entry<String,Object> param : params.entrySet()) { if (postData.length() != 0) postData.append( postData.append(URLEncoder.encode(param.getKey(), "UTF-8")); postData.append( postData.append(URLEncoder.encode(String.valueOf(param.getValue()), "UTF-8")); } String urlParameters = postData.toString(); URLConnection conn = url.openConnection(); conn.setDoOutput(true); OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream()); writer.write(urlParameters); writer.flush(); String result = ""; String line; BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream())); while ((line = reader.readLine()) != null) { result += line; } writer.close(); reader.close() System.out.println(result);
Document doc = Jsoup.parseBodyFragment(value); Iterator<Element> opts = doc.select("option").iterator(); for (;opts.hasNext();) { Element item = opts.next(); if (item.hasAttr("value")) { System.out.println(item.attr("value")); } }
public class HttpClientForExample { private final String USER_AGENT = "Mozilla/5.0"; public static void main(String[] args) throws Exception { HttpClientExample http = new HttpClientExample(); System.out.println("Testing 1 - Send Http GET request"); http.sendGet(); System.out.println("\nTesting 2 - Send Http POST request"); http.sendPost(); } private void sendGet() throws Exception { String url = "http: HttpClient client = new DefaultHttpClient(); HttpGet request = new HttpGet(url); request.addHeader("User-Agent", USER_AGENT); HttpResponse response = client.execute(request); System.out.println("\nSending System.out.println("Response Code : " + response.getStatusLine().getStatusCode()); BufferedReader rd = new BufferedReader( new InputStreamReader(response.getEntity().getContent())); StringBuffer result = new StringBuffer(); String line = ""; while ((line = rd.readLine()) != null) { result.append(line); } System.out.println(result.toString()); } private void sendPost() throws Exception { String url = "https: HttpClient client = new DefaultHttpClient(); HttpPost post = new HttpPost(url); post.setHeader("User-Agent", USER_AGENT); List<NameValuePair> urlParameters = new ArrayList<NameValuePair>(); urlParameters.add(new BasicNameValuePair("sn", "C02G8416DRJM")); urlParameters.add(new BasicNameValuePair("cn", "")); urlParameters.add(new BasicNameValuePair("locale", "")); urlParameters.add(new BasicNameValuePair("caller", "")); urlParameters.add(new BasicNameValuePair("num", "12345")); post.setEntity(new UrlEncodedFormEntity(urlParameters)); HttpResponse response = client.execute(post); System.out.println("\nSending System.out.println("Post parameters : " + post.getEntity()); System.out.println("Response Code : " + response.getStatusLine().getStatusCode()); BufferedReader rd = new BufferedReader( new InputStreamReader(response.getEntity().getContent())); StringBuffer result = new StringBuffer(); String line = ""; while ((line = rd.readLine()) != null) { result.append(line); } System.out.println(result.toString()); } }
public static PricesResponse getResponse(EventRequestRaw request) { String urlParameters = Piping.serialize(request); HttpURLConnection conn = RestClient.getPOSTConnection(endPoint, urlParameters); PricesResponse response = null; try { OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream()); writer.write(urlParameters); writer.flush(); BufferedReader reader = new BufferedReader(new InputStreamReader((conn.getInputStream()), StandardCharsets.UTF_8)); String json = Buffering.getString(reader); response = (PricesResponse) Piping.deserialize(json, PricesResponse.class); writer.close(); reader.close(); } catch (Exception e) { e.printStackTrace(); } conn.disconnect(); System.out.println("PricesClient: " + response.toString()); return response; } public static HttpURLConnection getPOSTConnection(String endPoint, String urlParameters) { return RestClient.getConnection(endPoint, "POST", urlParameters); } public static HttpURLConnection getConnection(String endPoint, String method, String urlParameters) { System.out.println("ENDPOINT " + endPoint + " METHOD " + method); HttpURLConnection conn = null; try { URL url = new URL(endPoint); conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(method); conn.setDoOutput(true); conn.setRequestProperty("Content-Type", "text/plain"); } catch (IOException e) { e.printStackTrace(); } return conn; }
public static String getJson(String serverUrl,String host,String jsonobject){ StringBuilder sb = new StringBuilder(); String http = serverUrl; HttpURLConnection urlConnection = null; try { URL url = new URL(http); urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.setDoOutput(true); urlConnection.setRequestMethod("POST"); urlConnection.setUseCaches(false); urlConnection.setConnectTimeout(50000); urlConnection.setReadTimeout(50000); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("Host", host); urlConnection.connect(); OutputStreamWriter out = new OutputStreamWriter(urlConnection.getOutputStream()); out.write(jsonobject); out.close(); int HttpResult = urlConnection.getResponseCode(); if (HttpResult == HttpURLConnection.HTTP_OK) { BufferedReader br = new BufferedReader(new InputStreamReader( urlConnection.getInputStream(), "utf-8")); String line = null; while ((line = br.readLine()) != null) { sb.append(line + "\n"); } br.close(); Log.e("new Test", "" + sb.toString()); return sb.toString(); } else { Log.e(" ", "" + urlConnection.getResponseMessage()); } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (JSONException e) { e.printStackTrace(); } finally { if (urlConnection != null) urlConnection.disconnect(); } return null; }
private static final HttpRequest<String.class> HTTP_REQUEST = HttpRequestBuilder.createPost("http: .responseDeserializer(ResponseDeserializer.ignorableDeserializer()) .build(); public void sendRequest(String request){ String parameters = request.split("\\?")[1]; ResponseHandler<String> responseHandler = HTTP_REQUEST.executeWithQuery(parameters); System.out.println(responseHandler.getStatusCode()); System.out.println(responseHandler.get()); }
private static final HttpRequest<?> HTTP_REQUEST = HttpRequestBuilder.createPost("http: public void sendRequest(String request){ ResponseHandler<String> responseHandler = HTTP_REQUEST.executeWithQuery(parameters); }
public static JSONObject doPostRequest(HashMap<String, String> data, String url) { try { RequestBody requestBody; MultipartBuilder mBuilder = new MultipartBuilder().type(MultipartBuilder.FORM); if (data != null) { for (String key : data.keySet()) { String value = data.get(key); Utility.printLog("Key Values", key + "-----------------" + value); mBuilder.addFormDataPart(key, value); } } else { mBuilder.addFormDataPart("temp", "temp"); } requestBody = mBuilder.build(); Request request = new Request.Builder() .url(url) .post(requestBody) .build(); OkHttpClient client = new OkHttpClient(); Response response = client.newCall(request).execute(); String responseBody = response.body().string(); Utility.printLog("URL", url); Utility.printLog("Response", responseBody); return new JSONObject(responseBody); } catch (UnknownHostException | UnsupportedEncodingException e) { JSONObject jsonObject=new JSONObject(); try { jsonObject.put("status","false"); jsonObject.put("message",e.getLocalizedMessage()); } catch (JSONException e1) { e1.printStackTrace(); } Log.e(TAG, "Error: " + e.getLocalizedMessage()); } catch (Exception e) { e.printStackTrace(); JSONObject jsonObject=new JSONObject(); try { jsonObject.put("status","false"); jsonObject.put("message",e.getLocalizedMessage()); } catch (JSONException e1) { e1.printStackTrace(); } Log.e(TAG, "Other Error: " + e.getLocalizedMessage()); } return null; }
public static byte[] httpBuildQueryString(Map<String, Object> postsData) throws UnsupportedEncodingException { StringBuilder postData = new StringBuilder(); for (Map.Entry<String,Object> param : postsData.entrySet()) { if (postData.length() != 0) postData.append( Object value = param.getValue(); String key = param.getKey(); if(value instanceof Object[] || value instanceof List<?>) { int size = value instanceof Object[] ? ((Object[])value).length : ((List<?>)value).size(); for(int i = 0; i < size; i++) { Object val = value instanceof Object[] ? ((Object[])value)[i] : ((List<?>)value).get(i); if(i>0) postData.append( postData.append(URLEncoder.encode(key + "[" + i + "]", "UTF-8")); postData.append( postData.append(URLEncoder.encode(String.valueOf(val), "UTF-8")); } } else { postData.append(URLEncoder.encode(key, "UTF-8")); postData.append( postData.append(URLEncoder.encode(String.valueOf(value), "UTF-8")); } } return postData.toString().getBytes("UTF-8"); }
<dependency> <groupId>com.google.code.gson</groupId> <artifactId>gson</artifactId> <version>2.8.5</version> <scope>compile</scope> </dependency>
import org.apache.http.HttpResponse; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.*; import org.apache.http.impl.client.CloseableHttpClient; import com.google.gson.Gson;
private CloseableHttpClient httpclient = HttpClients.createDefault(); HttpPost httppost = new HttpPost("https: Product product = new Product(); Gson gson = new Gson(); String client = gson.toJson(product); httppost.setEntity(new StringEntity(client, ContentType.APPLICATION_JSON)); httppost.setHeader("RANDOM-HEADER", "headervalue"); HttpResponse response = null; try { response = httpclient.execute(httppost); } catch (IOException e) { throw new InternalServerErrorException("Post fails"); } Response.Status responseStatus = Response.Status.fromStatusCode(response.getStatusLine().getStatusCode()); return Response.status(responseStatus).build();
URL url = new URL(urlString); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.connect(); connection.getOutputStream().close();
button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { } });
public static int larger(final List<Integer> ns, final int i) { for (Integer n : ns) if (n > i) return n; return i; }
public static int smaller(final List<Integer> ns, final int i) { for (Integer n : ns) if (n < i) return n; return i; }
public static <T> T firstMatch(final List<T> ts, final F<T, Boolean> f, T z) { for (T t : ts) if (f.f(t)) return t; return z; }
F<Integer, Boolean> greaterThanTen = new F<Integer, Boolean> { Boolean f(final Integer n) { return n > 10; } }; int moreThanMyFingersCanCount = firstMatch(xs, greaterThanTen, x);
class A{ public void methodA() { System.out.println("methodA"); } } class B{ A a = new A() { public void methodA() { System.out.println("anonymous methodA"); } }; }
interface interfaceA{ public void methodA(); } class B{ interfaceA a = new interfaceA() { public void methodA() { System.out.println("anonymous methodA implementer"); } }; }
interface Foo { void methodFoo(); } class B{ void do(Foo f) { } } class A{ void methodA() { B b = new B(); b.do(new Foo() { public void methodFoo() { System.out.println("methodFoo"); } }); } }
Map map = new HashMap() {{ put("key", "value"); }};
myButton.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e) { } });
button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent arg0) { } });
new Thread() { public void run() { try { Thread.sleep(300); } catch (InterruptedException e) { System.out.println("Exception message: " + e.getMessage()); System.out.println("Exception cause: " + e.getCause()); } } }.start();
new Thread(new Runnable() { public void run() { } }).start();
public class Person { public enum Sex { MALE, FEMALE } String name; LocalDate birthday; Sex gender; String emailAddress; public int getAge() { } public void printPerson() { } }
public static void printPersons( List<Person> roster, CheckPerson tester) { for (Person p : roster) { if (tester.test(p)) { p.printPerson(); } } }
printPersons( roster, new CheckPerson() { public boolean test(Person p) { return p.getGender() == Person.Sex.MALE && p.getAge() >= 18 && p.getAge() <= 25; } } );
printPersons( roster, (Person p) -> p.getGender() == Person.Sex.MALE && p.getAge() >= 18 && p.getAge() <= 25 );
public class HeavyClass{ private final Object finalizerGuardian = new Object() { @Override protected void finalize() throws Throwable{ } }; }
TreeSet treeSetObj = new TreeSet(new Comparator() { public int compare(String i1,String i2) { return i2.compareTo(i1); } });
public abstract class TypeHolder<T> { private final Type type; public TypeReference() { final Type superClass = getClass().getGenericSuperclass(); this.type = ((ParameterizedType) superClass).getActualTypeArguments()[0]; } public final Type getType() { return this.type; } }
TypeHolder<List<String>, Map<Ineger, Long>> holder = new TypeHolder<List<String>, Map<Ineger, Long>>() {};
import java.util.Scanner; abstract class AnonymousInner { abstract void sum(); } class AnonymousInnerMain { public static void main(String []k){ Scanner sn = new Scanner(System.in); System.out.println("Enter two vlaues"); int a= Integer.parseInt(sn.nextLine()); int b= Integer.parseInt(sn.nextLine()); AnonymousInner ac = new AnonymousInner(){ void sum(){ int c= a+b; System.out.println("Sum of two number is: "+c); } }; ac.sum(); } }
ThreadClass task = new ThreadClass(); Thread runner = new Thread(task); runner.start();
Thread runner = new Thread(new Runnable() { public void run() { } }); runner.start();
MyClass.method((a, b) -> a+b); class MyClass{ static int method(Lambda l){ return l(5, 10); } }
static int method(IntBinaryOperator op){ return op.applyAsInt(5, 10); }
public interface TwoArgIntOperator { public int op(int a, int b); } static int method(TwoArgIntOperator operator) { return operator.op(5, 10); }
interface TwoArgInterface { public int operation(int a, int b); } public class MyClass { public static void main(String javalatte[]) { TwoArgInterface plusOperation = (a, b) -> a + b; System.out.println("Sum of 10,34 : " + plusOperation.operation(10, 34)); } }
import java.util.function.IntBinaryOperator; public class MyClass1 { static void main(String javalatte[]) { IntBinaryOperator plusOperation = (a, b) -> a + b; System.out.println("Sum of 10,34 : " + plusOperation.applyAsInt(10, 34)); } }
class Klass { static List<String> foo(Integer a, String b) { ... } } class MyClass{ static List<String> method(BiFunction<Integer, String, List<String>> fn){ return fn.apply(5, "FooBar"); } } List<String> lStr = MyClass.method((a, b) -> Klass.foo((Integer) a, (String) b));
public class LambdaDemo { public static List<Integer> filter(IMyFunc testNum, List<Integer> listItems) { List<Integer> result = new ArrayList<Integer>(); for(Integer item: listItems) { if(testNum.test(item)) { result.add(item); } } return result; } public static void main(String[] args) { List<Integer> myList = new ArrayList<Integer>(); myList.add(1); myList.add(4); myList.add(6); myList.add(7); Collection<Integer> values = filter(n -> n > 5, myList); System.out.println("Filtered values " + values); } }
Import java.util.function.Consumer public Class Main { public static void runLambda(BiConsumer<Integer, Integer> lambda) { lambda.accept(102, 54) } public static void main(String[] args) { runLambda((int1, int2) -> System.out.println(int1 + " + " + int2 + " = " + (int1 + int2))); }
public interface MyFunctionalInterface { String makeIt(String s); }
public class Main { static void printIt(String s, MyFunctionalInterface f) { System.out.println(f.makeIt(s)); } public static void main(String[] args) { } }
public class Main { static void printIt(String s, MyFunctionalInterface f) { System.out.println(f.makeIt(s)); } public static void main(String[] args) { printIt("Java", s -> s + " is Awesome"); } }
@FuntionalInterface public interface SumLambdaExpression { public int do(int a, int b); } public class MyClass { public static void main(String [] args) { SumLambdaExpression s = (a,b)->a+b; lambdaArgFunction(s); } public static void lambdaArgFunction(SumLambdaExpression s) { System.out.println("Output : "+s.do(2,5)); } }
void somewhereInYourCode() { method(() -> { }); } void method(Callback callback) { callback.call(); }
method(new Callback() { @Override public void call() { } });
@FunctionalInterface interface FInterface{ int callMeLambda(String temp); } class ConcreteClass{ void funcUsesAnonymousOrLambda(FInterface fi){ System.out.println("===Executing method arg instantiated with Lambda===")); } public static void main(){ funcUsesAnonymousOrLambda(new FInterface() { int callMeLambda(String temp){ return 0; } } } /***********Can be replaced by Lambda below*********/ funcUsesAnonymousOrLambda( (x) -> { return 0; } }
for 10 child classes - instanceof: 1200ms vs switch: 470ms for 5 child classes - instanceof: 375ms vs switch: 204ms
import java.util.Date; public class InstanceOfVsEnum { public static int c1, c2, c3, c4, c5, c6, c7, c8, c9, cA; public static class Handler { public enum Type { Type1, Type2, Type3, Type4, Type5, Type6, Type7, Type8, Type9, TypeA } protected Handler(Type type) { this.type = type; } public final Type type; public static void addHandlerInstanceOf(Handler h) { if( h instanceof H1) { c1++; } else if( h instanceof H2) { c2++; } else if( h instanceof H3) { c3++; } else if( h instanceof H4) { c4++; } else if( h instanceof H5) { c5++; } else if( h instanceof H6) { c6++; } else if( h instanceof H7) { c7++; } else if( h instanceof H8) { c8++; } else if( h instanceof H9) { c9++; } else if( h instanceof HA) { cA++; } } public static void addHandlerSwitch(Handler h) { switch( h.type ) { case Type1: c1++; break; case Type2: c2++; break; case Type3: c3++; break; case Type4: c4++; break; case Type5: c5++; break; case Type6: c6++; break; case Type7: c7++; break; case Type8: c8++; break; case Type9: c9++; break; case TypeA: cA++; break; } } } public static class H1 extends Handler { public H1() { super(Type.Type1); } } public static class H2 extends Handler { public H2() { super(Type.Type2); } } public static class H3 extends Handler { public H3() { super(Type.Type3); } } public static class H4 extends Handler { public H4() { super(Type.Type4); } } public static class H5 extends Handler { public H5() { super(Type.Type5); } } public static class H6 extends Handler { public H6() { super(Type.Type6); } } public static class H7 extends Handler { public H7() { super(Type.Type7); } } public static class H8 extends Handler { public H8() { super(Type.Type8); } } public static class H9 extends Handler { public H9() { super(Type.Type9); } } public static class HA extends Handler { public HA() { super(Type.TypeA); } } final static int cCycles = 10000000; public static void main(String[] args) { H1 h1 = new H1(); H2 h2 = new H2(); H3 h3 = new H3(); H4 h4 = new H4(); H5 h5 = new H5(); H6 h6 = new H6(); H7 h7 = new H7(); H8 h8 = new H8(); H9 h9 = new H9(); HA hA = new HA(); Date dtStart = new Date(); for( int i = 0; i < cCycles; i++ ) { Handler.addHandlerInstanceOf(h1); Handler.addHandlerInstanceOf(h2); Handler.addHandlerInstanceOf(h3); Handler.addHandlerInstanceOf(h4); Handler.addHandlerInstanceOf(h5); Handler.addHandlerInstanceOf(h6); Handler.addHandlerInstanceOf(h7); Handler.addHandlerInstanceOf(h8); Handler.addHandlerInstanceOf(h9); Handler.addHandlerInstanceOf(hA); } System.out.println("Instance of - " + (new Date().getTime() - dtStart.getTime())); dtStart = new Date(); for( int i = 0; i < cCycles; i++ ) { Handler.addHandlerSwitch(h1); Handler.addHandlerSwitch(h2); Handler.addHandlerSwitch(h3); Handler.addHandlerSwitch(h4); Handler.addHandlerSwitch(h5); Handler.addHandlerSwitch(h6); Handler.addHandlerSwitch(h7); Handler.addHandlerSwitch(h8); Handler.addHandlerSwitch(h9); Handler.addHandlerSwitch(hA); } System.out.println("Switch of - " + (new Date().getTime() - dtStart.getTime())); } }
x instanceof X ==> x.getClass()==X.class ==> x.classID == constant_X_ID
if (objectStruct->iAmInstanceOf == &java_lang_String_class)
if (SomeObject instanceOf Integer) { [do something] } if (SomeObject instanceOf Double) { [do something different] }
package com.javadude.sample; import java.util.HashMap; import java.util.Map; public class StrategyExample { static class SomeCommonSuperType {} static class SubType1 extends SomeCommonSuperType {} static class SubType2 extends SomeCommonSuperType {} static class SubType3 extends SomeCommonSuperType {} static interface Handler<T extends SomeCommonSuperType> { Object handle(T object); } static class HandlerMap { private Map<Class<? extends SomeCommonSuperType>, Handler<? extends SomeCommonSuperType>> handlers_ = new HashMap<Class<? extends SomeCommonSuperType>, Handler<? extends SomeCommonSuperType>>(); public <T extends SomeCommonSuperType> void add(Class<T> c, Handler<T> handler) { handlers_.put(c, handler); } @SuppressWarnings("unchecked") public <T extends SomeCommonSuperType> Object handle(T o) { return ((Handler<T>) handlers_.get(o.getClass())).handle(o); } } public static void main(String[] args) { HandlerMap handlerMap = new HandlerMap(); handlerMap.add(SubType1.class, new Handler<SubType1>() { @Override public Object handle(SubType1 object) { System.out.println("Handling SubType1"); return null; } }); handlerMap.add(SubType2.class, new Handler<SubType2>() { @Override public Object handle(SubType2 object) { System.out.println("Handling SubType2"); return null; } }); handlerMap.add(SubType3.class, new Handler<SubType3>() { @Override public Object handle(SubType3 object) { System.out.println("Handling SubType3"); return null; } }); SubType1 subType1 = new SubType1(); handlerMap.handle(subType1); SubType2 subType2 = new SubType2(); handlerMap.handle(subType2); SubType3 subType3 = new SubType3(); handlerMap.handle(subType3); } }
if (o instanceof Class1) doThis(); else if (o instanceof Class2) doThat();
static final int ID_A = 0; static final int ID_B = 1; abstract class Base { final int id; Base(int i) { id = i; } } class A extends Base { A() { super(ID_A); } } class B extends Base { B() { super(ID_B); } } ... Base obj = ... switch(obj.id) { case ID_A: .... break; case ID_B: .... break; }
public abstract class Base { protected enum TYPE { DERIVED_A, DERIVED_B } public abstract TYPE getType(); class DerivedA extends Base { @Override public TYPE getType() { return TYPE.DERIVED_A; } } class DerivedB extends Base { @Override public TYPE getType() { return TYPE.DERIVED_B; } } }
if (!(seq instanceof SingleItem)) { seq = seq.head(); }
public class Stock { private final double price; private final int quantity; Stock(double price, int quantity) { this.price = price; this.quantity = quantity; } public double getPrice() { return price; } public int getQuantity() { return quantity; } public double getValue() { return getPrice() * getQuantity(); } @Test public void getValueTest() { Stock stock = mock(Stock.class); when(stock.getPrice()).thenReturn(100.00); when(stock.getQuantity()).thenReturn(200); double value = stock.getValue(); assertEquals("Stock value not correct", 100.00*200, value, .00001); }
Stock stock = mock(Stock.class); when(stock.getPrice()).thenReturn(100.00); when(stock.getQuantity()).thenReturn(200); when(stock.getValue()).thenCallRealMethod();
Stock stock = spy(Stock.class); when(stock.getPrice()).thenReturn(100.00); when(stock.getQuantity()).thenReturn(200);
Stock stock = spy(Stock.class); doReturn(100.00).when(stock).getPrice(); doReturn(200).when(stock).getQuantity();
@Test public void getValueTest() { Stock stock = new Stock(100.00, 200); double value = stock.getValue(); assertEquals("Stock value not correct", 100.00*200, value, .00001); }
List list = new LinkedList(); List spy = spy(list); when(spy.size()).thenReturn(100); spy.add("one"); spy.add("two"); System.out.println(spy.size());
Foo mock = mock(Foo.class, CALLS_REAL_METHODS); value = mock.getSomething(); when(mock.getSomething()).thenReturn(fakeValue); value = mock.getSomething();
public static <T> T mock(Class<T> classToMock) { return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS)); }
/** * The default <code>Answer</code> of every mock <b>if</b> the mock was not stubbed. * Typically it just returns some empty value. * <p> * {@link Answer} can be used to define the return values of unstubbed invocations. * <p> * This implementation first tries the global configuration. * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.) */
/** * Optional <code>Answer</code> to be used with {@link Mockito * <p> * {@link Answer} can be used to define the return values of unstubbed invocations. * <p> * This implementation can be helpful when working with legacy code. * When this implementation is used, unstubbed methods will delegate to the real implementation. * This is a way to create a partial mock object that calls real methods by default. * <p> * As usual you are going to read <b>the partial mock warning</b>: * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects. * How does partial mock fit into this paradigm? Well, it just doesn * Partial mock usually means that the complexity has been moved to a different method on the same object. * In most cases, this is not the way you want to design your application. * <p> * However, there are rare cases when partial mocks come handy: * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.) * However, I wouldn * <p> * Example: * <pre class="code"><code class="java"> * Foo mock = mock(Foo.class, CALLS_REAL_METHODS); * * * value = mock.getSomething(); * * when(mock.getSomething()).thenReturn(fakeValue); * * * value = mock.getSomething(); * </code></pre> */
import org.junit.Test; import static org.mockito.Mockito.*; import static org.junit.Assert.*; public class StockTest { public class Stock { private final double price; private final int quantity; Stock(double price, int quantity) { this.price = price; this.quantity = quantity; } public double getPrice() { return price; } public int getQuantity() { return quantity; } public double getValue() { return getPrice() * getQuantity(); } } @Test public void getValueTest() { Stock stock = mock(Stock.class, withSettings().defaultAnswer(CALLS_REAL_METHODS)); when(stock.getPrice()).thenReturn(100.00); when(stock.getQuantity()).thenReturn(200); double value = stock.getValue(); assertEquals("Stock value not correct", 100.00 * 200, value, .00001); } }
[2011-10-03 17:20:09 - Screen] Android requires compiler compliance level 5.0 or 6.0. Found [2011-10-03 17:21:55 - App] Android requires compiler compliance level 5.0 or 6.0. Found [2011-10-03 17:21:59 - App] Android requires compiler compliance level 5.0 or 6.0. Found
Enable project-specific settings and set the compliance level to 1.6
public class Employee { private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } }
interface EmployeeDAO { List<Employee> findAll(); List<Employee> findById(); List<Employee> findByName(); boolean insertEmployee(Employee employee); boolean updateEmployee(Employee employee); boolean deleteEmployee(Employee employee); }
list persons = DAO.getPersons(); ... person = DAO.getPersonWithName("John"); age = person.age;
while (getNext(line)) { if (line.isEmpty() || line.isComment()) continue; }
aLoopName: for (;;) { while (someCondition) if (otherCondition) continue aLoopName;
int sum = 0; for(int i = 1; i <= 100 ; i++){ if(i % 2 == 0) continue; sum += i; }
for(int i=0; i < 10; ++i) { if (i % 2 == 0) { continue; } System.out.println(i); }
Random r = new Random(); Set<Integer> aSet= new HashSet<Integer>(); int anInt; do { anInt = r.nextInt(10); if (anInt % 2 == 0) continue; System.out.println(anInt); } while (aSet.add(anInt)); System.out.println(aSet);
for (int i = 0; i < 10; i++) { if (i%2 == 0) continue; System.out.println(i+""); }
public class ContinueBreak { public static void main(String[] args) { String[] table={"aa","bb","cc","dd"}; for(String ss:table){ if("bb".equals(ss)){ continue; } System.out.println(ss); if("cc".equals(ss)){ break; } } System.out.println("Out of the loop."); } }
public class Pair<L,R> { private final L left; private final R right; public Pair(L left, R right) { this.left = left; this.right = right; } public L getLeft() { return left; } public R getRight() { return right; } @Override public int hashCode() { return left.hashCode() ^ right.hashCode(); } @Override public boolean equals(Object o) { if (!(o instanceof Pair)) return false; Pair pairo = (Pair) o; return this.left.equals(pairo.getLeft()) && this.right.equals(pairo.getRight()); } }
java.util.List<java.util.Map.Entry<String,Integer>> pairList= new java.util.ArrayList<>();
java.util.Map.Entry<String,Integer> pair1=new java.util.AbstractMap.SimpleEntry<>("Not Unique key1",1); java.util.Map.Entry<String,Integer> pair2=new java.util.AbstractMap.SimpleEntry<>("Not Unique key2",2); pairList.add(pair1); pairList.add(pair2);
Entry<String,Integer> pair1=new SimpleEntry<>("Not Unique key1",1); Entry<String,Integer> pair2=new SimpleEntry<>("Not Unique key2",2); pairList.add(pair1); pairList.add(pair2);
pairList.add(createEntry("Not Unique key1", 1)); pairList.add(createEntry("Not Unique key2", 2));
TupleList<java.util.Map.Entry<String,Integer>> pair = new TupleList<>(); pair.of("Not Unique key1", 1); pair.of("Not Unique key2", 2);
import java.util.Objects; public class Pair<K, V> { public final K key; public final V value; public Pair(K key, V value) { this.key = key; this.value = value; } public boolean equals(Object o) { return o instanceof Pair && Objects.equals(key, ((Pair<?,?>)o).key) && Objects.equals(value, ((Pair<?,?>)o).value); } public int hashCode() { return 31 * Objects.hashCode(key) + Objects.hashCode(value); } public String toString() { return key + "=" + value; } }
List<Pair<String, Integer>> myPairs = new ArrayList<Pair<String, Integer>>(); myPairs.add(Pair.of("val1", 11)); myPairs.add(Pair.of("val2", 17)); for(Pair<String, Integer> pair : myPairs) { System.out.println(pair.getLeft() + ": " + pair.getRight()); System.out.println(pair.getKey() + ": " + pair.getValue()); }
import org.apache.commons.lang3.tuple.ImmutablePair; import org.apache.commons.lang3.tuple.Pair; ... @SuppressWarnings("unchecked") Pair<String, Integer>[] arr = new ImmutablePair[]{ ImmutablePair.of("A", 1), ImmutablePair.of("B", 2)}; String key = arr[0].getKey(); String left = arr[0].getLeft(); Integer value = arr[0].getValue(); Integer right = arr[0].getRight();
<dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-lang3</artifactId> <version>3.4</version> </dependency>
class Pair<L,R> { final L left; final R right; public Pair(L left, R right) { this.left = left; this.right = right; } static <L,R> Pair<L,R> of(L left, R right){ return new Pair<L,R>(left, right); } }
import java.util.AbstractMap.SimpleEntry; import java.util.ArrayList; import java.util.List; import java.util.Map.Entry; SimpleEntry<String, String> myEntry = new SimpleEntry<String, String>("ID", "Text"); System.out.println("key: " + myEntry.getKey() + " value:" + myEntry.getValue()); System.out.println(); List<Entry<String,String>> pairList = new ArrayList<>(); Entry<String,String> firstButton = new SimpleEntry<String, String>("Red ", "Way out"); pairList.add(firstButton); pairList.add(new SimpleEntry<String,String>("Gray", "Alternate route")); for (Entry<String, String> entr : pairList) { System.out.println("Button: " + entr.getKey() + " Label: " + entr.getValue()); }
public static void main(String []args) { HashMap<String, Integer> values = new HashMap<String,Integer>(); values.put("A", 235); Set<Map.Entry<String,Integer>> list = values.entrySet(); }
String str = "TextX Xto modifyX"; str = str.replace(
public String replaceAll(String regex, String replacement)
String test = "09-09-2012"; String arr [] = test.split("-"); String ans = ""; for(String t : arr) ans+=t;
public class RemoveCharacter { public static void main(String[] args){ String str = "MXy nameX iXs farXazX"; char x = System.out.println(removeChr(str,x)); } public static String removeChr(String str, char x){ StringBuilder strBuilder = new StringBuilder(); char[] rmString = str.toCharArray(); for(int i=0; i<rmString.length; i++){ if(rmString[i] == x){ } else { strBuilder.append(rmString[i]); } } return strBuilder.toString(); } }
package com.acn.demo.action; public class RemoveCharFromString { static String input = ""; public static void main(String[] args) { input = "abadbbeb34erterb"; char token = removeChar(token); } private static void removeChar(char token) { System.out.println(input); for (int i=0;i<input.length();i++) { if (input.charAt(i) == token) { input = input.replace(input.charAt(i), System.out.println("MATCH FOUND"); } input = input.replaceAll(" ", ""); System.out.println(input); } } }
Map<String, Integer> integers; integers.values().stream().mapToInt(i -> i).sum();
integers.values().stream().mapToInt(i -> i.intValue()).sum(); integers.values().stream().mapToInt(Integer::intValue).sum();
integers.values().stream().mapToInt(Integer::intValue).sum(); integers.values().stream().collect(Collectors.summingInt(Integer::intValue));
LongAdder a = new LongAdder(); map.values().parallelStream().forEach(a::add); sum = a.intValue();
int sum = numbers.stream().reduce(0, (x,y) -> x+y);
int sum = numbers.stream().reduce(0, Integer::sum);
int sum = numbers.parallelStream().reduce(0, Integer::sum);
integers.values().stream().mapToInt(i -> i).reduce(0, (x,y) -> x+y);
integers.values().stream().reduce(0, Integer::sum);
long sum = result.stream().map(e -> e.getCreditAmount()).reduce(0L, (x, y) -> x + y);
long sum = result.stream().map(e -> e.getCreditAmount()).reduce(0L, Integer::sum);
int sum = integers.values().stream().reduce(0, Integer::sum);
List<Integer> list = Arrays.asList(2, 4, 5, 6); int sum = list.stream().collect(Collectors.summingInt(Integer::intValue));
class Pojo{ int num; public Pojo(int num) { super(); this.num = num; } public int getNum() { return num; } public void setNum(int num) { this.num = num; } } List<Pojo> list = new ArrayList<Pojo>(); list.add(new Pojo(1)); list.add(new Pojo(5)); list.add(new Pojo(3)); list.add(new Pojo(4)); list.add(new Pojo(5)); int totalSum = list.stream().mapToInt(pojo -> pojo.getNum()).sum(); System.out.println(totalSum);
public class J { public static void main(String[] args) { String main = "The character sequence \"main\" is an identifier, not a keyword or reserved word."; System.out.println(main); } }
The character sequence "main" is an identifier, not a keyword or reserved word.
public class main { public String main = "main"; public void main(String main) { System.out.println("This object is an instance of the class " + this.getClass().getCanonicalName()); System.out.println("The value of the argument \"main\" for this call to the method \"main(String main)\" is " + main); System.out.println("The value of the field \"main\" is " + this.main); } public static void main(String[] args) { main main = new main(); main.main(main.main + main.main); } }
This object is an instance of the class main The value of the argument "main" for this call to the method "main(String main)" is mainmain The value of the field "main" is main
public class Foo{ public static void main(String[] args){ } }
public class Main { public static void main(String args[]){ Main main = new Main(); } }
public class Object { public void foo() { ... } } public class BadChosenIdentifier { public static void main() { new BadChosenIdentifier().toString(new Object()); } public void toString(Object java1234) { String _result$ = java1234 + " -> to avoid"; System.out.println(_result$); } }
package main; public class main { static main main; String Main; main(String main) { Main = main; } main(main main) { System.out.println(main.Main); } main main(main main) { return new main(main); } public static void main(main...Main) { main: for (main main : Main) { main = (main instanceof Main) ? new main(main): main.main(main); break main; } } public static void main(String[] args) { main = new main("main"); main.main(main, main); main = main.new Main(main) { main main(main main) { return ((Main)main).main(); } }; main.main(main); main.main(main,main); } abstract class Main extends main { Main(main main) { super("main"); } main main() { main.Main = "Main"; return main; } } }
public class Main { private static String main; public static void main(String[] main) { Main.main = main[0]; new Main().main(Main.main); } private void main(String main) { System.out.println(main); } }
option b and c boths are valid, because main is not a keyword or reserve word it option a,d and e is invalid because you cant declare the identifiers with which have start with number or special character(except _ and $). you can declare - abc_123,_abc,$abc but can
@Bean @Scope("prototype") public SomeService someService() { switch (state) { case 1: return new Impl1(); case 2: return new Impl2(); case 3: return new Impl3(); default: return new Impl(); } }
@Configuration public class ApplicationConfig { @Bean public User adminUserProfile() { return new User("Rami","Nassar"); } }
@Component public class SomeClass { private int number; public SomeClass(Integer theNumber){ this.number = theNumber.intValue(); } public int getNumber(){ return this.number; } }
@Bean Integer theNumber(){ return new Integer(3456); }
public class SomeClass { private int number; public SomeClass(Integer theNumber){ this.number = theNumber.intValue(); } public int getNumber(){ return this.number; } }
@Bean Integer theNumber(){ return new Integer(3456); } @Bean SomeClass someClass(Integer theNumber){ return new SomeClass(theNumber); }
@Bean SomeClass strawberryClass(){ return new SomeClass(new Integer(1)); }
@Override public int hashCode() { return Objects.hashCode(this.firstName, this.lastName); }
@Override public int hashCode() { int result = 17; result = 31 * result + (booleanField ? 1 : 0); result = 31 * result + byteField; result = 31 * result + charField; result = 31 * result + shortField; result = 31 * result + intField; result = 31 * result + (int)(longField ^ (longField >>> 32)); result = 31 * result + Float.floatToIntBits(floatField); long doubleFieldBits = Double.doubleToLongBits(doubleField); result = 31 * result + (int)(doubleFieldBits ^ (doubleFieldBits >>> 32)); result = 31 * result + Arrays.hashCode(arrayField); result = 31 * result + referenceField.hashCode(); result = 31 * result + (nullableReferenceField == null ? 0 : nullableReferenceField.hashCode()); return result; }
@Override public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof MyType)) { return false; } MyType lhs = (MyType) o; return booleanField == lhs.booleanField && byteField == lhs.byteField && charField == lhs.charField && shortField == lhs.shortField && intField == lhs.intField && longField == lhs.longField && floatField == lhs.floatField && doubleField == lhs.doubleField && Arrays.equals(arrayField, lhs.arrayField) && referenceField.equals(lhs.referenceField) && (nullableReferenceField == null ? lhs.nullableReferenceField == null : nullableReferenceField.equals(lhs.nullableReferenceField)); }
public int hashCode() { int hashCode = 1; Iterator i = iterator(); while (i.hasNext()) { Object obj = i.next(); hashCode = 31*hashCode + (obj==null ? 0 : obj.hashCode()); } return hashCode; }
public int hashCode(){ return intMember ^ (stringField != null ? stringField.hashCode() : 0); }
Zam obj1 = new Zam("foo", "bar", "baz"); Zam obj2 = new Zam("fo", "obar", "baz");
public int hashCode() { return (getFoo().hashCode() + getBar().hashCode()).toString().hashCode();
public static int hash(final Object... objects) { return Arrays.deepHashCode(objects); }
import java.util.Objects; public class Demo { public static class A { private final String param1; public A(final String param1) { this.param1 = param1; } @Override public int hashCode() { return Objects.hash( super.hashCode(), this.param1); } } public static class B extends A { private final String param2; private final String param3; public B( final String param1, final String param2, final String param3) { super(param1); this.param2 = param2; this.param3 = param3; } @Override public final int hashCode() { return Objects.hash( super.hashCode(), this.param2, this.param3); } } public static void main(String [] args) { A a = new A("A"); B b = new B("A", "B", "C"); System.out.println("A: " + a.hashCode()); System.out.println("B: " + b.hashCode()); } }
class ListPair { List<Integer> first; List<Integer> second; ListPair(List<Integer> first, List<Integer> second) { this.first = first; this.second = second; } public int hashCode() { return Objects.hashCode(first, second); } ... }
seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
public class Zam { private String foo; private String bar; private String somethingElse; public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } Zam otherObj = (Zam)obj; if ((getFoo() == null && otherObj.getFoo() == null) || (getFoo() != null && getFoo().equals(otherObj.getFoo()))) { if ((getBar() == null && otherObj. getBar() == null) || (getBar() != null && getBar().equals(otherObj. getBar()))) { return true; } } return false; } public int hashCode() { return (getFoo() + getBar()).hashCode(); } public String getFoo() { return foo; } public String getBar() { return bar; } }
boolean doubleBackToExitPressedOnce = false; @Override public void onBackPressed() { if (doubleBackToExitPressedOnce) { super.onBackPressed(); return; } this.doubleBackToExitPressedOnce = true; Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { doubleBackToExitPressedOnce=false; } }, 2000); }
private var doubleBackToExitPressedOnce = false override fun onBackPressed() { if (doubleBackToExitPressedOnce) { super.onBackPressed() return } this.doubleBackToExitPressedOnce = true Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT).show() Handler().postDelayed(Runnable { doubleBackToExitPressedOnce = false }, 2000) }
private static final int TIME_INTERVAL = 2000; private long mBackPressed; @Override public void onBackPressed() { if (mBackPressed + TIME_INTERVAL > System.currentTimeMillis()) { super.onBackPressed(); return; } else { Toast.makeText(getBaseContext(), "Tap back button in order to exit", Toast.LENGTH_SHORT).show(); } mBackPressed = System.currentTimeMillis(); }
private boolean doubleBackToExitPressedOnce; private Handler mHandler = new Handler(); private final Runnable mRunnable = new Runnable() { @Override public void run() { doubleBackToExitPressedOnce = false; } }; @Override protected void onDestroy() { super.onDestroy(); if (mHandler != null) { mHandler.removeCallbacks(mRunnable); } } @Override public void onBackPressed() { if (doubleBackToExitPressedOnce) { super.onBackPressed(); return; } this.doubleBackToExitPressedOnce = true; Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT).show(); mHandler.postDelayed(mRunnable, 2000); }
private boolean doubleBackToExitPressedOnce = false; @Override protected void onResume() { super.onResume(); this.doubleBackToExitPressedOnce = false; } @Override public void onBackPressed() { if (doubleBackToExitPressedOnce) { super.onBackPressed(); return; } this.doubleBackToExitPressedOnce = true; Toast.makeText(this, R.string.exit_press_back_twice_message, Toast.LENGTH_SHORT).show(); }
private long lastPressedTime; private static final int PERIOD = 2000; @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) { switch (event.getAction()) { case KeyEvent.ACTION_DOWN: if (event.getDownTime() - lastPressedTime < PERIOD) { finish(); } else { Toast.makeText(getApplicationContext(), "Press again to exit.", Toast.LENGTH_SHORT).show(); lastPressedTime = event.getEventTime(); } return true; } } return false; }
long back_pressed; @Override public void onBackPressed() { if (back_pressed + 1000 > System.currentTimeMillis()){ super.onBackPressed(); } else{ Toast.makeText(getBaseContext(), "Press once again to exit!", Toast.LENGTH_SHORT) .show(); } back_pressed = System.currentTimeMillis(); }
package com.mehuljoisar.d_pressbacktwicetoexit; import android.os.Bundle; import android.os.Handler; import android.app.Activity; import android.widget.Toast; public class MainActivity extends Activity { private static final long delay = 2000L; private boolean mRecentlyBackPressed = false; private Handler mExitHandler = new Handler(); private Runnable mExitRunnable = new Runnable() { @Override public void run() { mRecentlyBackPressed=false; } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public void onBackPressed() { if (mRecentlyBackPressed) { mExitHandler.removeCallbacks(mExitRunnable); mExitHandler = null; super.onBackPressed(); } else { mRecentlyBackPressed = true; Toast.makeText(this, "press again to exit", Toast.LENGTH_SHORT).show(); mExitHandler.postDelayed(mExitRunnable, delay); } } }
Snackbar mSnackbar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final LinearLayout layout = findViewById(R.id.layout_main); mSnackbar = Snackbar.make(layout, R.string.press_back_again, Snackbar.LENGTH_SHORT); } @Override public void onBackPressed() { if (mSnackbar.isShown()) { super.onBackPressed(); } else { mSnackbar.show(); } }
public void onBackPressed() { if (doubleBackToExitPressedOnce) { super.onBackPressed(); return; } this.doubleBackToExitPressedOnce = true; Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { doubleBackToExitPressedOnce=false; } }, 2000);
private static long back_pressed_time; private static long PERIOD = 2000; @Override public void onBackPressed() { if (back_pressed_time + PERIOD > System.currentTimeMillis()) super.onBackPressed(); else Toast.makeText(getBaseContext(), "Press once again to exit!", Toast.LENGTH_SHORT).show(); back_pressed_time = System.currentTimeMillis(); }
boolean doubleBackToExitPressedOnce = false; @Override public void onBackPressed() { if (doubleBackToExitPressedOnce) { super.onBackPressed(); return; } this.doubleBackToExitPressedOnce = true; Snackbar.make(findViewById(R.id.photo_album_parent_view), "Please click BACK again to exit", Snackbar.LENGTH_SHORT).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { doubleBackToExitPressedOnce=false; } }, 2000); }
@Override public void onBackPressed() { if (exitToast.getView().isShown()) { exitToast.cancel(); finish(); } else { exitToast.show(); } }
private static final long BACK_PRESS_DELAY = 1000; private boolean mBackPressCancelled = false; private long mBackPressTimestamp; private Toast mBackPressToast; @Override public void onBackPressed() { if (!mBackPressCancelled) { if (getSupportFragmentManager().getBackStackEntryCount() > 0) { super.onBackPressed(); } else { if (mBackPressToast != null) { mBackPressToast.cancel(); } long currentTimestamp = System.currentTimeMillis(); if (currentTimestamp < mBackPressTimestamp + BACK_PRESS_DELAY) { super.onBackPressed(); } else { mBackPressTimestamp = currentTimestamp; mBackPressToast = Toast.makeText(this, getString(R.string.warning_exit), Toast.LENGTH_SHORT); mBackPressToast.show(); } } } }
@Override public boolean onKeyDown(int keyCode, KeyEvent event) { if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.ECLAIR && keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) { onBackPressed(); } return super.onKeyDown(keyCode, event); }
exitToast = Toast.makeText(this, "Press again to exit", Toast.LENGTH_SHORT); . . @Override public void onBackPressed() { if (exitToast.getView().getWindowToken() == null) exitToast.show(); else { finish(); exitToast.cancel(); } }
@Override public void onBackPressed() { ++k; if(k==1){ Toast.makeText(this, "Press back one more time to exit", Toast.LENGTH_LONG).show(); }else{ finish(); } }
boolean doubleBackToExitPressedOnce = false; @Override public void onBackPressed() { if (doubleBackToExitPressedOnce) { Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_HOME); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); finish(); System.exit(0); return; } this.doubleBackToExitPressedOnce = true; Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { doubleBackToExitPressedOnce=false; } }, 2000); }
@Override public void onBackPressed() { Log.d("CDA", "onBackPressed Called"); Intent intent = new Intent(); intent.setAction(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_HOME); startActivity(intent); }
private long onRecentBackPressedTime; @Override public void onBackPressed() { if (System.currentTimeMillis() - onRecentBackPressedTime > 2000) { onRecentBackPressedTime = System.currentTimeMillis(); Toast.makeText(this, "Please press BACK again to exit", Toast.LENGTH_SHORT).show(); return; } super.onBackPressed(); }
private boolean backPressedOnce = false; private Handler statusUpdateHandler; private Runnable statusUpdateRunnable; public void onBackPressed() { if (backPressedOnce) { finish(); } backPressedOnce = true; final Toast toast = Toast.makeText(this, "Press again to exit", Toast.LENGTH_SHORT); toast.show(); statusUpdateRunnable = new Runnable() { @Override public void run() { backPressedOnce = false; toast.cancel(); } }; statusUpdateHandler.postDelayed(statusUpdateRunnable, 2000); } @Override protected void onDestroy() { super.onDestroy(); if (statusUpdateHandler != null) { statusUpdateHandler.removeCallbacks(statusUpdateRunnable); } }
private Handler tapHandler; private Runnable tapRunnable; private int mTapCount = 0; private int milSecDealy = 2000; onCreate(){ ... tapHandler = new Handler(Looper.getMainLooper()); }
private void askToExit() { if (mTapCount >= 2) { releaseTapValues(); } mTapCount++; validateTapCount(); } private void validateTapCount() { if (tapRunnable == null) { tapRunnable = new Runnable() { @Override public void run() { releaseTapValues(); } }; tapHandler.postDelayed(tapRunnable, milSecDealy); } } private void releaseTapValues() { if (tapHandler != null) { tapHandler.removeCallbacks(tapRunnable); tapRunnable = null; mTapCount = 0; } } @Override protected void onDestroy() { super.onDestroy(); releaseTapValues(); }
@Override public void onBackPressed() { DrawerLayout drawer = findViewById(R.id.drawer_layout); if (drawer.isDrawerOpen(GravityCompat.END)) { drawer.closeDrawer(GravityCompat.END); } else { if (doubleBackToExitPressedOnce) { super.onBackPressed(); moveTaskToBack(true); return; } else { this.doubleBackToExitPressedOnce = true; Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { doubleBackToExitPressedOnce = false; } }, 2000); } } }
private Boolean exit = false; if (exit) { onBackPressed(); }
@Override public void onBackPressed() { if (exit) { finish(); } else { Toast.makeText(this, "Press Back again to Exit.", Toast.LENGTH_SHORT).show(); exit = true; new Handler().postDelayed(new Runnable() { @Override public void run() { exit = false; } }, 3 * 1000); } }
private var exit = false if (exit) { onBackPressed() }
override fun onBackPressed(){ if (exit){ finish() }else{ Toast.makeText(this, "Press Back again to Exit.", Toast.LENGTH_SHORT).show() exit = true Handler().postDelayed({ exit = false }, 3 * 1000) } }
boolean doubleBackToExitPressedOnce = false; @Override public void onBackPressed() { if (doubleBackToExitPressedOnce) { super.onBackPressed(); return; } this.doubleBackToExitPressedOnce = true; Snackbar.make(findViewById(R.id.photo_album_parent_view), "Please click BACK again to exit", Snackbar.LENGTH_SHORT).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { doubleBackToExitPressedOnce=false; } }, 2000); }
boolean doubleBackToExitPressedOnce = false; Handler myHandler; Runnable myRunnable; Toast myToast; @Override public void onBackPressed() { if (doubleBackToExitPressedOnce) { myHandler.removeCallbacks(myRunnable); myToast.cancel(); super.onBackPressed(); return; } this.doubleBackToExitPressedOnce = true; myToast = Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT); myToast.show(); myHandler = new Handler(); myRunnable = new Runnable() { @Override public void run() { doubleBackToExitPressedOnce = false; } }; myHandler.postDelayed(myRunnable, 2000); }
long previousTime; @Override public void onBackPressed() { if (2000 + previousTime > (previousTime = System.currentTimeMillis())) { super.onBackPressed(); } else { Toast.makeText(getBaseContext(), "Tap back button in order to exit", Toast.LENGTH_SHORT).show(); } }
boolean doubleBackToExitPressedOnce = false; @Override public void onBackPressed() { if (doubleBackToExitPressedOnce) { super.onBackPressed(); return; } this.doubleBackToExitPressedOnce = true; Snackbar.make(content, "Please click BACK again to exit", Snackbar.LENGTH_SHORT) .setAction("Action", null).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { doubleBackToExitPressedOnce=false; } }, 2000); }
private Snackbar exitSnackBar; @Override public void onBackPressed() { if (isNavDrawerOpen()) { closeNavDrawer(); } else if (getSupportFragmentManager().getBackStackEntryCount() == 0) { if (exitSnackBar != null && exitSnackBar.isShown()) { super.onBackPressed(); } else { exitSnackBar = Snackbar.make( binding.getRoot(), R.string.navigation_exit, 2000 ); exitSnackBar.show(); } } else { super.onBackPressed(); } }
boolean doubleBackToExitPressedOnce = false; @Override public void onBackPressed() { DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); if (drawer.isDrawerOpen(GravityCompat.START)) { drawer.closeDrawer(GravityCompat.START); } else { if (doubleBackToExitPressedOnce) { if (getFragmentManager().getBackStackEntryCount() ==0) { finishAffinity(); System.exit(0); } else { getFragmentManager().popBackStackImmediate(); } return; } if (getFragmentManager().getBackStackEntryCount() ==0) { this.doubleBackToExitPressedOnce = true; Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { doubleBackToExitPressedOnce = false; } }, 2000); } else { getFragmentManager().popBackStackImmediate(); } } }
import android.app.Activity; import android.support.annotation.StringRes; import android.widget.Toast; public class ExitApp { private static long lastClickTime; public static void now(Activity ctx, @StringRes int message) { now(ctx, ctx.getString(message), 2500); } public static void now(Activity ctx, @StringRes int message, long time) { now(ctx, ctx.getString(message), time); } public static void now(Activity ctx, String message, long time) { if (ctx != null && !message.isEmpty() && time != 0) { if (lastClickTime + time > System.currentTimeMillis()) { ctx.finish(); } else { Toast.makeText(ctx, message, Toast.LENGTH_SHORT).show(); lastClickTime = System.currentTimeMillis(); } } } }
@Override public void onBackPressed() { ExitApp.now(this,"Press again for close"); }
private boolean exit = false; @Override public void onBackPressed() { if (exit) { finish(); } else { Toast.makeText(this, "Press back again to exit", Toast.LENGTH_SHORT).show(); exit = true; new CountDownTimer(3000,1000) { @Override public void onTick(long l) { } @Override public void onFinish() { exit = false; } }.start(); } }
class Hello { class Thing { public int size; Thing() { size = 0; } } public static void main(String[] args) { Thing thing1 = new Thing(); System.out.println("Hello, World!"); } }
public static void main(String[] args) { Hello h = new Hello(); Thing thing1 = h.new Thing(); }
public class MyInnerClass { public static void main(String args[]) throws InterruptedException { new MyInnerClass.StaticInnerClass().staticInnerClassMethod(); StaticInnerClass staticInnerclass = new StaticInnerClass(); staticInnerclass.staticInnerClassMethod(); LocalInnerClass localInnerClass = new MyInnerClass().new LocalInnerClass(); localInnerClass.localInnerClassMethod(); /* * Pay attention to the opening curly braces and the fact that there * semicolon at the very end, once the anonymous class is created: */ /* AnonymousClass anonymousClass = new AnonymousClass() { };*/ } static class StaticInnerClass { public void staticInnerClassMethod() { System.out.println("Hay... from Static Inner class!"); } } class LocalInnerClass { public void localInnerClassMethod() { System.out.println("Hay... from local Inner class!"); } } }
public class PQ { public static void main(String[] args) { Dog dog = new PQ().new Dog(); PQ pq = new PQ(); Dog dog1 = pq.new Dog(); } abstract class Animal { abstract void checkup(); } class Dog extends Animal { @Override void checkup() { System.out.println("Dog checkup"); } } class Cat extends Animal { @Override void checkup() { System.out.println("Cat Checkup"); } } }
private final ReentrantLock lock = new ReentrantLock(); private static List<Integer> ints; public Integer getResult(String name) { . . . lock.lock(); try { if (ints.size()==3) { ints=null; return -9; } for (int x=0; x<ints.size(); x++) { System.out.println("["+name+"] "+x+"/"+ints.size()+". values >>>>"+ints.get(x)); } } finally { lock.unlock(); } return random; }
private ReentrantLock lock; public void foo() { ... lock.lock(); ... } public void bar() { ... lock.unlock(); ... }
private final ReentrantLock lock = new ReentrantLock(true);
private static ReentrantLock lock = new ReentrantLock(); void accessResource() { lock.lock(); if( checkSomeCondition() ) { accessResource(); } lock.unlock(); }
@Entity public class User { @Id private int id; private UUID uuid; private String screenName; private String email; public User() { } @PrePersist public void ensureUuid() { if (getUuid() == null) { log.warn(format("User + "uuid: %s, name: %s, email: %s", getUuid(), getScreenName(), getEmail())); setUuid(UUID.randomUUID()); } } @Override public int hashCode() { return getUuid().hashCode(); } @Override public boolean equals(final Object obj) { if (this == obj) return true; if (!(obj instanceof User)) return false; return getUuid().equals(((User) obj).getUuid()); } }
User user = new User(); user.setName("Master Yoda"); user.setEmail("yoda@jedicouncil.org"); jediSet.add(user); em.persist(user); jediCouncilSet.add(user);
User user = new User(); user.setUuid(UUID.randomUUID());
@Entity public class User { @Id private int id; private UUID uuid; ... public User() { } public User(UUID uuid) { setUuid(uuid); } ... }
User user = new User(UUID.randomUUID()); ... jediSet.add(user); em.persist(user);
@Entity public class Book implements Identifiable<Long> { @Id @GeneratedValue private Long id; private String title; @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Book)) return false; Book book = (Book) o; return getId() != null && Objects.equals(getId(), book.getId()); } @Override public int hashCode() { return 31; } }
@MappedSuperclass public abstract class AbstractJpaEntity extends AbstractMutable implements Identifiable, Modifiable { private static final long serialVersionUID = 1L; @Version @Column(name = "version", nullable = false) private int version = 0; @Column(name = "uuid_least_sig_bits") private long uuidLeastSigBits = 0; @Column(name = "uuid_most_sig_bits") private long uuidMostSigBits = 0; private transient int hashCode = 0; public AbstractJpaEntity() { // } public abstract Integer getId(); public abstract void setId(final Integer id); public boolean isPersisted() { return getId() != null; } public int getVersion() { return version; } private void initUUID() { final UUID uuid = UUID.randomUUID(); uuidLeastSigBits = uuid.getLeastSignificantBits(); uuidMostSigBits = uuid.getMostSignificantBits(); } public long getUuidLeastSigBits() { if (uuidMostSigBits == 0) { initUUID(); } return uuidLeastSigBits; } public long getUuidMostSigBits() { if (uuidMostSigBits == 0) { initUUID(); } return uuidMostSigBits; } public UUID getUuid() { return new UUID(getUuidMostSigBits(), getUuidLeastSigBits()); } @Override public int hashCode() { if (hashCode == 0) { hashCode = (int) (getUuidMostSigBits() >> 32 ^ getUuidMostSigBits() ^ getUuidLeastSigBits() >> 32 ^ getUuidLeastSigBits()); } return hashCode; } @Override public boolean equals(final Object obj) { if (obj == null) { return false; } if (!(obj instanceof AbstractJpaEntity)) { return false; } final AbstractJpaEntity entity = (AbstractJpaEntity) obj; return getUuidMostSigBits() == entity.getUuidMostSigBits() && getUuidLeastSigBits() == entity.getUuidLeastSigBits(); } @PrePersist public void prePersist() { getUuidLeastSigBits(); } }
@MappedSuperclass abstract public class Entity implements Serializable { @Id @GeneratedValue @Column(nullable = false, updatable = false) protected Long id; @Transient private Long tempId; public void setId(Long id) { this.id = id; } public Long getId() { return id; } private void setTempId(Long tempId) { this.tempId = tempId; } private Long getTempId() { if (tempId == null) setTempId(getId() == null ? 0 : getId()); return tempId; } @Override public boolean equals(Object obj) { if (super.equals(obj)) return true; if (obj == null || !Hibernate.getClass(obj).equals(this.getClass())) return false; Entity o = (Entity) obj; return getTempId() != 0 && o.getTempId() != 0 && getTempId().equals(o.getTempId()); } @Override public int hashCode() { return getTempId() == 0 ? super.hashCode() : getTempId().hashCode(); } }
@MappedSuperclass public abstract class AbstractPersistable<K extends Serializable> { @Id @GeneratedValue private K id; @Transient private final String kind; public AbstractPersistable(final String kind) { this.kind = requireNonNull(kind, "Entity kind cannot be null"); } @Override public final boolean equals(final Object obj) { if (this == obj) return true; if (!(obj instanceof AbstractPersistable)) return false; final AbstractPersistable<?> that = (AbstractPersistable<?>) obj; return null != this.id && Objects.equals(this.id, that.id) && Objects.equals(this.kind, that.kind); } @Override public final int hashCode() { return Objects.hash(kind, id); } public K getId() { return id; } protected void setId(final K id) { this.id = id; } }
static class Foo extends AbstractPersistable<Long> { public Foo() { super("Foo"); } }
@Test public void test_EqualsAndHashcode_GivenSubclass() { EqualsVerifier.forClass(Foo.class) .suppress(Warning.NONFINAL_FIELDS, Warning.TRANSIENT_FIELDS) .withOnlyTheseFields("id", "kind") .withNonnullFields("id", "kind") .verify(); assertNotEquals(new Foo(), new Foo()); }
@Entity class Parent { @Id @GeneratedValue Long id; @NaturalId UUID uuid; @OneToMany(mappedBy = "parent") Set<Child> children; } @Entity class Child { @EmbeddedId ChildId id; @ManyToOne Parent parent; @Embeddable class ChildId { UUID parentUuid; UUID childUuid; } }
@Entity class Parent { @Id @GeneratedValue Long id; @OneToMany(mappedBy = "parent") Set<Child> children; } @Entity class Child { @EmbeddedId ChildId id; @ManyToOne Parent parent; @PrePersist void postPersist() { parent.children.remove(this); } @PostPersist void postPersist() { parent.children.add(this); } @Embeddable class ChildId { Long parentId; @GeneratedValue Long childId; } }
@ManagedBean public class MyCarFacade { public Car createCar(){ Car car = new Car(); em.persist(car); return car; } }
public class MyEntity { @Id() @Column(name = "ID", length = 20, nullable = false, unique = true) @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id = null; @Transient private UUID uuid = null; @Column(name = "UUID_MOST", nullable = true, unique = false, updatable = false) private Long uuidMostSignificantBits = null; @Column(name = "UUID_LEAST", nullable = true, unique = false, updatable = false) private Long uuidLeastSignificantBits = null; @Override public final int hashCode() { return this.getUuid().hashCode(); } @Override public final boolean equals(Object toBeCompared) { if(this == toBeCompared) { return true; } if(toBeCompared == null) { return false; } if(!this.getClass().isInstance(toBeCompared)) { return false; } return this.getUuid().equals(((MyEntity)toBeCompared).getUuid()); } public final UUID getUuid() { if(this.uuid != null) { return this.uuid; } if(this.uuidMostSignificantBits != null) { this.uuid = new UUID(this.uuidMostSignificantBits, this.uuidLeastSignificantBits); } else if(this.getId() != null) { this.uuid = new UUID(this.getId(), this.getId()); } else { this.setUuid(UUID.randomUUID()); } return this.uuid; } private void setUuid(UUID uuid) { if(uuid == null) { return; } if(uuid.getMostSignificantBits() == uuid.getLeastSignificantBits()) { throw new Exception("UUID: " + this.getUuid() + " format is only for internal use"); } this.uuidMostSignificantBits = uuid.getMostSignificantBits(); this.uuidLeastSignificantBits = uuid.getLeastSignificantBits(); this.uuid = uuid; }
public boolean equals(Object obj) { if (null == obj) { return false; } if (this == obj) { return true; } if (!getClass().equals(ClassUtils.getUserClass(obj))) { return false; } AbstractPersistable<?> that = (AbstractPersistable<?>) obj; return null == this.getId() ? false : this.getId().equals(that.getId()); } @Override public int hashCode() { int hashCode = 17; hashCode += null == getId() ? 0 : getId().hashCode() * 31; return hashCode; }
import javax.persistence._ import scala.util.Random @Entity @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) abstract class UUIDEntity { @Id @GeneratedValue(strategy = GenerationType.TABLE) var id:java.lang.Long=null var uuid:java.lang.Long=Random.nextLong() override def equals(o:Any):Boolean= o match{ case o : UUIDEntity => o.uuid==uuid case _ => false } override def hashCode() = uuid.hashCode() }
ArrayList<Thing> basket = new ArrayList<Thing>(); Thing thing = new Thing(100); basket.add(thing); Thing another = new Thing(100); basket.contains(another);
class Thing { public int value; public Thing (int x) { value = x; } equals (Thing x) { if (x.value == value) return true; return false; } }
public class Thing { public int value; public Thing (int x) { this.value = x; } @Override public boolean equals(Object object) { boolean sameSame = false; if (object != null && object instanceof Thing) { sameSame = this.value == ((Thing) object).value; } return sameSame; } }
class Thing { public int value; public Thing (int x) { value = x; } equals (Thing x) { if (x.value == value) return true; return false; } }
class Thing { public int value; public Thing (int x) { value = x; } public boolean equals (Object o) { Thing x = (Thing) o; if (x.value == value) return true; return false; } }
public class Thing { public Object value; public Thing (Object x) { this.value = x; } @Override public boolean equals(Object object) { boolean sameSame = false; if (object != null && object instanceof Thing) { sameSame = this.value == ((Thing) object).value; } return sameSame; } }
public class Thing { public Object value; public Thing (Object x) { value = x; } @Override public boolean equals(Object object) { if (object != null && object instanceof Thing) { Thing thing = (Thing) object; if (value == null) { return (thing.value == null); } else { return value.equals(thing.value); } } return false; } }
https%3A%2F%2Fmywebsite%2Fdocs%2Fenglish%2Fsite%2Fmybook.do%3Frequest_type
class StringUTF { public static void main(String[] args) { try{ String url = "https%3A%2F%2Fmywebsite%2Fdocs%2Fenglish%2Fsite%2Fmybook.do" + "%3Frequest_type%3D%26type%3Dprivate"; System.out.println(url+"Hello World!------->" + new String(url.getBytes("UTF-8"),"ASCII")); } catch(Exception E){ } } }
String result = java.net.URLDecoder.decode(url, "UTF-8");
String url = "https%3A%2F%2Fmywebsite%2Fdocs%2Fenglish%2Fsite%2Fmybook.do%3Frequest_type"; System.out.println(new java.net.URI(url).getPath());
String decoded = java.net.URLDecoder.decode(url, "UTF-8");
try { String result = URLDecoder.decode(urlString, "UTF-8"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); }
public String decodeString(String URL) { String urlString=""; try { urlString = URLDecoder.decode(URL,"UTF-8"); } catch (UnsupportedEncodingException e) { } return urlString; }
import java.io.UnsupportedEncodingException; import java.net.URISyntaxException; public class URLDecoding { String decoded = ""; public String decodeMethod(String url) throws UnsupportedEncodingException { decoded = java.net.URLDecoder.decode(url, "UTF-8"); return decoded; } public String getPathMethod(String url) throws URISyntaxException { decoded = new java.net.URI(url).getPath(); return decoded; } public static void main(String[] args) throws UnsupportedEncodingException, URISyntaxException { System.out.println(" Here is your Decoded url with decode method : "+ new URLDecoding().decodeMethod("https%3A%2F%2Fmywebsite%2Fdocs%2Fenglish%2Fsite%2Fmybook.do%3Frequest_type")); System.out.println("Here is your Decoded url with getPath method : "+ new URLDecoding().getPathMethod("https%3A%2F%2Fmywebsite%2Fdocs%2Fenglish%2Fsite%2Fmybook.do%3Frequest")); } }
public static String decode(String url) { try { String prevURL=""; String decodeURL=url; while(!prevURL.equals(decodeURL)) { prevURL=decodeURL; decodeURL=URLDecoder.decode( decodeURL, "UTF-8" ); } return decodeURL; } catch (UnsupportedEncodingException e) { return "Issue while decoding" +e.getMessage(); } }
import javax.script.ScriptEngineManager; import javax.script.ScriptEngine; import javax.script.ScriptException; public class Test { public static void main(String[] args) throws ScriptException { ScriptEngineManager mgr = new ScriptEngineManager(); ScriptEngine engine = mgr.getEngineByName("JavaScript"); String foo = "40+2"; System.out.println(engine.eval(foo)); } }
public static double eval(final String str) { return new Object() { int pos = -1, ch; void nextChar() { ch = (++pos < str.length()) ? str.charAt(pos) : -1; } boolean eat(int charToEat) { while (ch == if (ch == charToEat) { nextChar(); return true; } return false; } double parse() { nextChar(); double x = parseExpression(); if (pos < str.length()) throw new RuntimeException("Unexpected: " + (char)ch); return x; } double parseExpression() { double x = parseTerm(); for (;;) { if (eat( else if (eat( else return x; } } double parseTerm() { double x = parseFactor(); for (;;) { if (eat( else if (eat( else return x; } } double parseFactor() { if (eat( if (eat( double x; int startPos = this.pos; if (eat( x = parseExpression(); eat( } else if ((ch >= while ((ch >= x = Double.parseDouble(str.substring(startPos, this.pos)); } else if (ch >= while (ch >= String func = str.substring(startPos, this.pos); x = parseFactor(); if (func.equals("sqrt")) x = Math.sqrt(x); else if (func.equals("sin")) x = Math.sin(Math.toRadians(x)); else if (func.equals("cos")) x = Math.cos(Math.toRadians(x)); else if (func.equals("tan")) x = Math.tan(Math.toRadians(x)); else throw new RuntimeException("Unknown function: " + func); } else { throw new RuntimeException("Unexpected: " + (char)ch); } if (eat( return x; } }.parse(); }
System.out.println(eval("((4 - 2^3 + 1) * -sqrt(3*3+4*4)) / 2"));
@FunctionalInterface interface Expression { double eval(); }
Expression parseExpression() { Expression x = parseTerm(); for (;;) { if (eat( Expression a = x, b = parseTerm(); x = (() -> a.eval() + b.eval()); } else if (eat( Expression a = x, b = parseTerm(); x = (() -> a.eval() - b.eval()); } else { return x; } } }
public static void main(String[] args) { Map<String,Double> variables = new HashMap<>(); Expression exp = parse("x^2 - x + 2", variables); for (double x = -20; x <= +20; x++) { variables.put("x", x); System.out.println(x + " => " + exp.eval()); } }
Interpreter interpreter = new Interpreter(); interpreter.eval("result = (7+21*6)/(32-27)"); System.out.println(interpreter.get("result"));
Class. forName("org.sqlite.JDBC"); Connection conn = DriverManager.getConnection("jdbc:sqlite::memory:"); Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery( "select (1+10)/20.0 amount"); rs.next(); System.out.println(rs.getBigDecimal(1)); stat.close(); conn.close();
ResultSet rs = stat.executeQuery( "select (1+10)/20.0 amount, (1+100)/20.0 amount2");
Expression e = new Expression("( 2 + 3/4 + sin(pi) )/2"); double v = e.calculate()
Argument x = new Argument("x = 10"); Constant a = new Constant("a = pi^2"); Expression e = new Expression("cos(a*x)", x, a); double v = e.calculate()
Function f = new Function("f(x, y, z) = sin(x) + cos(y*z)"); Expression e = new Expression("f(3,2,5)", f); double v = e.calculate()
Expression e = new Expression("sum( i, 1, 100, sin(i) )"); double v = e.calculate()
ExpressionParser parser = new SpelExpressionParser(); int two = parser.parseExpression("1 + 1").getValue(Integer.class); double twentyFour = parser.parseExpression("2.0 * 3e0 * 4").getValue(Double.class);
ExpressionsEvaluator evalExpr = ExpressionsFactory.create("2+3*4-6/2"); assertEquals(BigDecimal.valueOf(11), evalExpr.eval());
String math = "1+4"; if (math.split("+").length == 2) { } else if (math.split("-").length == 2) { } ...
1 While the thing on top of the operator stack is not a left parenthesis, 1 Pop the operator from the operator stack. 2 Pop the value stack twice, getting two operands. 3 Apply the operator to the operands, in the correct order. 4 Push the result onto the value stack. 2 Pop the left parenthesis from the operator stack, and discard it.
1 While the operator stack is not empty, and the top thing on the operator stack has the same or greater precedence as thisOp, 1 Pop the operator from the operator stack. 2 Pop the value stack twice, getting two operands. 3 Apply the operator to the operands, in the correct order. 4 Push the result onto the value stack. 2 Push thisOp onto the operator stack.
ExprEvaluator util = new ExprEvaluator(); IExpr result = util.evaluate("10-40"); System.out.println(result.toString());
IAST function = D(Times(Sin(x), Cos(x)), x); IExpr result = util.evaluate(function);
public static double eval(final String str) { return new Object() { int pos = -1, ch; void nextChar() { ch = (++pos < str.length()) ? str.charAt(pos) : -1; } boolean eat(int charToEat) { while (ch == if (ch == charToEat) { nextChar(); return true; } return false; } double parse() { nextChar(); double x = parseExpression(); if (pos < str.length()) throw new RuntimeException("Unexpected: " + (char)ch); return x; } double parseExpression() { double x = parseTerm(); for (;;) { if (eat( else if (eat( else return x; } } double parseTerm() { double x = parseFactor(); for (;;) { if (eat( else if (eat( else if (eat( else return x; } } double parseFactor() { if (eat( if (eat( double x; int startPos = this.pos; if (eat( x = parseExpression(); eat( } else if ((ch >= while ((ch >= x = Double.parseDouble(str.substring(startPos, this.pos)); } else if (ch >= while (ch >= String func = str.substring(startPos, this.pos); x = parseFactor(); if (func.equals("sqrt")) x = Math.sqrt(x); else if (func.equals("sin")) x = Math.sin(Math.toRadians(x)); else if (func.equals("cos")) x = Math.cos(Math.toRadians(x)); else if (func.equals("tan")) x = Math.tan(Math.toRadians(x)); else throw new RuntimeException("Unknown function: " + func); } else { throw new RuntimeException("Unexpected: " + (char)ch); } return x; } }.parse(); }
import javax.script.ScriptEngine; import javax.script.ScriptEngineManager; public class EvalUtil { private static ScriptEngine engine = new ScriptEngineManager().getEngineByName("JavaScript"); public static void main(String[] args) { try { System.out.println((new EvalUtil()).eval("(((5+5)/2) > 5) || 5 >3 ")); System.out.println((new EvalUtil()).eval("(((5+5)/2) > 5) || true")); } catch (Exception e) { e.printStackTrace(); } } public Object eval(String input) throws Exception{ try { if(input.matches(".*[a-zA-Z;~` throw new Exception("Invalid expression : " + input ); } return engine.eval(input); } catch (Exception e) { e.printStackTrace(); throw e; } } }
package ExpressionCalculator.expressioncalculator; import java.text.DecimalFormat; import java.util.Scanner; public class ExpressionCalculator { private static String addSpaces(String exp){ exp = exp.replaceAll("(?<=[0-9()])[\\/]", " / "); exp = exp.replaceAll("(?<=[0-9()])[\\^]", " ^ "); exp = exp.replaceAll("(?<=[0-9()])[\\*]", " * "); exp = exp.replaceAll("(?<=[0-9()])[+]", " + "); exp = exp.replaceAll("(?<=[0-9()])[-]", " - "); /*while(exp.indexOf(" ") != -1){ exp = exp.replace(" ", " "); }*/ exp = exp.replaceAll(" {2,}", " "); return exp; } public static Double evaluate(String expr){ DecimalFormat df = new DecimalFormat(" String expression = addSpaces(expr); try { int indexClose = expression.indexOf(")"); int indexOpen = -1; if (indexClose != -1) { String substring = expression.substring(0, indexClose); indexOpen = substring.lastIndexOf("("); substring = substring.substring(indexOpen + 1).trim(); if(indexOpen != -1 && indexClose != -1) { Double result = evaluate(substring); expression = expression.substring(0, indexOpen).trim() + " " + result + " " + expression.substring(indexClose + 1).trim(); return evaluate(expression.trim()); } } String operation = ""; if(expression.indexOf(" / ") != -1){ operation = "/"; }else if(expression.indexOf(" ^ ") != -1){ operation = "^"; } else if(expression.indexOf(" * ") != -1){ operation = "*"; } else if(expression.indexOf(" + ") != -1){ operation = "+"; } else if(expression.indexOf(" - ") != -1){ operation = "-"; } else{ return Double.parseDouble(expression); } int index = expression.indexOf(operation); if(index != -1){ indexOpen = expression.lastIndexOf(" ", index - 2); indexOpen = (indexOpen == -1)?0:indexOpen; indexClose = expression.indexOf(" ", index + 2); indexClose = (indexClose == -1)?expression.length():indexClose; if(indexOpen != -1 && indexClose != -1) { Double lhs = Double.parseDouble(expression.substring(indexOpen, index)); Double rhs = Double.parseDouble(expression.substring(index + 2, indexClose)); Double result = null; switch (operation){ case "/": if(rhs == 0){ return null; } result = lhs / rhs; break; case "^": result = Math.pow(lhs, rhs); break; case "*": result = lhs * rhs; break; case "-": result = lhs - rhs; break; case "+": result = lhs + rhs; break; default: break; } if(indexClose == expression.length()){ expression = expression.substring(0, indexOpen) + " " + result + " " + expression.substring(indexClose); }else{ expression = expression.substring(0, indexOpen) + " " + result + " " + expression.substring(indexClose + 1); } return Double.valueOf(df.format(evaluate(expression.trim()))); } } }catch(Exception exp){ exp.printStackTrace(); } return 0.0; } public static void main(String args[]){ Scanner scanner = new Scanner(System.in); System.out.print("Enter an Mathematical Expression to Evaluate: "); String input = scanner.nextLine(); System.out.println(evaluate(input)); }
String st = "10+3"; int result; for(int i=0;i<st.length();i++) { if(st.charAt(i)== { result=Integer.parseInt(st.substring(0, i))+Integer.parseInt(st.substring(i+1, st.length())); System.out.print(result); } }
String expressionStr = "x+y"; Map<String, Object> vars = new HashMap<String, Object>(); vars.put("x", 10); vars.put("y", 20); ExecutableStatement statement = (ExecutableStatement) MVEL.compileExpression(expressionStr); Object result = MVEL.executeExpression(statement, vars);
import java.util.*; StringTokenizer st; int ans; public class check { String str="7 + 5"; StringTokenizer st=new StringTokenizer(str); int v1=Integer.parseInt(st.nextToken()); String op=st.nextToken(); int v2=Integer.parseInt(st.nextToken()); if(op.equals("+")) { ans= v1 + v2; } if(op.equals("-")) { ans= v1 - v2; } }
public class RhinoApp { private String simpleAdd = "(12+13+2-2)*2+(12+13+2-2)*2"; public void runJavaScript() { Context jsCx = Context.enter(); Context.getCurrentContext().setOptimizationLevel(-1); ScriptableObject scope = jsCx.initStandardObjects(); Object result = jsCx.evaluateString(scope, simpleAdd , "formula", 0, null); Context.exit(); System.out.println(result); }
package test; public class Calculator { public static Double calculate(String expression){ if (expression == null || expression.length() == 0) { return null; } return calc(expression.replace(" ", "")); } public static Double calc(String expression) { if (expression.startsWith("(") && expression.endsWith(")")) { return calc(expression.substring(1, expression.length() - 1)); } String[] containerArr = new String[]{expression}; double leftVal = getNextOperand(containerArr); expression = containerArr[0]; if (expression.length() == 0) { return leftVal; } char operator = expression.charAt(0); expression = expression.substring(1); while (operator == containerArr[0] = expression; double rightVal = getNextOperand(containerArr); expression = containerArr[0]; if (operator == leftVal = leftVal * rightVal; } else { leftVal = leftVal / rightVal; } if (expression.length() > 0) { operator = expression.charAt(0); expression = expression.substring(1); } else { return leftVal; } } if (operator == return leftVal + calc(expression); } else { return leftVal - calc(expression); } } private static double getNextOperand(String[] exp){ double res; if (exp[0].startsWith("(")) { int open = 1; int i = 1; while (open != 0) { if (exp[0].charAt(i) == open++; } else if (exp[0].charAt(i) == open--; } i++; } res = calc(exp[0].substring(1, i - 1)); exp[0] = exp[0].substring(i); } else { int i = 1; if (exp[0].charAt(0) == i++; } while (exp[0].length() > i && isNumber((int) exp[0].charAt(i))) { i++; } res = Double.parseDouble(exp[0].substring(0, i)); exp[0] = exp[0].substring(i); } return res; } private static boolean isNumber(int c) { int zero = (int) int nine = (int) return (c >= zero && c <= nine) || c == } public static void main(String[] args) { System.out.println(calculate("(((( -6 )))) * 9 * -1")); System.out.println(calc("(-5.2+-5*-5*((5/4+2)))")); } }
Object object = createInstance("mypackage.MyClass","MyAttributeValue");
Class<?> clazz = Class.forName(className); Constructor<?> ctor = clazz.getConstructor(String.class); Object object = ctor.newInstance(new Object[] { ctorArgument });
package foo; public class Outer { public static class Nested {} }
Class<?> c = Class.forName("mypackage.MyClass"); Constructor<?> cons = c.getConstructor(String.class); Object object = cons.newInstance("MyAttributeValue");
return Class.forName(className).getConstructor(String.class).newInstance(arg);
Class<?> myClass = Class.forName("com.example.MyClass"); Constructor<?> constructor = myClass.getConstructors()[0];
import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class Main { public static void main(String args[]) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { String myClassName = Base.class.getName(); Class<?> myClass = Class.forName(myClassName); Constructor<?> ctr = myClass.getConstructor(String.class); String arg1 = "My User Data"; Object object = ctr.newInstance(new Object[] { arg1 }); Base base = (Base)object; System.out.println(base.data); } }
public class Base { public String data = null; public Base() { data = "default"; System.out.println("Base()"); } public Base(String arg1) { data = arg1; System.out.println("Base("+arg1+")"); } }
Constructor<?> ctr = myClass.getConstructor(String.class, String.class, String.class); Object object = ctr.newInstance(new Object[] { "Arg1", "Arg2", "Arg3" });
public class Base { public Base(String a, String b, String c){ } }
Class<?> c = Class.forName("mypackage.MyClass"); Constructor<?> ctor = c.getConstructors()[0]; Object object=ctor.newInstance(new Object[]{"ContstractorArgs"}); c.getDeclaredMethods()[0].invoke(object,Object... MethodArgs);
Class<?> clazz = Class.forName("myPackage.MyClass"); Constructor<?> cons = clazz.getDeclaredConstructor(); cons.setAccessible(true); Object obj = cons.newInstance();
return Class.forName(**complete classname**) .getConstructor(**here pass parameters passed in constructor**) .newInstance(**here pass arguments**);
return Class.forName("com.page.BillablePage") .getConstructor(WebDriver.class) .newInstance(this.driver);
@Repository("personDao") public class PersonDaoImpl extends AbstractDaoImpl implements PersonDao { }
@Repository("personDao") public class PersonDaoImpl extends AbstractDaoImpl implements PersonDao { @Resource(name = "propertyConfigurer") protected void setProperties(PropertyPlaceholderConfigurer ppc) { } }
@Value(" public void setDatabaseName(String dbName) { ... } @Value(" public void setKeyGenerator(KeyGenerator kg) { ... }
private @Value("${propertyName}") String propertyField;
<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" p:location="classpath:propertyFile.properties" name="propertiesBean"/>
@PropertySource("classpath:propertyFile.properties") public class AppConfig { @Bean public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() { return new PropertySourcesPlaceholderConfigurer(); }
<context:property-placeholder location="classpath:test.properties"/>
private @Value("${propertyName}") String propertyField;
<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"> <property name="location" value="/WEB-INF/app.properties" /> </bean> <bean id="appProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"> <property name="singleton" value="true"/> <property name="properties"> <props> <prop key="results.max">${results.max}</prop> </props> </property> </bean>
<bean id="appProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"> <property name="singleton" value="true" /> <property name="ignoreResourceNotFound" value="true" /> <property name="locations"> <list> <value>classpath:live.properties</value> <value>classpath:development.properties</value> </list> </property> </bean>
<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"> <property name="properties" ref="appProperties" /> </bean>
@Property(key="property.key", defaultValue="default") public void setProperty(String property) { this.property = property; }
@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD, ElementType.FIELD}) public @interface Property { String key(); String defaultValue() default ""; }
public class PropertyAnnotationAndPlaceholderConfigurer extends PropertyPlaceholderConfigurer { private static Logger log = Logger.getLogger(PropertyAnnotationAndPlaceholderConfigurer.class); @Override protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties properties) throws BeansException { super.processProperties(beanFactory, properties); for (String name : beanFactory.getBeanDefinitionNames()) { MutablePropertyValues mpv = beanFactory.getBeanDefinition(name).getPropertyValues(); Class clazz = beanFactory.getType(name); if(log.isDebugEnabled()) log.debug("Configuring properties for bean="+name+"["+clazz+"]"); if(clazz != null) { for (PropertyDescriptor property : BeanUtils.getPropertyDescriptors(clazz)) { Method setter = property.getWriteMethod(); Method getter = property.getReadMethod(); Property annotation = null; if(setter != null && setter.isAnnotationPresent(Property.class)) { annotation = setter.getAnnotation(Property.class); } else if(setter != null && getter != null && getter.isAnnotationPresent(Property.class)) { annotation = getter.getAnnotation(Property.class); } if(annotation != null) { String value = resolvePlaceholder(annotation.key(), properties, SYSTEM_PROPERTIES_MODE_FALLBACK); if(StringUtils.isEmpty(value)) { value = annotation.defaultValue(); } if(StringUtils.isEmpty(value)) { throw new BeanConfigurationException("No such property=["+annotation.key()+"] found in properties."); } if(log.isDebugEnabled()) log.debug("setting property=["+clazz.getName()+"."+property.getName()+"] value=["+annotation.key()+"="+value+"]"); mpv.addPropertyValue(property.getName(), value); } } for(Field field : clazz.getDeclaredFields()) { if(log.isDebugEnabled()) log.debug("examining field=["+clazz.getName()+"."+field.getName()+"]"); if(field.isAnnotationPresent(Property.class)) { Property annotation = field.getAnnotation(Property.class); PropertyDescriptor property = BeanUtils.getPropertyDescriptor(clazz, field.getName()); if(property.getWriteMethod() == null) { throw new BeanConfigurationException("setter for property=["+clazz.getName()+"."+field.getName()+"] not available."); } Object value = resolvePlaceholder(annotation.key(), properties, SYSTEM_PROPERTIES_MODE_FALLBACK); if(value == null) { value = annotation.defaultValue(); } if(value == null) { throw new BeanConfigurationException("No such property=["+annotation.key()+"] found in properties."); } if(log.isDebugEnabled()) log.debug("setting property=["+clazz.getName()+"."+field.getName()+"] value=["+annotation.key()+"="+value+"]"); mpv.addPropertyValue(property.getName(), value); } } } } } }
@PropertySource("classpath:/com/myProject/config/properties/database.properties")
java.util.Properties props = System.getProperties().getProperty("propertyName");
<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"> <property name="location" value="/WEB-INF/app.properties" /> </bean> <util:properties id="appProperties" location="classpath:/WEB-INF/app.properties"/>
<bean id="someFile" class="java.io.File"> <constructor-arg value="${someFile}"/> </bean>
@Service public class Thing public Thing(@Qualifier("someFile") File someFile) { ...
AutowiredFakaSource fakeDataSource = ctx.getBean(AutowiredFakaSource.class);
package org.some.beans; public class MyBean { Long id; String name; public void setId(Long id) { this.id = id; } public Long getId() { return id; } public void setName(String name) { this.name = name; } public String getName() { return name; } }
<bean id="Bean1" class="org.some.beans.MyBean"> <property name="id" value="1"/> <property name="name" value="MyBean"/> </bean>
<bean id="Bean2" class="org.some.beans.MyBean"> <property name="id" value="2"/> <property name="name" value="EnotherBean"/> </bean>
MyBean b1 = appContext.getBean("Bean1"); System.out.println("Bean id = " + b1.getId() + " name = " + b1.getName()); MyBean b2 = appContext.getBean("Bean2"); System.out.println("Bean id = " + b2.getId() + " name = " + b2.getName());
Bean id = 1 name = MyBean Bean id = 2 name = AnotherBean
@Repository("personDao") public class PersonDaoImpl extends AbstractDaoImpl implements PersonDao { Long maxResults; public void setMaxResults(Long maxResults) { this.maxResults = maxResults; } public void someMethod(Long results) { if (results < maxResults) { ... } } }
<bean id="placeholderConfig" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"> <property name="locations"> <list> <value>/WEB-INF/classes/config_properties/dev/database.properties</value> </list> </property> </bean> <bean id="devDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"> <property name="driverClass" value="${dev.app.jdbc.driver}"/> <property name="jdbcUrl" value="${dev.app.jdbc.url}"/> <property name="user" value="${dev.app.jdbc.username}"/> <property name="password" value="${dev.app.jdbc.password}"/> <property name="acquireIncrement" value="3"/> <property name="minPoolSize" value="5"/> <property name="maxPoolSize" value="10"/> <property name="maxStatementsPerConnection" value="11000"/> <property name="numHelperThreads" value="8"/> <property name="idleConnectionTestPeriod" value="300"/> <property name="preferredTestQuery" value="SELECT 0"/> </bean>
log4j:WARN No appenders could be found for logger (dao.hsqlmanager). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http:
String log4jConfPath = "/path/to/log4j.properties"; PropertyConfigurator.configure(log4jConfPath);
log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{yy/MM/dd HH:mm:ss} %p %c{2}: %m%n
log4j.rootLogger=DEBUG, A1 log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n log4j.logger.com.foo=WARN
log4j.rootLogger=debug, stdout, R log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n log4j.appender.R=org.apache.log4j.RollingFileAppender log4j.appender.R.File=example.log log4j.appender.R.MaxFileSize=100KB log4j.appender.R.MaxBackupIndex=1 log4j.appender.R.layout=org.apache.log4j.PatternLayout log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n
solr.log=logs/ log4j.rootLogger=INFO, file, CONSOLE log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout log4j.appender.CONSOLE.layout.ConversionPattern=%-4r [%t] %-5p %c %x \u2013 %m%n log4j.appender.file=org.apache.log4j.RollingFileAppender log4j.appender.file.MaxFileSize=4MB log4j.appender.file.MaxBackupIndex=9 log4j.appender.file.File=${solr.log}/solr.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=%-5p - %d{yyyy-MM-dd HH:mm:ss.SSS}; %C; %m\n log4j.logger.org.apache.zookeeper=WARN log4j.logger.org.apache.hadoop=WARN log4j.logger.org.apache.solr.update.LoggingInfoStream=OFF
Properties props = new Properties(); props.load(new FileInputStream("log4j property file path")); props.setProperty("log4j.appender.File.File", "Folder where you want to store log files/" + "File Name");
log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
Logger.getLogger(Lang.class.getName()).debug("Loading language: " + filename);
PropertyConfigurator.configure(xmlLog4JConfigFile);
<build> <sourceDirectory> src/main/java</sourceDirectory> <testSourceDirectory> src/test/java</testSourceDirectory> <resources> <resource> <directory>resources</directory> </resource> </resources> </build >
Properties prop = new Properties(); prop.setProperty("log4j.rootLogger", "WARN"); PropertyConfigurator.configure(prop);
Logger log = LogManager.getLogger(MyClassIWantedToLogFrom.class);
<plugin> <artifactId>maven-assembly-plugin</artifactId> <version>2.2-beta-5</version> <configuration> <archive> <manifest> <addClasspath>true</addClasspath> <mainClass>com.mycompany.mainPackage.mainClass</mainClass> </manifest> <manifestEntries> <Class-Path>.</Class-Path> <!-- need to add current directory to classpath properties files can be found --> </manifestEntries> </archive> <descriptorRefs> <descriptorRef>jar-with-dependencies</descriptorRef> </descriptorRefs> </configuration> <executions> <execution> <id>make-assembly</id> <phase>package</phase> <goals> <goal>single</goal> </goals> </execution> </executions> </plugin>
final static Logger logging = Logger.getLogger(ProcessorTest.class);
No appenders could be found for logger (org.apache.kafka.producer.Sender)
<dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <scope>runtime</scope> </dependency>
<dependency> <groupId>org.apache.logging.log4j</groupId> <artifactId>log4j-slf4j-impl</artifactId> <scope>runtime</scope> </dependency>
System.setProperty("log4j.configurationFile", "log4j2.xml");
public class AppConfig extends SpringBootServletInitializer { public static void main( String[] args ) { ConfigurableApplicationContext context = SpringApplication.run( AppConfig.class, args ); } @Override protected SpringApplicationBuilder configure( SpringApplicationBuilder application ) { InputStream log4j = this.getClass().getClassLoader().getResourceAsStream("log4j.properties"); PropertyConfigurator.configure(log4j); return application; } }
String log4jConfPath ="path to/log4j.properties"; PropertyConfigurator.configure(log4jConfPath);
log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{yy/MM/dd HH:mm:ss} %p %c{2}: %m%n
log4j.rootLogger=INFO, theConsoleAppender log4j.appender.theConsoleAppender=org.apache.log4j.ConsoleAppender log4j.appender.theConsoleAppender.layout=org.apache.log4j.PatternLayout log4j.appender.theConsoleAppender.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n
log4j.rootLogger=file log4j.appender.FILE=org.apache.log4j.FileAppender log4j.appender.FILE.File=c:/Trace/MsgStackLogging.log log4j.appender.FILE.layout=org.apache.log4j.PatternLayout log4j.appender.FILE.layout.ConversionPattern=%m%n log4j.appender.FILE.ImmediateFlush=true log4j.appender.FILE.Threshold=debug log4j.appender.FILE.Append=false
log4j.rootLogger=FILE log4j.appender.FILE=org.apache.log4j.FileAppender log4j.appender.FILE.File=c:/Trace/MsgStackLogging.log log4j.appender.FILE.layout=org.apache.log4j.PatternLayout log4j.appender.FILE.layout.ConversionPattern=%m%n log4j.appender.FILE.ImmediateFlush=true log4j.appender.FILE.Threshold=debug log4j.appender.FILE.Append=false
@Entity @Table(name = "T_TOPIC") public class Topic { @Id @GeneratedValue(strategy=GenerationType.AUTO) private int id; @ManyToOne @JoinColumn(name="USER_ID") private User author; @Enumerated(EnumType.STRING) private Tag topicTag; private String name; private String text; @OneToMany(mappedBy = "topic", cascade = CascadeType.ALL) private Collection<Comment> comments = new LinkedHashSet<Comment>(); ... public Collection<Comment> getComments() { return comments; } }
@Controller @RequestMapping(value = "/topic") public class TopicController { @Autowired private TopicService service; private static final Logger logger = LoggerFactory.getLogger(TopicController.class); @RequestMapping(value = "/details/{topicId}", method = RequestMethod.GET) public ModelAndView details(@PathVariable(value="topicId") int id) { Topic topicById = service.findTopicByID(id); Collection<Comment> commentList = topicById.getComments(); Hashtable modelData = new Hashtable(); modelData.put("topic", topicById); modelData.put("commentList", commentList); return new ModelAndView("/topic/details", modelData); } }
<%@page import="com.epam.mvc3.helpers.Utils"%> <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%> <%@ taglib uri="http: <%@ page session="false" %> <html> <head> <title>View Topic</title> </head> <body> <ul> <c:forEach items="${commentList}" var="item"> <jsp:useBean id="item" type="mvc3.model.Comment"/> <li>${item.getText()}</li> </c:forEach> </ul> </body> </html>
@OneToMany(fetch = FetchType.EAGER, mappedBy = "topic", cascade = CascadeType.ALL) private Collection<Comment> comments = new LinkedHashSet<Comment>();
Collection<Comment> commentList = topicById.getComments();
<c:forEach items="topic.comments" var="item"> </c:forEach>
<filter> <filter-name>SpringOpenEntityManagerInViewFilter</filter-name> <filter-class>org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter</filter-class> </filter> <filter-mapping> <filter-name>SpringOpenEntityManagerInViewFilter</filter-name> <url-pattern>/*</url-pattern> </filter-mapping>
@Transactional(propagation=Propagation.REQUIRED, readOnly=true, noRollbackFor=Exception.class)
@Controller @RequestMapping(value = "/topic") @Transactional
@ElementCollection(fetch = FetchType.EAGER) public List<Long> ids;
@PersistenceContext(type = PersistenceContextType.EXTENDED)
<f:attribute name="collectionType" value="java.util.ArrayList" />
@Controller @RequestMapping("/") @Transactional public class UserController { }
Node n = Hibernate.initialize(n); Hibernate.initialize(n.getChildren());
<tx:annotation-driven transaction-manager="myTxManager" />
criteria.setFetchMode("lazily_fetched_member", FetchMode.EAGER);
entityManager.detach(topicById); topicById.getComments()
Hibernate.initialize(topicById.getComments()); entityManager.detach(topicById); topicById.getComments()
@Transactional public void checkTicketSalePresence(UUID ticketUuid, UUID saleUuid) { Optional<Ticket> savedTicketOpt = ticketRepository.findById(ticketUuid); savedTicketOpt.ifPresent(ticket -> { Optional<Sale> saleOpt = ticket.getSales().stream().filter(sale -> sale.getUuid() == saleUuid).findFirst(); assertThat(saleOpt).isPresent(); }); }
@OneToMany(mappedBy = "a", cascade = CascadeType.ALL) Set<B> bs;
org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: mvc3.model.Topic.comments, no session or session was closed
@OneToMany(fetch = FetchType.EAGER, mappedBy = "topic", cascade = CascadeType.ALL) private Collection<Comment> comments = new LinkedHashSet<Comment>();
Set<myObject> set=null; hibernateSession.open set=hibernateSession.getMyObjects(); hibernateSession.close();
Set<myObject> set=new HashSet<myObject>(); hibernateSession.open set.addAll(hibernateSession.getMyObjects()); hibernateSession.close();
Collection<Comment> commentList = this.transactionTemplate.execute (status -> topicById.getComments());
private List<Categories> children = new ArrayList<Categories>();
public interface Service { ... } public interface Provider { Service newService(); } public class Services { private Services() { } private static final Map<String, Provider> providers = new ConcurrentHashMap<String, Provider>(); public static final String DEFAULT_PROVIDER_NAME = "<def>"; public static void registerDefaultProvider(Provider p) { registerProvider(DEFAULT_PROVIDER_NAME, p); } public static void registerProvider(String name, Provider p){ providers.put(name, p); } public static Service newInstance() { return newInstance(DEFAULT_PROVIDER_NAME); } public static Service newInstance(String name) { Provider p = providers.get(name); if (p == null) throw new IllegalArgumentException( "No provider registered with name: " + name); return p.newService(); } }
String[] monthNames = new String[12]; String name = monthNames[calendar.get(Calendar.MONTH)];
(0 + 1) % 12 = 1 (1 + 1) % 12 = 2 (2 + 1) % 12 = 3 (3 + 1) % 12 = 4 (4 + 1) % 12 = 5 (5 + 1) % 12 = 6 (6 + 1) % 12 = 7 (7 + 1) % 12 = 8 (8 + 1) % 12 = 9 (9 + 1) % 12 = 10 (10 + 1) % 12 = 11 (11 + 1) % 12 = 0
if (date.getMonth() == 3) out.print("March"); if (date.getMonth() == Calendar.MARCH) out.print("March");
String output = Month.FEBRUARY.getDisplayName( TextStyle.FULL , Locale.CANADA_FRENCH );
GregorianCalendar gc = new GregorianCalendar(); gc.setLenient( false ); gc.set( 2001, 1, 1, 1, 0, 0 ); int year = gc.get ( Calendar.YEAR );
if (!resultSet.next() ) { System.out.println("no data"); }
if (!resultSet.isBeforeFirst() ) { System.out.println("No data"); }
if (!resultSet.next() ) { System.out.println("no data"); } else { do { } while (resultSet.next()); }
while ( resultSet.next() ) { resultSet.getString("columnName"); }
if(resultSet.next()) { do { } while (resultSet.next()); }
public static boolean isMyResultSetEmpty(ResultSet rs) throws SQLException { return (!rs.isBeforeFirst() && rs.getRow() == 0); }
while (resultSet.next()) { ... read from the row here ... }
if (res.next()) { do { } while (res.next()); } else { }
if (!resultSet.isAfterLast() ) { System.out.println("No data"); }
ResultSet resultSet = preparedStatement.executeQuery(); if(resultSet.next()) else
ResultSet rs = rs.executeQuery(); if(rs.next()) { rs = rs.executeQuery(); while(rs.next()) { } } else { }
ResultSet result = stmt.executeQuery(sqlQuery); if (!result.next()) status = "ERROR"; else status = "SUCCESS";
public static boolean resultSetIsEmpty(ResultSet rs){ try { rs.last(); int rsRows=rs.getRow(); if (rsRows == 0) { return true; } rs.beforeFirst(); return false; }catch(SQLException ex){ return true; } }
CallableStatement proc = dbconex.prepareCall(select, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
if(resultSet.first) { } else { system.out.println("No raw or resultSet is empty"); }
boolean found = false; while ( resultSet.next() ) { found = true; resultSet.getString("column_name"); } if (!found) System.out.println("No Data");
if(rs.absolute(1)){ System.out.println("We have data"); } else { System.out.println("No data"); }
if(CollectionUtils.isNotEmpty(resultList)){ /** * do some stuff */ }
int getRow() throws SQLException Retrieves the current row number. The first row is number 1, the second number 2, and so on. Note:Support for the getRow method is optional for ResultSets with a result set type of TYPE_FORWARD_ONLY Returns: the current row number; 0 if there is no current row Throws: SQLException - if a database access error occurs or this method is called on a closed result set SQLFeatureNotSupportedException - if the JDBC driver does not support this method Since: 1.2
for(int i = 0; i < sparseArray.size(); i++) { int key = sparseArray.keyAt(i); Object obj = sparseArray.get(key); }
for(int i = 0, nsize = sparseArray.size(); i < nsize; i++) { Object obj = sparseArray.valueAt(i); }
public final class SparseArrayIterator<E> implements ListIterator<E> { private final SparseArray<E> array; private int cursor; private boolean cursorNowhere; /** * @param array * to iterate over. * @return A ListIterator on the elements of the SparseArray. The elements * are iterated in the same order as they occur in the SparseArray. * {@link * SparseArray key, not an index! To get the index, call * {@link android.util.SparseArray */ public static <E> ListIterator<E> iterate(SparseArray<E> array) { return iterateAt(array, -1); } /** * @param array * to iterate over. * @param key * to start the iteration at. {@link android.util.SparseArray * < 0 results in the same call as {@link * @return A ListIterator on the elements of the SparseArray. The elements * are iterated in the same order as they occur in the SparseArray. * {@link * SparseArray key, not an index! To get the index, call * {@link android.util.SparseArray */ public static <E> ListIterator<E> iterateAtKey(SparseArray<E> array, int key) { return iterateAt(array, array.indexOfKey(key)); } /** * @param array * to iterate over. * @param location * to start the iteration at. Value < 0 results in the same call * as {@link * {@link android.util.SparseArray * @return A ListIterator on the elements of the SparseArray. The elements * are iterated in the same order as they occur in the SparseArray. * {@link * SparseArray key, not an index! To get the index, call * {@link android.util.SparseArray */ public static <E> ListIterator<E> iterateAt(SparseArray<E> array, int location) { return new SparseArrayIterator<E>(array, location); } private SparseArrayIterator(SparseArray<E> array, int location) { this.array = array; if (location < 0) { cursor = -1; cursorNowhere = true; } else if (location < array.size()) { cursor = location; cursorNowhere = false; } else { cursor = array.size() - 1; cursorNowhere = true; } } @Override public boolean hasNext() { return cursor < array.size() - 1; } @Override public boolean hasPrevious() { return cursorNowhere && cursor >= 0 || cursor > 0; } @Override public int nextIndex() { if (hasNext()) { return array.keyAt(cursor + 1); } else { throw new NoSuchElementException(); } } @Override public int previousIndex() { if (hasPrevious()) { if (cursorNowhere) { return array.keyAt(cursor); } else { return array.keyAt(cursor - 1); } } else { throw new NoSuchElementException(); } } @Override public E next() { if (hasNext()) { if (cursorNowhere) { cursorNowhere = false; } cursor++; return array.valueAt(cursor); } else { throw new NoSuchElementException(); } } @Override public E previous() { if (hasPrevious()) { if (cursorNowhere) { cursorNowhere = false; } else { cursor--; } return array.valueAt(cursor); } else { throw new NoSuchElementException(); } } @Override public void add(E object) { throw new UnsupportedOperationException(); } @Override public void remove() { if (!cursorNowhere) { array.remove(array.keyAt(cursor)); cursorNowhere = true; cursor--; } else { throw new IllegalStateException(); } } @Override public void set(E object) { if (!cursorNowhere) { array.setValueAt(cursor, object); } else { throw new IllegalStateException(); } } }
for(int i = 0, arraySize= mySparseArray.size(); i < arraySize; i++) { Object obj = mySparseArray.get( mySparseArray.keyAt(i)); }
private void getValues(){ for(int i=0; i<sparseArray.size(); i++){ int key = sparseArray.keyAt(i); Log.d("Element at "+key, " is "+sparseArray.get(key)); sparseArray.remove(key); i=-1; } }
public class SparseArrayIterator<T> implements Iterator<T> { private final SparseArray<T> array; private int index; public SparseArrayIterator(SparseArray<T> array) { this.array = array; } @Override public boolean hasNext() { return array.size() > index; } @Override public T next() { return array.valueAt(index++); } @Override public void remove() { array.removeAt(index); } } public class SparseArrayIterable<T> implements Iterable<T> { private final SparseArray<T> sparseArray; public SparseArrayIterable(SparseArray<T> sparseArray) { this.sparseArray = sparseArray; } @Override public Iterator<T> iterator() { return new SparseArrayIterator<>(sparseArray); } }
public class SparseKeyValue<T> { private final int key; private final T value; public SparseKeyValue(int key, T value) { this.key = key; this.value = value; } public int getKey() { return key; } public T getValue() { return value; } } public class SparseArrayKeyValueIterator<T> implements Iterator<SparseKeyValue<T>> { private final SparseArray<T> array; private int index; public SparseArrayKeyValueIterator(SparseArray<T> array) { this.array = array; } @Override public boolean hasNext() { return array.size() > index; } @Override public SparseKeyValue<T> next() { SparseKeyValue<T> keyValue = new SparseKeyValue<>(array.keyAt(index), array.valueAt(index)); index++; return keyValue; } @Override public void remove() { array.removeAt(index); } } public class SparseArrayKeyValueIterable<T> implements Iterable<SparseKeyValue<T>> { private final SparseArray<T> sparseArray; public SparseArrayKeyValueIterable(SparseArray<T> sparseArray) { this.sparseArray = sparseArray; } @Override public Iterator<SparseKeyValue<T>> iterator() { return new SparseArrayKeyValueIterator<T>(sparseArray); } }
public abstract class SparseArrayUtils { public static <T> Iterable<SparseKeyValue<T>> keyValueIterable(SparseArray<T> sparseArray) { return new SparseArrayKeyValueIterable<>(sparseArray); } public static <T> Iterable<T> iterable(SparseArray<T> sparseArray) { return new SparseArrayIterable<>(sparseArray); } }
SparseArray<String> a = ...; for (String s: SparseArrayUtils.iterable(a)) { } for (SparseKeyValue<String> s: SparseArrayUtils.keyValueIterable(a)) { }
for(int i = 0; i < sparseArray.size(); i++) { int key = sparseArray.keyAt(i); Object obj = sparseArray.get(key); }
for (int index = 0; index < mAdapter.getItemCount(); index++) { if (toDelete.get(index) == true) { long idOfItemToDelete = (allItems.get(index).getId()); mDbManager.markItemForDeletion(idOfItemToDelete); } }
public void doSomething(Number param) { if( param instanceof Double) { System.out.println("param is a Double"); } else if( param instanceof Integer) { System.out.println("param is an Integer"); } if( param instanceof Comparable) { System.out.println("param is comparable"); } }
class A { } class C extends A { } class D extends A { } public static void testInstance(){ A c = new C(); A d = new D(); Assert.assertTrue(c instanceof A && d instanceof A); Assert.assertTrue(c instanceof C && d instanceof D); Assert.assertFalse(c instanceof D); Assert.assertFalse(d instanceof C); }
public class MainClass { public static void main(String[] a) { String s = "Hello"; int i = 0; String g; if (s instanceof java.lang.String) { System.out.println("s is a String"); } if (i instanceof Integer) { System.out.println("i is an Integer"); } if (g instanceof java.lang.String) { System.out.println("g is a String"); } }
import com.text.Formatter; private Formatter textFormatter; private com.json.Formatter jsonFormatter;
import java.util.Calendar import com.example.Calendar as MyCalendar MyCalendar myCalendar = new MyCalendar()
package com.mycompany.installer; public abstract class ConfigurationReader { private static class Implementation extends com.mycompany.installer.implementation.ConfigurationReader {} public abstract String getLoaderVirtualClassPath(); public static QueryServiceConfigurationReader getInstance() { return new Implementation(); } }
try{ .. m.invoke(testObject); .. } catch(AssertionError e){ ... } catch(Exception e){ .. }
try { .. m.invoke(testObject); .. } catch (InvocationTargetException e) { e.getCause().printStackTrace(); } catch (Exception e) { e.printStackTrace(); }
try{ ... } catch(Exception e){ if(e.getCause().getClass().equals(AssertionError.class)){ } else { } }
public interface C {} public class A<B implements C>{}
interface IntfSub extends IntfSuper {} class ClzSub extends ClzSuper {}
@RequestMapping(method = RequestMethod.GET) public ModelAndView showResults(final HttpServletRequest request...) { final String currentUser = SecurityContextHolder.getContext().getAuthentication().getName(); ... }
@RequestMapping(method = RequestMethod.GET) public ModelAndView showResults(final HttpServletRequest request, Principal principal) { final String currentUser = principal.getName(); }
public interface SecurityContextFacade { SecurityContext getContext(); void setContext(SecurityContext securityContext); }
public class FooController { private final SecurityContextFacade securityContextFacade; public FooController(SecurityContextFacade securityContextFacade) { this.securityContextFacade = securityContextFacade; } public void doSomething(){ SecurityContext context = securityContextFacade.getContext(); } }
public class FooControllerTest { private FooController controller; private SecurityContextFacade mockSecurityContextFacade; private SecurityContext mockSecurityContext; @Before public void setUp() throws Exception { mockSecurityContextFacade = mock(SecurityContextFacade.class); mockSecurityContext = mock(SecurityContext.class); stub(mockSecurityContextFacade.getContext()).toReturn(mockSecurityContext); controller = new FooController(mockSecurityContextFacade); } @Test public void testDoSomething() { controller.doSomething(); verify(mockSecurityContextFacade).getContext(); } }
public class SecurityContextHolderFacade implements SecurityContextFacade { public SecurityContext getContext() { return SecurityContextHolder.getContext(); } public void setContext(SecurityContext securityContext) { SecurityContextHolder.setContext(securityContext); } }
<bean id="myController" class="com.foo.FooController"> ... <constructor-arg index="1"> <bean class="com.foo.SecurityContextHolderFacade"> </constructor-arg> </bean>
/** * Returns the domain User object for the currently logged in user, or null * if no User is logged in. * * @return User object for the currently logged in user, or null if no User * is logged in. */ public static User getCurrentUser() { Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal() if (principal instanceof MyUserDetails) return ((MyUserDetails) principal).getUser(); return null; } /** * Utility method to determine if the current user is logged in / * authenticated. * <p> * Equivalent of calling: * <p> * <code>getCurrentUser() != null</code> * * @return if user is logged in */ public static boolean isLoggedIn() { return getCurrentUser() != null; }
@RequestMapping(method = RequestMethod.GET) public ModelAndView showResults(@AuthenticationPrincipal CustomUser currentUser, HttpServletRequest request) { String currentUsername = currentUser.getUsername(); }
import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.servlet.support.RequestContext; import foo.Form; @Controller @RequestMapping(value="/welcome") public class IndexController { @RequestMapping(method=RequestMethod.GET) public String getCreateForm(Model model, HttpServletRequest request) { if(request.getUserPrincipal() != null) { String loginName = request.getUserPrincipal().getName(); System.out.println("loginName : " + loginName ); } model.addAttribute("form", new Form()); return "welcome"; } }
@RequestMapping(method = RequestMethod.GET) public String currentUserNameByPrincipal(Principal principal) { return principal.getName(); }
@RequestMapping(method = RequestMethod.GET) public String currentUserNameByAuthentication(Authentication authentication) { return authentication.getName(); }
@RequestMapping(method = RequestMethod.GET) public String currentUserByHTTPRequest(HttpServletRequest request) { return request.getUserPrincipal().getName(); }
public ModelAndView someRequestHandler(@ActiveUser User activeUser) { ... }
public class SomeService { private String principal; @Principal public setPrincipal(String principal){ this.principal=principal; } }
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.userdetails.User; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; @Controller public class KnoteController { @RequestMapping(method = RequestMethod.GET) public java.lang.String list(Model uiModel, UsernamePasswordAuthenticationToken authToken) { if (authToken instanceof UsernamePasswordAuthenticationToken) { user = (User) authToken.getPrincipal(); } ... }
@ControllerAdvice public class ControllerAdvicer { private static final Logger LOGGER = LoggerFactory.getLogger(ControllerAdvicer.class); @ModelAttribute("userActive") public UserActive currentUser(@AuthenticationPrincipal UserActive currentUser) { return currentUser; } }
public class UserActive extends org.springframework.security.core.userdetails.User { private final User user; public UserActive(User user) { super(user.getUsername(), user.getPasswordHash(), user.getGrantedAuthorities()); this.user = user; } }
@RequestMapping(value = "/monitoring", method = RequestMethod.GET) public ModelAndView getMonitoringPage(Model model, final HttpServletRequest request) { showRequestLog("monitoring"); Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); String userName = authentication.getName(); HttpSession session = request.getSession(true); session.setAttribute("username", userName); return new ModelAndView(catalogPath + "monitoring"); }
<@security.authorize ifAnyGranted="ROLE_ADMIN, ROLE_USER"> <p style="padding-right: 20px;">Logged in as ${username!"Anonymous" }</p> </@security.authorize>
23.59004 to 23.59 35.7 to 35.70 3.0 to 3.00 9 to 9.00
double[] arr = { 23.59004, 35.7, 3.0, 9 }; for ( double dub : arr ) { System.out.println( String.format( "%.2f", dub ) ); }
String str = "1986-04-08 12:30"; DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"); LocalDateTime dateTime = LocalDateTime.parse(str, formatter);
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"); LocalDateTime dateTime = LocalDateTime.of(1986, Month.APRIL, 8, 12, 30); String formattedDateTime = dateTime.format(formatter);
String strDate = "2015-08-04"; LocalDate aLD = LocalDate.parse(strDate); System.out.println("Date: " + aLD); String strDatewithTime = "2015-08-04T10:11:30"; LocalDateTime aLDT = LocalDateTime.parse(strDatewithTime); System.out.println("Date with Time: " + aLDT);
Date: 2015-08-04 Date with Time: 2015-08-04T10:11:30
DateTimeFormatter dTF = DateTimeFormatter.ofPattern("dd MMM uuuu"); String anotherDate = "04 Aug 2015"; LocalDate lds = LocalDate.parse(anotherDate, dTF); System.out.println(anotherDate + " parses to " + lds);
String strDate = "2015-08-04"; LocalDate aLD = LocalDate.parse(strDate); DateTimeFormatter dTF = DateTimeFormatter.ofPattern("dd MMM uuuu"); System.out.println(aLD + " formats as " + dTF.format(aLD));
LocalDateTime ldt = LocalDateTime.now(); ZonedDateTime zdt = ldt.atZone(ZoneOffset.UTC); String iso8601 = zdt.toString();
String iso8601 = "2016-02-14T18:32:04.150Z"; ZonedDateTime zdt = ZonedDateTime.parse(iso8601); LocalDateTime ldt = zdt.toLocalDateTime();
public class MyException extends Exception {} public class Foo { public bar() throws MyException { throw new MyException("try again please"); } }
cannot find symbol: constructor MyException(java.lang.String)
public class MyException extends Exception { public MyException(String message) { super(message); } }
public class CustomException extends Exception { public CustomException(String message) { super(message); } public CustomException(String message, Throwable throwable) { super(message, throwable); } }
package com.example.exception; public class MyException extends Exception { public MyException() { } public MyException(String message) { super(message); } public MyException(Throwable cause) { super(cause); } public MyException(String message, Throwable cause) { super(message, cause); } }
package customExceptions; public class MyException extends Exception{ public MyException(String exc) { super(exc); } public String getMessage() { return super.getMessage(); } }
import customExceptions.MyException; public class UseCustomException { MyException newExc=new MyException("This is a custom exception"); public UseCustomException() throws MyException { System.out.println("Hello Back Again with custom exception"); throw newExc; } public static void main(String args[]) { try { UseCustomException use=new UseCustomException(); } catch(MyException myEx) { System.out.println("This is my custom exception:" + myEx.getMessage()); } } }
c:/Program Files/Java/jre(5,6,7..any version)/bin/javaw.exe
F:\Softwares\LANGUAGES SOFTEARE\Android Setup\eclipse
HKEY_CURRENT_USER\Environment Path REG_SZ %JAVA_HOME%\bin;C:\ProgramFiles\nodejs HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment JAVA_HOME REG_SZ C:\ProgramFiles\Java\jdk Path REG_EXPAND_SZ C:\bin;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\ WindowsPowerShell\v1.0\;C:\Program Files\Intel\DMIX;c:\Program Files (x86)\Microsoft SQL Server\90\Tools\binn\;C:\Progra m Files (x86)\Perforce;C:\ProgramFiles\010 Editor;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;C:\ProgramFiles\ Git\cmd;C:\Program Files (x86)\Skype\Phone\ C:\Users\ssfang> echo %^JAVA_HOME% = "%^JAVA_HOME%" = %%JAVA_HOME%% %JAVA_HOME% %JAVA_HOME% = "%^JAVA_HOME%" = %C:\ProgramFiles\Java\jdk% C:\ProgramFiles\Java\jdk
C:\Users\ssfang> where node java C:\ProgramFiles\nodejs\node.exe INFO: Could not find "java".
C:\Users\ssfang> setx PATH %^JAVA_HOME%\bin;"C:\ProgramFiles\nodejs" SUCCESS: Specified value was saved. C:\Users\ssfang> reg query HKEY_CURRENT_USER\Environment /v Path HKEY_CURRENT_USER\Environment Path REG_EXPAND_SZ %JAVA_HOME%\bin;C:\ProgramFiles\nodejs C:\Users\ssfang> where node java C:\ProgramFiles\nodejs\node.exe INFO: Could not find "java". C:\Users\ssfang>echo %PATH% C:\bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Fi les\Intel\DMIX;c:\Program Files (x86)\Microsoft SQL Server\90\Tools\binn\;C:\Program Files (x86)\Perforce;C:\ProgramFile s\010 Editor;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;C:\ProgramFiles\Git\cmd;C:\Program Files (x86)\Skype\ Phone\;%JAVA_HOME%\bin;C:\ProgramFiles\nodejs
<# Add-Type @' public class CSharp { public static void Method(object[] first, object[] second) { System.Console.WriteLine("Hello world"); } } $a = 1..4; [string[]]$b = "a","b","c","d"; [CSharp]::Method($a, $b); <# if (-not ("MyClass" -as [type])) { add-type @" public class MyClass { } "@ } p.s. there http: I think it will be wanted when debugging. It is much simpler to close a tab in Console and open new one in PowerShell_ISE.exe or close PowerShell.exe. Or Start-Job -ScriptBlock { param([uri]$url,$OutputDir) Invoke-RestMethod $url | Out-File "$OutputDir\$($url.Segments[-1])" -Force } -ArgumentList $link,$OutputDir if (-not ([System.Management.Automation.PSTypeName] { $sig=@" using System; using System.Runtime.InteropServices; using System.Text; using System.Collections.Generic; namespace PInvoke { public static class User32 { public const UInt32 WM_SETTINGCHANGE = 0x001A; [System.Runtime.InteropServices.DllImport("user32.dll", EntryPoint = "SendMessageTimeout", SetLastError = true)] public static extern uint SendMessageTimeout(IntPtr hWnd, uint Msg, int wParam, string lParam, SendMessageTimeoutFlags fuFlags, uint uTimeout, out int lpdwResult); } [Flags] public enum SendMessageTimeoutFlags : uint { SMTO_NORMAL = 0x0, SMTO_BLOCK = 0x1, SMTO_ABORTIFHUNG = 0x2, SMTO_NOTIMEOUTIFNOTHUNG = 0x8, SMTO_ERRORONEXIT = 0x20 } public class Program { public static void Main(string[] args) { Console.WriteLine("Over!!!!!!!!!!!!!!!!!!!!!!!!!"); } } } "@ Add-Type -TypeDefinition $sig } $innerPinvokeResult=[int]0 [PInvoke.User32]::SendMessageTimeout([IntPtr]0xffff, [PInvoke.User32]::WM_SETTINGCHANGE, 0, "Environment", [PInvoke.SendMessageTimeoutFlags]::SMTO_NORMAL, 1000, [ref]$innerPinvokeResult);
/m Specifies to set the variable in the system environment. The default setting is the local environment
ReportTypeEnum value = ReportTypeEnum.values()[ordinal];
enum Suit { Hearts, Diamonds, Spades, Clubs; public static final Suit values[] = values(); }
public enum Suit { spades, hearts, diamonds, clubs; private static final Map<Integer, Suit> lookup = new HashMap<Integer, Suit>(); static{ int ordinal = 0; for (Suit suit : EnumSet.allOf(Suit.class)) { lookup.put(ordinal, suit); ordinal+= 1; } } public Suit fromOrdinal(int ordinal) { return lookup.get(ordinal); } }
public ReportTypeEnum { R1(1), R2(2), R3(3), R4(4), R5(5), R6(6), R7(7), R8(8); private static Logger log = LoggerFactory.getLogger(ReportEnumType.class); private static Map<Integer, ReportTypeEnum> lookup; private Integer dbValue; private ReportTypeEnum(Integer dbValue) { this.dbValue = dbValue; } static { try { ReportTypeEnum[] vals = ReportTypeEnum.values(); lookup = new HashMap<Integer, ReportTypeEnum>(vals.length); for (ReportTypeEnum rpt: vals) lookup.put(rpt.getDbValue(), rpt); } catch (Exception e) { log.error("Unexpected exception initializing " + ReportTypeEnum.class, e); } } public static ReportTypeEnum fromDbValue(Integer dbValue) { return lookup.get(dbValue); } public Integer getDbValue() { return this.dbValue; } }
/** * convert ordinal to Enum * @param clzz may not be null * @param ordinal * @return e with e.ordinal( ) == ordinal * @throws IllegalArgumentException if ordinal out of range */ public static <E extends Enum<E> > E lookupEnum(Class<E> clzz, int ordinal) { EnumSet<E> set = EnumSet.allOf(clzz); if (ordinal < set.size()) { Iterator<E> iter = set.iterator(); for (int i = 0; i < ordinal; i++) { iter.next(); } E rval = iter.next(); assert(rval.ordinal() == ordinal); return rval; } throw new IllegalArgumentException("Invalid value " + ordinal + " for " + clzz.getName( ) + ", must be < " + set.size()); } @Test public void lookupTest( ) { java.util.concurrent.TimeUnit tu = lookupEnum(TimeUnit.class, 3); System.out.println(tu); }
public enum Suit implements java.io.Serializable, Comparable<Suit>{ spades, hearts, diamonds, clubs; private static final Suit [] lookup = Suit.values(); public Suit fromOrdinal(int ordinal) { if(ordinal< 1 || ordinal> 3) return null; return lookup[value-1]; } }
public class MainTest { public static void main(String[] args) { Suit d3 = Suit.diamonds; Suit d3Test = Suit.fromOrdinal(2); if(d3.equals(d3Test)){ System.out.println("Susses"); }else System.out.println("Fails"); } }
public enum SomeStatus { UNINITIALIZED, STATUS_1, RESERVED_1, STATUS_2, RESERVED_2, STATUS_3; private static SomeStatus[] values = null; public static SomeStatus fromInteger(int i) { if(SomeStatus.values == null) { SomeStatus.values = SomeStatus.values(); } if (i < 0) return SomeStatus.values[0]; if (i >= SomeStatus.values.length) return SomeStatus.values[0]; return SomeStatus.values[i]; } }
String iso8601 = DateFormat.getDateTimeInstance(DateFormat.ISO_8601).format(date);
TimeZone tz = TimeZone.getTimeZone("UTC"); DateFormat df = new SimpleDateFormat("yyyy-MM-dd df.setTimeZone(tz); String nowAsISO = df.format(new Date());
TimeZone tz = TimeZone.getTimeZone("UTC"); DateFormat df = new SimpleDateFormat("yyyy-MM-dd df.setTimeZone(tz); String nowAsISO = df.format(new Date());
thisMoment = DateTimeFormatter.ofPattern("yyyy-MM-dd .withZone(ZoneOffset.UTC) .format(Instant.now());
thisMoment = String.format("%tFT%<tRZ", Calendar.getInstance(TimeZone.getTimeZone("Z")));
ZonedDateTime.now( ZoneOffset.UTC ).format( DateTimeFormatter.ISO_INSTANT )
ZonedDateTime.now( ZoneId.of( "Europe/Paris" ) ) .truncatedTo( ChronoUnit.MINUTES ) .format( DateTimeFormatter.ISO_DATE_TIME )
.format( DateTimeFormatter.ISO_LOCAL_DATE_TIME ) .format( DateTimeFormatter.ISO_LOCAL_DATE ) .format( DateTimeFormatter.ISO_LOCAL_TIME ) .format( DateTimeFormatter.ofPattern( "yyyy-MM-dd HH:mm" ) )
DateFormat df = new SimpleDateFormat("yyyy-MM-dd String nowAsString = df.format(new Date());
javax.xml.bind.DatatypeConverter.printDateTime( Calendar.getInstance(TimeZone.getTimeZone("UTC")) );
String output = new DateTime( DateTimeZone.UTC ).toString() ;
DateTime now = new DateTime( DateTimeZone.UTC ) ; String output = ISODateTimeFormat.dateHourMinute.print( now ) ;
TimeZone tz = TimeZone.getTimeZone("UTC"); DateFormat df = new SimpleDateFormat("yyyy-MM-dd df.setTimeZone(tz); String nowAsISO = df.format(new Date()); System.out.println(nowAsISO); DateFormat df1 = new SimpleDateFormat("yyyy-MM-dd Date finalResult = df1.parse(nowAsISO); System.out.println(finalResult);
for (String timeZone : TimeZone.getAvailableIDs()) { DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd dateFormat.setTimeZone(TimeZone.getTimeZone(timeZone)); String formatted = dateFormat.format(new Date()); System.out.print(formatted); if (formatted.endsWith("Z")) { System.out.print("\t(" + timeZone + ")"); } System.out.println(); }
public class Iso8601Util { private static TimeZone tz = TimeZone.getTimeZone("UTC"); private static DateFormat df = new SimpleDateFormat("yyyy-MM-dd static { df.setTimeZone(tz); } public static String now() { return df.format(new Date()); } }
private static final String GMT = "GMT"; private static final String DATE_FORMAT_ISO = "yyyyMMdd public static Calendar isoToCalendar(final String inputDate) { Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(GMT)); try { SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_ISO, Locale.US); dateFormat.setTimeZone(TimeZone.getTimeZone(GMT)); Date date = dateFormat.parse(inputDate); calendar.setTime(date); } catch (ParseException e) { Log.e("TAG",e.getMessage()); } return calendar; }
private static String getCurrentDateIso() { DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd dateFormat.setTimeZone(TimeZone.getTimeZone("UTC")); return dateFormat.format(new Date()); }
Instant.now() .truncatedTo( ChronoUnit.MINUTES ) .toString()
Instant instant = Instant.now().truncatedTo( ChronoUnit.MINUTES ) ; String output = instant.toString();
DateTimeFormatter.ISO_DATE_TIME .withZone(ZoneOffset.UTC) .format(yourDateObject.toInstant())
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd String date=sdf.format (new Date() );
-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044
-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=1044
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=1044
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 <YourAppName>
java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 <YourAppName>
java -Xnoagent -Djava.compiler=NONE -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 <YourAppName>
java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044 HelloWhirled Listening for transport dt_socket at address: 1044 Hello whirled
/** * When {@paramref a} is null, we rely on b for the discombobulation. * * @param a this is one of the parameters * @param b another param */ void foo(String a, int b) {...}
/** * Allocates a new <code>String</code> that contains characters from * a subarray of the character array argument. The <code>offset</code> * argument is the index of the first character of the subarray and * the <code>count</code> argument specifies the length of the * subarray. The contents of the subarray are copied; subsequent * modification of the character array does not affect the newly * created string. * * @param value array that is the source of characters. * @param offset the initial offset. * @param count the length. * @exception IndexOutOfBoundsException if the <code>offset</code> * and <code>count</code> arguments index characters outside * the bounds of the <code>value</code> array. */ public String(char value[], int offset, int count) { if (offset < 0) { throw new StringIndexOutOfBoundsException(offset); } if (count < 0) { throw new StringIndexOutOfBoundsException(count); } if (offset > value.length - count) { throw new StringIndexOutOfBoundsException(offset + count); } this.value = new char[count]; this.count = count; System.arraycopy(value, offset, this.value, 0, count); }
Test x = new Test(); Test y = new Test(); x.instanceVariable = 10; y.instanceVariable = 20; System.out.println(x.instanceVariable);
Test x = new Test(); Test y = new Test(); x.staticVariable = 10; y.staticVariable = 20; System.out.println(x.staticVariable);
Test x = new Test(); Test y = new Test(); Test.staticVariable = 10; Test.staticVariable = 20; System.out.println(Test.staticVariable);
Class Test{ public final int a; } Test t1 = new Test(); t1.a = 10; Test t2 = new Test(); t2.a = 20;
Class TestStatic{ public static final int a; } TestStatic t1 = new TestStatic(); t1.a = 10; TestStatic t2 = new TestStatic(); t1.a = 20;
public class ConstTest { private final int value = 10; private static final int valueStatic = 20; private final File valueObject = new File(""); private static final File valueObjectStatic = new File(""); public void printAddresses() { System.out.println("final int address " + ObjectUtils.identityToString(value)); System.out.println("final static int address " + ObjectUtils.identityToString(valueStatic)); System.out.println("final file address " + ObjectUtils.identityToString(valueObject)); System.out.println("final static file address " + ObjectUtils.identityToString(valueObjectStatic)); } public static void main(final String args[]) { final ConstTest firstObj = new ConstTest(); final ConstTest sndObj = new ConstTest(); firstObj.printAdresses(); sndObj.printAdresses(); } }
final int address java.lang.Integer@6d9efb05 final static int address java.lang.Integer@60723d7c final file address java.io.File@6c22c95b final static file address java.io.File@5fd1acd3
final int address java.lang.Integer@6d9efb05 final static int address java.lang.Integer@60723d7c final file address java.io.File@3ea981ca final static file address java.io.File@5fd1acd3
public class TestClass { private final static double NUMBER = Math.random(); public TestClass () { System.out.println(NUMBER); } }
public class TestClass { private final double NUMBER = Math.random(); public TestClass () { System.out.println(NUMBER); } }
public class StaticVariable { static int noOfInstances; StaticVariable() { noOfInstances++; } public static void main(String[] args) { StaticVariable sv1 = new StaticVariable(); System.out.println("No. of instances for sv1 : " + sv1.noOfInstances); StaticVariable sv2 = new StaticVariable(); System.out.println("No. of instances for sv1 : " + sv1.noOfInstances); System.out.println("No. of instances for st2 : " + sv2.noOfInstances); StaticVariable sv3 = new StaticVariable(); System.out.println("No. of instances for sv1 : " + sv1.noOfInstances); System.out.println("No. of instances for sv2 : " + sv2.noOfInstances); System.out.println("No. of instances for sv3 : " + sv3.noOfInstances); } }
C:\java>java StaticVariable No. of instances for sv1 : 1 No. of instances for sv1 : 2 No. of instances for st2 : 2 No. of instances for sv1 : 3 No. of instances for sv2 : 3 No. of instances for sv3 : 3
class A { final int f; static final int sf = 5; A(int num) { this.f = num; } void show() { System.out.printf("About Object: %s\n Final: %d\n Static Final: %d\n\n", this.toString(), this.f, sf); } public static void main(String[] args) { A ob1 = new A(14); ob1.show(); A ob2 = new A(21); ob2.show(); } }
public class JustFinalAttr { public final int Number; public JustFinalAttr(int a){ Number=a; } } ...System.out.println(new JustFinalAttr(4).Number);
final String CENT_1 = new Random().nextInt(2) == 0 ? "HEADS" : "TAILS"; final static String CENT_2 = new Random().nextInt(2) == 0 ? "HEADS" : "TAILS";
package test; public class Test { final long OBJECT_ID = new Random().nextLong(); final static long CLASSS_ID = new Random().nextLong(); public static void main(String[] args) { Test[] test = new Test[5]; for (int i = 0; i < test.length; i++){ test[i] = new Test(); System.out.println("Class id: "+test[i].CLASSS_ID); System.out.println("Object id: "+test[i].OBJECT_ID); } } }
public final class Foo { private final int i; private static final int j=20; public Foo(int val){ this.i=val; } public static void main(String[] args) { Foo foo1= new Foo(10); Foo foo2= new Foo(40); System.out.println(foo1.i); System.out.println(foo2.i); System.out.println(check.j); } }
public class ExperimentFinal { private final int a; private static final int b = 999; public ExperimentFinal(int a) { super(); this.a = a; } public int getA() { return a; } public int getB() { return b; } public void print(int a, int b) { System.out.println("final int: " + a + " \nstatic final int: " + b); } public static void main(String[] args) { ExperimentFinal test = new ExperimentFinal(9); test.print(test.getA(), test.getB()); } }
public class City { private static double iphone_base_price = 10000; private double iphone_citi_price; private final double iphone_diff; private String cityName = ""; private static final String countryName = "India"; public City(String cityName, double iphone_diff) { super(); this.iphone_diff = iphone_diff; iphone_citi_price = iphone_base_price + iphone_diff; this.cityName = cityName; } /** * get phone price * * @return */ private double getPrice() { return iphone_citi_price; } /** * Get city name * * @return */ private String getCityName() { return cityName; } public static void main(String[] args) { City newyork = new City("Newyork", 300); System.out.println(newyork.getPrice() + " " + newyork.getCityName()); City california = new City("California", 800); System.out.println(california.getPrice() + " " + california.getCityName()); iphone_base_price = 9000; City delhi = new City("delhi", 400); System.out.println(delhi.getPrice() + " " + delhi.getCityName()); City moscow = new City("delhi", 500); System.out.println(moscow.getPrice() + " " + moscow.getCityName()); System.out.println(countryName); } }
public class LengthDemo { public static void main(String[] args) { Rectangle box = new Rectangle(); System.out.println("Sending the value 10.0 " + "to the setLength method."); box.setLength(10.0); System.out.println("Done."); } }
ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream("/Users/Desktop/files/temp.txt")); oos.writeObject(linkedListHead); oos.close();
public class MyExternalizable implements Externalizable { private String userName; private String passWord; private Integer roll; public MyExternalizable() { } public MyExternalizable(String userName, String passWord, Integer roll) { this.userName = userName; this.passWord = passWord; this.roll = roll; } @Override public void writeExternal(ObjectOutput oo) throws IOException { oo.writeObject(userName); oo.writeObject(roll); } @Override public void readExternal(ObjectInput oi) throws IOException, ClassNotFoundException { userName = (String)oi.readObject(); roll = (Integer)oi.readObject(); } public String toString() { StringBuilder b = new StringBuilder(); b.append("userName: "); b.append(userName); b.append(" passWord: "); b.append(passWord); b.append(" roll: "); b.append(roll); return b.toString(); } public static void main(String[] args) { try { MyExternalizable m = new MyExternalizable("nikki", "student001", 20); System.out.println(m.toString()); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("/Users/Desktop/files/temp1.txt")); oos.writeObject(m); oos.close(); System.out.println("***********************************************************************"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream("/Users/Desktop/files/temp1.txt")); MyExternalizable mm = (MyExternalizable)ois.readObject(); mm.toString(); System.out.println(mm.toString()); } catch (ClassNotFoundException ex) { Logger.getLogger(MyExternalizable.class.getName()).log(Level.SEVERE, null, ex); } catch(IOException ex) { Logger.getLogger(MyExternalizable.class.getName()).log(Level.SEVERE, null, ex); } } }
java.io.InvalidClassException: javaserialization.MyExternalizable; javaserialization.MyExternalizable; no valid constructor.
userName: nikki passWord: student001 roll: 20 *********************************************************************** userName: nikki passWord: null roll: 20
package java.io; public interface Externalizable extends Serializable { public void writeExternal(ObjectOutput out) throws IOException; public void readExternal(ObjectInput in) throws IOException, java.lang.ClassNotFoundException; }
@Override public void writeExternal(ObjectOutput out) throws IOException { out.writeInt( id ); out.writeUTF( role ); out.writeObject(address); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { this.id = in.readInt(); this.address = (Address) in.readObject(); this.role = in.readUTF(); }
class Role { String role; } class User extends Role implements Serializable { private static final long serialVersionUID = 5081877L; Integer id; Address address; public User() { System.out.println("Default Constructor get executed."); } public User( String role ) { this.role = role; System.out.println("Parametarised Constructor."); } } class Address implements Serializable { private static final long serialVersionUID = 5081877L; String country; }
class User extends Role implements Externalizable { Integer id; Address address; public User() { System.out.println("Default Constructor get executed."); } public User( String role ) { this.role = role; System.out.println("Parametarised Constructor."); } @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeInt( id ); out.writeUTF( role ); out.writeObject(address); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { this.id = in.readInt(); this.address = (Address) in.readObject(); this.role = in.readUTF(); } }
public class CustomClass_Serialization { static String serFilename = "D:/serializable_CustomClass.ser"; public static void main(String[] args) throws IOException { Address add = new Address(); add.country = "IND"; User obj = new User("SE"); obj.id = 7; obj.address = add; objects_serialize(obj, serFilename); objects_deserialize(obj, serFilename); objects_WriteRead_External(obj, serFilename); } public static void objects_serialize( User obj, String serFilename ) throws IOException{ FileOutputStream fos = new FileOutputStream( new File( serFilename ) ); ObjectOutputStream objectOut = new ObjectOutputStream( fos ); objectOut.writeObject( obj ); objectOut.flush(); objectOut.close(); fos.close(); System.out.println("Data Stored in to a file"); } public static void objects_deserialize( User obj, String serFilename ) throws IOException{ try { FileInputStream fis = new FileInputStream( new File( serFilename ) ); ObjectInputStream ois = new ObjectInputStream( fis ); Object readObject; readObject = ois.readObject(); String calssName = readObject.getClass().getName(); System.out.println("Restoring Class Name : "+ calssName); User user = (User) readObject; System.out.format("Obj[Id:%d, Role:%s] \n", user.id, user.role); Address add = (Address) user.address; System.out.println("Inner Obj : "+ add.country ); ois.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static void objects_WriteRead_External( User obj, String serFilename ) throws IOException { FileOutputStream fos = new FileOutputStream(new File( serFilename )); ObjectOutputStream objectOut = new ObjectOutputStream( fos ); obj.writeExternal( objectOut ); objectOut.flush(); fos.close(); System.out.println("Data Stored in to a file"); try { User user = new User(); FileInputStream fis = new FileInputStream(new File( serFilename )); ObjectInputStream ois = new ObjectInputStream( fis ); user.readExternal(ois); System.out.format("Obj[Id:%d, Role:%s] \n", user.id, user.role); Address add = (Address) user.address; System.out.println("Inner Obj : "+ add.country ); ois.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } }
@Override public void writeExternal(ObjectOutput out) throws IOException { out.writeUTF(key); out.writeUTF(value); out.writeObject(emp); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { this.key = in.readUTF(); this.value = in.readUTF(); this.emp = (Employee) in.readObject(); } **In case of Serializable interface** /* We can comment below two method and use default serialization process as well Sequence of class attributes in read and write methods MUST BE same. private void writeObject(java.io.ObjectOutput stream) */ private void writeObject(java.io.ObjectOutputStream Outstream) throws IOException { System.out.println("from writeObject()"); /* We can define custom validation or business rules inside read/write methods. This way our validation methods will be automatically called by JVM, immediately after default serialization and deserialization process happens. checkTestInfo(); */ stream.writeUTF(name); stream.writeInt(age); stream.writeObject(salary); stream.writeObject(address); } private void readObject(java.io.ObjectInputStream Instream) throws IOException, ClassNotFoundException { System.out.println("from readObject()"); name = (String) stream.readUTF(); age = stream.readInt(); salary = (BigDecimal) stream.readObject(); address = (Address) stream.readObject(); }
public interface Foo{ public void MakeFoo(); void PerformBar(); }
public interface MyInterface { int CONST00 = 0; void method00(); static void method01() {} default void method02() {} private static void method03() {} private void method04() {} public static final int CONST10 = 0; public abstract void method10(); public static void method11() {} public default void method12() {} private static void method13() {} private void method14() {} }
PipedInputStream in = new PipedInputStream(); final PipedOutputStream out = new PipedOutputStream(in); new Thread(new Runnable() { public void run () { try { originalByteArrayOutputStream.writeTo(out); } catch (IOException e) { } } }).start();
public void doTwoThingsWithStream(InputStream inStream, OutputStream outStream){ ByteArrayOutputStream baos = new ByteArrayOutputStream(); doFirstThing(inStream, baos); InputStream isFromFirstData = new ByteArrayInputStream(baos.toByteArray()); doSecondThing(isFromFirstData, outStream); }
ByteArrayOutputStream buffer = (ByteArrayOutputStream) aOutputStream; byte[] bytes = buffer.toByteArray(); InputStream inputStream = new ByteArrayInputStream(bytes);
package info.whitebyte.utils; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; /** * This class extends the ByteArrayOutputStream by * providing a method that returns a new ByteArrayInputStream * which uses the internal byte array buffer. This buffer * is not copied, so no additional memory is used. After * creating the ByteArrayInputStream the instance of the * ByteArrayInOutStream can not be used anymore. * <p> * The ByteArrayInputStream can be retrieved using <code>getInputStream()</code>. * @author Nick Russler */ public class ByteArrayInOutStream extends ByteArrayOutputStream { /** * Creates a new ByteArrayInOutStream. The buffer capacity is * initially 32 bytes, though its size increases if necessary. */ public ByteArrayInOutStream() { super(); } /** * Creates a new ByteArrayInOutStream, with a buffer capacity of * the specified size, in bytes. * * @param size the initial size. * @exception IllegalArgumentException if size is negative. */ public ByteArrayInOutStream(int size) { super(size); } /** * Creates a new ByteArrayInputStream that uses the internal byte array buffer * of this ByteArrayInOutStream instance as its buffer array. The initial value * of pos is set to zero and the initial value of count is the number of bytes * that can be read from the byte array. The buffer array is not copied. This * instance of ByteArrayInOutStream can not be used anymore after calling this * method. * @return the ByteArrayInputStream instance */ public ByteArrayInputStream getInputStream() { ByteArrayInputStream in = new ByteArrayInputStream(this.buf, 0, this.count); this.buf = null; return in; } }
InputStream is = ... InputStream gz = IOUtil.pipe(is, o -> new GZIPOutputStream(o));
<dependency> <groupId>com.github.davidmoten</groupId> <artifactId>io-extras</artifactId> <version>0.1</version> </dependency>
import java.io.{IOException, InputStream, OutputStream} import scala.annotation.tailrec /** Acts as a replacement for ByteArrayOutputStream * */ class HugeMemoryOutputStream(capacity: Long) extends OutputStream { private val PAGE_SIZE: Int = 1024000 private val ALLOC_STEP: Int = 1024 /** Pages array * */ private var streamBuffers: Array[Array[Byte]] = Array.empty[Array[Byte]] /** Allocated pages count * */ private var pageCount: Int = 0 /** Allocated bytes count * */ private var allocatedBytes: Long = 0 /** Current position in stream * */ private var position: Long = 0 /** Stream length * */ private var length: Long = 0 allocSpaceIfNeeded(capacity) /** Gets page count based on given length * * @param length Buffer length * @return Page count to hold the specified amount of data */ private def getPageCount(length: Long) = { var pageCount = (length / PAGE_SIZE).toInt + 1 if ((length % PAGE_SIZE) == 0) { pageCount -= 1 } pageCount } /** Extends pages array * */ private def extendPages(): Unit = { if (streamBuffers.isEmpty) { streamBuffers = new Array[Array[Byte]](ALLOC_STEP) } else { val newStreamBuffers = new Array[Array[Byte]](streamBuffers.length + ALLOC_STEP) Array.copy(streamBuffers, 0, newStreamBuffers, 0, streamBuffers.length) streamBuffers = newStreamBuffers } pageCount = streamBuffers.length } /** Ensures buffers are bug enough to hold specified amount of data * * @param value Amount of data */ private def allocSpaceIfNeeded(value: Long): Unit = { @tailrec def allocSpaceIfNeededIter(value: Long): Unit = { val currentPageCount = getPageCount(allocatedBytes) val neededPageCount = getPageCount(value) if (currentPageCount < neededPageCount) { if (currentPageCount == pageCount) extendPages() streamBuffers(currentPageCount) = new Array[Byte](PAGE_SIZE) allocatedBytes = (currentPageCount + 1).toLong * PAGE_SIZE allocSpaceIfNeededIter(value) } } if (value < 0) throw new Error("AllocSpaceIfNeeded < 0") if (value > 0) { allocSpaceIfNeededIter(value) length = Math.max(value, length) if (position > length) position = length } } /** * Writes the specified byte to this output stream. The general * contract for <code>write</code> is that one byte is written * to the output stream. The byte to be written is the eight * low-order bits of the argument <code>b</code>. The 24 * high-order bits of <code>b</code> are ignored. * <p> * Subclasses of <code>OutputStream</code> must provide an * implementation for this method. * * @param b the <code>byte</code>. */ @throws[IOException] override def write(b: Int): Unit = { val buffer: Array[Byte] = new Array[Byte](1) buffer(0) = b.toByte write(buffer) } /** * Writes <code>len</code> bytes from the specified byte array * starting at offset <code>off</code> to this output stream. * The general contract for <code>write(b, off, len)</code> is that * some of the bytes in the array <code>b</code> are written to the * output stream in order; element <code>b[off]</code> is the first * byte written and <code>b[off+len-1]</code> is the last byte written * by this operation. * <p> * The <code>write</code> method of <code>OutputStream</code> calls * the write method of one argument on each of the bytes to be * written out. Subclasses are encouraged to override this method and * provide a more efficient implementation. * <p> * If <code>b</code> is <code>null</code>, a * <code>NullPointerException</code> is thrown. * <p> * If <code>off</code> is negative, or <code>len</code> is negative, or * <code>off+len</code> is greater than the length of the array * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown. * * @param b the data. * @param off the start offset in the data. * @param len the number of bytes to write. */ @throws[IOException] override def write(b: Array[Byte], off: Int, len: Int): Unit = { @tailrec def writeIter(b: Array[Byte], off: Int, len: Int): Unit = { val currentPage: Int = (position / PAGE_SIZE).toInt val currentOffset: Int = (position % PAGE_SIZE).toInt if (len != 0) { val currentLength: Int = Math.min(PAGE_SIZE - currentOffset, len) Array.copy(b, off, streamBuffers(currentPage), currentOffset, currentLength) position += currentLength writeIter(b, off + currentLength, len - currentLength) } } allocSpaceIfNeeded(position + len) writeIter(b, off, len) } /** Gets an InputStream that points to HugeMemoryOutputStream buffer * * @return InputStream */ def asInputStream(): InputStream = { new HugeMemoryInputStream(streamBuffers, length) } private class HugeMemoryInputStream(streamBuffers: Array[Array[Byte]], val length: Long) extends InputStream { /** Current position in stream * */ private var position: Long = 0 /** * Reads the next byte of data from the input stream. The value byte is * returned as an <code>int</code> in the range <code>0</code> to * <code>255</code>. If no byte is available because the end of the stream * has been reached, the value <code>-1</code> is returned. This method * blocks until input data is available, the end of the stream is detected, * or an exception is thrown. * * <p> A subclass must provide an implementation of this method. * * @return the next byte of data, or <code>-1</code> if the end of the * stream is reached. */ @throws[IOException] def read: Int = { val buffer: Array[Byte] = new Array[Byte](1) if (read(buffer) == 0) throw new Error("End of stream") else buffer(0) } /** * Reads up to <code>len</code> bytes of data from the input stream into * an array of bytes. An attempt is made to read as many as * <code>len</code> bytes, but a smaller number may be read. * The number of bytes actually read is returned as an integer. * * <p> This method blocks until input data is available, end of file is * detected, or an exception is thrown. * * <p> If <code>len</code> is zero, then no bytes are read and * <code>0</code> is returned; otherwise, there is an attempt to read at * least one byte. If no byte is available because the stream is at end of * file, the value <code>-1</code> is returned; otherwise, at least one * byte is read and stored into <code>b</code>. * * <p> The first byte read is stored into element <code>b[off]</code>, the * next one into <code>b[off+1]</code>, and so on. The number of bytes read * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of * bytes actually read; these bytes will be stored in elements * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>, * leaving elements <code>b[off+</code><i>k</i><code>]</code> through * <code>b[off+len-1]</code> unaffected. * * <p> In every case, elements <code>b[0]</code> through * <code>b[off]</code> and elements <code>b[off+len]</code> through * <code>b[b.length-1]</code> are unaffected. * * <p> The <code>read(b,</code> <code>off,</code> <code>len)</code> method * for class <code>InputStream</code> simply calls the method * <code>read()</code> repeatedly. If the first such call results in an * <code>IOException</code>, that exception is returned from the call to * the <code>read(b,</code> <code>off,</code> <code>len)</code> method. If * any subsequent call to <code>read()</code> results in a * <code>IOException</code>, the exception is caught and treated as if it * were end of file; the bytes read up to that point are stored into * <code>b</code> and the number of bytes read before the exception * occurred is returned. The default implementation of this method blocks * until the requested amount of input data <code>len</code> has been read, * end of file is detected, or an exception is thrown. Subclasses are encouraged * to provide a more efficient implementation of this method. * * @param b the buffer into which the data is read. * @param off the start offset in array <code>b</code> * at which the data is written. * @param len the maximum number of bytes to read. * @return the total number of bytes read into the buffer, or * <code>-1</code> if there is no more data because the end of * the stream has been reached. * @see java.io.InputStream */ @throws[IOException] override def read(b: Array[Byte], off: Int, len: Int): Int = { @tailrec def readIter(acc: Int, b: Array[Byte], off: Int, len: Int): Int = { val currentPage: Int = (position / PAGE_SIZE).toInt val currentOffset: Int = (position % PAGE_SIZE).toInt val count: Int = Math.min(len, length - position).toInt if (count == 0 || position >= length) acc else { val currentLength = Math.min(PAGE_SIZE - currentOffset, count) Array.copy(streamBuffers(currentPage), currentOffset, b, off, currentLength) position += currentLength readIter(acc + currentLength, b, off + currentLength, len - currentLength) } } readIter(0, b, off, len) } /** * Skips over and discards <code>n</code> bytes of data from this input * stream. The <code>skip</code> method may, for a variety of reasons, end * up skipping over some smaller number of bytes, possibly <code>0</code>. * This may result from any of a number of conditions; reaching end of file * before <code>n</code> bytes have been skipped is only one possibility. * The actual number of bytes skipped is returned. If <code>n</code> is * negative, the <code>skip</code> method for class <code>InputStream</code> always * returns 0, and no bytes are skipped. Subclasses may handle the negative * value differently. * * The <code>skip</code> method of this class creates a * byte array and then repeatedly reads into it until <code>n</code> bytes * have been read or the end of the stream has been reached. Subclasses are * encouraged to provide a more efficient implementation of this method. * For instance, the implementation may depend on the ability to seek. * * @param n the number of bytes to be skipped. * @return the actual number of bytes skipped. */ @throws[IOException] override def skip(n: Long): Long = { if (n < 0) 0 else { position = Math.min(position + n, length) length - position } } } }
val out: HugeMemoryOutputStream = new HugeMemoryOutputStream(initialCapacity ) out.write(...) ... val in1: InputStream = out.asInputStream() in1.read(...) ... val in2: InputStream = out.asInputStream() in2.read(...) ...
OutputStream out = new ByteArrayOutputStream(); ... out.write(); ... ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(out.toString().getBytes()));
double multiplyByPowerOfTen(final double d, final int exponent) { switch (exponent) { case 0: return d; case 1: return d*10; case 2: return d*100; case 9: return d*1000000000; case 10: return d*10000000000L; case 18: return d*1000000000000000000L; default: throw new ParseException("Unhandled power of ten " + power, 0); } }
[Verified Entry Point] 0x00000000024f0160: mov DWORD PTR [rsp-0x6000],eax ; {no_reloc} 0x00000000024f0167: push rbp 0x00000000024f0168: sub rsp,0x10 ;*synchronization entry ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56) 0x00000000024f016c: cmp edx,0x3 0x00000000024f016f: je 0x00000000024f01c3 0x00000000024f0171: cmp edx,0x3 0x00000000024f0174: jg 0x00000000024f01a5 0x00000000024f0176: cmp edx,0x1 0x00000000024f0179: je 0x00000000024f019b 0x00000000024f017b: cmp edx,0x1 0x00000000024f017e: jg 0x00000000024f0191 0x00000000024f0180: test edx,edx 0x00000000024f0182: je 0x00000000024f01cb 0x00000000024f0184: mov ebp,edx 0x00000000024f0186: mov edx,0x17 0x00000000024f018b: call 0x00000000024c90a0 ; OopMap{off=48} ;*new ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83) ; {runtime_call} 0x00000000024f0190: int3 ;*new ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83) 0x00000000024f0191: mulsd xmm0,QWORD PTR [rip+0xffffffffffffffa7] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@52 (line 62) ; {section_word} 0x00000000024f0199: jmp 0x00000000024f01cb 0x00000000024f019b: mulsd xmm0,QWORD PTR [rip+0xffffffffffffff8d] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@46 (line 60) ; {section_word} 0x00000000024f01a3: jmp 0x00000000024f01cb 0x00000000024f01a5: cmp edx,0x5 0x00000000024f01a8: je 0x00000000024f01b9 0x00000000024f01aa: cmp edx,0x5 0x00000000024f01ad: jg 0x00000000024f0184 ;*tableswitch ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56) 0x00000000024f01af: mulsd xmm0,QWORD PTR [rip+0xffffffffffffff81] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@64 (line 66) ; {section_word} 0x00000000024f01b7: jmp 0x00000000024f01cb 0x00000000024f01b9: mulsd xmm0,QWORD PTR [rip+0xffffffffffffff67] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@70 (line 68) ; {section_word} 0x00000000024f01c1: jmp 0x00000000024f01cb 0x00000000024f01c3: mulsd xmm0,QWORD PTR [rip+0xffffffffffffff55] ;*tableswitch ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56) ; {section_word} 0x00000000024f01cb: add rsp,0x10 0x00000000024f01cf: pop rbp 0x00000000024f01d0: test DWORD PTR [rip+0xfffffffffdf3fe2a],eax ; {poll_return} 0x00000000024f01d6: ret
[Verified Entry Point] 0x000000000287fe20: mov DWORD PTR [rsp-0x6000],eax ; {no_reloc} 0x000000000287fe27: push rbp 0x000000000287fe28: sub rsp,0x10 ;*synchronization entry ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56) 0x000000000287fe2c: cmp edx,0x13 0x000000000287fe2f: jae 0x000000000287fe46 0x000000000287fe31: movsxd r10,edx 0x000000000287fe34: shl r10,0x3 0x000000000287fe38: movabs r8,0x287fd70 ; {section_word} 0x000000000287fe42: jmp QWORD PTR [r8+r10*1] ;*tableswitch ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56) 0x000000000287fe46: mov ebp,edx 0x000000000287fe48: mov edx,0x31 0x000000000287fe4d: xchg ax,ax 0x000000000287fe4f: call 0x00000000028590a0 ; OopMap{off=52} ;*new ; - javaapplication4.Test1::multiplyByPowerOfTen@202 (line 96) ; {runtime_call} 0x000000000287fe54: int3 ;*new ; - javaapplication4.Test1::multiplyByPowerOfTen@202 (line 96) 0x000000000287fe55: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe8b] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@194 (line 92) ; {section_word} 0x000000000287fe5d: jmp 0x000000000287ff16 0x000000000287fe62: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe86] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@188 (line 90) ; {section_word} 0x000000000287fe6a: jmp 0x000000000287ff16 0x000000000287fe6f: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe81] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@182 (line 88) ; {section_word} 0x000000000287fe77: jmp 0x000000000287ff16 0x000000000287fe7c: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe7c] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@176 (line 86) ; {section_word} 0x000000000287fe84: jmp 0x000000000287ff16 0x000000000287fe89: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe77] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@170 (line 84) ; {section_word} 0x000000000287fe91: jmp 0x000000000287ff16 0x000000000287fe96: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe72] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@164 (line 82) ; {section_word} 0x000000000287fe9e: jmp 0x000000000287ff16 0x000000000287fea0: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe70] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@158 (line 80) ; {section_word} 0x000000000287fea8: jmp 0x000000000287ff16 0x000000000287feaa: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe6e] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@152 (line 78) ; {section_word} 0x000000000287feb2: jmp 0x000000000287ff16 0x000000000287feb4: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe24] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@146 (line 76) ; {section_word} 0x000000000287febc: jmp 0x000000000287ff16 0x000000000287febe: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe6a] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@140 (line 74) ; {section_word} 0x000000000287fec6: jmp 0x000000000287ff16 0x000000000287fec8: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe68] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@134 (line 72) ; {section_word} 0x000000000287fed0: jmp 0x000000000287ff16 0x000000000287fed2: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe66] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@128 (line 70) ; {section_word} 0x000000000287feda: jmp 0x000000000287ff16 0x000000000287fedc: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe64] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@122 (line 68) ; {section_word} 0x000000000287fee4: jmp 0x000000000287ff16 0x000000000287fee6: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe62] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@116 (line 66) ; {section_word} 0x000000000287feee: jmp 0x000000000287ff16 0x000000000287fef0: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe60] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@110 (line 64) ; {section_word} 0x000000000287fef8: jmp 0x000000000287ff16 0x000000000287fefa: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe5e] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@104 (line 62) ; {section_word} 0x000000000287ff02: jmp 0x000000000287ff16 0x000000000287ff04: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe5c] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@98 (line 60) ; {section_word} 0x000000000287ff0c: jmp 0x000000000287ff16 0x000000000287ff0e: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe12] ;*tableswitch ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56) ; {section_word} 0x000000000287ff16: add rsp,0x10 0x000000000287ff1a: pop rbp 0x000000000287ff1b: test DWORD PTR [rip+0xfffffffffd9b00df],eax ; {poll_return} 0x000000000287ff21: ret
[Verified Entry Point] 0x0000000002524560: mov DWORD PTR [rsp-0x6000],eax ; {no_reloc} 0x0000000002524567: push rbp 0x0000000002524568: sub rsp,0x10 ;*synchronization entry ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56) 0x000000000252456c: movapd xmm1,xmm0 0x0000000002524570: cmp edx,0x1f 0x0000000002524573: jae 0x0000000002524592 ;*tableswitch ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56) 0x0000000002524575: movsxd r10,edx 0x0000000002524578: shl r10,0x3 0x000000000252457c: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe3c] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@364 (line 118) ; {section_word} 0x0000000002524584: movabs r8,0x2524450 ; {section_word} 0x000000000252458e: jmp QWORD PTR [r8+r10*1] ;*tableswitch ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56) 0x0000000002524592: mov ebp,edx 0x0000000002524594: mov edx,0x31 0x0000000002524599: xchg ax,ax 0x000000000252459b: call 0x00000000024f90a0 ; OopMap{off=64} ;*new ; - javaapplication4.Test1::multiplyByPowerOfTen@370 (line 120) ; {runtime_call} 0x00000000025245a0: int3 ;*new ; - javaapplication4.Test1::multiplyByPowerOfTen@370 (line 120) 0x00000000025245a1: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe27] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@358 (line 116) ; {section_word} 0x00000000025245a9: jmp 0x0000000002524744 0x00000000025245ae: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe22] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@348 (line 114) ; {section_word} 0x00000000025245b6: jmp 0x0000000002524744 0x00000000025245bb: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe1d] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@338 (line 112) ; {section_word} 0x00000000025245c3: jmp 0x0000000002524744 0x00000000025245c8: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe18] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@328 (line 110) ; {section_word} 0x00000000025245d0: jmp 0x0000000002524744 0x00000000025245d5: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe13] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@318 (line 108) ; {section_word} 0x00000000025245dd: jmp 0x0000000002524744 0x00000000025245e2: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe0e] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@308 (line 106) ; {section_word} 0x00000000025245ea: jmp 0x0000000002524744 0x00000000025245ef: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe09] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@298 (line 104) ; {section_word} 0x00000000025245f7: jmp 0x0000000002524744 0x00000000025245fc: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe04] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@288 (line 102) ; {section_word} 0x0000000002524604: jmp 0x0000000002524744 0x0000000002524609: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffdff] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@278 (line 100) ; {section_word} 0x0000000002524611: jmp 0x0000000002524744 0x0000000002524616: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffdfa] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@268 (line 98) ; {section_word} 0x000000000252461e: jmp 0x0000000002524744 0x0000000002524623: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffd9d] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@258 (line 96) ; {section_word} 0x000000000252462b: jmp 0x0000000002524744 0x0000000002524630: movapd xmm0,xmm1 0x0000000002524634: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffe0c] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@242 (line 92) ; {section_word} 0x000000000252463c: jmp 0x0000000002524744 0x0000000002524641: movapd xmm0,xmm1 0x0000000002524645: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffddb] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@236 (line 90) ; {section_word} 0x000000000252464d: jmp 0x0000000002524744 0x0000000002524652: movapd xmm0,xmm1 0x0000000002524656: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffdd2] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@230 (line 88) ; {section_word} 0x000000000252465e: jmp 0x0000000002524744 0x0000000002524663: movapd xmm0,xmm1 0x0000000002524667: mulsd xmm0,QWORD PTR [rip+0xfffffffffffffdc9] ;*dmul ; - javaapplication4.Test1::multiplyByPowerOfTen@224 (line 86) ; {section_word} [etc.] 0x0000000002524744: add rsp,0x10 0x0000000002524748: pop rbp 0x0000000002524749: test DWORD PTR [rip+0xfffffffffde1b8b1],eax ; {poll_return} 0x000000000252474f: ret
public class SwitchTest10 { public static void main(String[] args) { int n = 0; switcher(n); } public static void switcher(int n) { switch(n) { case 0: System.out.println(0); break; case 1: System.out.println(1); break; case 2: System.out.println(2); break; case 3: System.out.println(3); break; case 4: System.out.println(4); break; case 5: System.out.println(5); break; case 6: System.out.println(6); break; case 7: System.out.println(7); break; case 8: System.out.println(8); break; case 9: System.out.println(9); break; case 10: System.out.println(10); break; default: System.out.println("test"); } } }
public static void switcher(int); Code: 0: iload_0 1: tableswitch{ 0: 60; 1: 70; 2: 80; 3: 90; 4: 100; 5: 110; 6: 120; 7: 131; 8: 142; 9: 153; 10: 164; default: 175 }
public class SwitchTest22 { public static void main(String[] args) { int n = 0; switcher(n); } public static void switcher(int n) { switch(n) { case 0: System.out.println(0); break; case 1: System.out.println(1); break; case 2: System.out.println(2); break; case 3: System.out.println(3); break; case 4: System.out.println(4); break; case 5: System.out.println(5); break; case 6: System.out.println(6); break; case 7: System.out.println(7); break; case 8: System.out.println(8); break; case 9: System.out.println(9); break; case 100: System.out.println(10); break; case 110: System.out.println(10); break; case 120: System.out.println(10); break; case 130: System.out.println(10); break; case 140: System.out.println(10); break; case 150: System.out.println(10); break; case 160: System.out.println(10); break; case 170: System.out.println(10); break; case 180: System.out.println(10); break; case 190: System.out.println(10); break; case 200: System.out.println(10); break; case 210: System.out.println(10); break; case 220: System.out.println(10); break; default: System.out.println("test"); } } }
public static void switcher(int); Code: 0: iload_0 1: lookupswitch{ 0: 196; 1: 206; 2: 216; 3: 226; 4: 236; 5: 246; 6: 256; 7: 267; 8: 278; 9: 289; 100: 300; 110: 311; 120: 322; 130: 333; 140: 344; 150: 355; 160: 366; 170: 377; 180: 388; 190: 399; 200: 410; 210: 421; 220: 432; default: 443 }
public static void switcher(int); Code: 0: iload_0 1: tableswitch{ 0: 104; 1: 114; 2: 124; 3: 134; 4: 144; 5: 154; 6: 164; 7: 175; 8: 186; 9: 197; 10: 219; 11: 219; 12: 219; 13: 219; 14: 219; 15: 219; 16: 219; 17: 219; 18: 219; 19: 219; 20: 219; 21: 208; default: 219 }
private static final double[] mul={1d, 10d...}; static double multiplyByPowerOfTen(final double d, final int exponent) { if (exponent<0 || exponent>=mul.length) throw new ParseException(); return mul[exponent]*d; }
wr.write(new sun.misc.BASE64Encoder().encode(buf));
import sun.misc.BASE64Encoder; import sun.misc.BASE64Decoder;
byte[] encodedBytes = Base64.encodeBase64("Test".getBytes()); System.out.println("encodedBytes " + new String(encodedBytes)); byte[] decodedBytes = Base64.decodeBase64(encodedBytes); System.out.println("decodedBytes " + new String(decodedBytes));
byte[] encodedBytes = Base64.getEncoder().encode("Test".getBytes()); System.out.println("encodedBytes " + new String(encodedBytes)); byte[] decodedBytes = Base64.getDecoder().decode(encodedBytes); System.out.println("decodedBytes " + new String(decodedBytes));
byte[] salt = new byte[] { 50, 111, 8, 53, 86, 35, -19, -47 }; System.out.println(DatatypeConverter.printBase64Binary(salt));
Base64.getEncoder().encodeToString(string.getBytes(StandardCharsets.UTF_8))
import java.nio.charset.StandardCharsets; import java.util.Base64; public class Temp { public static void main(String... args) throws Exception { final String s = "old crow medicine show"; final byte[] authBytes = s.getBytes(StandardCharsets.UTF_8); final String encoded = Base64.getEncoder().encodeToString(authBytes); System.out.println(s + " => " + encoded); } }
old crow medicine show => b2xkIGNyb3cgbWVkaWNpbmUgc2hvdw==
<dependency> <artifactId>guava</artifactId> <groupId>com.google.guava</groupId> <type>jar</type> <version>14.0.1</version> </dependency>
String inputContent = "Hello Vit Nam"; String base64String = BaseEncoding.base64().encode(inputContent.getBytes("UTF-8")); System.out.println("Base64:" + base64String); byte[] contentInBytes = BaseEncoding.base64().decode(base64String); System.out.println("Source content: " + new String(contentInBytes, "UTF-8"));
import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.io.FileWriter; import java.io.InputStream; import java.io.IOException; import java.io.OutputStream; public class Base64 { public static void main(String args[]) throws IOException { /* * if (args.length != 2) {System.out.println( * "Command line parameters: inputFileName outputFileName"); * System.exit(9); } encodeFile(args[0], args[1]); */ File sourceImage = new File("back3.png"); File sourceImage64 = new File("back3.txt"); File destImage = new File("back4.png"); encodeFile(sourceImage, sourceImage64); decodeFile(sourceImage64, destImage); } private static void encodeFile(File inputFile, File outputFile) throws IOException { BufferedInputStream in = null; BufferedWriter out = null; try { in = new BufferedInputStream(new FileInputStream(inputFile)); out = new BufferedWriter(new FileWriter(outputFile)); encodeStream(in, out); out.flush(); } finally { if (in != null) in.close(); if (out != null) out.close(); } } private static void encodeStream(InputStream in, BufferedWriter out) throws IOException { int lineLength = 72; byte[] buf = new byte[lineLength / 4 * 3]; while (true) { int len = in.read(buf); if (len &lt;= 0) break; out.write(Base64Coder.encode(buf, 0, len)); out.newLine(); } } static String encodeArray(byte[] in) throws IOException { StringBuffer out = new StringBuffer(); out.append(Base64Coder.encode(in, 0, in.length)); return out.toString(); } static byte[] decodeArray(String in) throws IOException { byte[] buf = Base64Coder.decodeLines(in); return buf; } private static void decodeFile(File inputFile, File outputFile) throws IOException { BufferedReader in = null; BufferedOutputStream out = null; try { in = new BufferedReader(new FileReader(inputFile)); out = new BufferedOutputStream(new FileOutputStream(outputFile)); decodeStream(in, out); out.flush(); } finally { if (in != null) in.close(); if (out != null) out.close(); } } private static void decodeStream(BufferedReader in, OutputStream out) throws IOException { while (true) { String s = in.readLine(); if (s == null) break; byte[] buf = Base64Coder.decodeLines(s); out.write(buf); } } }
Bitmap bmImage = ByteArrayOutputStream baos = new ByteArrayOutputStream(); bmImage.compress(Bitmap.CompressFormat.JPEG, 100, baos); byte[] imageData = baos.toByteArray(); String encodedImage = Base64.encodeArray(imageData);
<img alt="" src="data:image/png;base64,<?php echo $encodedImage; ?>" width="100px" /> <img alt="" src="data:image/png;base64,/9j/4AAQ...........1f/9k=" width="100px" />
public interface MyCodec { static String apacheDecode(String encodedStr) { return new String(Base64.decodeBase64(encodedStr), Charset.forName("UTF-8")); } static String apacheEncode(String decodedStr) { byte[] decodedByteArr = decodedStr.getBytes(Charset.forName("UTF-8")); return Base64.encodeBase64String(decodedByteArr); } static String javaDecode(String encodedStr) { return new String(java.util.Base64.getDecoder().decode(encodedStr), Charset.forName("UTF-8")); } static String javaEncode(String decodedStr) { byte[] decodedByteArr = decodedStr.getBytes(Charset.forName("UTF-8")); return java.util.Base64.getEncoder().encodeToString(decodedByteArr); } }
public class CodecDemo { public static void main(String[] args) { String decodedText = "Hello World!"; String encodedApacheText = MyCodec.apacheEncode(decodedText); String encodedJavaText = MyCodec.javaEncode(decodedText); System.out.println("Apache encoded text: " + MyCodec.apacheEncode(encodedApacheText)); System.out.println("Java encoded text: " + MyCodec.javaEncode(encodedJavaText)); System.out.println("Encoded results equal: " + encodedApacheText.equals(encodedJavaText)); System.out.println("Apache decode Java: " + MyCodec.apacheDecode(encodedJavaText)); System.out.println("Java decode Java: " + MyCodec.javaDecode(encodedJavaText)); System.out.println("Apache decode Apache: " + MyCodec.apacheDecode(encodedApacheText)); System.out.println("Java decode Apache: " + MyCodec.javaDecode(encodedApacheText)); } }
Apache encoded text: U0dWc2JHOGdWMjl5YkdRaA0K Java encoded text: U0dWc2JHOGdWMjl5YkdRaA== Encoded results equal: false Apache decode Java: Hello World! Java decode Java: Hello World! Apache decode Apache: Hello World! Exception in thread "main" java.lang.IllegalArgumentException: Illegal base64 character d at java.util.Base64$Decoder.decode0(Base64.java:714) at java.util.Base64$Decoder.decode(Base64.java:526) at java.util.Base64$Decoder.decode(Base64.java:549)
return Base64.encodeBase64String(decodedByteArr).trim();
Apache encoded text: U0dWc2JHOGdWMjl5YkdRaA== Java encoded text: U0dWc2JHOGdWMjl5YkdRaA== Encoded results equal: true Apache decode Java: Hello World! Java decode Java: Hello World! Apache decode Apache: Hello World! Java decode Apache: Hello World!
byte[] bytesEncoded = Base64.encodeBase64(str .getBytes()); System.out.println("ecncoded value is " + new String(bytesEncoded )); byte[] valueDecoded= Base64.decodeBase64(bytesEncoded ); System.out.println("Decoded value is " + new String(valueDecoded));
import android.util.Base64; byte[] encodedBytes = Base64.encode("Test".getBytes()); Log.d("tag", "encodedBytes " + new String(encodedBytes)); byte[] decodedBytes = Base64.decode(encodedBytes); Log.d("tag", "decodedBytes " + new String(decodedBytes));
import java.util.Base64; String str = "your string"; String encodedStr = Base64.getEncoder().encodeToString(str.getBytes("utf-8"));
byte[] raw = { 1, 2, 3 }; String encoded = Base64Utils.encodeToString(raw); byte[] decoded = Base64Utils.decodeFromString(encoded);
import javax.xml.bind.DatatypeConverter; public static String toBase64(String data) { return DatatypeConverter.printBase64Binary(data.getBytes()); }
com.sun.org.apache.xml.internal.security.utils.Base64.encode("The string to encode goes here");
URLClassLoader child = new URLClassLoader( new URL[] {myJar.toURI().toURL()}, this.getClass().getClassLoader() ); Class classToLoad = Class.forName("com.MyClass", true, child); Method method = classToLoad.getDeclaredMethod("myMethod"); Object instance = classToLoad.newInstance(); Object result = method.invoke(instance);
File file = ... URL url = file.toURI().toURL(); URLClassLoader classLoader = (URLClassLoader)ClassLoader.getSystemClassLoader(); Method method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class); method.setAccessible(true); method.invoke(classLoader, url);
JarClassLoader jcl = new JarClassLoader(); jcl.add("myjar.jar"); jcl.add(new URL("http: jcl.add(new FileInputStream("myotherjar.jar")); jcl.add("myclassfolder/"); jcl.add("myjarlib/"); JclObjectFactory factory = JclObjectFactory.getInstance(); Object obj = factory.create(jcl, "mypackage.MyClass");
/************************************************************************************************** * Copyright (c) 2004, Federal University of So Carlos * * * * All rights reserved. * * * * Redistribution and use in source and binary forms, with or without modification, are permitted * * provided that the following conditions are met: * * * * * Redistributions of source code must retain the above copyright notice, this list of * * conditions and the following disclaimer. * * * Redistributions in binary form must reproduce the above copyright notice, this list of * * * conditions and the following disclaimer in the documentation and/or other materials * * * provided with the distribution. * * * Neither the name of the Federal University of So Carlos nor the names of its * * * contributors may be used to endorse or promote products derived from this software * * * without specific prior written permission. * * * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS * * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT * * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR * * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * **************************************************************************************************/ /* * Created on Oct 6, 2004 */ package tools; import java.io.File; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader; /** * Useful class for dynamically changing the classpath, adding classes during runtime. */ public class ClasspathHacker { /** * Parameters of the method to add an URL to the System classes. */ private static final Class<?>[] parameters = new Class[]{URL.class}; /** * Adds a file to the classpath. * @param s a String pointing to the file * @throws IOException */ public static void addFile(String s) throws IOException { File f = new File(s); addFile(f); } /** * Adds a file to the classpath * @param f the file to be added * @throws IOException */ public static void addFile(File f) throws IOException { addURL(f.toURI().toURL()); } /** * Adds the content pointed by the URL to the classpath. * @param u the URL pointing to the content to be added * @throws IOException */ public static void addURL(URL u) throws IOException { URLClassLoader sysloader = (URLClassLoader)ClassLoader.getSystemClassLoader(); Class<?> sysclass = URLClassLoader.class; try { Method method = sysclass.getDeclaredMethod("addURL",parameters); method.setAccessible(true); method.invoke(sysloader,new Object[]{ u }); } catch (Throwable t) { t.printStackTrace(); throw new IOException("Error, could not add URL to system classloader"); } } public static void main(String args[]) throws IOException, SecurityException, ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException{ addFile("C:\\dynamicloading.jar"); Constructor<?> cs = ClassLoader.getSystemClassLoader().loadClass("test.DymamicLoadingTest").getConstructor(String.class); DymamicLoadingTest instance = (DymamicLoadingTest)cs.newInstance(); instance.test(); } }
java.lang.ClassCastException: java.base/jdk.internal.loader.ClassLoaders$AppClassLoader cannot be cast to java.base/java.net.URLClassLoader
package ClassPathAgent; import java.io.IOException; import java.lang.instrument.Instrumentation; import java.util.jar.JarFile; public class ClassPathAgent { public static void agentmain(String args, Instrumentation instrumentation) throws IOException { instrumentation.appendToSystemClassLoaderSearch(new JarFile(args)); } }
Manifest-Version: 1.0 Agent-Class: ClassPathAgent.ClassPathAgent
import java.io.File; import net.bytebuddy.agent.ByteBuddyAgent; public class ClassPathUtil { private static File AGENT_JAR = new File("/path/to/agent.jar"); public static void addJarToClassPath(File jarFile) { ByteBuddyAgent.attach(AGENT_JAR, String.valueOf(ProcessHandle.current().pid()), jarFile.getPath()); } }
public void initialize(String libDir) throws Exception { File dependencyDirectory = new File(libDir); File[] files = dependencyDirectory.listFiles(); ArrayList<URL> urls = new ArrayList<URL>(); for (int i = 0; i < files.length; i++) { if (files[i].getName().endsWith(".jar")) { urls.add(files[i].toURL()); } } classLoader = new JarFileClassLoader("Scheduler CL" + System.currentTimeMillis(), urls.toArray(new URL[urls.size()]), GFClassLoader.class.getClassLoader()); }
String jarFile = "path/to/jarfile.jar"; DexClassLoader classLoader = new DexClassLoader(jarFile, "/data/data/" + context.getPackageName() + "/", null, getClass().getClassLoader()); Class<?> myClass = classLoader.loadClass("MyClass");
Thread.currentThread().setContextClassLoader(classLoader);
File file = ... URL url = file.toURI().toURL(); URLClassLoader sysLoader = new URLClassLoader(new URL[0]); Method sysMethod = URLClassLoader.class.getDeclaredMethod("addURL", new Class[]{URL.class}); sysMethod.setAccessible(true); sysMethod.invoke(sysLoader, new Object[]{url});
package agent; import java.io.IOException; import java.lang.instrument.Instrumentation; import java.util.jar.JarFile; public class Agent { public static Instrumentation instrumentation; public static void premain(String args, Instrumentation instrumentation) { Agent.instrumentation = instrumentation; } public static void agentmain(String args, Instrumentation instrumentation) { Agent.instrumentation = instrumentation; } public static void appendJarFile(JarFile file) throws IOException { if (instrumentation != null) { instrumentation.appendToSystemClassLoaderSearch(file); } } }
Launcher-Agent-Class: agent.Agent Agent-Class: agent.Agent Premain-Class: agent.Agent
ClassLoader classLoader = ClassLoader.getSystemClassLoader(); try { Method method = classLoader.getClass().getDeclaredMethod("addURL", URL.class); method.setAccessible(true); method.invoke(classLoader, new File(jarPath).toURI().toURL()); } catch (NoSuchMethodException e) { Method method = classLoader.getClass() .getDeclaredMethod("appendToClassPathForInstrumentation", String.class); method.setAccessible(true); method.invoke(classLoader, jarPath); }
File libDir = new File("path/to/jar"); ProxyCallerInterface caller = ObjectBuilder.builder() .setClassName("net.proxy.lib.test.LibClass") .setArtifact(DirArtifact.builder() .withClazz(ObjectBuilderTest.class) .withVersionInfo(newVersionInfo(libDir)) .build()) .build(); String version = caller.call("getLibVersion").asString();
Foo value = map.get(key); if (value != null) { ... } else { }
Foo value = map.get(key); if (value != null) { ... } else { if (map.containsKey(key)) { } else { } }
@Override public boolean containsKey(Object key) { Entry<K, V> m = getEntry(key); return m != null; } @Override public V get(Object key) { Entry<K, V> m = getEntry(key); if (m != null) { return m.value; } return null; }
if(map.get(key) != null || (map.get(key) == null && map.containsKey(key)))
Object value = map.get(key); if (value == null) { value = createValue(key); map.put(key, value); }
public final class Integer extends Number implements Comparable<Integer> { ... @Override public int hashCode() { return Integer.hashCode(value); } public static int hashCode(int value) { return value; } ... }
HashMap<String, ArrayList<Integer>> map = new HashMap<>(); map.computeIfAbsent("checking_account", key -> new ArrayList<>()) .add(100) .add(200);
import java.util.Scanner; Scanner reader = new Scanner(System.in); System.out.println("Enter a number: "); int n = reader.nextInt(); reader.close();
import java.util.Scanner; Scanner scan = new Scanner(System.in); String s = scan.next(); int i = scan.nextInt();
import java.io.BufferedReader; import java.io.InputStreamReader; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String s = br.readLine(); int i = Integer.parseInt(br.readLine());
import java.io.DataInputStream; DataInputStream dis = new DataInputStream(System.in); int i = dis.readInt();
import java.io.Console; Console console = System.console(); String s = console.readLine(); int i = Integer.parseInt(console.readLine());
Console console = System.console(); String input = console.readLine("Enter input:");
BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String accStr; System.out.println("Enter your Account number: "); accStr = br.readLine();
Scanner scanner = new Scanner (System.in); System.out.print("Enter your name"); name = scanner.next();
Scanner input = new Scanner(System.in); System.out.println("Please enter your name : "); s = input.next(); System.out.println("Please enter your age : "); i = input.nextInt(); System.out.println("Please enter your salary : "); d = input.nextDouble();
import java.util.Scanner; public class PrintNumber { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int num = 0; int sum = 0; System.out.println( "Please enter a number to show its digits"); num = scan.nextInt(); System.out.println( "Here are the digits and the sum of the digits"); while (num > 0) { System.out.println("==>" + num % 10); sum += num % 10; num = num / 10; } System.out.println("Sum is " + sum); } }
BufferedReader bufferReader = new BufferedReader(new InputStreamReader(System.in)); String inputLine = bufferReader.readLine();
InputStreamReader inp = new InputStreamReader(system.in); BufferedReader br = new BufferedReader(inp);
import java.util.Scanner; public class Example { public static void main(String[] args) { int input = 0; System.out.println("The super insano calculator"); System.out.println("enter the corrosponding number:"); Scanner reader3 = new Scanner(System.in); System.out.println( "1. Add | 2. Subtract | 3. Divide | 4. Multiply"); input = reader3.nextInt(); int a = 0, b = 0; Scanner reader = new Scanner(System.in); System.out.println("Enter the first number"); a = reader.nextInt(); Scanner reader1 = new Scanner(System.in); System.out.println("Enter the scend number"); b = reader1.nextInt(); switch (input){ case 1: System.out.println(a + " + " + b + " = " + add(a, b)); break; case 2: System.out.println(a + " - " + b + " = " + subtract(a, b)); break; case 3: System.out.println(a + " / " + b + " = " + divide(a, b)); break; case 4: System.out.println(a + " * " + b + " = " + multiply(a, b)); break; default: System.out.println("your input is invalid!"); break; } } static int add(int lhs, int rhs) { return lhs + rhs; } static int subtract(int lhs, int rhs) { return lhs - rhs; } static int divide(int lhs, int rhs) { return lhs / rhs; } static int multiply(int lhs, int rhs) { return lhs * rhs; } }
import java.util.Scanner; class Daytwo{ public static void main(String[] args){ System.out.println("HelloWorld"); Scanner reader = new Scanner(System.in); System.out.println("Enter the number "); int n = reader.nextInt(); System.out.println("You entered " + n); } }
Scanner input = new Scanner(System.in); String inputval = input.next();
DataInputStream input = new DataInputStream(System.in); System.out.print("Enter your name"); String name = input.readLine();
import java.util.Scanner; class GetInputFromUser { public static void main(String args[]) { int a; float b; String s; Scanner in = new Scanner(System.in); System.out.println("Enter a string"); s = in.nextLine(); System.out.println("You entered string " + s); System.out.println("Enter an integer"); a = in.nextInt(); System.out.println("You entered integer " + a); System.out.println("Enter a float"); b = in.nextFloat(); System.out.println("You entered float " + b); } }
import java.util.Scanner; public class Myapplication{ public static void main(String[] args){ Scanner in = new Scanner(System.in); int a; System.out.println("enter:"); a = in.nextInt(); System.out.println("Number is= " + a); } }
InputStreamReader inp = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(inp);
public static void main(String[] args) { Scanner reader = new Scanner(System.in); System.out.println("Enter a number: "); int i = reader.nextInt(); for (int j = 0; j < i; j++) System.out.println("I love java"); }
package inputTest; import java.util.Scanner; import java.util.InputMismatchException; public class InputTest { public static void main(String args[]) { Scanner reader = new Scanner(System.in); System.out.println("Please enter integers. Type 0 to exit."); boolean done = false; while (!done) { System.out.print("Enter an integer: "); try { int n = reader.nextInt(); if (n == 0) { done = true; } else { System.out.println("\tThe number entered was: " + n); } } catch (InputMismatchException e) { System.out.println("\tInvalid input type (must be an integer)"); reader.nextLine(); } } System.out.println("Exiting..."); reader.close(); } }
Please enter integers. Type 0 to exit. Enter an integer: 12 The number entered was: 12 Enter an integer: -56 The number entered was: -56 Enter an integer: 4.2 Invalid input type (must be an integer) Enter an integer: but i hate integers Invalid input type (must be an integer) Enter an integer: 3 The number entered was: 3 Enter an integer: 0 Exiting...
package main; import java.io.IOException; public class Root { public static void main(String[] args) { new Root(); } public Root() { while(true) { try { for(int y = 0; y < System.in.available(); ++y) { System.out.print((char)System.in.read()); } } catch(IOException ex) { ex.printStackTrace(System.out); break; } } } }
public String readLine(String tPromptString) { byte[] tBuffer = new byte[256]; int tPos = 0; System.out.print(tPromptString); while(true) { byte tNextByte = readByte(); if(tNextByte == 10) { return new String(tBuffer, 0, tPos); } if(tNextByte != 13) { tBuffer[tPos] = tNextByte; ++tPos; } } }
import java.util.Scanner; public class userinput { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print("Name : "); String name = input.next(); System.out.print("Last Name : "); String lname = input.next(); System.out.print("Age : "); byte age = input.nextByte(); System.out.println(" " ); System.out.println(" " ); System.out.println("Firt Name: " + name); System.out.println("Last Name: " + lname); System.out.println(" Age: " + age); } }
class ex1 { public static void main(String args[]){ int a, b, c; a = Integer.parseInt(args[0]); b = Integer.parseInt(args[1]); c = a + b; System.out.println("c = " + c); } } javac ex1.java java ex1 10 20 c = 30
public class PKladrBuilding extends PRQObject public abstract class PRQObject extends PObject public abstract class PObject implements Serializable
private static final long serialVersionUID = $randomLong$L; $END$
private static final long serialVersionUID = 1L; $END$
base_dir=$(pwd) src_dir=$base_dir/src/main/java ic_api_cp=$base_dir/target/classes while read f do clazz=${f clazz=${clazz/%.java/} seruidstr=$(serialver -classpath $ic_api_cp $clazz | cut -d perl -ni.bak -e "print $_; printf qq{%s\n}, q{ private $seruidstr} if /public class/" $src_dir/$f done
com/abc/ic/api/model/domain/item/BizOrderTransDO.java com/abc/ic/api/model/domain/item/CardPassFeature.java com/abc/ic/api/model/domain/item/CategoryFeature.java com/abc/ic/api/model/domain/item/GoodsFeature.java com/abc/ic/api/model/domain/item/ItemFeature.java com/abc/ic/api/model/domain/item/ItemPicUrls.java com/abc/ic/api/model/domain/item/ItemSkuDO.java com/abc/ic/api/model/domain/serve/ServeCategoryFeature.java com/abc/ic/api/model/domain/serve/ServeFeature.java com/abc/ic/api/model/param/depot/DepotItemDTO.java com/abc/ic/api/model/param/depot/DepotItemQueryDTO.java com/abc/ic/api/model/param/depot/InDepotDTO.java com/abc/ic/api/model/param/depot/OutDepotDTO.java
Hashtable<Long, Tuple<Set<Long>,Set<Long>>> table = ...
public class Tuple<X, Y> { public final X x; public final Y y; public Tuple(X x, Y y) { this.x = x; this.y = y; } }
Unit<A> (1 element) Pair<A,B> (2 elements) Triplet<A,B,C> (3 elements)
public class Tuple<X, Y> { public final X x; public final Y y; public Tuple(X x, Y y) { this.x = x; this.y = y; } @Override public String toString() { return "(" + x + "," + y + ")"; } @Override public boolean equals(Object other) { if (other == this) { return true; } if (!(other instanceof Tuple)){ return false; } Tuple<X,Y> other_ = (Tuple<X,Y>) other; return other_.x.equals(this.x) && other_.y.equals(this.y); } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((x == null) ? 0 : x.hashCode()); result = prime * result + ((y == null) ? 0 : y.hashCode()); return result; } }
import java.util.*; /** * A tuple of two classes that implement Comparable */ public class ComparableTuple<X extends Comparable<? super X>, Y extends Comparable<? super Y>> extends Tuple<X, Y> implements Comparable<ComparableTuple<X, Y>> { public ComparableTuple(X x, Y y) { super(x, y); } /** * Implements lexicographic order */ public int compareTo(ComparableTuple<X, Y> other) { int d = this.x.compareTo(other.x); if (d == 0) return this.y.compareTo(other.y); return d; } }
@Data(staticConstructor = "of") public class Pair<A, B> { private final A left; private final B right; }
public [int,boolean] Find(int i) { int idx = FindInArray(A,i); return [idx,idx>=0]; } [idx, found] = Find(7);
String result = String.format("%4d", i * j); System.out.println( result );
final static String HexChars = "0123456789abcdef"; public static String getHexQuad(long v) { String ret; if(v > 0xffff) ret = getHexQuad(v >> 16); else ret = ""; ret += String.format("%c%c%c%c", HexChars.charAt((int) ((v >> 12) & 0x0f)), HexChars.charAt((int) ((v >> 8) & 0x0f)), HexChars.charAt((int) ((v >> 4) & 0x0f)), HexChars.charAt((int) ( v & 0x0f))); return ret; }
... ret += "ABCD". replace( replace( replace( replace( ...
... ret += HexChars.charAt((int) ((v >> 12) & 0x0f))); ret += HexChars.charAt((int) ((v >> 8) & 0x0f))); ...
public class ArgumentExample { public static void main(String[] args) { for(int i = 0; i < args.length; i++) { System.out.println(args[i]); } } }
public static void main(String [] args) { String one = args[0]; String two = args[1]; }
public class HelloWorld { public static void main(String[] parameter) { System.out.println(parameter[0] + parameter[1]); System.out.println(Integer.parseInt(parameter[0]) + Integer.parseInt(parameter[1])); System.out.println(Float.parseFloat(parameter[0]) + Float.parseFloat(parameter[1])); System.out.println(Long.parseLong(parameter[0]) + Long.parseLong(parameter[1])); System.out.println(Double.parseDouble(parameter[0]) + Double.parseDouble(parameter[1])); } }
public void foo() { String [] args = new String[2]; args[0] = "hello"; args[1] = "every"; System.out.println("Output: " + args[0] + args[1]); }
mainID = (*env)->GetStaticMethodID(env, mainClass, "main", "([Ljava/lang/String;)V"); ... { ... mods = (*env)->CallIntMethod(env, obj, mid); if ((mods & 1) == 0) { /* if (!Modifier.isPublic(mods)) ... */ message = "Main method not public."; messageDest = JNI_TRUE; goto leave; ...
for(int i = 0; i < args.length; i++) { System.out.println("Argument is: "+args[i]); }
objc[10012]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home/bin/java and /Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home/jre/lib/libinstrument.dylib. One of the two will be used. Which one is undefined.
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_21.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH
function setjdk() { if [ $ removeFromPath if [ -n "${JAVA_HOME+x}" ]; then removeFromPath $JAVA_HOME fi export JAVA_HOME=`/usr/libexec/java_home -v $@` export PATH=$JAVA_HOME/bin:$PATH fi } function removeFromPath() { export PATH=$(echo $PATH | sed -E -e "s;:$1;;" -e "s;$1:?;;") }
sudo rm -rf /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk sudo rm -rf /Library/PreferencePanes/JavaControlPanel.prefPane sudo rm -rf /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin sudo rm -rf /Library/LaunchAgents/com.oracle.java.Java-Updater.plist sudo rm -rf /Library/PrivilegedHelperTools/com.oracle.java.JavaUpdateHelper sudo rm -rf /Library/LaunchDaemons/com.oracle.java.JavaUpdateHelper.plist sudo rm -rf /Library/Preferences/com.oracle.java.Helper-Tool.plist
java version "1.7.0_21" Java(TM) SE Runtime Environment (build 1.7.0_21-b12) Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)
/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home
public static boolean isInteger(String s) { return isInteger(s,10); } public static boolean isInteger(String s, int radix) { if(s.isEmpty()) return false; for(int i = 0; i < s.length(); i++) { if(i == 0 && s.charAt(i) == if(s.length() == 1) return false; else continue; } if(Character.digit(s.charAt(i),radix) < 0) return false; } return true; }
public static boolean isInteger(String s, int radix) { Scanner sc = new Scanner(s.trim()); if(!sc.hasNextInt(radix)) return false; sc.nextInt(radix); return !sc.hasNext(); }
public static boolean isInteger(String s) { try { Integer.parseInt(s); } catch(NumberFormatException e) { return false; } catch(NullPointerException e) { return false; } return true; }
str.matches("-?\\d+"); -? --> negative sign, could have none or one \\d+ --> one or more digits
try{ int num = Integer.parseInt(str); } catch (NumberFormatException e) { }
static boolean isInt(String s) { try { int i = Integer.parseInt(s); return true; } catch(NumberFormatException er) { return false; } }
static boolean isInt(String s) { for(int a=0;a<s.length();a++) { if(a==0 && s.charAt(a) == if( !Character.isDigit(s.charAt(a)) ) return false; } return true; }
public boolean isInt(String str){ return (str.lastIndexOf("-") == 0 && !str.equals("-0")) ? str.substring(1).matches( "\\d+") : str.matches("\\d+"); }
OrderedMap<Integer, String> om = new OrderedMap<>(); om.put(0, "Zero"); om.put(7, "Seven"); String o = om.get(7); List<Integer> keys = om.getKeys(); List<String> values = om.getValues(); for(int i = 0; i < keys.size(); i++) { Integer key = keys.get(i); String value = values.get(i); Assert(om.get(key) == value); }
TreeMap<String, Integer> users = new TreeMap<String, Integer>(); users.put("Bob", 1); users.put("Alice", 2); users.put("John", 3); for (String key: users.keySet()) { System.out.println(key + " (ID = "+ users.get(key) + ")"); }
import java.util.*; import java.util.Map.*; public class Solution { public static void main(String[] args) { Map<String, Integer> map = new HashMap<String, Integer>(); map.put("Python", 3); map.put("C", 0); map.put("JavaScript", 4); map.put("C++", 1); map.put("Golang", 5); map.put("Java", 2); List<Entry<String, Integer>> list = new LinkedList<Entry<String, Integer>>(map.entrySet()); Collections.sort(list, new Comparator<Entry<String, Integer>>(){ @Override public int compare(Entry<String, Integer> m1, Entry<String, Integer> m2) { return m1.getValue().compareTo(m2.getValue()); } }); for(Entry<String, Integer> value: list) { System.out.println(value); } } }
Object string = "abcd"; int i = 0; while (i < 12289) { i++; try { Integer a = (Integer) string; } catch (Exception e) { e.printStackTrace(); } }
* the name of the class of this object * ": " (a colon and a space) * the result of invoking this object
StackTraceElement[] trace = exception.getStackTrace()
import java.io.PrintWriter; import java.io.StringWriter; public static String getStackTrace(Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); t.printStackTrace(pw); pw.flush(); sw.flush(); return sw.toString(); }
java.lang.NullPointerException: at com.company.product.MyTest.test(MyTest.java:37)
java.lang.NullPointerException at com.company.product.library.ArgumentChecker.nonNull(ArgumentChecker.java:67) at ... at com.company.product.aspects.CheckArgumentsAspect.wrap(CheckArgumentsAspect.java:82) at ... at com.company.product.MyTest.test(MyTest.java:37)
private void askForPermission() { String[] permissions = new String[]{Manifest.permission.SEND_SMS}; ActivityCompat.requestPermissions(getActivity(), permissions, PERMISSIONS_CODE); }
@Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == PERMISSIONS_CODE) { for (int i = 0; i < permissions.length; i++) { String permission = permissions[i]; int grantResult = grantResults[i]; if (permission.equals(Manifest.permission.SEND_SMS)) { if (grantResult == PackageManager.PERMISSION_GRANTED) { onPPSButtonPress(); } else { requestPermissions(new String[]{Manifest.permission.SEND_SMS}, PERMISSIONS_CODE); } } } } }
ActivityCompat.requestPermissions(this,permissionsList,REQUEST_CODE);
android:noHistory="true" android:excludeFromRecents="true"
FragmentCompat.requestPermissions(permissionsList, RequestCode)
ActivityCompat.requestPermissions(Activity, permissionsList, RequestCode);
YourActivity extends SomeActivityNotCallingSuperOnRequestPermissionsResult{ Fragment requestingFragment; ... @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if(requestingFragment!=null) requestingFragment.onRequestPermissionsResult(requestCode, permissions, grantResults); } ...
FragmentCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION);
@Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); if (ContextCompat.checkSelfPermission(context, Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_DENIED) requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, 0); }
/* use the object of your fragment to call the * onRequestPermissionsResult in fragment after * in activity and use different request Code for * both Activity and Fragment */ if (isFragment) mFragment.requestPermissions(permissions.toArray(new String[permissions.size()]),requestPermission); else ActivityCompat.requestPermissions(mActivity,permissions.toArray(new String[permissions.size()]),requestPermission);
@Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); }
ActivityCompat.requestPermissions(this, permissionsList, permissionscode);
requestPermissions(permissionsList, permissionscode);
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { int index = (requestCode>>16)&0xffff; if (index != 0) { index--; String who = mPendingFragmentActivityResults.get(index); mPendingFragmentActivityResults.remove(index); if (who == null) { Log.w(TAG, "Activity result delivered for unknown Fragment."); return; } Fragment frag = mFragments.findFragmentByWho(who); if (frag == null) { Log.w(TAG, "Activity result no fragment exists for who: " + who); } else { frag.onRequestPermissionsResult(requestCode&0xffff, permissions, grantResults); } } }
@Override public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) { switch (requestCode) { case Constants.PERMISSIONS_REQUEST_CALL_PHONE: { if ( grantResults[0] == PackageManager.PERMISSION_GRANTED) { checkPermissionsAndCall(); } } } } public void checkPermissionsAndCall(){ if (Build.VERSION.SDK_INT > 22) { if(ContextCompat.checkSelfPermission(getContext(), Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED){ requestPermissions( new String[]{Manifest.permission.CALL_PHONE}, Constants.PERMISSIONS_REQUEST_CALL_PHONE); } else{ callIntent(); } } }
private void showContacts() { if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, PERMISSIONS_REQUEST_READ_CONTACTS); } else { doShowContacts(); } } @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS && grantResults[0] == PackageManager.PERMISSION_GRANTED) { doShowContacts(); } }
public class BaseActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) { switch (requestCode) { case 1: { if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) { CustomToast.getInstance().setCustomToast("Now you can share the Hack."); } else { Toast.makeText(this, "Permission denied to read your External storage", Toast.LENGTH_SHORT).show(); } } } }
ActivityCompat.requestPermissions(getActivity(), new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
class PermissionType(val manifest_permission: String, val packageManager: String) { object Defined { val camera = PermissionType(Manifest.permission.CAMERA, PackageManager.FEATURE_CAMERA) val currentLocation = PermissionType(Manifest.permission.ACCESS_FINE_LOCATION, PackageManager.FEATURE_LOCATION_GPS) } } class Permission { enum class PermissionResult { ACCESS_ALLOWED, ACCESS_DENIED, NO_SYSTEM_FEATURE; } interface ManagerDelegate { fun permissionManagerDelegate(result: Array<Pair<String, PermissionResult>>) } class Manager internal constructor(private val delegate: ManagerDelegate?) { private var context: Context? = null private var fragment: Fragment? = null private var activity: AppCompatActivity? = null private var permissionTypes: Array<PermissionType> = arrayOf() private val REQUEST_CODE = 999 private val semaphore = Semaphore(1, true) private var result: Array<Pair<String, PermissionResult>> = arrayOf() constructor(permissionType: PermissionType, delegate: ManagerDelegate?): this(delegate) { permissionTypes = arrayOf(permissionType) } constructor(permissionTypes: Array<PermissionType>, delegate: ManagerDelegate?): this(delegate) { this.permissionTypes = permissionTypes } init { when (delegate) { is Fragment -> { this.fragment = delegate this.context = delegate.context } is AppCompatActivity -> { this.activity = delegate this.context = delegate } } } private fun hasSystemFeature(permissionType: PermissionType) : Boolean { return context?.packageManager?.hasSystemFeature(permissionType.packageManager) ?: false } private fun hasAccess(permissionType: PermissionType) : Boolean { return if (Build.VERSION.SDK_INT < 23) true else { context?.checkSelfPermission(permissionType.manifest_permission) == PackageManager.PERMISSION_GRANTED } } private fun sendRequest(permissionTypes: Array<String>) { if (fragment != null) { fragment?.requestPermissions(permissionTypes, REQUEST_CODE) return } if (activity != null){ ActivityCompat.requestPermissions(activity!!, permissionTypes, REQUEST_CODE) } } fun check() { semaphore.acquire() AsyncTask.execute { var permissionsForSendingRequest: Array<String> = arrayOf() this.result = arrayOf() for (it in permissionTypes) { if (!hasSystemFeature(it)) { result += Pair(it.manifest_permission, PermissionResult.NO_SYSTEM_FEATURE) continue } if (hasAccess(it)) { result += Pair(it.manifest_permission, PermissionResult.ACCESS_ALLOWED) } else { permissionsForSendingRequest += it.manifest_permission } } if (permissionsForSendingRequest.isNotEmpty()) { sendRequest(permissionsForSendingRequest) } else { delegate?.permissionManagerDelegate(result) } } } fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) { when (requestCode) { REQUEST_CODE -> { if (grantResults.isEmpty()) { return } for ((i,permission) in permissions.withIndex()) { for (item in this.permissionTypes) { if (permission == item.manifest_permission && i < grantResults.size) { result += if (grantResults[i] == PackageManager.PERMISSION_GRANTED) { Pair(item.manifest_permission, PermissionResult.ACCESS_ALLOWED) } else { Pair(item.manifest_permission, PermissionResult.ACCESS_DENIED) } break } } } delegate?.permissionManagerDelegate(result) } } semaphore.release() } } }
class BaseActivity : AppCompatActivity(), Permission.ManagerDelegate { private lateinit var permissionManager: Permission.Manager override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.base_activity) permissionManager = Permission.Manager(arrayOf(PermissionType.Defined.camera, PermissionType.Defined.currentLocation), this) permissionManager.check() } override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) { super.onRequestPermissionsResult(requestCode, permissions, grantResults) permissionManager.onRequestPermissionsResult(requestCode, permissions, grantResults) } override fun permissionManagerDelegate(result: Array<Pair<String, Permission.PermissionResult>>) { result.forEach { println("!!! ${it.first} ${it.second}") // // } } }
public String appendWithDelimiter( String original, String addition, String delimiter ) { if ( original.equals( "" ) ) { return addition; } else { return original + delimiter + addition; } } String parameterString = ""; if ( condition ) parameterString = appendWithDelimiter( parameterString, "elementName", "," ); if ( anotherCondition ) parameterString = appendWithDelimiter( parameterString, "anotherElementName", "," );
parameterArray = []; parameterArray << "elementName" if condition; parameterArray << "anotherElementName" if anotherCondition; parameterString = parameterArray.join(",");
StringJoiner joiner = new StringJoiner(","); joiner.add("01").add("02").add("03"); String joinedString = joiner.toString();
String joinedString = String.join(" - ", "04", "05", "06");
List<String> strings = new LinkedList<>(); strings.add("Java");strings.add("is"); strings.add("cool"); String message = String.join(" ", strings);
public static String join(List<String> list, String delim) { StringBuilder sb = new StringBuilder(); String loopDelim = ""; for(String s : list) { sb.append(loopDelim); sb.append(s); loopDelim = delim; } return sb.toString(); }
List<String> list = new ArrayList<String>(); if( condition ) list.add("elementName"); if( anotherCondition ) list.add("anotherElementName"); join(list, ",");
android.text.TextUtils.join(CharSequence delimiter, Iterable tokens)
"My pets are: " + Joiner.on(", ").join(Arrays.asList("rabbit", "parrot", "dog")); Joiner.on(" AND ").join(Arrays.asList("field1=1" , "field2=2", "field3=3")); Joiner.on(",").skipNulls().join(Arrays.asList("London", "Moscow", null, "New York", null, "Paris")); Joiner.on(", ").useForNull("Team held a draw").join(Arrays.asList("FC Barcelona", "FC Bayern", null, null, "Chelsea FC", "AC Milan"));
List<String> list = Arrays.asList("foo", "bar", "baz"); String joined = String.join(" and ", list);
public static String join(Iterable<? extends CharSequence> s, String delimiter) { Iterator<? extends CharSequence> iter = s.iterator(); if (!iter.hasNext()) return ""; StringBuilder buffer = new StringBuilder(iter.next()); while (iter.hasNext()) buffer.append(delimiter).append(iter.next()); return buffer.toString(); }
list.stream().map(Object::toString) .collect(Collectors.joining(delimiter));
list.stream().map(String::valueOf) .collect(Collectors.joining(delimiter))
package util; import java.util.ArrayList; import java.util.Iterable; import java.util.Collections; import java.util.Iterator; public class Utils { public static String join(String delimiter, Iterable<? extends Object> objs) { if (objs.isEmpty()) { return ""; } Iterator<? extends Object> iter = objs.iterator(); StringBuilder buffer = new StringBuilder(); buffer.append(iter.next()); while (iter.hasNext()) { buffer.append(delimiter).append(iter.next()); } return buffer.toString(); } public static String join(String delimiter, Object... objs) { ArrayList<Object> list = new ArrayList<Object>(); Collections.addAll(list, objs); return join(delimiter, list); } }
stringCollection.stream().collect(Collectors.joining(", "));
StringBuilder buf = new StringBuilder(); Separator sep = new Separator(", "); for (String each : list) { buf.append(sep).append(each); }
public class Separator { private boolean skipFirst; private final String value; public Separator() { this(", "); } public Separator(String value) { this.value = value; this.skipFirst = true; } public void reset() { skipFirst = true; } public String toString() { String sep = skipFirst ? "" : value; skipFirst = false; return sep; } }
/** * * @param delim : String that should be kept in between the parts * @param parts : parts that needs to be joined * @return a String that */ private static final String join(String delim, String... parts) { StringBuilder builder = new StringBuilder(); for (int i = 0; i < parts.length - 1; i++) { builder.append(parts[i]).append(delim); } if(parts.length > 0){ builder.append(parts[parts.length - 1]); } return builder.toString(); }
import org.springframework.util.StringUtils; List<String> groupIds = new List<String>; groupIds.add("a"); groupIds.add("b"); groupIds.add("c"); String csv = StringUtils.arrayToCommaDelimitedString(groupIds.toArray());
MutableList<Integer> list = FastList.newListWith(1, 2, 3); assertEquals("[1/2/3]", list.makeString("[", "/", "]")); assertEquals("1/2/3", list.makeString("/")); assertEquals("1, 2, 3", list.makeString()); assertEquals(list.toString(), list.makeString("[", ", ", "]"));
MutableList<Integer> list = FastList.newListWith(1, 2, 3); Appendable appendable = new StringBuilder(); list.appendString(appendable, "[", "/", "]"); assertEquals("[1/2/3]", appendable.toString());
List<Object> list = ...; ListAdapter.adapt(list).makeString(",");
ArrayList<String> parms = new ArrayList<String>(); if (someCondition) parms.add("someString"); if (anotherCondition) parms.add("someOtherString"); String sep = ""; StringBuffer b = new StringBuffer(); for (String p: parms) { b.append(sep); b.append(p); sep = "yourDelimiter"; }
import junit.framework.Assert; import org.junit.Test; public class StringUtil { public static String join(String delim, String... strings) { StringBuilder builder = new StringBuilder(); if (strings != null) { for (String str : strings) { if (builder.length() > 0) { builder.append(delim).append(" "); } builder.append(str); } } return builder.toString(); } @Test public void joinTest() { Assert.assertEquals("", StringUtil.join(",", null)); Assert.assertEquals("", StringUtil.join(",", "")); Assert.assertEquals("", StringUtil.join(",", new String[0])); Assert.assertEquals("test", StringUtil.join(",", "test")); Assert.assertEquals("foo, bar", StringUtil.join(",", "foo", "bar")); Assert.assertEquals("foo, bar, x", StringUtil.join(",", "foo", "bar", "x")); } }
String asString = org.springframework.util.StringUtils.collectionToDelimitedString(codes, ";"); Set<String> collection = org.springframework.util.StringUtils.commaDelimitedListToSet(asString);
StringBuilder sb = new StringBuilder(); if (condition) { sb.append("elementName").append(","); } if (anotherCondition) { sb.append("anotherElementName").append(","); } String parameterString = sb.toString();
public static String appendWithDelimiter(String original, String addition, String delimiter) { if (original.equals("")) { return addition; } else { StringBuilder sb = new StringBuilder(original.length() + addition.length() + delimiter.length()); sb.append(original); sb.append(delimiter); sb.append(addition); return sb.toString(); } }
public String appendWithDelimiters(String delimiter, String original, String addition) { StringBuilder sb = new StringBuilder(original); if(sb.length()!=0) { sb.append(delimiter).append(addition); } else { sb.append(addition); } return sb.toString(); } public String appendWithDelimitersGeneric(String delimiter, String... strings) { StringBuilder sb = new StringBuilder(); for (String string : strings) { if(sb.length()!=0) { sb.append(delimiter).append(string); } else { sb.append(string); } } return sb.toString(); } public void testAppendWithDelimiters() { String string = appendWithDelimitersGeneric(",", "string1", "string2", "string3"); }
public StringBuffer appendWithDelimiter( StringBuffer original, String addition, String delimiter ) { if ( original == null ) { StringBuffer buffer = new StringBuffer(); buffer.append(addition); return buffer; } else { buffer.append(delimiter); buffer.append(addition); return original; } }
String parameterString = ""; if ( condition ) parameterString = appendWithDelimiter( parameterString, "elementName", "," ); if ( anotherCondition ) parameterString = appendWithDelimiter( parameterString, "anotherElementName", "," );
StringBuilder parameterString = new StringBuilder(); if (condition) parameterString.append("elementName").append(","); if (anotherCondition) parameterString.append("anotherElementName").append(","); ...
if (parameterString.length() > 0) parameterString.deleteCharAt(parameterString.length() - 1);
appendWithDelimiter( StringBuffer buffer, String addition, String delimiter ) { if ( buffer.length() == 0) { buffer.append(addition); } else { buffer.append(delimiter); buffer.append(addition); } } StringBuffer parameterBuffer = new StringBuffer(); if ( condition ) { appendWithDelimiter(parameterBuffer, "elementName", "," ); } if ( anotherCondition ) { appendWithDelimiter(parameterBuffer, "anotherElementName", "," ); } return parameterBuffer.toString();
@Override public String join(String separator) { Separator sep = new Separator(separator); StringBuilder sb = new StringBuilder(); for (T item : iterable) { sb.append(sep).append(item); } return sb.toString(); }
class Separator { private final String separator; private boolean wasCalled; public Separator(String separator) { this.separator = separator; this.wasCalled = false; } @Override public String toString() { if (!wasCalled) { wasCalled = true; return ""; } else { return separator; } } }
for(int i = 0; i < 10; i++) { System.out.println(i); }
for(int i = 0; i < 10; i = i + 1) { System.out.println(i); }
0 bipush 7 2 istore_1 [x] 3 iload_1 [x] 4 iinc 1 1 [x] 7 istore_1 [x] 8 return
0 bipush 7 2 istore_1 [x] 3 iinc 1 1 [x] 6 iload_1 [x] 7 istore_1 [x] 8 return
int x = 7; -> x get 7 value <br> x = x++; -> x get x value AND only then x is incremented
int x = 7; x = x++; x is 7 int x = 7; x = x = x+1; x is 8
if (Condition 1) Some HTML code for con1 else if (Condition 2) Some HTML code for con2
var isiPad = navigator.userAgent.match(/iPad/i) != null; if (isiPad) {} else {}
${condition ? "some text when true" : "some text when false"}
<c:choose> <c:when test="${..}">...</c:when> <!-- if condition --> <c:when test="${..}">...</c:when> <!-- else if condition --> <c:otherwise>...</c:otherwise> <!-- else condition --> </c:choose>
<c:choose> <c:when test="${myvar.equals( ... </c:when> <c:when test="${myvar.equals( ... </c:when> <c:otherwise> ... </c:otherwise> </c:choose>
<%@ taglib prefix= <c:set var="val" value="5"/> <c:choose> <c:when test="${val == Value is 5 </c:when> <c:otherwise> Value is not 5 </c:otherwise> </c:choose>
<%@ taglib prefix= <c:set var="isiPad" value="value"/> <c:choose> <!-- if condition --> <c:when test="${...}">Html Code</c:when> <!-- else condition --> <c:otherwise>Html code</c:otherwise> </c:choose>
<% String username = (String)session.getAttribute("username"); if(username==null) { %> <p> username is null</p> <% } else { %> <p> username is not null</p> <% } %>
<script> var isiPad = navigator.userAgent.match(/iPad/i) != null; if (isiPad) { document.write("Some HTML code for con1"); } else { document.write("Some HTML code for con2"); } </script>
<c:if test="${condition}"> </c:if> <c:if test="${!condition}"> </c:if>
1. Please Add the JSTL tag lib on the top of the page.` <%@ taglib uri="http: 2. Please Write the following code ` <c:choose> <c:when test="${params.number >=40 && params.number <50}"> <p> Two digit number starting with 4. </p> </c:when> <c:otherwise> <p> Other numbers. </p> </c:otherwise> </c:choose>`
val gson = (new GsonBuilder).create val a: JsonObject = gson.toJsonTree("""{ "a": "A", "b": true }""").getAsJsonObject val b: JsonObject = gson.fromJson("""{ "a": "A", "b": true }""", classOf[JsonObject])
JsonParser parser = new JsonParser(); JsonObject o = parser.parse("{\"a\": \"A\"}").getAsJsonObject();
JsonObject o = new JsonParser().parse("{\"a\": \"A\"}").getAsJsonObject();
String jsonStr = "{\"a\": \"A\"}"; Gson gson = new Gson(); JsonElement element = gson.fromJson (jsonStr, JsonElement.class); JsonObject jsonObj = element.getAsJsonObject();
JsonElement element = new JsonPrimitive(yourString); JsonObject result = element.getAsJsonObject();
import com.google.gson.Gson; import com.google.gson.GsonBuilder; import com.google.gson.JsonElement; import com.google.gson.JsonObject; GsonBuilder gson_builder = new GsonBuilder(); gson_builder.registerTypeAdapter( JsonElement.class, new JsonDeserializer<JsonElement>() { @Override public JsonElement deserialize(JsonElement arg0, Type arg1, JsonDeserializationContext arg2) throws JsonParseException { return arg0; } } ); String str = "{ \"a\": \"A\", \"b\": true }"; Gson gson = gson_builder.create(); JsonElement element = gson.fromJson(str, JsonElement.class); JsonObject object = element.getAsJsonObject();
public class HibernateProxyTypeAdapter implements JsonSerializer<HibernateProxy>{ public JsonElement serialize(HibernateProxy object_, Type type_, JsonSerializationContext context_) { return new GsonBuilder().create().toJsonTree(initializeAndUnproxy(object_)).getAsJsonObject(); } public static <T> T initializeAndUnproxy(T entity) { if (entity == null) { throw new NullPointerException("Entity passed for initialization is null"); } Hibernate.initialize(entity); if (entity instanceof HibernateProxy) { entity = (T) ((HibernateProxy) entity).getHibernateLazyInitializer() .getImplementation(); } return entity; } }
Gson gson = new GsonBuilder() .registerTypeHierarchyAdapter(HibernateProxy.class, new HibernateProxyTypeAdapter()) .create();
String jsonIn = "[{\"property\":\"COLUMN_NAME\",\"direction\":\"ASC\"}]"; JsonArray o = (JsonArray)new JsonParser().parse(jsonIn); String sortColumn = o.get(0).getAsJsonObject().get("property").getAsString()); String sortDirection = o.get(0).getAsJsonObject().get("direction").getAsString());
JsonObject complaint = new JsonObject(); complaint.addProperty("key", "value");
DateField curDateFld = new DateField("Choose Date: ", System.currentTimeMillis(), DateField.DATE | DateField.FIELD_LEFT);
long myLong = 1234567890123L; String myString = Long.toString(myLong);
long date = curDateFld.getDate(); String str = ""+date;
long date = curDateFld.getDate(); String str = String.valueOf(date); date = Long.valueOf(str);
public class SimpleMovieLister { private MovieFinder movieFinder; @Autowired public void setMovieFinder(MovieFinder movieFinder) { this.movieFinder = movieFinder; } }
public class MovieRecommender { private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) { this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; } }
class Red implements Color class Blue implements Color class myMainClass{ @Autowired private Color color; draw(){ color.design(); } }
<context:component-scan base-package="com.mycompany.movies" />
@Qualifier("redBean") class Red implements Color { } @Qualifier("blueBean") class Blue implements Color { }
<bean id="redBean" class="com.mycompany.movies.Red"/> <bean id="blueBean" class="com.mycompany.movies.Blue"/>
@Autowired @Qualifier("redBean") public void setColor(Color color) { this.color = color; }
@Resource(name="redBean") public void setColor(Color color) { this.color = color; }
@Autowired public void prepare( Interface1 bean1, Interface1 bean2 ) { ... }
@Autowired public void prepare( @Qualifier("bean1") Interface1 bean1, @Qualifier("bean2") Interface1 bean2 ) { ... }
<beans:bean id="movieFinder" class="com.movies.MovieFinder" />
<beans:bean id="movieFinder" class="com.movies.MovieFinder" > <beans:constructor-arg value="100" /> </beans:bean>
<beans:bean id="movieFinder" class="com.movies.MovieFinder" > <beans:constructor-arg ref="otherBeanRef" /> </beans:bean>
@RequestMapping(value="/user/{userId}/invoices", method = RequestMethod.GET) public List<Invoice> listUsersInvoices( @PathVariable("userId") int user, @RequestParam(value = "date", required = false) Date dateOrNull) { ... }
public String getDetails( @RequestParam(value="param1", required=true) String param1, @RequestParam(value="param2", required=false) String param2){ ... }
@RequestMapping("/hello/{id}") public String getDetails(@PathVariable(value="id") String id, @RequestParam(value="param1", required=true) String param1, @RequestParam(value="param2", required=false) String param2){ ....... }
@RequestMapping(value = "/{stocks}", method = RequestMethod.GET) public String showPortfolioValues(@MatrixVariable Map<String, List<String>> matrixVars, Model model) { logger.info("Storing {} Values which are: {}", new Object[] { matrixVars.size(), matrixVars }); List<List<String>> outlist = map2List(matrixVars); model.addAttribute("stocks", outlist); return "stocks"; }
<mvc:annotation-driven enableMatrixVariables="true" >
@RequestMapping(value="/pow", method=RequestMethod.GET) public int pow(@RequestParam(value="base") int base1, @RequestParam(value="ext") int ext1){ int pow = (int) Math.pow(base1, ext1); return pow; } @RequestMapping("/sqrt/{num}") public double sqrt(@PathVariable(value="num") int num1){ double sqrtnum=Math.sqrt(num1); return sqrtnum; }
@PathVariable - must be placed in the endpoint uri and access the query parameter value from the request @RequestParam - must be passed as method parameter (optional based on the required property) http: @RequestMapping(value=/call/{callId}", method = RequestMethod.GET) public List<Calls> getAgentCallById( @PathVariable(callId") int callId, @RequestParam(value = status", required = false) String callStatus) { } http: @RequestMapping(value=/call/{callId}", method = RequestMethod.GET) public List<Calls> getAgentCallById( @PathVariable(callId") int callId, @RequestParam(value = status", required = true) String callStatus) { }
public class Car extends Vehicle{....} public class Boat extends Vehicle{....}
Vehicle[] myGarage= new Vehicle[10]; myGarage[0]=new Car(2,true); myGarage[1]=new Boat(4,600);
public class Garage { private List<Car> cars; private List<Boat> boats; }
public abstract class Vehicle { protected int price; public getPrice() { return price; } public abstract int getPriceAfterYears(int years); }
public Car extends Vehicle { private boolean automatic; @Override public getPriceAfterYears(int years) { return Math.max(0, this.price - (years * 1000)); } }
public int numberOfAutomaticCars() { int s = 0; for(Car car : cars) { if(car.isAutomatic()) { s++; } } return s; } public List<Vehicle> getVehicles() { List<Vehicle> v = new ArrayList<>(); v.addAll(cars); v.addAll(boats); return v; } public getAveragePriceAfterYears(int years) { List<Vehicle> vehicules = getVehicles(); int s = 0; for(Vehicle v : vehicules) { s += v.getPriceAfterYears(years); } return s / vehicules.size(); }
Vehicle v = myGarage[0]; if (v instanceof Car) { ((Car)v).doSomeCarStuff(); } else if(v instanceof Boat){ ((Boat)v).doSomeBoatStuff(); }
abstract class Vehicle { protected abstract void identifyWhereIAm(); protected abstract void startEngine(); protected abstract void driveUntilIArriveHome(); protected abstract void stopEngine(); public void navigateToHome() { identifyWhereIAm(); startEngine(); driveUntilIArriveHome(); stopEngine(); } }
public class VisitorDemo { public static interface Visitable { void accept(Visitor visitor); } public static interface Visitor { void visit(Boat boat); void visit(Car car); } public static abstract class Vehicle implements Visitable { } public static class Car extends Vehicle { public void doCarStuff() { System.out.println("Doing car stuff"); } @Override public void accept(Visitor visitor) { visitor.visit(this); } } public static class Boat extends Vehicle { public void doBoatStuff() { System.out.println("Doing boat stuff"); } @Override public void accept(Visitor visitor) { visitor.visit(this); } } public static class StuffVisitor implements Visitor { @Override public void visit(Boat boat) { boat.doBoatStuff(); } @Override public void visit(Car car) { car.doCarStuff(); } } public static void main(String[] args) { Vehicle[] garage = { new Boat(), new Car(), new Car(), new Boat(), new Car() }; Visitor visitor = new StuffVisitor(); for (Vehicle v : garage) { v.accept(visitor); } } }
abstract class Vehicle { public abstract string getDescription() ; } class Transmission { public Transmission(bool isAutomatic) { this.isAutomatic = isAutomatic; } private bool isAutomatic; public bool getIsAutomatic() { return isAutomatic; } } class Car extends Vehicle { @Override public string getDescription() { return "a car"; } private Transmission transmission; public Transmission getTransmission() { return transmission; } } class Boat extends Vehicle { @Override public string getDescription() { return "a boat"; } } public enum InspectionBoolean { FALSE, TRUE, UNSUPPORTED } public class CarInspector { public bool isCar(Vehicle v) { return (v instanceof Car); } public bool isAutomatic(Car car) { Transmission t = car.getTransmission(); return t.getIsAutomatic(); } public bool isAutomatic(Vehicle vehicle) { if (!isCar(vehicle)) throw new UnsupportedVehicleException(); return isAutomatic((Car)vehicle); } public InspectionBoolean isAutomatic(Vehicle[] garage, int bay) { if (!isCar(garage[bay])) return InspectionBoolean.UNSUPPORTED; return isAutomatic(garage[bay]) ? InspectionBoolean.TRUE : InspectionBoolean.FALSE; } }
abstract class Vehicle { } class Transmission { public Transmission(bool isAutomatic) { this.isAutomatic = isAutomatic; } private bool isAutomatic; public bool getIsAutomatic() { return isAutomatic; } } interface HasTransmission { Transmission getTransmission(); } class Car extends Vehicle, HasTransmission { private Transmission transmission; @Override public Transmission getTransmission() { return transmission; } } class Bus extends Vehicle, HasTransmission { private Transmission transmission; @Override public Transmission getTransmission() { return transmission; } } class Boat extends Vehicle { } enum InspectionBoolean { FALSE, TRUE, UNSUPPORTED } class TransmissionInspector { public bool hasTransmission(Vehicle v) { return (v instanceof HasTransmission); } public bool isAutomatic(HasTransmission h) { Transmission t = h.getTransmission(); return t.getIsAutomatic(); } public bool isAutomatic(Vehicle v) { if (!hasTranmission(v)) throw new UnsupportedVehicleException(); return isAutomatic((HasTransmission)v); } public InspectionBoolean isAutomatic(Vehicle[] garage, int bay) { if (!hasTranmission(garage[bay])) return InspectionBoolean.UNSUPPORTED; return isAutomatic(garage[bay]) ? InspectionBoolean.TRUE : InspectionBoolean.FALSE; } }
class Supported<T> { private bool supported = false; private T value; public Supported() { } public Supported(T value) { this.isSupported = true; this.value = value; } public bool isSupported() { return supported; } public T getValue() { if (!supported) throw new NotSupportedException(); return value; } }
class TransmissionInspector { public Supported<bool> isAutomatic(Vehicle[] garage, int bay) { if (!hasTranmission(garage[bay])) return new Supported<bool>(); return new Supported<bool>(isAutomatic(garage[bay])); } public Supported<int> getGearCount(Vehicle[] garage, int bay) { if (!hasTranmission(garage[bay])) return new Supported<int>(); return new Supported<int>(getGearCount(garage[bay])); } }
public abstract class Vehicle { public final boolean isCar; public final boolean isBoat; public Vehicle (boolean isCar, boolean isBoat) { this.isCar = isCar; this.isBoat = isBoat; } }
public class Car extends Vehicle { public Car (...) { super(true, false); ... } } public class Boat extends Vehicle { public Boat (...) { super(false, true); ... } }
boolean carIsAutomatic = false; if (myGarage[0].isCar) { Car car = (Car) myGarage[0]; car.carMethod(); carIsAutomatic = car.auto; } else if (myGarage[0].isBoat) { Boat boat = (Boat) myGarage[0]; boat.boatMethod(); }
import org.junit.Test; /** need to allow forbidden references! */ import sun.misc.Unsafe; /** * Demonstrate how to throw an undeclared checked exception. * This is a hack, because it uses the forbidden Class {@link sun.misc.Unsafe}. */ public class ExceptionTest { /** * A checked exception. */ public static class MyException extends Exception { private static final long serialVersionUID = 5960664994726581924L; } /** * Throw the Exception. */ @SuppressWarnings("restriction") public static void throwUndeclared() { getUnsafe().throwException(new MyException()); } /** * Return an instance of {@link sun.misc.Unsafe}. * @return THE instance */ @SuppressWarnings("restriction") private static Unsafe getUnsafe() { try { Field singleoneInstanceField = Unsafe.class.getDeclaredField("theUnsafe"); singleoneInstanceField.setAccessible(true); return (Unsafe) singleoneInstanceField.get(null); } catch (IllegalArgumentException e) { throw createExceptionForObtainingUnsafe(e); } catch (SecurityException e) { throw createExceptionForObtainingUnsafe(e); } catch (NoSuchFieldException e) { throw createExceptionForObtainingUnsafe(e); } catch (IllegalAccessException e) { throw createExceptionForObtainingUnsafe(e); } } private static RuntimeException createExceptionForObtainingUnsafe(final Throwable cause) { return new RuntimeException("error while obtaining sun.misc.Unsafe", cause); } /** * scenario: test that an CheckedException {@link MyException} can be thrown * from an method that not declare it. */ @Test(expected = MyException.class) public void testUnsingUnsaveToThrowCheckedException() { throwUndeclared(); } }
public class TestDatabase { public static void main(String[] args) { Database db = new Database(); try { db.connect(); } catch (Exception e) { e.printStackTrace(); } db.close(); } }
import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class Database { private Connection con; public void connect() throws Exception{ if(con != null) return; try { Class.forName("com.mysql.jdbc.Driver"); } catch (ClassNotFoundException e) { throw new Exception("No database"); } String connectionURL = "jdbc:mysql: con = DriverManager.getConnection(connectionURL, "root", "milos23"); } public void close(){ if(con != null){ try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } } }
Properties properties = new Properties(); properties.setProperty("user", "root"); properties.setProperty("password", "milos23); properties.setProperty("useSSL", "false"); properties.setProperty("autoReconnect", "true"); try (Connection conn = DriverManager.getConnection(connectionUrl, properties)) { ... } catch (SQLException e) { ... }
<property> <name>javax.jdo.option.ConnectionURL</name> <value>jdbc:mysql: <description>metadata is stored in a MySQL server</description> </property>
this.conn = (Connection)DriverManager .getConnection(url + dbName + "?useSSL=false", userName, password);
<property name="hibernate.connection.url"> jdbc:mysql: </property>
String text = "12.34"; double value = Double.parseDouble(text);
double total = Double.parseDouble(jlbTotal.getText()); double price = Double.parseDouble(jlbPrice.getText());
String number = "123,321"; double value = Double.parseDouble( number.replace(",",".") );
String s = "10.1"; Double d = Double.parseDouble(s);
String doubleAsString = "23.23"; BigDecimal price = new BigDecimal(doubleAsString); BigDecimal total = price.plus(anotherPrice);
String someValue= "52.23"; Double doubleVal = Double.parseDouble(someValue); System.out.println(doubleVal);
DecimalFormat df = new DecimalFormat(); DecimalFormatSymbols sfs = new DecimalFormatSymbols(); sfs.setDecimalSeparator( df.setDecimalFormatSymbols(sfs); double d = df.parse(number).doubleValue();
String double_string = "100.215"; Double double = Double.parseDouble(double_string);
Double temp = Double.valueOf(str); number = temp.doubleValue();
public static double convertToDouble(String temp){ String a = temp; String s = a.replaceAll(",","").trim(); String f = s.replaceAll(" ", ""); double result = Double.parseDouble(f); return result; }
public static double str2doubel(String str) { double num = 0; double num2 = 0; int idForDot = str.indexOf( boolean isNeg = false; String st; int start = 0; int end = str.length(); if (idForDot != -1) { st = str.substring(0, idForDot); for (int i = str.length() - 1; i >= idForDot + 1; i--) { num2 = (num2 + str.charAt(i) - } } else { st = str; } if (st.charAt(0) == isNeg = true; start++; } else if (st.charAt(0) == start++; } for (int i = start; i < st.length(); i++) { if (st.charAt(i) == continue; } num *= 10; num += st.charAt(i) - } num = num + num2; if (isNeg) { num = -1 * num; } return num; }
str = "Hello I String[] splited = str.split("\\s+");
String str = " Hello I String[] splitStr = str.split("\\s+");
splitStr[0] == ""; splitStr[1] == "Hello"; splitStr[2] == "I splitStr[3] == "Your"; splitStr[4] == "String";
String str = " Hello I String[] splitStr = str.trim().split("\\s+");
str = "Hello I String[] splitStr = str.split("\\s+");
String str = "This is String"; String[] splited = str.split("\\s+"); String split_one=splited[0]; String split_second=splited[1]; String split_three=splited[2]; Log.d("Splited String ", "Splited String" + split_one+split_second+split_three);
StringTokenizer tokens = new StringTokenizer("Hello I String[] splited = new String[tokens.countTokens()]; int index = 0; while(tokens.hasMoreTokens()){ splited[index] = tokens.nextToken(); ++index; }
import java.util.regex.Pattern; ... private static final Pattern SPACE = Pattern.compile(" "); String[] arr = SPACE.split(str);
str1 = " Hello I str2 = " Are you serious about this question_ boy, aren
String CurrentString = "First Second Last"; String[] separated = CurrentString.split(" "); for (int i = 0; i < separated.length; i++) { if (i == 0) { Log.d("FName ** ", "" + separated[0].trim() + "\n "); } else if (i == 1) { Log.d("MName ** ", "" + separated[1].trim() + "\n "); } else if (i == 2) { Log.d("LName ** ", "" + separated[2].trim()); } }
private String shorterName(String s){ String[] sArr = s.split("\\,|\\s+"); String output = sArr[0]; return output; }
String thisString="Hello world"; String[] parts = theString.split(" "); String first = parts[0]; String second = parts[1];
List<String> output = new ArrayList<>(); try (Scanner sc = new Scanner(inputString)) { while (sc.hasNext()) output.add(sc.next()); }
String str = "Hello I String[] splited = str.split(" "); var splited = str.split(" "); var splited1=splited[0]; var splited2=splited[1]; var splited3=splited[2]; var splited4=splited[3];
<jar ...> <manifest> <attribute name="Main-Class" value="MyApplication"/> </manifest> </jar>
<import resource="classpath:/META-INF/cxf/cxf.xml" /> <import resource="classpath:/META-INF/cxf/cxf-extensions-*.xml" />
import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; EntityManagerFactory emf = Persistence.createEntityManagerFactory(persistenceUnitName);
Date date = Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
import java.time.Instant; import java.time.LocalDate; import java.time.LocalDateTime; import java.time.ZoneId; import java.util.Date; public class DateUtils { public static Date asDate(LocalDate localDate) { return Date.from(localDate.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant()); } public static Date asDate(LocalDateTime localDateTime) { return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); } public static LocalDate asLocalDate(Date date) { return Instant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault()).toLocalDate(); } public static LocalDateTime asLocalDateTime(Date date) { return Instant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault()).toLocalDateTime(); } }
LocalDate ldate = ...; Instant instant = Instant.from(ldate.atStartOfDay(ZoneId.of("GMT"))); Date date = Date.from(instant);
LocalDate localDate = LocalDate.now(); Date date = new Date(localDate.atStartOfDay(ZoneId.of("America/New_York")).toEpochSecond() * 1000);
java.util.Date d = new SimpleDateFormat("yyyy-MM-dd").parse(localDate.toString());
fun LocalDate.toDate(): Date = Date.from(this.atStartOfDay(ZoneId.systemDefault()).toInstant())
java.util.Date.from(localDate.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());
new Date(localDate.toEpochDay() * DateUtils.MILLIS_PER_DAY);
public static Date convertToTimeZone(Date date, String tzFrom, String tzTo) { return Date.from(LocalDateTime.ofInstant(date.toInstant(), ZoneId.of(tzTo)).atZone(ZoneId.of(tzFrom)).toInstant()); }
public Date convertFrom(LocalDate date) { return java.sql.Timestamp.valueOf(date.atStartOfDay()); }
int day = this.datePicker2.getDate().getDayOfMonth(); int month = this.datePicker2.getDate().getMonthValue(); int year = this.datePicker2.getDate().getYear(); Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.YEAR, year); calendar.set(Calendar.MONTH, month-1); calendar.set(Calendar.DATE, day); Date date = calendar.getTime();
InputStream is = new ByteArrayInputStream( myString.getBytes( charset ) );
InputStreamReader isr = new InputStreamReader(IOUtils.toInputStream(myString));
String charset = ...; byte[] bytes = string.getBytes(charset); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); InputStreamReader isr = new InputStreamReader(bais);
ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(object); oos.flush(); oos.close(); bos.close(); byte[] byteData = bos.toByteArray();
ByteArrayInputStream bais = new ByteArrayInputStream(byteData); (Object) object = (Object) new ObjectInputStream(bais).readObject();
public class Order { private long number; public Order() { } /** * Copy constructor */ public Order(Order source) { number = source.number; } } public class Customer { private String name; private List<Order> orders = new ArrayList<Order>(); public Customer() { } /** * Copy constructor */ public Customer(Customer source) { name = source.name; for (Order sourceOrder : source.orders) { orders.add(new Order(sourceOrder)); } } public String getName() { return name; } public void setName(String name) { this.name = name; } }
My_Object object2= org.apache.commons.lang.SerializationUtils.clone(object1);
Cloner cloner = new Cloner(); MyClass clone = cloner.deepClone(o);
private static final XStream XSTREAM = new XStream(); ... Object newObject = XSTREAM.fromXML(XSTREAM.toXML(obj));
import com.thoughtworks.xstream.XStream; public class deepCopy { private static XStream xstream = new XStream(); public static Object deepCopy(Object obj){ return xstream.fromXML(xstream.toXML(obj)); } }
@SuppressWarnings("unchecked") public static <T extends Serializable> T clone(T object) { return (T) SerializationUtils.deserialize(SerializationUtils.serialize(object)); }
public static <T> T copy(T anObject, Class<T> classInfo) { Gson gson = new GsonBuilder().create(); String text = gson.toJson(anObject); T newObject = gson.fromJson(text, classInfo); return newObject; } public static void main(String[] args) { String originalObject = "hello"; String copiedObject = copy(originalObject, String.class); }
public static Object deepClone(Object object) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(object); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); } catch (Exception e) { e.printStackTrace(); return null; } } 2) MyAddress address = new MyAddress("Vishrantwadi ", "Pune", "India"); MyPerson al = new MyPerson("Al", "Arun", address); MyPerson neighbor = (MyPerson)deepClone(al);
int fourBytesIJustRead = someObject.getInt(); long unsignedValue = fourBytesIJustRead & 0xffffffffl;
import static org.joou.Unsigned.*; UByte b = ubyte(1); UShort s = ushort(1); UInteger i = uint(1); ULong l = ulong(1);
long getUnsigned(int signed) { return signed >= 0 ? signed : 2 * (long) Integer.MAX_VALUE + 2 + signed; }
if(this.altura < 0){ String aux = Integer.toString(this.altura); char aux2[] = aux.toCharArray(); aux = ""; for(int con = 1; con < aux2.length; con++){ aux += aux2[con]; } this.altura = Integer.parseInt(aux); System.out.println("New Value: " + this.altura); }
System.out.println("Integer "+(int)header[0]+" = "+((int)header[0]&0xff));
public int calculateSomething(Optional<String> p1, Optional<BigDecimal> p2 { }
public int calculateSomething(String p1, BigDecimal p2) { }
public int calculateSomething() { calculateSomething(null, null); } public int calculateSomething(String p1) { calculateSomething(p1, null); } public int calculateSomething(BigDecimal p2) { calculateSomething(null, p2); } public int calculateSomething(String p1, BigDecimal p2) { }
Optional<String> p1 = otherObject.getP1(); Optional<BigInteger> p2 = otherObject.getP2(); int result = myObject.calculateSomething(p1, p2);
Optional<String> p1 = otherObject.getP1(); Optional<BigInteger> p2 = otherObject.getP2(); int result = myObject.calculateSomething(p1.orElse(null), p2.orElse(null));
Optional<String> p1 = otherObject.getP1(); Optional<BigInteger> p2 = otherObject.getP2(); int result; if (p1.isPresent()) { if (p2.isPresent()) { result = myObject.calculateSomething(p1, p2); } else { result = myObject.calculateSomething(p1); } } else { if (p2.isPresent()) { result = myObject.calculateSomething(p2); } else { result = myObject.calculateSomething(); } }
public SystemMessage(String title, String content, Optional<Attachment> attachment) { }
SystemMessage withoutAttachment = new SystemMessage("title", "content", Optional.empty()); Attachment attachment = new Attachment(); SystemMessage withAttachment = new SystemMessage("title", "content", Optional.ofNullable(attachment));
public SystemMessage(String title, String content) { this(title, content, null); } public SystemMessage(String title, String content, Attachment attachment) { }
SystemMessage withoutAttachment = new SystemMessage("title", "content"); Attachment attachment = new Attachment(); SystemMessage withAttachment = new SystemMessage("title", "content", attachment);
public int calculateSomething(@NotNull final String p1, @NotNull final String p2) {}
public void method(Optional<MyClass> param) { if(param.isPresent()) { } else { } }
public int calculateSomething(Optional<String> p1, Optional<BigDecimal> p2 {}
Either<Error, String> value = compute().right().map((s) -> calculateSomething( < here you have to wrap the parameter in a Optional even if you know it string >));
void doSomething(Optional<ISOCode> isoOpt, Optional<Product> prodOpt){ if(isoOpt != null){ isoOpt.orElse(ISOCode.UNKNOWN); } if(prodOpt != null){ prodOpt.orElseThrow(NullPointerException::new); } }
Optional<String> p1 = otherObject.getP1(); Optional<BigInteger> p2 = otherObject.getP2(); Supplier<Integer> calculatedValueSupplier = () -> {
Optional<String> p1 = otherObject.getP1(); Optional<BigInteger> p2 = otherObject.getP2(); MyCalculator mc = new MyCalculator(); p1.map(mc::setP1); p2.map(mc::setP2); int result = mc.calculate();
public static <T, U> Function<? super T, Optional<U>> optFun(Function<T, U> function) { return t -> Optional.ofNullable(function.apply(t)); }
return Arrays.asList(enclosingInfo.getEnclosingClass().getDeclaredMethods()) .stream() .filter(m -> Objects.equals(m.getName(), enclosingInfo.getName()) .filter(m -> Arrays.equals(m.getParameterTypes(), parameterClasses)) .filter(m -> Objects.equals(m.getReturnType(), returnType)) .findFirst() .getOrThrow(() -> new InternalError(...));
Method matching = Arrays.asList(enclosingInfo.getEnclosingClass().getDeclaredMethods()) .stream() .filter(m -> Objects.equals(m.getName(), enclosingInfo.getName()) .filter(m -> Arrays.equals(m.getParameterTypes(), parameterClasses)) .filter(m -> Objects.equals(m.getReturnType(), returnType)) .getFirst(); if (matching == null) throw new InternalError("Enclosing method not found"); return matching;
$ which java /usr/bin/java $ ls -l /usr/bin/java lrwxr-xr-x 1 root wheel 74 Nov 7 07:59 /usr/bin/java -> /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java
@echo off setlocal ::- Get the Java Version set KEY="HKLM\SOFTWARE\JavaSoft\Java Runtime Environment" set VALUE=CurrentVersion reg query %KEY% /v %VALUE% 2>nul || ( echo JRE not installed exit /b 1 ) set JRE_VERSION= for /f "tokens=2,*" %%a in ( set JRE_VERSION=%%b ) echo JRE VERSION: %JRE_VERSION% ::- Get the JavaHome set KEY="HKLM\SOFTWARE\JavaSoft\Java Runtime Environment\%JRE_VERSION%" set VALUE=JavaHome reg query %KEY% /v %VALUE% 2>nul || ( echo JavaHome not installed exit /b 1 ) set JAVAHOME= for /f "tokens=2,*" %%a in ( set JAVAHOME=%%b ) echo JavaHome: %JAVAHOME% endlocal
public class Main { public static void main(String[] args) { System.out.println(System.getProperty("java.home")); } } $ javac Main.java $ java Main
/Library/Java/JavaVirtualMachines/jdk-9.0.4.jdk/Contents/Home
$ which java /usr/bin/java /private/tmp $ ls -l /usr/bin/java lrwxr-xr-x 1 root wheel 74 14 Nov 17:37 /usr/bin/java -> /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java
if [[ $(which ${JAVA_HOME}/bin/java) ]]; then exe="${JAVA_HOME}/bin/java" elif [[ $(which java) ]]; then exe="java" else echo "Java environment is not detected." exit 1 fi ${exe} -version
@echo off if "%JAVA_HOME%" == "" goto nojavahome echo Using JAVA_HOME : %JAVA_HOME% "%JAVA_HOME%/bin/java.exe" -version goto exit :nojavahome echo The JAVA_HOME environment variable is not defined correctly echo This environment variable is needed to run this program. goto exit :exit
::- Test for the registry location SET VALUE=CurrentVersion SET KEY_1="HKLM\SOFTWARE\JavaSoft\Java Development Kit" SET KEY_2=HKLM\SOFTWARE\JavaSoft\JDK SET REG_1=reg.exe SET REG_2="C:\Windows\sysnative\reg.exe" SET REG_3="C:\Windows\syswow64\reg.exe" SET KEY=%KEY_1% SET REG=%REG_1% %REG% QUERY %KEY% /v %VALUE% 2>nul IF %ERRORLEVEL% EQU 0 GOTO _set_value SET KEY=%KEY_2% SET REG=%REG_1% %REG% QUERY %KEY% /v %VALUE% 2>nul IF %ERRORLEVEL% EQU 0 GOTO _set_value ::- %REG_2% is for 64-bit installations, using "C:\Windows\sysnative" SET KEY=%KEY_1% SET REG=%REG_2% %REG% QUERY %KEY% /v %VALUE% 2>nul IF %ERRORLEVEL% EQU 0 GOTO _set_value SET KEY=%KEY_2% SET REG=%REG_2% %REG% QUERY %KEY% /v %VALUE% 2>nul IF %ERRORLEVEL% EQU 0 GOTO _set_value ::- %REG_3% is for 32-bit installations on a 64-bit system, using "C:\Windows\syswow64" SET KEY=%KEY_1% SET REG=%REG_3% %REG% QUERY %KEY% /v %VALUE% 2>nul IF %ERRORLEVEL% EQU 0 GOTO _set_value SET KEY=%KEY_2% SET REG=%REG_3% %REG% QUERY %KEY% /v %VALUE% 2>nul IF %ERRORLEVEL% EQU 0 GOTO _set_value :_set_value FOR /F "tokens=2,*" %%a IN ( SET JDK_VERSION=%%b ) SET KEY=%KEY%\%JDK_VERSION% SET VALUE=JavaHome FOR /F "tokens=2,*" %%a IN ( SET JAVAHOME=%%b ) ECHO "%JAVAHOME%" ::- SETX JAVA_HOME "%JAVAHOME%"
JAVA_FLAGS=-Dhttp.proxyHost=10.0.0.100 -Dhttp.proxyPort=8800 java ${JAVA_FLAGS} ...
-Dhttp.nonProxyHosts="localhost|127.0.0.1|10.*.*.*|*.foo.com|etc"
System.setProperty("java.net.useSystemProxies", "true");
... public void setProxy() { if (isUseHTTPProxy()) { System.setProperty("http.proxyHost", getHTTPHost()); System.setProperty("http.proxyPort", getHTTPPort()); System.setProperty("https.proxyHost", getHTTPHost()); System.setProperty("https.proxyPort", getHTTPPort()); if (isUseHTTPAuth()) { String encoded = new String(Base64.encodeBase64((getHTTPUsername() + ":" + getHTTPPassword()).getBytes())); con.setRequestProperty("Proxy-Authorization", "Basic " + encoded); Authenticator.setDefault(new ProxyAuth(getHTTPUsername(), getHTTPPassword())); } } if (isUseSOCKSProxy()) { System.setProperty("socksProxyHost", getSOCKSHost()); System.setProperty("socksProxyPort", getSOCKSPort()); if (isUseSOCKSAuth()) { System.setProperty("java.net.socks.username", getSOCKSUsername()); System.setProperty("java.net.socks.password", getSOCKSPassword()); Authenticator.setDefault(new ProxyAuth(getSOCKSUsername(), getSOCKSPassword())); } } } ... public class ProxyAuth extends Authenticator { private PasswordAuthentication auth; private ProxyAuth(String user, String password) { auth = new PasswordAuthentication(user, password == null ? new char[]{} : password.toCharArray()); } protected PasswordAuthentication getPasswordAuthentication() { return auth; } } ...
if (needsProxy()) { System.setProperty("http.proxyHost",getProxyHost()); System.setProperty("http.proxyPort",getProxyPort()); } else { System.setProperty("http.proxyHost",""); System.setProperty("http.proxyPort",""); }
System.getProperties().put("http.proxyHost", "someProxyURL"); System.getProperties().put("http.proxyPort", "someProxyPort");
System.setProperty("java.net.useSystemProxies", "true");
import java.net.*; import java.io.*; public class ProxyAuthenticator extends Authenticator { private String userName, password; protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(userName, password.toCharArray()); } public ProxyAuthenticator(String userName, String password) { this.userName = userName; this.password = password; } }
import java.net.Authenticator; import ProxyAuthenticator; public class Example { public static void main(String[] args) { String username = System.getProperty("proxy.authentication.username"); String password = System.getProperty("proxy.authentication.password"); if (username != null && !username.equals("")) { Authenticator.setDefault(new ProxyAuthenticator(username, password)); } } }
System.setProperty("http.proxyHost", "proxy host addr"); System.setProperty("http.proxyPort", "808"); Authenticator.setDefault(new Authenticator() { protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication("domain\\user","password".toCharArray()); } }); URL url = new URL("http: URLConnection con = url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader( con.getInputStream())); String inputLine; while ((inputLine = in.readLine()) != null) System.out.println(inputLine); in.close();
java -Dhttp.proxyHost=10.10.10.10 -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password -jar myJar.jar
System.getProperties().put("http.proxyHost", "someProxyURL"); System.getProperties().put("http.proxyPort", "someProxyPort"); System.getProperties().put("http.proxyUser", "someUserName"); System.getProperties().put("http.proxyPassword", "somePassword");
C:\temp>java -Dhttps.proxyHost=host -Dhttps.proxyPort=port -Dhttps=proxyUser=user -Dhttps.proxyPassword="password" -Djavax.net.ssl.trustStore=c:/cacerts -Djavax.net.ssl.trustStorePassword=changeit com.andreas.JavaNetHttpConnection
C:\temp>java com.andreas.JavaNetHttpConnection -Dhttps.proxyHost=host -Dhttps.proxyPort=port -Dhttps=proxyUser=user -Dhttps.proxyPassword="password" -Djavax.net.ssl.trustStore=c:/cacerts -Djavax.net.ssl.trustStorePassword=changeit
String proxyFileName = "proxy.txt" String proxyPort = "1234" String url = "http: File testProxyFile = new File(proxyFileName) URLConnection connection if (!testProxyFile.exists()) { logger.debug "proxyFileName doesn connection = url.toURL().openConnection() } else { String proxyAddress = testProxyFile.text connection = url.toURL().openConnection(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyAddress, proxyPort))) } try { connection.connect() } catch (Exception e) { logger.error e.printStackTrace() }
import com.sun.deploy.net.proxy.DeployProxySelector; import com.sun.deploy.services.PlatformType; import com.sun.deploy.services.ServiceManager; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public abstract class ExtendedProxyManager { private static final Log logger = LogFactory.getLog(ExtendedProxyManager.class); /** * After calling this method, proxy settings can be magically retrieved from default browser settings. */ public static boolean init() { logger.debug("Init started"); ServiceManager .setService(System.getProperty("os.name").toLowerCase().indexOf("windows") != -1 ? PlatformType.STANDALONE_TIGER_WIN32 : PlatformType.STANDALONE_TIGER_UNIX); try { DeployProxySelector.reset(); } catch (Throwable throwable) { logger.error("Unable to initialize extended dynamic browser proxy settings support.", throwable); return false; } return true; } }
public void setHttpProxy(boolean isNeedProxy) { if (isNeedProxy) { System.setProperty("http.proxyHost", getProxyHost()); System.setProperty("http.proxyPort", getProxyPort()); } else { System.clearProperty("http.proxyHost"); System.clearProperty("http.proxyPort"); } }
java -DsocksProxyHost=127.0.0.1 -DsocksProxyPort=8080 org.example.Main
CatalogResolver cr = new CatalogResolver(); ... yourParser.setEntityResolver(cr)
UrlQuerySanitizer.ValueSanitizer sanitizer = UrlQuerySanitizer.getAllButNullLegal(); sanitizer.parseUrl(url); String value = sanitizer.getValue("paramname");
import android.net.Uri; [...] Uri uri=Uri.parse(url_string); uri.getQueryParameter("para1");
public static Map<String, List<String>> getUrlParameters(String url) throws UnsupportedEncodingException { Map<String, List<String>> params = new HashMap<String, List<String>>(); String[] urlParts = url.split("\\?"); if (urlParts.length > 1) { String query = urlParts[1]; for (String param : query.split("&")) { String pair[] = param.split("="); String key = URLDecoder.decode(pair[0], "UTF-8"); String value = ""; if (pair.length > 1) { value = URLDecoder.decode(pair[1], "UTF-8"); } List<String> values = params.get(key); if (values == null) { values = new ArrayList<String>(); params.put(key, values); } values.add(value); } } return params; }
import org.eclipse.jetty.util.*; URL url = new URL("www.example.com/index.php?foo=bar&bla=blub"); MultiMap<String> params = new MultiMap<String>(); UrlEncoded.decodeTo(url.getQuery(), params, "UTF-8"); assert params.getString("foo").equals("bar"); assert params.getString("bla").equals("blub");
UriComponents components = UriComponentsBuilder.fromUri(uri).build(); List<String> myParam = components.getQueryParams().get("myParam");
public static Map<String, List<String>> getParameterMapOfLists(String queryString) { Map<String, List<String>> mapOfLists = new HashMap<String, List<String>>(); if (queryString == null || queryString.length() == 0) { return mapOfLists; } List<NameValuePair> list = URLEncodedUtils.parse(URI.create("http: for (NameValuePair pair : list) { List<String> values = mapOfLists.get(pair.getName()); if (values == null) { values = new ArrayList<String>(); mapOfLists.put(pair.getName(), values); } if (pair.getValue() != null) { values.add(pair.getValue()); } } return mapOfLists; }
public static Map<String, String[]> getParameterMap(String queryString) { Map<String, List<String>> mapOfLists = getParameterMapOfLists(queryString); Map<String, String[]> mapOfArrays = new HashMap<String, String[]>(); for (String key : mapOfLists.keySet()) { mapOfArrays.put(key, mapOfLists.get(key).toArray(new String[] {})); } return mapOfArrays; }
Uri uri = Uri.parse(url_string.replace("+", "%20")); uri.getQueryParameter("para1");
public static String getQueryString(String url, String tag) { String[] params = url.split("&"); Map<String, String> map = new HashMap<String, String>(); for (String param : params) { String name = param.split("=")[0]; String value = param.split("=")[1]; map.put(name, value); } Set<String> keys = map.keySet(); for (String key : keys) { if(key.equals(tag)){ return map.get(key); } System.out.println("Name=" + key); System.out.println("Value=" + map.get(key)); } return ""; }
public static String getQueryString(String url, String tag) { try { Uri uri=Uri.parse(url); return uri.getQueryParameter(tag); }catch(Exception e){ Log.e(TAG,"getQueryString() " + e.getMessage()); } return ""; }
String url = "http: String tagValue = getQueryString(url,"awidth");
public static Map<String, String> getUrlParameters(URI uri) throws UnsupportedEncodingException { Map<String, String> params = new HashMap<String, String>(); for (String param : uri.getQuery().split("&")) { String pair[] = param.split("="); String key = URLDecoder.decode(pair[0], "UTF-8"); String value = ""; if (pair.length > 1) { value = URLDecoder.decode(pair[1], "UTF-8"); } params.put(new String(key), new String(value)); } return params; }
UrlQuerySanitizer sanitzer = new UrlQuerySanitizer(url); String value = sanitzer.getValue("your_get_parameter");
Multimap<String, String> getUrlParameters(String url) { try { Multimap<String, String> ret = ArrayListMultimap.create(); for (NameValuePair param : URLEncodedUtils.parse(new URI(url), "UTF-8")) { ret.put(param.getName(), param.getValue()); } return ret; } catch (URISyntaxException e) { throw new RuntimeException(e); } }
public class QueryString { private Map<String, List<String>> parameters; public QueryString(String qs) { parameters = new TreeMap<String, List<String>>(); String pairs[] = qs.split("&"); for (String pair : pairs) { String name; String value; int pos = pair.indexOf( if (pos == -1) { name = pair; value = null; } else { try { name = URLDecoder.decode(pair.substring(0, pos), "UTF-8"); value = URLDecoder.decode(pair.substring(pos+1, pair.length()), "UTF-8"); } catch (UnsupportedEncodingException e) { throw new IllegalStateException("No UTF-8"); } } List<String> list = parameters.get(name); if (list == null) { list = new ArrayList<String>(); parameters.put(name, list); } list.add(value); } } public String getParameter(String name) { List<String> values = parameters.get(name); if (values == null) return null; if (values.size() == 0) return ""; return values.get(0); } public String[] getParameterValues(String name) { List<String> values = parameters.get(name); if (values == null) return null; return (String[])values.toArray(new String[values.size()]); } public Enumeration<String> getParameterNames() { return Collections.enumeration(parameters.keySet()); } public Map<String, String[]> getParameterMap() { Map<String, String[]> map = new TreeMap<String, String[]>(); for (Map.Entry<String, List<String>> entry : parameters.entrySet()) { List<String> list = entry.getValue(); String[] values; if (list == null) values = null; else values = (String[]) list.toArray(new String[list.size()]); map.put(entry.getKey(), values); } return map; } }
if (queryString != null) { final String[] arrParameters = queryString.split("&"); for (final String tempParameterString : arrParameters) { final String[] arrTempParameter = tempParameterString.split("="); if (arrTempParameter.length >= 2) { final String parameterKey = arrTempParameter[0]; final String parameterValue = arrTempParameter[1]; } } }
public static Map <String, String> parseQueryString (final URL url) throws UnsupportedEncodingException { final Map <String, String> qps = new TreeMap <String, String> (); final StringTokenizer pairs = new StringTokenizer (url.getQuery (), "&"); while (pairs.hasMoreTokens ()) { final String pair = pairs.nextToken (); final StringTokenizer parts = new StringTokenizer (pair, "="); final String name = URLDecoder.decode (parts.nextToken (), "ISO-8859-1"); final String value = URLDecoder.decode (parts.nextToken (), "ISO-8859-1"); qps.put (name, value); } return qps; }
Multimap<String,String> parseQueryString(String queryString, String encoding) { LinkedListMultimap<String, String> result = LinkedListMultimap.create(); for(String entry : Splitter.on("&").omitEmptyStrings().split(queryString)) { String pair [] = entry.split("=", 2); try { result.put(URLDecoder.decode(pair[0], encoding), pair.length == 2 ? URLDecoder.decode(pair[1], encoding) : null); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } } return result; }
var myURL: String? = null if (intent.hasExtra("my_value")) { myURL = intent.extras.getString("my_value") } else { myURL = intent.dataString } val sanitizer = UrlQuerySanitizer(myURL) sanitizer.allowUnregisteredParamaters = true val parameterNamesToValues: List<UrlQuerySanitizer.ParameterValuePair> = sanitizer.parameterList val parameterIterator: Iterator<UrlQuerySanitizer.ParameterValuePair> = parameterNamesToValues.iterator() val stringBuilder = StringBuilder() while (parameterIterator.hasNext()) { val parameterValuePair: UrlQuerySanitizer.ParameterValuePair = parameterIterator.next() val parameterName: String = parameterValuePair.mParameter val parameterValue: String = parameterValuePair.mValue stringBuilder.append("Key: $parameterName\nValue: $parameterValue\n\n") } val paramListString = stringBuilder.toString() val textView: TextView = findViewById(R.id.activity_title) as TextView textView.text = "Paramlist is \n\n$paramListString" if (sanitizer.hasParameter("type")) { val type = sanitizer.getValue("type") println("sanitizer has type param $type") }
public static Map<String, String> getQueryMap(String uri) { String queryParms[] = uri.split("\\?"); Map<String, String> map = new HashMap<>(); if (queryParms == null || queryParms.length == 0) return map; String[] params = queryParms[1].split("&"); for (String param : params) { String name = param.split("=")[0]; String value = param.split("=")[1]; map.put(name, value); } return map; }
xparm=0 word="" loop get next char if no char exit loop if char== param_name[xparm]=word word="" else if char== param_value[xparm]=word word="" xparm=xparm+1 else if char== read next two chars word=word+interpret the chars as hex digits to make a byte else word=word+char
ArrayList<Integer> arr = new ArrayList(10); int size = arr.size();
String[] str = new String[10]; int size = str.length;
public static void main(String[] args) { int x = args.length; }
public static void main(java.lang.String[]); Code: 0: aload_0 1: arraylength 2: istore_1 3: return
Field field = args.getClass().getField("length"); System.out.println(field.get(args));
static class StuffClass { int stuff; StuffClass(int stuff) { this.stuff = stuff; } } public static void main(String[] args) { int[] test = new int[5]; test[0] = 2; test[1] = 33; System.out.println("Length of int[]:\t" + test.length); String[] test2 = new String[5]; test2[0] = "2"; test2[1] = "33"; System.out.println("Length of String[]:\t" + test2.length); StuffClass[] test3 = new StuffClass[5]; test3[0] = new StuffClass(2); test3[1] = new StuffClass(33); System.out.println("Length of StuffClass[]:\t" + test3.length); }
Length of int[]: 5 Length of String[]: 5 Length of StuffClass[]: 5
ArrayList<Integer> intsList = new ArrayList<Integer>(); System.out.println("List size:\t" + intsList.size()); intsList.add(2); System.out.println("List size:\t" + intsList.size()); intsList.add(33); System.out.println("List size:\t" + intsList.size());
class A implements Cloneable, java.io.Serializable { public final int length = X; public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(e.getMessage()); } } }
int [] ints = new int[23]; System.out.println(ClassLayout.parseInstance(ints).toPrintable());
OFFSET SIZE TYPE DESCRIPTION 16 4 (object header) 17 00 00 00 (00010111 00000000 00000000 00000000) (23)
{ "http: "id": "http: }, "http: "id": "http: "shares": 16 } , "http: "id": "http: "shares": 16 } }
jsonObject = new JSONObject(contents.trim()); Iterator<String> keys = jsonObject.keys(); while(keys.hasNext()) { String key = keys.next(); if (jObject.get(key) instanceof JSONObject) { } }
for(int i = 0; i<jobject.names().length(); i++){ Log.v(TAG, "key = " + jobject.names().getString(i) + " value = " + jobject.get(jobject.names().getString(i))); }
import org.json.simple.JSONObject; public static void printJsonObject(JSONObject jsonObj) { for (Object key : jsonObj.keySet()) { String keyStr = (String)key; Object keyvalue = jsonObj.get(keyStr); System.out.println("key: "+ keyStr + " value: " + keyvalue); if (keyvalue instanceof JSONObject) printJsonObject((JSONObject)keyvalue); } }
JSONObject object = new JSONObject (); JSONArray keys = object.names (); for (int i = 0; i < keys.length (); ++i) { String key = keys.getString (i); String value = object.getString (key); }
Iterator<JSONObject> iterator = jsonObject.values().iterator(); while (iterator.hasNext()) { jsonChildObject = iterator.next(); String id = (String) jsonChildObject.get("id"); }
private <T> Iterable<T> iteratorToIterable(final Iterator<T> iterator) { return new Iterable<T>() { @Override public Iterator<T> iterator() { return iterator; } }; }
private <T> Iterable<T> iteratorToIterable(Iterator<T> iterator) { return () -> iterator; }
for (String key : iteratorToIterable(object.keys())) { JSONObject entry = object.getJSONObject(key);
HashMap<String,String> myKeyValues = new HashMap<String,String>(); Stack<String> key_path = new Stack<String>(); private void loadJson(JSONObject json){ Iterator<?> json_keys = json.keys(); while( json_keys.hasNext() ){ String json_key = (String)json_keys.next(); try{ key_path.push(json_key); loadJson(json.getJSONObject(json_key)); }catch (JSONException e){ String key = ""; for(String sub_key: key_path){ key += sub_key+"."; } key = key.substring(0,key.length()-1); System.out.println(key+": "+json.getString(json_key)); key_path.pop(); myKeyValues.put(key, json.getString(json_key)); } } if(key_path.size() > 0){ key_path.pop(); } }
JSONObject jObject = new JSONObject(contents.trim()); jObject.keys().forEachRemaining(k -> { });
public static void incrementValue(JSONObject obj, List<String> keysToIncrementValue) { Set<String> keys = obj.keySet(); for (String key : keys) { Object ob = obj.get(key); if (keysToIncrementValue.contains(key)) { obj.put(key, (Integer)obj.get(key) + 1); } if (ob instanceof JSONObject) { incrementValue((JSONObject) ob, keysToIncrementValue); } else if (ob instanceof JSONArray) { JSONArray arr = (JSONArray) ob; for (int i=0; i < arr.length(); i++) { Object arrObj = arr.get(0); if (arrObj instanceof JSONObject) { incrementValue((JSONObject) arrObj, keysToIncrementValue); } } } } }
JSONObject object = .... incrementValue(object, Arrays.asList("id", "product_id", "category_id", "customer_id"));
public static void main(String args[]) { String s = ""; JSONParser parser = new JSONParser(); JSONObject obj = null; try { obj = (JSONObject) parser.parse(s); @SuppressWarnings("unchecked") List<String> parameterKeys = new ArrayList<String>(obj.keySet()); List<String> result = null; List<String> keys = new ArrayList<>(); for (String str : parameterKeys) { keys.add(str); result = this.addNestedKeys(obj, keys, str); } System.out.println(result.toString()); } catch (ParseException e) { e.printStackTrace(); } } public static List<String> addNestedKeys(JSONObject obj, List<String> keys, String key) { if (isNestedJsonAnArray(obj.get(key))) { JSONArray array = (JSONArray) obj.get(key); for (int i = 0; i < array.length(); i++) { try { JSONObject arrayObj = (JSONObject) array.get(i); List<String> list = new ArrayList<>(arrayObj.keySet()); for (String s : list) { putNestedKeysToList(keys, key, s); addNestedKeys(arrayObj, keys, s); } } catch (JSONException e) { LOG.error("", e); } } } else if (isNestedJsonAnObject(obj.get(key))) { JSONObject arrayObj = (JSONObject) obj.get(key); List<String> nestedKeys = new ArrayList<>(arrayObj.keySet()); for (String s : nestedKeys) { putNestedKeysToList(keys, key, s); addNestedKeys(arrayObj, keys, s); } } return keys; } private static void putNestedKeysToList(List<String> keys, String key, String s) { if (!keys.contains(key + Constants.JSON_KEY_SPLITTER + s)) { keys.add(key + Constants.JSON_KEY_SPLITTER + s); } } private static boolean isNestedJsonAnObject(Object object) { boolean bool = false; if (object instanceof JSONObject) { bool = true; } return bool; } private static boolean isNestedJsonAnArray(Object object) { boolean bool = false; if (object instanceof JSONArray) { bool = true; } return bool; }
Iterator iterator = jsonObject.entrySet().iterator(); while (iterator.hasNext()) { Entry<String, JsonElement> entry = (Entry<String, JsonElement>) iterator.next(); jsonObject1.add(entry.getKey(), entry.getValue()); }
Set<Foo> set = ...; ... Foo foo = new Foo(1, 2, 3); Foo bar = set.get(foo);
public static void main(String[] args) { Set<Foo> set = new HashSet<Foo>(); set.add(new Foo("Hello")); for (Iterator<Foo> it = set.iterator(); it.hasNext(); ) { Foo f = it.next(); if (f.equals(new Foo("Hello"))) System.out.println("foo found"); } } static class Foo { String string; Foo(String string) { this.string = string; } @Override public int hashCode() { return string.hashCode(); } @Override public boolean equals(Object obj) { return string.equals(((Foo) obj).string); } }
Set<Foo> set = ...; List<Foo> list = new ArrayList<Foo>(set); Foo obj = list.get(0);
Foo getEqual(Foo sample, Set<Foo> all) { for (Foo one : all) { if (one.equals(sample)) { return one; } } return null; }
return all.stream().filter(sample::equals).findAny().orElse(null);
class City extends UniqueItem { public void doSomething() { } } public class GameMap { private MagicSet<City> cities; public GameMap(Collection<City> cities) { cities = new MagicHashSet<>(cities); } /* * cityId is the UUID of the city you want to retrieve. * If you have a copied instance of that city, you can simply * call copiedCity.getId() and pass the return value to this method. */ public void doSomethingInCity(UUID cityId) { City city = cities.getFromId(cityId); city.doSomething(); } }
Foo foo = set.stream().filter(item->item.equals(theItemYouAreLookingFor)).findFirst().get();
Object objectToGet = ... Map<Object, Object> map = new HashMap<Object, Object>(set.size()); for (Object o : set) { map.put(o, o); } Object objectFromSet = map.get(objectToGet);
mySet.stream() .filter(object -> object.property.equals(myProperty)) .findFirst().get();
Map<Integer,Foo> map = Maps.uniqueIndex(fooSet, Foo::getKey);
class SelfMappingHashMap<V> extends HashMap<V, V>{ @Override public String toString(){ return keySet().toString(); } @Override public V get( Object key ){ throw new UnsupportedOperationException( "use tryToGetRealFromCandidate()"); } @Override public V put( V key, V value ){ assert key.equals( value ); return super.put( key, value ); } public V tryToGetRealFromCandidate( V key ){ return super.get(key); } }
SelfMappingHashMap<SomeClass> selfMap = new SelfMappingHashMap<SomeClass>(); ... SomeClass candidate = new SomeClass(); if( selfMap.contains( candidate ) ){ SomeClass realThing = selfMap.tryToGetRealFromCandidate( candidate ); ... realThing.useInSomeWay()... }
public interface NoVisibleConstructor { NoVisibleConstructor addOrGetExisting( GettableSet<? extends NoVisibleConstructor> gettableSet ); }; public interface GettableSet<V extends NoVisibleConstructor> extends Set<V> { V getGenuineFromImpostor( V impostor ); }
public class GettableHashSet<V extends NoVisibleConstructor> implements GettableSet<V> { private Map<V, V> map = new HashMap<V, V>(); @Override public V getGenuineFromImpostor(V impostor ) { return map.get( impostor ); } @Override public int size() { return map.size(); } @Override public boolean contains(Object o) { return map.containsKey( o ); } @Override public boolean add(V e) { assert e != null; V result = map.put( e, e ); return result != null; } @Override public boolean remove(Object o) { V result = map.remove( o ); return result != null; } @Override public boolean addAll(Collection<? extends V> c) { throw new UnsupportedOperationException(); } @Override public void clear() { map.clear(); } }
class SomeClass implements NoVisibleConstructor { private SomeClass( Object param1, Object param2 ){ } static SomeClass getOrCreate( GettableSet<SomeClass> gettableSet, Object param1, Object param2 ) { SomeClass candidate = new SomeClass( param1, param2 ); if (gettableSet.contains(candidate)) { return gettableSet.getGenuineFromImpostor(candidate); } gettableSet.add( candidate ); return candidate; } @Override public NoVisibleConstructor addOrGetExisting( GettableSet<? extends NoVisibleConstructor> gettableSet ){ } }
protected SomeClass(){ throw new UnsupportedOperationException(); }
public abstract class AbstractSetMember implements NoVisibleConstructor { @Override public NoVisibleConstructor addOrGetExisting(GettableSet<? extends NoVisibleConstructor> gettableSet) { AbstractSetMember member = this; @SuppressWarnings("unchecked") GettableSet<AbstractSetMembers> set = (GettableSet<AbstractSetMember>) gettableSet; if (gettableSet.contains( member )) { member = set.getGenuineFromImpostor( member ); cleanUpAfterFindingGenuine( set ); } else { addNewToSet( set ); } return member; } abstract public void addNewToSet(GettableSet<? extends AbstractSetMember> gettableSet ); abstract public void cleanUpAfterFindingGenuine(GettableSet<? extends AbstractSetMember> gettableSet ); }
SomeClass setMember = new SomeClass( param1, param2 ).addOrGetExisting( set );
ModelClass m1 = null; int nth=scanner.nextInt(); for(int index=0;index<hashset1.size();index++){ m1 = (ModelClass) itr.next(); if(nth == index) { System.out.println(m1); break; } }
public class HashSet<E> .... private transient HashMap<E,Object> map;
<T> T onlyItem(Collection<T> items) { if (items.size() != 1) throw new IllegalArgumentException("Collection must have single item; instead it has " + items.size()); return items.iterator().next(); }
import java.util.Iterator; import java.util.HashSet; public class MyClass { public static void main(String[ ] args) { HashSet<String> animals = new HashSet<String>(); animals.add("fox"); animals.add("cat"); animals.add("dog"); animals.add("rabbit"); Iterator<String> it = animals.iterator(); while(it.hasNext()) { String value = it.next(); System.out.println(value); } } }
SharedPreferences se_get = getSharedPreferences("points",MODE_PRIVATE); Set<String> main = se_get.getStringSet("mydata",null); for(int jk = 0 ; jk < main.size();jk++) { Log.i("data",String.valueOf(main.toArray()[jk])); }
ObjectClass[] arrayName = SetOfObjects.toArray(new ObjectClass[setOfObjects.size()]);
FileUtils.writeByteArrayToFile(new File("pathname"), myByteArray)
try (FileOutputStream fos = new FileOutputStream("pathname")) { fos.write(myByteArray); }
try (FileOutputStream stream = new FileOutputStream(path)) { stream.write(bytes); }
FileUtils.writeByteArrayToFile(new File(path), bytes);
byte[] bytes = ...; Path path = Paths.get("C:\\myfile.pdf"); Files.write(path, bytes);
try (FileOutputStream fos = new FileOutputStream("fullPathToFile")) { fos.write(byteArray); } catch (IOException ioe) { ioe.printStackTrace(); }
File f = new File(fileName); byte[] fileContent = msg.getByteSequenceContent(); Path path = Paths.get(f.getAbsolutePath()); try { Files.write(path, fileContent); } catch (IOException ex) { Logger.getLogger(Agent2.class.getName()).log(Level.SEVERE, null, ex); }
String fileName = "file.test"; BufferedOutputStream bs = null; try { FileOutputStream fs = new FileOutputStream(new File(fileName)); bs = new BufferedOutputStream(fs); bs.write(byte_array); bs.close(); bs = null; } catch (Exception e) { e.printStackTrace() } if (bs != null) try { bs.close(); } catch (Exception e) {}
Path path = Paths.get(p); byte[] data = null; try { data = Files.readAllBytes(path); } catch (IOException ex) { Logger.getLogger(Agent1.class.getName()).log(Level.SEVERE, null, ex); }
File f = new File(fileName); byte[] fileContent = msg.getByteSequenceContent(); Path path = Paths.get(f.getAbsolutePath()); try { Files.write(path, fileContent); } catch (IOException ex) { Logger.getLogger(Agent2.class.getName()).log(Level.SEVERE, null, ex); }
new LengthOf(new TeeInput(array, new File("a.txt"))).value();
import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class ReadandWriteAByte { public void readandWriteBytesToFile(){ File file = new File("count.char"); File bfile = new File("bytefile.txt"); byte[] b; FileInputStream fis = null; FileOutputStream fos = null; try{ fis = new FileInputStream (file); fos = new FileOutputStream (bfile); b = new byte [1024]; int i; StringBuilder sb = new StringBuilder(); while ((i = fis.read(b))!=-1){ sb.append(new String(b,5,5)); fos.write(b, 2, 5); } System.out.println(sb.toString()); }catch (IOException e) { e.printStackTrace(); }finally { try { if(fis != null); fis.close(); }catch (IOException e){ e.printStackTrace(); } } } public static void main (String args[]){ ReadandWriteAByte rb = new ReadandWriteAByte(); rb.readandWriteBytesToFile(); } }
/** * Does some thing in old style. * * @deprecated use {@link */ @Deprecated public void old() { }
/** * @param basePrice * * @deprecated reason this method is deprecated <br/> * {will be removed in next version} <br/> * use {@link * * * <blockquote><pre> * getProduct().setPurchasePrice(200) * </pre></blockquote> * */ @Deprecated public void setBaseprice(int basePrice) { }
public class MySQLDatabaseConnectionFactory implements DatabaseConnectionFactory { @Override public Connection getConnection() { try { return DriverManager.getConnection(...); } catch (SQLException e) { throw new RuntimeException(e); } } }
@RunWith(PowerMockRunner.class) @PrepareForTest(DriverManager.class) public class Mocker { @Test public void testName() throws Exception { PowerMockito.mockStatic(DriverManager.class); BDDMockito.given(DriverManager.getConnection(...)).willReturn(...); sut.execute(); PowerMockito.verifyStatic(); DriverManager.getConnection(...); }
public class Slf4jMdcWrapper { public static final Slf4jMdcWrapper SINGLETON = new Slf4jMdcWrapper(); public String myApisToTheSaticMethodsInSlf4jMdcStaticUtilityClass() { return MDC.getWhateverIWant(); } }
public class SomeClassUnderTest { final Slf4jMdcWrapper myMockableObject; /** constructor used by CDI or whatever real life use case */ public myClassUnderTestContructor() { this.myMockableObject = Slf4jMdcWrapper.SINGLETON; } /** constructor used in tests*/ myClassUnderTestContructor(Slf4jMdcWrapper myMock) { this.myMockableObject = myMock; } }
public class SmokeRouteBuilder { public static String smokeMessageId() { try { return InetAddress.getLocalHost().getHostAddress(); } catch (UnknownHostException e) { log.error("Exception occurred while fetching localhost address", e); return UUID.randomUUID().toString(); } } }
@RunWith(PowerMockRunner.class) @PrepareForTest(SmokeRouteBuilder.class) public class SmokeRouteBuilderTest { @Test public void testSmokeMessageId_exception() throws UnknownHostException { UUID id = UUID.randomUUID(); mockStatic(InetAddress.class); mockStatic(UUID.class); when(InetAddress.getLocalHost()).thenThrow(UnknownHostException.class); when(UUID.randomUUID()).thenReturn(id); assertEquals(id.toString(), SmokeRouteBuilder.smokeMessageId()); } }
securityAlgo = MessageDigest.getInstance(SECURITY_ALGORITHM);
public class CustomObjectRule { object = DatatypeConverter.printHexBinary(MessageDigest.getInstance(SECURITY_ALGORITHM) .digest(message.getBytes(ENCODING))); }
PowerMockito.mockStatic(MessageDigest.class); PowerMockito.when(MessageDigest.getInstance(Mockito.anyString())) .thenThrow(new RuntimeException());
public class MySQLDatabaseConnectionFactory implements DatabaseConnectionFactory { @Override public Connection getConnection() { try { return _getConnection(...some params...); } catch (SQLException e) { throw new RuntimeException(e); } } Connection _getConnection(...some params...) throws SQLException { return DriverManager.getConnection(...some params...); } }
public class MockedConnectionFactory extends MySQLDatabaseConnectionFactory { Connection _getConnection(...some params...) throws SQLException { if (some param != something) throw new InvalidParameterException(); return Mockito.mock(Connection.class); } }
when(() -> DriverManager.getConnection(...)).thenReturn(...);
public class StaticMockingExperimentTest extends TestBase { Foo mock = Mockito.mock(Foo.class); MockHandler handler = Mockito.mockingDetails(mock).getMockHandler(); Method staticMethod; InvocationFactory.RealMethodBehavior realMethod = new InvocationFactory.RealMethodBehavior() { @Override public Object call() throws Throwable { return null; } }; @Before public void before() throws Throwable { staticMethod = Foo.class.getDeclaredMethod("staticMethod", String.class); } @Test public void verify_static_method() throws Throwable { Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod, "some arg"); handler.handle(invocation); verify(mock); Invocation verification = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod, "some arg"); handler.handle(verification); verify(mock, times(0)); Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod, "different arg"); handler.handle(differentArg); } @Test public void stubbing_static_method() throws Throwable { Invocation invocation = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod, "foo"); handler.handle(invocation); when(null).thenReturn("hey"); assertEquals("hey", handler.handle(invocation)); assertEquals("hey", handler.handle(invocation)); Invocation differentArg = Mockito.framework().getInvocationFactory().createInvocation(mock, withSettings().build(Foo.class), staticMethod, realMethod, "different arg"); assertEquals(null, handler.handle(differentArg)); } static class Foo { private final String arg; public Foo(String arg) { this.arg = arg; } public static String staticMethod(String arg) { return ""; } @Override public String toString() { return "foo:" + arg; } } }
Connection jdbcConnection = Mockito.mock(Connection.class); MockUp<DBConnection> mockUp = new MockUp<DBConnection>() { DBConnection singleton = new DBConnection(); @Mock public DBConnection getInstance() { return singleton; } @Mock public Connection getConnection() { return jdbcConnection; } };
if (Double.isNaN(doubleValue)) { ... } if (doubleObject.isNaN()) { ... }
/** * Returns {@code true} if the argument is a finite floating-point * value; returns {@code false} otherwise (for NaN and infinity * arguments). * * @param d the {@code double} value to be tested * @return {@code true} if the argument is a finite * floating-point value, {@code false} otherwise. * @since 1.8 */ public static boolean isFinite(double d)
public class Not_a_Number { public static void main(String[] args) { String message = "0.0/0.0 is NaN.\nsimilarly Math.sqrt(-1) is NaN."; String dottedLine = "------------------------------------------------"; Double numerator = -2.0; Double denominator = -2.0; while (denominator <= 1) { Double x = numerator/denominator; Double y = new Double (x); boolean z = y.isNaN(); System.out.println("y = " + y); System.out.println("z = " + z); if (z == true){ System.out.println(message); } else { System.out.println("Hi, everyone"); } numerator = numerator + 1; denominator = denominator +1; System.out.println(dottedLine); } } }
export CLASSPATH=/home/myaccount/myproject/lib/CoolFramework.jar:/home/myaccount/myproject/output/
java -cp "/home/myaccount/myproject/lib/CoolFramework.jar:/home/myaccount/myproject/output/" MyMainClass
CLASSPATH can be set permanently in the environment: In Windows, choose control panel  System  Advanced  Environment Variables  choose "System Variables" (for all the users) or "User Variables" (only the currently login user)  choose "Edit" (if CLASSPATH already exists) or "New"  Enter "CLASSPATH" as the variable name  Enter the required directories and JAR files (separated by semicolons) as the value (e.g., ".;c:\javaproject\classes;d:\tomcat\lib\servlet-api.jar"). Take note that you need to include the current working directory (denoted by To check the current setting of the CLASSPATH, issue the following command: > SET CLASSPATH CLASSPATH can be set temporarily for that particular CMD shell session by issuing the following command: > SET CLASSPATH=.;c:\javaproject\classes;d:\tomcat\lib\servlet-api.jar Instead of using the CLASSPATH environment variable, you can also use the command-line option -classpath or -cp of the javac and java commands, for example, > java classpath c:\javaproject\classes com.abc.project1.subproject2.MyClass3
System.exit(0) or EXIT_SUCCESS; ---> Success System.exit(1) or EXIT_FAILURE; ---> Exception System.exit(-1) or EXIT_ERROR; ---> Error
if (error < 2){ help(); System.exit(-1); } else{ doSomthing(); System.exit(0); }
java -jar myapp.jar if %errorlevel% neq 0 exit /b %errorlevel% rem -- next command if myapp is success --
class calc{ public static void main(String args[]) { int a, b, c; char ch; do{ Scanner s=new Scanner(System.in); System.out.print("1. Addition\n"); System.out.print("2. Substraction\n"); System.out.print("3. Multiplication\n"); System.out.print("4. Division\n"); System.out.print("5. Exit\n\n"); System.out.print("Enter your choice : "); ch=s.next().charAt(0); switch (ch) { case Addition chose1=new Addition(); chose1.add(); break; case Substraction chose2=new Substraction(); chose2.sub(); break; case Multiplication chose3= new Multiplication(); chose3.multi(); break; case Division chose4=new Division(); chose4.divi(); break; case System.exit(0); break; default : System.out.print("wrong choice!!!"); break; } System.out.print("\n--------------------------\n"); }while(ch !=5); }
Integer i = theLong != null ? theLong.intValue() : null;
Long l = 123L; Integer correctButComplicated = Integer.valueOf(l.intValue()); Integer withBoxing = l.intValue(); Integer terrible = (int) (long) l;
0 ldc2_w <Long 123> [17] 3 invokestatic java.lang.Long.valueOf(long) : java.lang.Long [19] 6 astore_1 [l] 7 aload_1 [l] 8 invokevirtual java.lang.Long.intValue() : int [25] 11 invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [29] 14 astore_2 [correctButComplicated] 15 aload_1 [l] 16 invokevirtual java.lang.Long.intValue() : int [25] 19 invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [29] 22 astore_3 [withBoxing] 23 aload_1 [l] 24 invokevirtual java.lang.Long.longValue() : long [34] 27 l2i 28 invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [29] 31 astore 4 [terrible]
public static int checkedCast(long value) { int result = (int) value; checkArgument(result == value, "Out of range: %s", value); return result; }
import static java.lang.Math.toIntExact; public class DateFormatSampleCode { public static void main(String[] args) { long longValue = 1223321L; int longTointValue = toIntExact(longValue); System.out.println(longTointValue); } }
public static int safeLongToInt( long longNumber ) { if ( longNumber < Integer.MIN_VALUE || longNumber > Integer.MAX_VALUE ) { throw new IllegalArgumentException( longNumber + " cannot be cast to int without changing its value." ); } return (int) longNumber; }
Integer intVal = longVal == null ? null : Math.toIntExact(longVal);
Long l = 1234567L; int i = org.springframework.util.NumberUtils.convertNumberToTargetClass(l, Integer.class);
String s = "...stuff..."; for (int i = 0; i < s.length(); i++){ char c = s.charAt(i); }
for(int i = 0, n = s.length() ; i < n ; i++) { char c = s.charAt(i); }
String str = "...."; int offset = 0, strLen = str.length(); while (offset < strLen) { int curChar = str.codePointAt(offset); offset += Character.charCount(curChar); }
int count = 1000; ... System.out.println("Test 1: charAt + String"); long t = System.currentTimeMillis(); int sum=0; for (int i=0; i<count; i++) { int len = str.length(); for (int j=0; j<len; j++) { if (str.charAt(j) == sum = sum + 1; } } t = System.currentTimeMillis()-t; System.out.println("result: "+ sum + " after " + t + "msec");
import java.text.*; final CharacterIterator it = new StringCharacterIterator(s); for(char c = it.first(); c != CharacterIterator.DONE; c = it.next()) { ... }
yourString.chars() .mapToObj(c -> Character.valueOf((char) c)) .forEach(c -> System.out.println(c));
String str = "xyz"; str.chars().forEachOrdered(i -> System.out.print((char)i)); str.codePoints().forEachOrdered(i -> System.out.print((char)i));
public class StringDemo { public static void main(String[] args) { String palindrome = "Dot saw I was Tod"; int len = palindrome.length(); char[] tempCharArray = new char[len]; char[] charArray = new char[len]; for (int i = 0; i < len; i++) { tempCharArray[i] = palindrome.charAt(i); } for (int j = 0; j < len; j++) { charArray[j] = tempCharArray[len - 1 - j]; } String reversePalindrome = new String(charArray); System.out.println(reversePalindrome); } }
StringTokenizer st = new StringTokenizer(str, str, true);
String supplementary = "Some Supplementary: "; supplementary.codePoints().forEach(cp -> System.out.print(new String(Character.toChars(cp))));
import java.util.Comparator; import java.util.HashMap; import java.util.Map; import java.util.TreeMap; public class Solution { public static void main(String[] args) { HashMap<String, Integer> map = new HashMap<String, Integer>(); map.put("a", 10); map.put("b", 30); map.put("c", 50); map.put("d", 40); map.put("e", 20); System.out.println(map); Map sortedMap = sortByValue(map); System.out.println(sortedMap); } public static Map sortByValue(Map unsortedMap) { Map sortedMap = new TreeMap(new ValueComparator(unsortedMap)); sortedMap.putAll(unsortedMap); return sortedMap; } } class ValueComparator implements Comparator { Map map; public ValueComparator(Map map) { this.map = map; } public int compare(Object keyA, Object keyB) { Comparable valueA = (Comparable) map.get(keyA); Comparable valueB = (Comparable) map.get(keyB); return valueB.compareTo(valueA); } }
int tmp = 0; String s = new String(new byte[64*1024]); { long st = System.nanoTime(); for(int i = 0, n = s.length(); i < n; i++) { tmp += s.charAt(i); } st = System.nanoTime() - st; System.out.println("1 " + st); } { long st = System.nanoTime(); char[] ch = s.toCharArray(); for(int i = 0, n = ch.length; i < n; i++) { tmp += ch[i]; } st = System.nanoTime() - st; System.out.println("2 " + st); } { long st = System.nanoTime(); for(char c : s.toCharArray()) { tmp += c; } st = System.nanoTime() - st; System.out.println("3 " + st); } System.out.println("" + tmp);
import lombok.Getter; import lombok.Setter; public class Profile { @Getter @Setter private String username; @Getter @Setter private String password; }
dependencies { compileOnly "org.projectlombok:lombok:1.16.18" }
import java.util.*; public class testing { public static void main(String [] arg) { int[] src = new int[] {1, 2, 3, 4, 5}; int b1[] = Arrays.copyOfRange(src, 0, 2); } }
System.arraycopy(Object[] src, int srcStartIndex, Object[] dest, int dstStartIndex, int lengthOfCopiedIndices);
int[] src = new int[] {1, 2, 3, 4, 5}; int[] dst = new int[3]; System.arraycopy(src, 1, dst, 0, 3);
subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive)
int newArrayLength = 30; int[] newArray = new int[newArrayLength]; System.arrayCopy(oldArray, 0, newArray, 0, newArray.length);
int[] subArr = IntStream.range(startInclusive, endExclusive) .map(i -> src[i]) .toArray();
double avg = IntStream.range(startInclusive, endExclusive) .mapToDouble(index -> src[index]) .average() .getAsDouble();
void setSpinner(String value) { int pos = getSpinnerField().getAdapter().indexOf(value); getSpinnerField().setSelection(pos); }
String compareValue = "some value"; ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(this, R.array.select_state, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); mSpinner.setAdapter(adapter); if (compareValue != null) { int spinnerPosition = adapter.getPosition(compareValue); mSpinner.setSelection(spinnerPosition); }
mySpinner.setSelection(getIndex(mySpinner, myValue)); private int getIndex(Spinner spinner, String myString){ for (int i=0;i<spinner.getCount();i++){ if (spinner.getItemAtPosition(i).toString().equalsIgnoreCase(myString)){ return i; } } return 0; }
mySpinner.setSelection(((ArrayAdapter<String>)mySpinner.getAdapter()).getPosition(myString));
int selectionPosition= adapter.getPosition("YOUR_VALUE"); spinner.setSelection(selectionPosition);
private int indexOf(final Adapter adapter, Object value) { for (int index = 0, count = adapter.getCount(); index < count; ++index) { if (adapter.getItem(index).equals(value)) { return index; } } return -1; }
String[] baths = getResources().getStringArray(R.array.array_baths); mSpnBaths.setSelection(Arrays.asList(baths).indexOf(value_here));
CursorAdapter myAdapter = (CursorAdapter) spinner_listino.getAdapter(); for(int i = 0; i < myAdapter.getCount(); i++) { if (myAdapter.getItemId(i) == ordine.getListino() ) { this.spinner_listino.setSelection(i); break; } }
private int getIndexByString(Spinner spinner, String string) { int index = 0; for (int i = 0; i < spinner.getCount(); i++) { if (spinner.getItemAtPosition(i).toString().equalsIgnoreCase(string)) { index = i; break; } } return index; }
yourSpinner.setSelection(arrayAdapter.getPosition("Your Desired Text"));
void setSpinner(String value) { yourSpinner.setSelection(arrayAdapter.getPosition(value)); }
private int getIndex(Spinner spinner, String columnName, String searchString) { if (searchString == null || spinner.getCount() == 0) { return -1; } else { Cursor cursor = (Cursor)spinner.getItemAtPosition(0); for (int i = 0; i < spinner.getCount(); i++) { cursor.moveToPosition(i); String itemText = cursor.getString(cursor.getColumnIndex(columnName)); if (itemText.equals(searchString)) { return i; } } return -1; } }
private int getIndex(Spinner spinner, String searchString) { if (searchString == null || spinner.getCount() == 0) { return -1; } else { for (int i = 0; i < spinner.getCount(); i++) { if (spinner.getItemAtPosition(i).toString().equals(searchString)) { return i; } } return -1; } };
List<Country> list = CountryBO.GetCountries(0); CountriesAdapter dataAdapter = new CountriesAdapter(this,list); dataAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); spnCountries.setAdapter(dataAdapter); spnCountries.setSelection(dataAdapter.getItemIndexById(userProfile.GetCountryId()));
public int getItemIndexById(String id) { for (Country item : this.items) { if(item.GetId().toString().equals(id.toString())){ return this.items.indexOf(item); } } return 0; }
JSONObject json = new JSONObject(string); JSONArray jsonArray = json.getJSONArray("answer"); Class<? extends MyActivity> cls = this.getClass(); for (int j=1; j< 11; j++) { JSONObject obj = jsonArray.getJSONObject(j-1); String movieid = obj.getString("id"); Field field = cls.getDeclaredField("s"+ j); int datapos = indexedExactSearch(Arrays.asList(Arrays.asList(this.data).toArray()), "value", movieid) ; int pos = this.adapter.getPosition(this.data[datapos]); ((Spinner)field.get(this)).setSelection(pos); }
/** * Searches for exact match of the specified class field (key) value within the specified list. * This uses a sequential search through each object in the list until a match is found or end * of the list reached. It may be necessary to convert a list of specific objects into generics, * ie: LinkedList&ltDevice&gt needs to be passed as a List&ltObject&gt or Object[&nbsp] by using * Arrays.asList(device.toArray(&nbsp)). * * @param list - list of objects to search through * @param key - the class field containing the value * @param value - the value to search for * @return index of the list object with an exact match (-1 if not found) */ public static <T> int indexedExactSearch(List<Object> list, String key, String value) { int low = 0; int high = list.size()-1; int index = low; String val = ""; while (index <= high) { try { val = cast(list.get(index).getClass().getDeclaredField(key).get(list.get(index)) , "NONE"); } catch (SecurityException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } if (val.equalsIgnoreCase(value)) return index; index = index + 1; } return -(low + 1); }
/** * Base String cast, return the value or default * @param object - generic Object * @param defaultValue - default value to give if Object is null * @return - returns type String */ public static String cast(Object object, String defaultValue) { return (object!=null) ? object.toString() : defaultValue; } /** * Base integer cast, return the value or default * @param object - generic Object * @param defaultValue - default value to give if Object is null * @return - returns type integer */ public static int cast(Object object, int defaultValue) { return castImpl(object, defaultValue).intValue(); } /** * Base cast, return either the value or the default * @param object - generic Object * @param defaultValue - default value to give if Object is null * @return - returns type Object */ public static Object castImpl(Object object, Object defaultValue) { return object!=null ? object : defaultValue; }
public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); int spinnerPosition; Spinner spinner1 = (Spinner) findViewById(R.id.spinner1); ArrayAdapter<CharSequence> adapter1 = ArrayAdapter.createFromResource( this, R.array.ccy_array, android.R.layout.simple_spinner_dropdown_item); adapter1.setDropDownViewResource(android.R.layout.simple_list_item_activated_1); spinner1.setAdapter(adapter1); spinnerPosition = 0; String strpos1 = prfs.getString("SPINNER1_VALUE", ""); if (strpos1 != null || !strpos1.equals(null) || !strpos1.equals("")) { strpos1 = prfs.getString("SPINNER1_VALUE", ""); spinnerPosition = adapter1.getPosition(strpos1); spinner1.setSelection(spinnerPosition); spinnerPosition = 0; }
Spinner spinner1 = (Spinner) findViewById(R.id.spinner1); String spinlong1 = spinner1.getSelectedItem().toString(); SharedPreferences prfs = getSharedPreferences("WHATEVER", Context.MODE_PRIVATE); SharedPreferences.Editor editor = prfs.edit(); editor.putString("SPINNER1_VALUE", spinlong1); editor.commit();
@Override public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) { adapter.swapCursor(cursor); cursor.moveToFirst(); int row_count = 0; int spinner_row = 0; while (spinner_row < 0 || row_count < cursor.getCount()){ int cursorItemID = bCursor.getInt(cursor.getColumnIndexOrThrow(someTable.COLUMN_ID)); if (knownID==cursorItemID){ spinner_row = row_count; } cursor.moveToNext(); row_count++; } } spinner.setSelection(spinner_row ); }
ArrayList<String> myList = new ArrayList<>(); myList.add(String.format(Locale.getDefault() ,"%d", 30)); myList.add(String.format(Locale.getDefault(), "%d", 50)); myList.add(String.format(Locale.getDefault(), "%d", 70)); myList.add(String.format(Locale.getDefault(), "%d", 100));
myList.setSelection(myAdapter.getPosition(String.format(Locale.getDefault(), "%d", 70)));
public class WebAddressRecord { ... public HTTPMethod AccessMethod = HTTPMethod.HEAD; ...
Spinner mySpinner = (Spinner) findViewById(R.id.spinnerHttpmethod); ArrayAdapter<HTTPMethod> adapter = new ArrayAdapter<HTTPMethod>(this, android.R.layout.simple_spinner_item, HTTPMethod.values()); mySpinner.setAdapter(adapter); int selectionPosition= adapter.getPosition(webAddressRecord.AccessMethod); mySpinner.setSelection(selectionPosition);
YourAdapter yourAdapter = new YourAdapter (getActivity(), R.layout.list_view_item,arrData); yourAdapter .setDropDownViewResource(R.layout.list_view_item); mySpinner.setAdapter(yourAdapter ); String strCompare = "Indonesia"; for (int i = 0; i < arrData.length ; i++){ if(arrData[i].getCode().equalsIgnoreCase(strCompare)){ int spinnerPosition = yourAdapter.getPosition(arrData[i]); mySpinner.setSelection(spinnerPosition); } }
ArrayAdapter<CharSequence> type=ArrayAdapter.createFromResource(this,R.array.admin_typee,android.R.layout.simple_spinner_dropdown_item); type.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); mainType.setAdapter(type); String group=mainType.getSelectedItem().toString();
pincodeSpinner.setSelection(resources.getStringArray(R.array.pincodes).indexOf(javaObject.pincode))
String path = "/var/data/stuff/xyz.dat"; String base = "/var/data"; String relative = new File(base).toURI().relativize(new File(path).toURI()).getPath();
import java.nio.file.Path; import java.nio.file.Paths; public class Test { public static void main(String[] args) { Path pathAbsolute = Paths.get("/var/data/stuff/xyz.dat"); Path pathBase = Paths.get("/var/data"); Path pathRelative = pathBase.relativize(pathAbsolute); System.out.println(pathRelative); } }
import java.io.File; import java.util.regex.Pattern; import org.apache.commons.io.FilenameUtils; public class ResourceUtils { /** * Get the relative path from one file to another, specifying the directory separator. * If one of the provided resources does not exist, it is assumed to be a file unless it ends with * * * @param targetPath targetPath is calculated to this file * @param basePath basePath is calculated from this file * @param pathSeparator directory separator. The platform default is not assumed so that we can test Unix behaviour when running on Windows (for example) * @return */ public static String getRelativePath(String targetPath, String basePath, String pathSeparator) { String normalizedTargetPath = FilenameUtils.normalizeNoEndSeparator(targetPath); String normalizedBasePath = FilenameUtils.normalizeNoEndSeparator(basePath); if (pathSeparator.equals("/")) { normalizedTargetPath = FilenameUtils.separatorsToUnix(normalizedTargetPath); normalizedBasePath = FilenameUtils.separatorsToUnix(normalizedBasePath); } else if (pathSeparator.equals("\\")) { normalizedTargetPath = FilenameUtils.separatorsToWindows(normalizedTargetPath); normalizedBasePath = FilenameUtils.separatorsToWindows(normalizedBasePath); } else { throw new IllegalArgumentException("Unrecognised dir separator } String[] base = normalizedBasePath.split(Pattern.quote(pathSeparator)); String[] target = normalizedTargetPath.split(Pattern.quote(pathSeparator)); StringBuffer common = new StringBuffer(); int commonIndex = 0; while (commonIndex < target.length && commonIndex < base.length && target[commonIndex].equals(base[commonIndex])) { common.append(target[commonIndex] + pathSeparator); commonIndex++; } if (commonIndex == 0) { throw new PathResolutionException("No common path element found for + " } // // boolean baseIsFile = true; File baseResource = new File(normalizedBasePath); if (baseResource.exists()) { baseIsFile = baseResource.isFile(); } else if (basePath.endsWith(pathSeparator)) { baseIsFile = false; } StringBuffer relative = new StringBuffer(); if (base.length != commonIndex) { int numDirsUp = baseIsFile ? base.length - commonIndex - 1 : base.length - commonIndex; for (int i = 0; i < numDirsUp; i++) { relative.append(".." + pathSeparator); } } relative.append(normalizedTargetPath.substring(common.length())); return relative.toString(); } static class PathResolutionException extends RuntimeException { PathResolutionException(String msg) { super(msg); } } }
public void testGetRelativePathsUnix() { assertEquals("stuff/xyz.dat", ResourceUtils.getRelativePath("/var/data/stuff/xyz.dat", "/var/data/", "/")); assertEquals("../../b/c", ResourceUtils.getRelativePath("/a/b/c", "/a/x/y/", "/")); assertEquals("../../b/c", ResourceUtils.getRelativePath("/m/n/o/a/b/c", "/m/n/o/a/x/y/", "/")); } public void testGetRelativePathFileToFile() { String target = "C:\\Windows\\Boot\\Fonts\\chs_boot.ttf"; String base = "C:\\Windows\\Speech\\Common\\sapisvr.exe"; String relPath = ResourceUtils.getRelativePath(target, base, "\\"); assertEquals("..\\..\\Boot\\Fonts\\chs_boot.ttf", relPath); } public void testGetRelativePathDirectoryToFile() { String target = "C:\\Windows\\Boot\\Fonts\\chs_boot.ttf"; String base = "C:\\Windows\\Speech\\Common\\"; String relPath = ResourceUtils.getRelativePath(target, base, "\\"); assertEquals("..\\..\\Boot\\Fonts\\chs_boot.ttf", relPath); } public void testGetRelativePathFileToDirectory() { String target = "C:\\Windows\\Boot\\Fonts"; String base = "C:\\Windows\\Speech\\Common\\foo.txt"; String relPath = ResourceUtils.getRelativePath(target, base, "\\"); assertEquals("..\\..\\Boot\\Fonts", relPath); } public void testGetRelativePathDirectoryToDirectory() { String target = "C:\\Windows\\Boot\\"; String base = "C:\\Windows\\Speech\\Common\\"; String expected = "..\\..\\Boot"; String relPath = ResourceUtils.getRelativePath(target, base, "\\"); assertEquals(expected, relPath); } public void testGetRelativePathDifferentDriveLetters() { String target = "D:\\sources\\recovery\\RecEnv.exe"; String base = "C:\\Java\\workspace\\AcceptanceTests\\Standard test data\\geo\\"; try { ResourceUtils.getRelativePath(target, base, "\\"); fail(); } catch (PathResolutionException ex) { } }
public static URI resolve(URI baseURI, String reference)
String s1 = "/var/data/stuff/xyz.dat"; String s2 = "/var/data"; String s3 = s1.substring(s2.length());
/** * Computes the path for a file relative to a given base, or fails if the only shared * directory is the root and the absolute form is better. * * @param base File that is the base for the result * @param name File to be "relativized" * @return the relative name * @throws IOException if files have no common sub-directories, i.e. at best share the * root prefix "/" or "C:\" */ public static String getRelativePath(File base, File name) throws IOException { File parent = base.getParentFile(); if (parent == null) { throw new IOException("No common directory"); } String bpath = base.getCanonicalPath(); String fpath = name.getCanonicalPath(); if (fpath.startsWith(bpath)) { return fpath.substring(bpath.length() + 1); } else { return (".." + File.separator + getRelativePath(parent, name)); } }
Path sourceFile = Paths.get("some/common/path/example/a/b/c/f1.txt"); Path targetFile = Paths.get("some/common/path/example/d/e/f2.txt"); Path relativePath = sourceFile.relativize(targetFile); System.out.println(relativePath);
Path sourceFile = Paths.get(new File("some/common/path/example/a/b/c/f1.txt").parent()); Path targetFile = Paths.get("some/common/path/example/d/e/f2.txt"); Path relativePath = sourceFile.relativize(targetFile); System.out.println(relativePath);
/** * Returns the path of one File relative to another. * * @param target the target directory * @param base the base directory * @return target * @throws IOException if an error occurs while resolving the files */ public static File getRelativeFile(File target, File base) throws IOException { String[] baseComponents = base.getCanonicalPath().split(Pattern.quote(File.separator)); String[] targetComponents = target.getCanonicalPath().split(Pattern.quote(File.separator)); int index = 0; for (; index < targetComponents.length && index < baseComponents.length; ++index) { if (!targetComponents[index].equals(baseComponents[index])) break; } StringBuilder result = new StringBuilder(); if (index != baseComponents.length) { for (int i = index; i < baseComponents.length; ++i) result.append(".." + File.separator); } for (; index < targetComponents.length; ++index) result.append(targetComponents[index] + File.separator); if (!target.getPath().endsWith("/") && !target.getPath().endsWith("\\")) { result.delete(result.length() - File.separator.length(), result.length()); } return new File(result.toString()); }
public static String getRelativePath(String targetPath, String basePath, String pathSeparator) { String[] base = basePath.split(Pattern.quote(pathSeparator), -1); String[] target = targetPath.split(Pattern.quote(pathSeparator), 0); String common = ""; int commonIndex = 0; for (int i = 0; i < target.length && i < base.length; i++) { if (target[i].equals(base[i])) { common += target[i] + pathSeparator; commonIndex++; } else break; } if (commonIndex == 0) { return targetPath; } String relative = ""; if (base.length == commonIndex) { } else { int numDirsUp = base.length - commonIndex - 1; for (int i = 1; i <= (numDirsUp); i++) { relative += ".." + pathSeparator; } } relative += targetPath.substring(common.length()); return relative; }
public void testGetRelativePathsUnixy() { assertEquals("stuff/xyz.dat", FileUtils.getRelativePath( "/var/data/stuff/xyz.dat", "/var/data/", "/")); assertEquals("../../b/c", FileUtils.getRelativePath( "/a/b/c", "/a/x/y/", "/")); assertEquals("../../b/c", FileUtils.getRelativePath( "/m/n/o/a/b/c", "/m/n/o/a/x/y/", "/")); } public void testGetRelativePathFileToFile() { String target = "C:\\Windows\\Boot\\Fonts\\chs_boot.ttf"; String base = "C:\\Windows\\Speech\\Common\\sapisvr.exe"; String relPath = FileUtils.getRelativePath(target, base, "\\"); assertEquals("..\\..\\..\\Boot\\Fonts\\chs_boot.ttf", relPath); } public void testGetRelativePathDirectoryToFile() { String target = "C:\\Windows\\Boot\\Fonts\\chs_boot.ttf"; String base = "C:\\Windows\\Speech\\Common"; String relPath = FileUtils.getRelativePath(target, base, "\\"); assertEquals("..\\..\\Boot\\Fonts\\chs_boot.ttf", relPath); } public void testGetRelativePathDifferentDriveLetters() { String target = "D:\\sources\\recovery\\RecEnv.exe"; String base = "C:\\Java\\workspace\\AcceptanceTests\\Standard test data\\geo\\"; String relPath = FileUtils.getRelativePath(target, base, "\\"); assertEquals(target, relPath); }
public class RelativePathFinder { public static String getRelativePath(String targetPath, String basePath, String pathSeparator) { String[] target = targetPath.split(pathSeparator); String[] base = basePath.split(pathSeparator); String common = ""; int commonIndex = 0; for (int i = 0; i < target.length && i < base.length; i++) { if (target[i].equals(base[i])) { common += target[i] + pathSeparator; commonIndex++; } } String relative = ""; if (commonIndex == base.length) { relative = "." + pathSeparator + targetPath.substring(common.length()); } else { for (int i = 1; i <= commonIndex; i++) { relative += ".." + pathSeparator; } relative += targetPath.substring(common.length()); } return relative; } public static String getRelativePath(String targetPath, String basePath) { return getRelativePath(targetPath, basePath, File.pathSeparator); } }
public class RelativePathFinderTest extends TestCase { public void testGetRelativePath() { assertEquals("./stuff/xyz.dat", RelativePathFinder.getRelativePath( "/var/data/stuff/xyz.dat", "/var/data/", "/")); assertEquals("../../b/c", RelativePathFinder.getRelativePath("/a/b/c", "/a/x/y/", "/")); } }
public static String getRelativePath(String targetPath, String basePath, String pathSeparator) { boolean isDir = false; { File f = new File(targetPath); isDir = f.isDirectory(); } String[] base = basePath.split(Pattern.quote(pathSeparator), -1); String[] target = targetPath.split(Pattern.quote(pathSeparator), 0); String common = ""; int commonIndex = 0; for (int i = 0; i < target.length && i < base.length; i++) { if (target[i].equals(base[i])) { common += target[i] + pathSeparator; commonIndex++; } else break; } if (commonIndex == 0) { return targetPath; } String relative = ""; if (base.length == commonIndex) { relative = "." + pathSeparator; } else { int numDirsUp = base.length - commonIndex - (isDir?0:1); for (int i = 1; i <= (numDirsUp); i++) { relative += ".." + pathSeparator; } } if (targetPath.length() > common.length()) { relative += targetPath.substring(common.length()); } return relative; }
public static String getRelativePath(String fromPath, String toPath) { String regexCharacter = File.separator; if (File.separatorChar == regexCharacter = "\\\\"; } String[] fromSplit = fromPath.split(regexCharacter); String[] toSplit = toPath.split(regexCharacter); int common = 0; while (fromSplit[common].equals(toSplit[common])) { common++; } StringBuffer result = new StringBuffer("."); for (int i = common; i < fromSplit.length; i++) { result.append(File.separatorChar).append(".."); } for (int i = common; i < toSplit.length; i++) { result.append(File.separatorChar).append(toSplit[i]); } return result.toString(); }
public static String getRelativePath (String baseDir, String targetPath) { String[] base = baseDir.replace( targetPath = targetPath.replace( String[] target = targetPath.split("\\/"); int commonCount = 0, commonLength = 0, maxCount = Math.min(target.length, base.length); while (commonCount < maxCount) { String targetElement = target[commonCount]; if (!targetElement.equals(base[commonCount])) break; commonCount++; commonLength += targetElement.length() + 1; } if (commonCount == 0) return targetPath; int targetLength = targetPath.length(); int dirsUp = base.length - commonCount; StringBuffer relative = new StringBuffer(dirsUp * 3 + targetLength - commonLength + 1); for (int i = 0; i < dirsUp; i++) relative.append("../"); if (commonLength < targetLength) relative.append(targetPath.substring(commonLength)); return relative.toString(); }
public static String GetRelativePath(String path, String base){ final String SEP = "/"; if (!base.endsWith(SEP)){ return ""; } boolean isfile = !path.endsWith(SEP); String a = ""; String b = ""; try { a = new File(base).getCanonicalFile().toURI().getPath(); b = new File(path).getCanonicalFile().toURI().getPath(); } catch (IOException e) { e.printStackTrace(); } String[] basePaths = a.split(SEP); String[] otherPaths = b.split(SEP); int n = 0; for(; n < basePaths.length && n < otherPaths.length; n ++) { if( basePaths[n].equals(otherPaths[n]) == false ) break; } StringBuffer tmp = new StringBuffer(""); for(int m = n; m < basePaths.length; m ++) tmp.append(".."+SEP); for(int m = n; m < otherPaths.length; m ++) { tmp.append(otherPaths[m]); tmp.append(SEP); } String result = tmp.toString(); if (isfile && result.endsWith(SEP)){ result = result.substring(0,result.length()-1); } return result; }
import static java.util.Arrays.asList; import static java.util.Collections.nCopies; import static org.apache.commons.io.FilenameUtils.normalizeNoEndSeparator; import static org.apache.commons.io.FilenameUtils.separatorsToUnix; import static org.apache.commons.lang3.StringUtils.getCommonPrefix; import static org.apache.commons.lang3.StringUtils.isBlank; import static org.apache.commons.lang3.StringUtils.isNotEmpty; import static org.apache.commons.lang3.StringUtils.join; import java.io.File; import java.util.ArrayList; import java.util.List; public class ResourceUtils { public static String getRelativePath(String targetPath, String basePath, String pathSeparator) { File baseFile = new File(basePath); if (baseFile.isFile() || !baseFile.exists() && !basePath.endsWith("/") && !basePath.endsWith("\\")) basePath = baseFile.getParent(); String target = separatorsToUnix(normalizeNoEndSeparator(targetPath)); String base = separatorsToUnix(normalizeNoEndSeparator(basePath)); String commonPrefix = getCommonPrefix(target, base); if (isBlank(commonPrefix)) return targetPath.replaceAll("/", pathSeparator); target = target.replaceFirst(commonPrefix, ""); base = base.replaceFirst(commonPrefix, ""); List<String> result = new ArrayList<>(); if (isNotEmpty(base)) result.addAll(nCopies(base.split("/").length, "..")); result.addAll(asList(target.replaceFirst("^/", "").split("/"))); return join(result, pathSeparator); } }
import org.codehaus.plexus.util.PathTool; String relativeFilePath = PathTool.getRelativeFilePath(file1, file2);
package org.afc.util; import java.io.File; import java.util.LinkedList; import java.util.List; public class FileUtil { public static String getRelativePath(String basePath, String filePath) { return getRelativePath(new File(basePath), new File(filePath)); } public static String getRelativePath(File base, File file) { List<String> bases = new LinkedList<String>(); bases.add(0, base.getName()); for (File parent = base.getParentFile(); parent != null; parent = parent.getParentFile()) { bases.add(0, parent.getName()); } List<String> files = new LinkedList<String>(); files.add(0, file.getName()); for (File parent = file.getParentFile(); parent != null; parent = parent.getParentFile()) { files.add(0, parent.getName()); } int overlapIndex = 0; while (overlapIndex < bases.size() && overlapIndex < files.size() && bases.get(overlapIndex).equals(files.get(overlapIndex))) { overlapIndex++; } StringBuilder relativePath = new StringBuilder(); for (int i = overlapIndex; i < bases.size(); i++) { relativePath.append("..").append(File.separatorChar); } for (int i = overlapIndex; i < files.size(); i++) { relativePath.append(files.get(i)).append(File.separatorChar); } relativePath.deleteCharAt(relativePath.length() - 1); return relativePath.toString(); } }
private String relative(String left, String right){ String[] lefts = left.split("/"); String[] rights = right.split("/"); int min = Math.min(lefts.length, rights.length); int commonIdx = -1; for(int i = 0; i < min; i++){ if(commonIdx < 0 && !lefts[i].equals(rights[i])){ commonIdx = i - 1; break; } } if(commonIdx < 0){ return null; } StringBuilder sb = new StringBuilder(Math.max(left.length(), right.length())); sb.append(left).append("/"); for(int i = commonIdx + 1; i < lefts.length;i++){ sb.append("../"); } for(int i = commonIdx + 1; i < rights.length;i++){ sb.append(rights[i]).append("/"); } return sb.deleteCharAt(sb.length() -1).toString(); }
import java.lang.reflect.Field; import android.content.Context; import android.graphics.Typeface; public final class FontsOverride { public static void setDefaultFont(Context context, String staticTypefaceFieldName, String fontAssetName) { final Typeface regular = Typeface.createFromAsset(context.getAssets(), fontAssetName); replaceFont(staticTypefaceFieldName, regular); } protected static void replaceFont(String staticTypefaceFieldName, final Typeface newTypeface) { try { final Field staticField = Typeface.class .getDeclaredField(staticTypefaceFieldName); staticField.setAccessible(true); staticField.set(null, newTypeface); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } }
public final class Application extends android.app.Application { @Override public void onCreate() { super.onCreate(); FontsOverride.setDefaultFont(this, "DEFAULT", "MyFontAsset.ttf"); FontsOverride.setDefaultFont(this, "MONOSPACE", "MyFontAsset2.ttf"); FontsOverride.setDefaultFont(this, "SERIF", "MyFontAsset3.ttf"); FontsOverride.setDefaultFont(this, "SANS_SERIF", "MyFontAsset4.ttf"); } }
<resources> <style name="AppBaseTheme" parent="android:Theme.Light"> </style> <!-- Application theme. --> <style name="AppTheme" parent="AppBaseTheme"> <item name="android:typeface">monospace</item> </style> </resources>
<style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar"> <item name="android:typeface">monospace</item> </style>
public class App extends Application { @Override public void onCreate() { super.onCreate(); CalligraphyConfig.initDefault(new CalligraphyConfig.Builder() .setDefaultFontPath("your font path") .setFontAttrId(R.attr.fontPath) .build() ); } }
@Override protected void attachBaseContext(Context newBase) { super.attachBaseContext(CalligraphyContextWrapper.wrap(newBase)); }
/** * Recursively sets a {@link Typeface} to all * {@link TextView}s in a {@link ViewGroup}. */ public static final void setAppFont(ViewGroup mContainer, Typeface mFont, boolean reflect) { if (mContainer == null || mFont == null) return; final int mCount = mContainer.getChildCount(); for (int i = 0; i < mCount; ++i) { final View mChild = mContainer.getChildAt(i); if (mChild instanceof TextView) { ((TextView) mChild).setTypeface(mFont); } else if (mChild instanceof ViewGroup) { setAppFont((ViewGroup) mChild, mFont); } else if (reflect) { try { Method mSetTypeface = mChild.getClass().getMethod("setTypeface", Typeface.class); mSetTypeface.invoke(mChild, mFont); } catch (Exception e) { } } } }
final Typeface mFont = Typeface.createFromAsset(getAssets(), "fonts/MyFont.ttf"); final ViewGroup mContainer = (ViewGroup) findViewById( android.R.id.content).getRootView(); HomeActivity.setAppFont(mContainer, mFont);
import java.lang.reflect.Field; import android.content.Context; import android.graphics.Typeface; public final class FontsOverride { public static void setDefaultFont(Context context, String staticTypefaceFieldName, String fontAssetName) { final Typeface regular = Typeface.createFromAsset(context.getAssets(), fontAssetName); replaceFont(staticTypefaceFieldName, regular); } protected static void replaceFont(String staticTypefaceFieldName,final Typeface newTypeface) { if (isVersionGreaterOrEqualToLollipop()) { Map<String, Typeface> newMap = new HashMap<String, Typeface>(); newMap.put("sans-serif", newTypeface); try { final Field staticField = Typeface.class.getDeclaredField("sSystemFontMap"); staticField.setAccessible(true); staticField.set(null, newMap); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } else { try { final Field staticField = Typeface.class.getDeclaredField(staticTypefaceFieldName); staticField.setAccessible(true); staticField.set(null, newTypeface); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } }
public final class Application extends android.app.Application { @Override public void onCreate() { super.onCreate(); FontsOverride.setDefaultFont(this, "DEFAULT", "MyFontAsset.ttf"); FontsOverride.setDefaultFont(this, "MONOSPACE", "MyFontAsset2.ttf"); FontsOverride.setDefaultFont(this, "SERIF", "MyFontAsset3.ttf"); FontsOverride.setDefaultFont(this, "SANS_SERIF", "MyFontAsset4.ttf"); } }
<resources> <style name="AppBaseTheme" parent="Theme.AppCompat.Light"> </style> <!-- Application theme. --> <style name="AppTheme" parent="AppBaseTheme"> <item name="android:typeface">monospace</item> </style> </resources>
<resources> <style name="AppBaseTheme" parent="Theme.AppCompat.Light"> </style> <!-- Application theme. --> <style name="AppTheme" parent="AppBaseTheme"> <item name="android:textAppearance">@style/CustomTextAppearance</item> </style> <style name="CustomTextAppearance"> <item name="android:typeface">monospace</item> </style> </resources>
public class CustomFontView extends TextView { public CustomFontView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); init(); } public CustomFontView(Context context, AttributeSet attrs) { super(context, attrs); init(); } public CustomFontView(Context context) { super(context); init(); } private void init() { if (!isInEditMode()) { Typeface tf = Typeface.createFromAsset(getContext().getAssets(), "Futura.ttf"); setTypeface(tf); } }
public static final void setAppFont(ViewGroup mContainer, Typeface mFont, boolean reflect) { if (mContainer == null || mFont == null) return; final int mCount = mContainer.getChildCount(); for (int i = 0; i < mCount; ++i) { final View mChild = mContainer.getChildAt(i); if (mChild instanceof TextView) { ((TextView) mChild).setTypeface(mFont); } else if (mChild instanceof ViewGroup) { setAppFont((ViewGroup) mChild, mFont); } else if (reflect) { try { Method mSetTypeface = mChild.getClass().getMethod("setTypeface", Typeface.class); mSetTypeface.invoke(mChild, mFont); } catch (Exception e) { } } } }
final ViewGroup mContainer = (ViewGroup) findViewById( android.R.id.content).getRootView(); HomeActivity.setAppFont(mContainer, Typeface.createFromAsset(getAssets(), "fonts/MyFont.ttf"));
<style name="TextAppearance.Material"> <item name="fontFamily">@string/font_family_body_1_material</item> </style>
<string name="font_family_body_1_material">sans-serif</string>
protected static void replaceFont(String staticTypefaceFieldName, final Typeface newTypeface) { if (isVersionGreaterOrEqualToLollipop()) { Map<String, Typeface> newMap = new HashMap<String, Typeface>(); newMap.put("sans-serif", newTypeface); try { final Field staticField = Typeface.class .getDeclaredField("sSystemFontMap"); staticField.setAccessible(true); staticField.set(null, newMap); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } else { try { final Field staticField = Typeface.class .getDeclaredField(staticTypefaceFieldName); staticField.setAccessible(true); staticField.set(null, newTypeface); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } }
public class CusFntTextView extends TextView { public CusFntTextView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); init(); } public CusFntTextView(Context context, AttributeSet attrs) { super(context, attrs); init(); } public CusFntTextView(Context context) { super(context); init(); } private void init() { if (!isInEditMode()) { Typeface tf = Typeface.createFromAsset(getContext().getAssets(), "Futura.ttf"); setTypeface(tf); } }
<com.packagename.CusFntTextView android:id="@+id/tvtitle" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hi Android" android:textAppearance="?android:attr/textAppearanceLarge" />
public FontTextView(Context context) { super(context); init(); } public FontTextView(Context context, AttributeSet attrs) { super(context, attrs); init(); } public FontTextView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); init(); } protected void init() { setTypeface(Typeface.createFromAsset(getContext().getAssets(), AppConst.FONT)); }
<resources> <style name="AppBaseTheme" parent="Theme.AppCompat.Light"> </style> <!-- Application theme. --> <style name="AppTheme" parent="AppBaseTheme"> <item name="android:typeface">monospace</item> </style> </resources>
<resources> <style name="AppBaseTheme" parent="Theme.AppCompat.Light"> </style> <!-- Application theme. --> <style name="AppTheme" parent="AppBaseTheme"> <item name="android:textAppearance">@style/CustomTextAppearance</item> </style> <style name="CustomTextAppearance"> <item name="android:typeface">monospace</item> </style> </resources>
import android.content.Context; import android.graphics.Typeface; import android.os.Build; import android.util.Log; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class FontsOverride { private static final int BOLD = 1; private static final int BOLD_ITALIC = 2; private static final int ITALIC = 3; private static final int LIGHT = 4; private static final int CONDENSED = 5; private static final int THIN = 6; private static final int MEDIUM = 7; private static final int REGULAR = 8; private Context context; public FontsOverride(Context context) { this.context = context; } public void loadFonts() { Map<String, Typeface> fontsMap = new HashMap<>(); fontsMap.put("sans-serif", getTypeface("comic.ttf", REGULAR)); fontsMap.put("sans-serif-bold", getTypeface("comic.ttf", BOLD)); fontsMap.put("sans-serif-italic", getTypeface("comic.ttf", ITALIC)); fontsMap.put("sans-serif-light", getTypeface("comic.ttf", LIGHT)); fontsMap.put("sans-serif-condensed", getTypeface("comic.ttf", CONDENSED)); fontsMap.put("sans-serif-thin", getTypeface("comic.ttf", THIN)); fontsMap.put("sans-serif-medium", getTypeface("comic.ttf", MEDIUM)); overrideFonts(fontsMap); } private void overrideFonts(Map<String, Typeface> typefaces) { if (Build.VERSION.SDK_INT == 21) { try { final Field field = Typeface.class.getDeclaredField("sSystemFontMap"); field.setAccessible(true); Map<String, Typeface> oldFonts = (Map<String, Typeface>) field.get(null); if (oldFonts != null) { oldFonts.putAll(typefaces); } else { oldFonts = typefaces; } field.set(null, oldFonts); field.setAccessible(false); } catch (Exception e) { Log.e("TypefaceUtil", "Cannot set custom fonts"); } } else { try { for (Map.Entry<String, Typeface> entry : typefaces.entrySet()) { final Field staticField = Typeface.class.getDeclaredField(entry.getKey()); staticField.setAccessible(true); staticField.set(null, entry.getValue()); } } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } private Typeface getTypeface(String fontFileName, int fontType) { final Typeface tf = Typeface.createFromAsset(context.getAssets(), "fonts/" + fontFileName); return Typeface.create(tf, fontType); } }
<?xml version="1.0" encoding="utf-8"?> <font-family xmlns:android="http: <font android:fontStyle="normal" android:fontWeight="400" android:font="@font/lobster_regular" /> <font android:fontStyle="italic" android:fontWeight="400" android:font="@font/lobster_italic" /> </font-family>
<TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:fontFamily="@font/lobster"/> <style name="customfontstyle" parent="@android:style/TextAppearance.Small"> <item name="android:fontFamily">@font/lobster</item> </style>
public class Font { private static Font font; public Typeface ROBO_LIGHT; private Font() { } public static Font getInstance(Context context) { if (font == null) { font = new Font(); font.init(context); } return font; } public void init(Context context) { ROBO_LIGHT = Typeface.createFromAsset(context.getAssets(), "Roboto-Light.ttf"); } }
public class FontHelper { private static Font font; public static void applyFont(View parentView, Context context) { font = Font.getInstance(context); apply((ViewGroup)parentView); } private static void apply(ViewGroup parentView) { for (int i = 0; i < parentView.getChildCount(); i++) { View view = parentView.getChildAt(i); if (view instanceof EditText) { ((EditText) view).setTypeface(font.ROBO_LIGHT); } if (view instanceof TextView) { ((TextView) view).setTypeface(font.ROBO_LIGHT); } else if (view instanceof ViewGroup && ((ViewGroup) view).getChildCount() > 0) { apply((ViewGroup) view); } } } }
<RelativeLayout xmlns:android="http: xmlns:tools="http: android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:id="@+id/mainParent" tools:context="${relativePackage}.${activityClass}" > <RelativeLayout android:id="@+id/mainContainer" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_above="@+id/homeFooter" android:layout_below="@+id/edit" > <ImageView android:id="@+id/PreviewImg" android:layout_width="match_parent" android:layout_height="match_parent" android:src="@drawable/abc_list_longpressed_holo" android:visibility="gone" /> <RelativeLayout android:id="@+id/visibilityLayer" android:layout_width="match_parent" android:layout_height="fill_parent" > <ImageView android:id="@+id/UseCamera" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentTop="true" android:layout_centerHorizontal="true" android:src="@drawable/camera" /> <TextView android:id="@+id/tvOR" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@+id/UseCamera" android:layout_centerHorizontal="true" android:layout_marginTop="20dp" android:text="OR" android:textSize="30dp" /> <TextView android:id="@+id/tvAND" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerHorizontal="true" android:layout_marginTop="20dp" android:text="OR" android:textSize="30dp" /> </RelativeLayout>
public class MainActivity extends BaseFragmentActivity { private EditText etName; private EditText etPassword; private TextView tvTitle; public static boolean isHome = false; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Font font=Font.getInstance(getApplicationContext()); FontHelper.applyFont(findViewById(R.id.mainParent), getApplicationContext()); } }
@Override public void setTypeface(Typeface tf, int style) { if (style == 1){ tf = Typeface.createFromAsset(getContext().getApplicationContext().getAssets(), "MuseoSans700.otf"); }else{ tf = Typeface.createFromAsset(getContext().getApplicationContext().getAssets(), "MuseoSans500.otf"); } super.setTypeface(tf, 0); }
protected void changeChildrenFont(ViewGroup v, Typeface font){ for(int i = 0; i < v.getChildCount(); i++){ if(v.getChildAt(i) instanceof ViewGroup){ changeChildrenFont((ViewGroup) v.getChildAt(i), font); } else{ try { Object[] nullArgs = null; Method methodTypeFace = v.getChildAt(i).getClass().getMethod("setTypeface", new Class[] {Typeface.class, Integer.TYPE}); Method methodGetTypeFace = v.getChildAt(i).getClass().getMethod("getTypeface", new Class[] {}); Typeface typeFace = ((Typeface)methodGetTypeFace.invoke(v.getChildAt(i), nullArgs)); methodTypeFace.invoke(v.getChildAt(i), new Object[] {font, typeFace == null ? 0 : typeFace.getStyle()}); } catch (Exception e) { e.printStackTrace(); } } } }
public final class TypefaceAssigner { public final Typeface DEFAULT; public final Typeface DEFAULT_BOLD; @Inject public TypefaceAssigner(AssetManager assetManager) { DEFAULT = Typeface.createFromAsset(assetManager, "TradeGothicLTCom.ttf"); DEFAULT_BOLD = Typeface.createFromAsset(assetManager, "TradeGothicLTCom-Bd2.ttf"); } public void assignTypeface(View v) { if (v instanceof ViewGroup) { for (int i = 0; i < ((ViewGroup) v).getChildCount(); i++) { View view = ((ViewGroup) v).getChildAt(i); if (view instanceof ViewGroup) { setTypeface(view); } else { setTypeface(view); } } } else { setTypeface(v); } } private void setTypeface(View view) { if (view instanceof TextView) { TextView textView = (TextView) view; Typeface typeface = textView.getTypeface(); if (typeface != null && typeface.isBold()) { textView.setTypeface(DEFAULT_BOLD); } else { textView.setTypeface(DEFAULT); } } } }
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"> <item name="android:fontFamily">@font/my_custom_font</item> </style>
<item name="android:fontFamily">@font/your_font</item>
<TextView android:layout_width="match_parent" android:layout_height="39dp" android:textColor="@color/abs__background_holo_light" android:textSize="12sp" android:gravity="bottom|center" android:typeface="sans" />
public class MyApplication extends Application { @Override public void onCreate() { TypefaceUtil.overrideFont(getApplicationContext(), "SANS_SERIF", "fonts/my_font.ttf"); } }
public class MyApplication extends Application { @Override public void onCreate() { FontsReplacer.replaceFonts(this); super.onCreate(); } }
<com.scopely.fontain.views.FontTextView android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@android:color/black" android:textColor="@android:color/white" android:textSize="11dp" android:gravity="center" android:id="@+id/tv1" app:font_family="myCustomFont" app:caps_mode="characters" app:font_weight="BOLD"/>
package com.theeasylearn.demo.designdemo; import android.content.Context; import android.graphics.Typeface; import android.util.AttributeSet; import android.widget.TextView; public class MyButton extends TextView { public MyButton(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); init(); } public MyButton(Context context, AttributeSet attrs) { super(context, attrs); init(); } public MyButton(Context context) { super(context); init(); } private void init() { Typeface tf = Typeface.createFromAsset( getContext().getAssets(), "angelina.TTF"); setTypeface(tf); } }
<style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"> <item name="fontFamily">@font/your_font</item> <!-- target android sdk versions < 26 and > 14 --> </style>
public class FontSampler extends Activity { @Override public void onCreate(Bundle icicle) { super.onCreate(icicle); setContentView(R.layout.main); TextView tv=(TextView)findViewById(R.id.custom); Typeface face=Typeface.createFromAsset(getAssets(), "fonts/HandmadeTypewriter.ttf"); tv.setTypeface(face); } }
public class MyRunnable implements Runnable { public MyRunnable(Object parameter) { } public void run() { } }
Runnable r = new MyRunnable(param_value); new Thread(r).start();
final X parameter = ...; Thread t = new Thread(new Runnable() { p = parameter; public void run() { ... }; t.start();
public class MyRunnable implements Runnable { private X parameter; public MyRunnable(X parameter) { this.parameter = parameter; } public void run() { } } Thread t = new Thread(new MyRunnable(parameter)); t.start();
class MyThread extends Thread { private String to; public MyThread(String to) { this.to = to; } @Override public void run() { System.out.println("hello " + to); } } public static void main(String[] args) { new MyThread("world!").start(); }
public class MyRunnable implements Runnable { private volatile String myParam; public MyRunnable(String myParam){ this.myParam = myParam; ... } public void run(){ ... } } MyRunnable myRunnable = new myRunnable("Hello World"); new Thread(myRunnable).start();
public void setMyParam(String value){ this.myParam = value; }
String someValue = "Just a demo, really..."; new Thread(new Runnable() { private String myParam; public Runnable init(String myParam) { this.myParam = myParam; return this; } @Override public void run() { System.out.println("This is called from another thread."); System.out.println(this.myParam); } }.init(someValue)).start();
String someValue = "Another demo, no serious thing..."; int anotherValue = 42; new Thread(new Runnable() { private String myParam; private int myOtherParam; { this.myParam = someValue; this.myOtherParam = anotherValue; } @Override public void run() { System.out.println("This comes from another thread."); System.out.println(this.myParam + ", " + this.myOtherParam); } }).start();
class MyThread implements Runnable{ private int a; private String b; private double c; public MyThread(int a, String b, double c){ this.a = a; this.b = b; this.c = c; } public void run(){ doSomething(a, b, c); } }
class PrimeThread extends Thread { long minPrime; PrimeThread(long minPrime) { this.minPrime = minPrime; } public void run() { . . . } } PrimeThread p = new PrimeThread(143); p.start(); class PrimeRun implements Runnable { long minPrime; PrimeRun(long minPrime) { this.minPrime = minPrime; } public void run() { . . . } } PrimeRun p = new PrimeRun(143); new Thread(p).start();
final String param1 = "First param"; final int param2 = 2; new Thread(() -> { System.out.println(param1); System.out.println(param2); }).start();
public static void main(String... args) throws Exception { ThreadType2 t = new ThreadType2(new RunnableType2(){ public void run(Object object) { System.out.println("Parameter="+object); }}); t.start("the parameter"); } public class ThreadType2 { final private Thread thread; private Object objectIn = null; ThreadType2(final RunnableType2 runnableType2) { thread = new Thread(new Runnable() { public void run() { runnableType2.run(objectIn); }}); } public void start(final Object object) { this.objectIn = object; thread.start(); } public Thread getThread() { return thread; } } public interface RunnableType2 { public void run(Object object); }
public void Function(final type variable) { Runnable runnable = new Runnable() { public void run() { } }; new Thread(runnable).start(); }
private static final ExecutorService executor = Executors.newCachedThreadPool(); executor.submit(() -> { myFunction(myParam1, myParam2); });
public class MyRunnable implements Runnable { private final Boolean PARAMETER_LOCK = false; private X parameter; public MyRunnable(X parameter) { this.parameter = parameter; } public void setParameter( final X newParameter ){ boolean done = false; synchronize( PARAMETER_LOCK ) { if( null == parameter ) { parameter = newParameter; done = true; } } if( ! done ) { throw new RuntimeException("MyRunnable - Parameter not cleared." ); } } public void clearParameter(){ synchronize( PARAMETER_LOCK ) { parameter = null; } } public void run() { X localParameter; synchronize( PARAMETER_LOCK ) { localParameter = parameter; } if( null != localParameter ) { clearParameter(); doSomeStuff( localParameter ); } }
public interface Runnable<TResult> { void run(TResult result); }
myManager.doCallbackOperation(new Runnable<MyResult>() { @Override public void run(MyResult result) { } });
public void doCallbackOperation(Runnable<MyResult> runnable) { new AsyncTask<Void, Void, MyResult>() { @Override protected MyResult doInBackground(Void... params) { return new MyResult(); } @Override protected void onPostExecute(MyResult result) { runnable.run(result); } }.execute(); }
public class WorkingTask implements Runnable { private final Object toWorkWith; public WorkingTask(Object workOnMe) { toWorkWith = workOnMe; } public void run() { } } Thread t = new Thread(new WorkingTask(theData)); t.start();
public class Extractor extends Thread { public String webpage = ""; public Extractor(String w){ webpage = w; } public void setWebpage(String l){ webpage = l; } @Override public void run() { System.out.println(webpage); } public String toString(){ return "Page: "+webpage; }}
Extractor e = new Extractor("www.google.com"); e.start();
String [] file = {"H1.txt","H2.txt","H3.txt","M4.txt","M5.txt","M6.txt"}; ArrayList<String> fileList = new ArrayList<String>(Arrays.asList(file)); String [] img = {"e1.jpg","e2.jpg","e3.jpg","e4.jpg","e5.jpg","e6.jpg"}; ArrayList<String> imgList = new ArrayList<String>(Arrays.asList(img)); Collections.shuffle(fileList);
fileList = {"M4.txt","M6.txt","H3.txt","M5.txt","H2.txt","H1.txt"};
imgList = {"e4.jpg","e6.jpg","e3.jpg","e5.jpg","e2.jpg","e1.jpg"};
long seed = System.nanoTime(); Collections.shuffle(fileList, new Random(seed)); Collections.shuffle(imgList, new Random(seed));
public class Data { private String txtFileName; private String imgFileName; }
List<Data> list = new ArrayList<Data>(); list.add(new Data("H1.txt", "e1.jpg")); list.add(new Data("H2.txt", "e2.jpg")); Collections.shuffle(list);
Map<String, String> fileToImg: List<String> fileList = new ArrayList(fileToImg.keySet()); Collections.shuffle(fileList); for(String item: fileList) { fileToImf.get(item); }
private List<Integer> getJumbledList() { List<Integer> myArrayList2 = new ArrayList<Integer>(); myArrayList2.add(8); myArrayList2.add(4); myArrayList2.add(9); Collections.shuffle(myArrayList2); return myArrayList2;
ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutput out = null; try { out = new ObjectOutputStream(bos); out.writeObject(yourObject); out.flush(); byte[] yourBytes = bos.toByteArray(); ... } finally { try { bos.close(); } catch (IOException ex) { } }
ByteArrayInputStream bis = new ByteArrayInputStream(yourBytes); ObjectInput in = null; try { in = new ObjectInputStream(bis); Object o = in.readObject(); ... } finally { try { if (in != null) { in.close(); } } catch (IOException ex) { } }
byte[] data = SerializationUtils.serialize(yourObject);
YourObject yourObject = SerializationUtils.deserialize(data)
<!-- https: <dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-lang3</artifactId> <version>3.5</version> </dependency>
private byte[] convertToBytes(Object object) throws IOException { try (ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutput out = new ObjectOutputStream(bos)) { out.writeObject(object); return bos.toByteArray(); } }
private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException { try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInput in = new ObjectInputStream(bis)) { return in.readObject(); } }
byte[] data = SerializationUtils.serialize(object);
Object object = (Object) SerializationUtils.deserialize(byte[] data)
public static byte[] serialize(Object object) { if (object == null) { return null; } ByteArrayOutputStream baos = new ByteArrayOutputStream(1024); try { ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(object); oos.flush(); } catch (IOException ex) { throw new IllegalArgumentException("Failed to serialize object of type: " + object.getClass(), ex); } return baos.toByteArray(); }
ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream()); oos.writeObject(appMessage);
ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); AppMessage appMessage = (AppMessage)ois.readObject();
OkHttpClient client = new OkHttpClient(); client.interceptors().add(new Interceptor(){ @Override public com.squareup.okhttp.Response intercept(Chain chain) throws IOException { Request request = chain.request(); Log.e(String.format("\nrequest:\n%s\nheaders:\n%s", request.body().toString(), request.headers())); com.squareup.okhttp.Response response = chain.proceed(request); return response; } }); Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(GsonConverterFactory.create()) .client(client).build();
request: com.squareup.okhttp.RequestBody$1@3ff4074d headers: Content-Type: application/vnd.ll.event.list+json
HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(); interceptor.setLevel(HttpLoggingInterceptor.Level.BODY); OkHttpClient client = new OkHttpClient.Builder().addInterceptor(interceptor).build(); Retrofit retrofit = new Retrofit.Builder() .baseUrl("https: .client(client) .addConverterFactory(GsonConverterFactory.create()) .build(); return retrofit.create(ApiClient.class);
HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(Level.BODY); OkHttpClient httpClient = new OkHttpClient(); httpClient.interceptors().add(logging); Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(httpClient) .build();
public class TimberLoggingInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); long t1 = System.nanoTime(); Timber.i("Sending request %s on %s%n%s", request.url(), chain.connection(), request.headers()); Timber.v("REQUEST BODY BEGIN\n%s\nREQUEST BODY END", bodyToString(request)); Response response = chain.proceed(request); ResponseBody responseBody = response.body(); String responseBodyString = response.body().string(); Response newResponse = response.newBuilder().body(ResponseBody.create(responseBody.contentType(), responseBodyString.getBytes())).build(); long t2 = System.nanoTime(); Timber.i("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers()); Timber.v("RESPONSE BODY BEGIN:\n%s\nRESPONSE BODY END", responseBodyString); return newResponse; } private static String bodyToString(final Request request){ try { final Request copy = request.newBuilder().build(); final Buffer buffer = new Buffer(); copy.body().writeTo(buffer); return buffer.readUtf8(); } catch (final IOException e) { return "did not work"; } } }
Request request = chain.request(); Buffer buffer = new Buffer(); request.body().writeTo(buffer); String body = buffer.readUtf8();
OkHttpClient client = new OkHttpClient(); client.interceptors().add(new LoggingInterceptor()); Retrofit retrofit = new Retrofit.Builder() .baseUrl("http: .addConverterFactory(GsonConverterFactory.create()) .client(client) .build();
public static class LoggingInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); long t1 = System.nanoTime(); String requestLog = String.format("Sending request %s on %s%n%s", request.url(), chain.connection(), request.headers()); if(request.method().compareToIgnoreCase("post")==0){ requestLog ="\n"+requestLog+"\n"+bodyToString(request); } Log.d("TAG","request"+"\n"+requestLog); Response response = chain.proceed(request); long t2 = System.nanoTime(); String responseLog = String.format("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers()); String bodyString = response.body().string(); Log.d("TAG","response"+"\n"+responseLog+"\n"+bodyString); return response.newBuilder() .body(ResponseBody.create(response.body().contentType(), bodyString)) .build(); } } public static String bodyToString(final Request request) { try { final Request copy = request.newBuilder().build(); final Buffer buffer = new Buffer(); copy.body().writeTo(buffer); return buffer.readUtf8(); } catch (final IOException e) { return "did not work"; } }`
OkHttpClient httpClient = new OkHttpClient.Builder() .addNetworkInterceptor(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request().newBuilder().addHeader("test", "test").build(); return chain.proceed(request); } }) .addNetworkInterceptor(new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY)) .build(); Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create(gsonBuilder.create())) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .client(httpClient) .baseUrl(AppConstants.SERVER_ADDRESS) .build();
HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor(); if (BuildConfig.DEBUG) loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.HEADERS); new OkHttpClient.Builder() .connectTimeout(60, TimeUnit.SECONDS) .readTimeout(60, TimeUnit.SECONDS) .writeTimeout(60, TimeUnit.SECONDS) .addInterceptor(new CatalogInterceptor(context)) .addInterceptor(new OAuthInterceptor(context)) .authenticator(new BearerTokenAuthenticator(context)) .addInterceptor(loggingInterceptor) .build();
final OkHttpClient.Builder builder = new OkHttpClient.Builder(); if (BuildConfig.DEBUG) { builder.networkInterceptors().add(new StethoInterceptor()); }
OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.addInterceptor(new MyCustomInterceptor()); builder.connectTimeout(60, TimeUnit.SECONDS); builder.readTimeout(60, TimeUnit.SECONDS); builder.writeTimeout(60, TimeUnit.SECONDS); builder.addNetworkInterceptor(LoggerInterceptor());
**HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(HttpLoggingInterceptor.Level.BODY); OkHttpClient.Builder httpClient=new OkHttpClient.Builder(); httpClient.addInterceptor(logging);** if (retrofit == null) { retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) **.client(httpClient.build())** .build(); }
OkHttpClient okHttpClient = new OkHttpClient.Builder() .addInterceptor(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); if (BuildConfig.DEBUG) { Log.e(getClass().getName(), request.method() + " " + request.url()); Log.e(getClass().getName(), "" + request.header("Cookie")); RequestBody rb = request.body(); Buffer buffer = new Buffer(); if (rb != null) rb.writeTo(buffer); LogUtils.LOGE(getClass().getName(), "Payload- " + buffer.readUtf8()); } return chain.proceed(request); } }) .readTimeout(60, TimeUnit.SECONDS) .connectTimeout(60, TimeUnit.SECONDS) .build(); iServices = new Retrofit.Builder() .baseUrl("Your Base URL") .client(okHttpClient) .addConverterFactory(GsonConverterFactory.create()) .build() .create(Your Service Interface .class);
val interceptor = HttpLoggingInterceptor() interceptor.level = HttpLoggingInterceptor.Level.BODY val client = OkHttpClient.Builder().addInterceptor(interceptor).build() val retrofit = Retrofit.Builder() .baseUrl(BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .build() return retrofit.create(PointApi::class.java)
private static final Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(new OkHttpClient().newBuilder() .addInterceptor(new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY)) .readTimeout(READ_TIMEOUT_SECONDS, TimeUnit.SECONDS) .writeTimeout(WRITE_TIMEOUT_SECONDS, TimeUnit.SECONDS) .connectTimeout(CONNECTION_TIMEOUT_SECONDS, TimeUnit.SECONDS) .build()) .addConverterFactory(GsonConverterFactory.create()) .build();
public static <T> T createApi(Context context, Class<T> clazz, String host, boolean debug) { if (singleton == null) { synchronized (RetrofitUtils.class) { if (singleton == null) { RestAdapter.Builder builder = new RestAdapter.Builder(); builder .setEndpoint(host) .setClient(new OkClient(OkHttpUtils.getInstance(context))) .setRequestInterceptor(RequestIntercepts.newInstance()) .setConverter(new GsonConverter(GsonUtils.newInstance())) .setErrorHandler(new ErrorHandlers()) .setLogLevel(debug ? RestAdapter.LogLevel.FULL : RestAdapter.LogLevel.NONE)/*LogLevel.BASIC will cause response.getBody().in() close*/ .setLog(new RestAdapter.Log() { @Override public void log(String message) { if (message.startsWith("{") || message.startsWith("[")) Logger.json(message); else { Logger.i(message); } } }); singleton = builder.build(); } } } return singleton.create(clazz); }
final MyClass myClassSpy = Mockito.spy(myInstance); Mockito.when(myClassSpy.method1()).thenReturn(myResults);
List list = new LinkedList(); List spy = spy(list); when(spy.get(0)).thenReturn("foo"); doReturn("foo").when(spy).get(0);
package common; public class Animal { void packageProtected(); } package instances; class Dog extends Animal { }
package common; public abstract class AnimalTest<T extends Animal> { @Before setup(){ doNothing().when(getInstance()).packageProtected(); } abstract T getInstance(); } package instances; class DogTest extends AnimalTest<Dog> { Dog getInstance(){ return spy(new Dog()); } @Test public void myTest(){} }
doReturn( "dummy" ).when( im ).getContentStringValue( anyInt(), isA( ScoreDoc.class ));
doReturn( "dummy" ).when( im ).getContentStringValue( anyInt(), any( ScoreDoc.class ));
public static <T> T isA(java.lang.Class<T> clazz) public static <T> T any(java.lang.Class<T> clazz)
WebFormCreatorActivity activity = spy(new WebFormCreatorActivity(clientFactory) { @Override public void select(TreeItem i) { log.debug("SELECT"); }; });
@Autowired private MonitoringDocumentsRepository repository void test(){ repository = Mockito.spy(repository) Mockito.doReturn(docs1, docs2) .when(repository).findMonitoringDocuments(Mockito.nullable(MonitoringDocumentSearchRequest.class)); }
repository = MonitoringDocumentsRepository$$EnhancerBySpringCGLIB$$MockitoMock$
repository = MonitoringDocumentsRepository$$MockitoMock$$EnhancerBySpringCGLIB$
@SpyBean private MonitoringDocumentsRepository repository void test(){ Mockito.doReturn(docs1, docs2) .when(repository).findMonitoringDocuments(Mockito.nullable(MonitoringDocumentSearchRequest.class)); }
public static boolean logicalXOR(boolean x, boolean y) { return ( ( x || y ) && ! ( x && y ) ); }
public static void main(String[] args) { boolean[] all = { false, true }; for (boolean a : all) { for (boolean b: all) { boolean c = a ^ b; System.out.println(a + " ^ " + b + " = " + c); } } }
if (set == null || set.isEmpty()) if (list != null && list.size() > 0)
public static boolean logicalXOR(boolean x, boolean y) { return ( ( x || y ) && ! ( x && y ) ); }
public static boolean logicalXOR(boolean x, boolean y) { return x != y; }
public static boolean XOR(boolean... args) { boolean r = false; for (boolean b : args) { r = r ^ b; } return r; }
public static boolean logicalXOR(boolean x, boolean y) { return ( ( x || y ) && ! ( x && y ) ); }
boolean result =BooleanUtils.xor(new boolean[]{true,false});
public class XOR_Test { public static void main (String args[]) { boolean a,b; a=false; b=false; System.out.println("a=false; b=false; -> " + (a^b)); a=false; b=true; System.out.println("a=false; b=true; -> " + (a^b)); a=true; b=false; System.out.println("a=true; b=false; -> " + (a^b)); a=true; b=true; System.out.println("a=true; b=true; -> " + (a^b)); } }
public boolean posNeg(int a, int b, boolean negative) { if(!negative){ return (a>0 && b<0)^(b>0 && a<0); } else return (a<0 && b<0); }
if(string.equals(null) || string.equals("")){ Log.d("iftrue", "seem to be true"); }else{ Log.d("iffalse", "seem to be false"); }
System.out.println(StringUtils.isEmpty("")); System.out.println(StringUtils.isEmpty(null));
System.out.println(Strings.isNullOrEmpty("")); System.out.println(Strings.isNullOrEmpty(null));
boolean isEmpty = str == null || str.trim().length() == 0; if (isEmpty) { }
<%@ page import="java.util.*" import="java.io.*"%> <% request.setAttribute("PAGE", "first.jsp");%> <jsp:forward page="/second.jsp"/>
<%@ page import="java.util.*" import="java.io.*"%> From Which Page : <%=request.getAttribute("PAGE")%><br> Data From Client : <%=request.getParameter("CLIENT")%>
From Which Page : *first.jsp* Data From Client : you
<html> <body> <form name="testForm" method="post" action="testJSP.jsp"> <input type="text" name="testParam" value="ClientParam"> <input type="submit"> </form> </body> </html> <html> <body> <% String sValue = request.getParameter("testParam"); %> <%= sValue %> </body> </html>
<jsp:forward page="destination.jsp"> <jsp:param name="userName" value="hamid"/> </jsp:forward>
java.lang.Object getAttribute(java.lang.String name) java.lang.String getParameter(java.lang.String name)
public static boolean isValidEmailAddress(String email) { boolean result = true; try { InternetAddress emailAddr = new InternetAddress(email); emailAddr.validate(); } catch (AddressException ex) { result = false; } return result; }
<dependency> <groupId>commons-validator</groupId> <artifactId>commons-validator</artifactId> <version>1.4.1</version> </dependency>
import org.apache.commons.validator.routines.EmailValidator;
String email = "myName@example.com"; boolean valid = EmailValidator.getInstance().isValid(email);
boolean allowLocal = true; boolean valid = EmailValidator.getInstance(allowLocal).isValid(email);
public boolean isValidEmailAddress(String email) { String ePattern = "^[a-zA-Z0-9.! java.util.regex.Pattern p = java.util.regex.Pattern.compile(ePattern); java.util.regex.Matcher m = p.matcher(email); return m.matches(); }
Pattern pattern = Pattern.compile("^.+@.+\\..+$"); Matcher matcher = pattern.matcher(email);
"<bob \" (here) " < (hi there) "bob(the man)smith" (hi) @ (there) example.com (hello) > (again)
@FacesValidator("emailValidator") public class EmailAddressValidator implements Validator { private String localPart; private String hostName; private boolean domain = true; Locale locale; ResourceBundle bundle; private List<FacesMessage> messages = new ArrayList<FacesMessage>(); private HostnameValidator hostnameValidator; @Override public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException { setOptions(component); String email = (String) value; boolean result = true; Pattern pattern = Pattern.compile("^(.+)@([^@]+[^.])$"); Matcher matcher = pattern.matcher(email); locale = context.getViewRoot().getLocale(); bundle = ResourceBundle.getBundle("com.myapp.resources.validationMessages", locale); boolean length = true; boolean local = true; if (matcher.find()) { localPart = matcher.group(1); hostName = matcher.group(2); if (localPart.length() > 64 || hostName.length() > 255) { length = false; addMessage("enterValidEmail", "email.AddressLengthExceeded"); } if (domain == true) { hostnameValidator = new HostnameValidator(); hostnameValidator.validate(context, component, hostName); } local = validateLocalPart(); if (local && length) { result = true; } else { result = false; } } else { result = false; addMessage("enterValidEmail", "invalidEmailAddress"); } if (result == false) { throw new ValidatorException(messages); } } private boolean validateLocalPart() { boolean result = false; String atext = "a-zA-Z0-9\\u0021\\u0023\\u0024\\u0025\\u0026\\u0027\\u002a" + "\\u002b\\u002d\\u002f\\u003d\\u003f\\u005e\\u005f\\u0060\\u007b" + "\\u007c\\u007d\\u007e"; Pattern regex = Pattern.compile("^["+atext+"]+(\\u002e+["+atext+"]+)*$"); Matcher matcher = regex.matcher(localPart); if (matcher.find()) { result = true; } else { String noWsCtl = "\\u0001-\\u0008\\u000b\\u000c\\u000e-\\u001f\\u007f"; String qText = noWsCtl + "\\u0021\\u0023-\\u005b\\u005d-\\u007e"; String ws = "\\u0020\\u0009"; regex = Pattern.compile("^\\u0022(["+ws+qText+"])*["+ws+"]?\\u0022$"); matcher = regex.matcher(localPart); if (matcher.find()) { result = true; } else { addMessage("enterValidEmail", "email.AddressDotAtom"); addMessage("enterValidEmail", "email.AddressQuotedString"); addMessage("enterValidEmail", "email.AddressInvalidLocalPart"); } } return result; } private void addMessage(String detail, String summary) { String detailMsg = bundle.getString(detail); String summaryMsg = bundle.getString(summary); messages.add(new FacesMessage(FacesMessage.SEVERITY_ERROR, summaryMsg, detailMsg)); } private void setOptions(UIComponent component) { Boolean domainOption = Boolean.valueOf((String) component.getAttributes().get("domain")); } }
@FacesValidator("hostNameValidator") public class HostnameValidator implements Validator { private Locale locale; private ResourceBundle bundle; private List<FacesMessage> messages; private boolean checkTld = true; private boolean allowLocal = false; private boolean allowDNS = true; private String tld; private String[] validTlds = {"ac", "ad", "ae", "aero", "af", "ag", "ai", "al", "am", "an", "ao", "aq", "ar", "arpa", "as", "asia", "at", "au", "aw", "ax", "az", "ba", "bb", "bd", "be", "bf", "bg", "bh", "bi", "biz", "bj", "bm", "bn", "bo", "br", "bs", "bt", "bv", "bw", "by", "bz", "ca", "cat", "cc", "cd", "cf", "cg", "ch", "ci", "ck", "cl", "cm", "cn", "co", "com", "coop", "cr", "cu", "cv", "cx", "cy", "cz", "de", "dj", "dk", "dm", "do", "dz", "ec", "edu", "ee", "eg", "er", "es", "et", "eu", "fi", "fj", "fk", "fm", "fo", "fr", "ga", "gb", "gd", "ge", "gf", "gg", "gh", "gi", "gl", "gm", "gn", "gov", "gp", "gq", "gr", "gs", "gt", "gu", "gw", "gy", "hk", "hm", "hn", "hr", "ht", "hu", "id", "ie", "il", "im", "in", "info", "int", "io", "iq", "ir", "is", "it", "je", "jm", "jo", "jobs", "jp", "ke", "kg", "kh", "ki", "km", "kn", "kp", "kr", "kw", "ky", "kz", "la", "lb", "lc", "li", "lk", "lr", "ls", "lt", "lu", "lv", "ly", "ma", "mc", "md", "me", "mg", "mh", "mil", "mk", "ml", "mm", "mn", "mo", "mobi", "mp", "mq", "mr", "ms", "mt", "mu", "museum", "mv", "mw", "mx", "my", "mz", "na", "name", "nc", "ne", "net", "nf", "ng", "ni", "nl", "no", "np", "nr", "nu", "nz", "om", "org", "pa", "pe", "pf", "pg", "ph", "pk", "pl", "pm", "pn", "pr", "pro", "ps", "pt", "pw", "py", "qa", "re", "ro", "rs", "ru", "rw", "sa", "sb", "sc", "sd", "se", "sg", "sh", "si", "sj", "sk", "sl", "sm", "sn", "so", "sr", "st", "su", "sv", "sy", "sz", "tc", "td", "tel", "tf", "tg", "th", "tj", "tk", "tl", "tm", "tn", "to", "tp", "tr", "travel", "tt", "tv", "tw", "tz", "ua", "ug", "uk", "um", "us", "uy", "uz", "va", "vc", "ve", "vg", "vi", "vn", "vu", "wf", "ws", "ye", "yt", "yu", "za", "zm", "zw"}; private Map<String, Map<Integer, Integer>> idnLength; private void init() { Map<Integer, Integer> biz = new HashMap<Integer, Integer>(); biz.put(5, 17); biz.put(11, 15); biz.put(12, 20); Map<Integer, Integer> cn = new HashMap<Integer, Integer>(); cn.put(1, 20); Map<Integer, Integer> com = new HashMap<Integer, Integer>(); com.put(3, 17); com.put(5, 20); Map<Integer, Integer> hk = new HashMap<Integer, Integer>(); hk.put(1, 15); Map<Integer, Integer> info = new HashMap<Integer, Integer>(); info.put(4, 17); Map<Integer, Integer> kr = new HashMap<Integer, Integer>(); kr.put(1, 17); Map<Integer, Integer> net = new HashMap<Integer, Integer>(); net.put(3, 17); net.put(5, 20); Map<Integer, Integer> org = new HashMap<Integer, Integer>(); org.put(6, 17); Map<Integer, Integer> tw = new HashMap<Integer, Integer>(); tw.put(1, 20); Map<Integer, Integer> idn1 = new HashMap<Integer, Integer>(); idn1.put(1, 20); Map<Integer, Integer> idn2 = new HashMap<Integer, Integer>(); idn2.put(1, 20); Map<Integer, Integer> idn3 = new HashMap<Integer, Integer>(); idn3.put(1, 20); Map<Integer, Integer> idn4 = new HashMap<Integer, Integer>(); idn4.put(1, 20); idnLength = new HashMap<String, Map<Integer, Integer>>(); idnLength.put("BIZ", biz); idnLength.put("CN", cn); idnLength.put("COM", com); idnLength.put("HK", hk); idnLength.put("INFO", info); idnLength.put("KR", kr); idnLength.put("NET", net); idnLength.put("ORG", org); idnLength.put("TW", tw); idnLength.put("", idn1); idnLength.put("", idn2); idnLength.put("", idn3); idnLength.put("", idn4); messages = new ArrayList<FacesMessage>(); } public HostnameValidator() { init(); } @Override public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException { String hostName = (String) value; locale = context.getViewRoot().getLocale(); bundle = ResourceBundle.getBundle("com.myapp.resources.validationMessages", locale); Pattern ipPattern = Pattern.compile("^[0-9a-f:\\.]*$", Pattern.CASE_INSENSITIVE); Matcher ipMatcher = ipPattern.matcher(hostName); if (ipMatcher.find()) { addMessage("hostname.IpAddressNotAllowed"); throw new ValidatorException(messages); } boolean result = false; hostName = hostName.replaceAll("(\\.)+$", ""); String[] domainParts = hostName.split("\\."); boolean status = false; if ((domainParts.length > 1) && (hostName.length() > 4) && (hostName.length() < 255)) { status = false; dowhile: do { int lastIndex = domainParts.length - 1; String domainEnding = domainParts[lastIndex]; Pattern tldRegex = Pattern.compile("([^.]{2,10})", Pattern.CASE_INSENSITIVE); Matcher tldMatcher = tldRegex.matcher(domainEnding); if (tldMatcher.find() || domainEnding.equals("") || domainEnding.equals("") || domainEnding.equals("") || domainEnding.equals("")) { tld = (String) tldMatcher.group(1).toLowerCase().trim(); if (checkTld == true) { boolean foundTld = false; for (int i = 0; i < validTlds.length; i++) { if (tld.equals(validTlds[i])) { foundTld = true; } } if (foundTld == false) { status = false; addMessage("hostname.UnknownTld"); break dowhile; } } /** * Match against IDN hostnames * Note: Keep label regex short to avoid issues with long patterns when matching IDN hostnames */ List<String> regexChars = getIdnRegexChars(); int check = 0; for (String domainPart : domainParts) { if (domainPart.indexOf("xn--") == 0) { domainPart = decodePunycode(domainPart.substring(4)); } if (domainPart.indexOf("-") == 0 || (domainPart.length() > 2 && domainPart.indexOf("-", 2) == 2 && domainPart.indexOf("-", 3) == 3) || (domainPart.indexOf("-") == (domainPart.length() - 1))) { status = false; addMessage("hostname.DashCharacter"); break dowhile; } boolean checked = false; for (int key = 0; key < regexChars.size(); key++) { String regexChar = regexChars.get(key); Pattern regex = Pattern.compile(regexChar); Matcher regexMatcher = regex.matcher(domainPart); status = regexMatcher.find(); if (status) { int length = 63; if (idnLength.containsKey(tld.toUpperCase()) && idnLength.get(tld.toUpperCase()).containsKey(key)) { length = idnLength.get(tld.toUpperCase()).get(key); } int utf8Length; try { utf8Length = domainPart.getBytes("UTF8").length; if (utf8Length > length) { addMessage("hostname.InvalidHostname"); } else { checked = true; break; } } catch (UnsupportedEncodingException ex) { Logger.getLogger(HostnameValidator.class.getName()).log(Level.SEVERE, null, ex); } } } if (checked) { ++check; } } if (check != domainParts.length) { status = false; addMessage("hostname.InvalidHostnameSchema"); } } else { status = false; addMessage("hostname.UndecipherableTld"); } } while (false); if (status == true && allowDNS) { result = true; } } else if (allowDNS == true) { addMessage("hostname.InvalidHostname"); throw new ValidatorException(messages); } Pattern regexLocal = Pattern.compile("^(([a-zA-Z0-9\\x2d]{1,63}\\x2e)*[a-zA-Z0-9\\x2d]{1,63}){1,254}$", Pattern.CASE_INSENSITIVE); boolean checkLocal = regexLocal.matcher(hostName).find(); if (allowLocal && !status) { if (checkLocal) { result = true; } else { result = false; addMessage("hostname.InvalidLocalName"); } } if (checkLocal && !allowLocal && !status) { result = false; addMessage("hostname.LocalNameNotAllowed"); } if (result == false) { throw new ValidatorException(messages); } } private void addMessage(String msg) { String bundlMsg = bundle.getString(msg); messages.add(new FacesMessage(FacesMessage.SEVERITY_ERROR, bundlMsg, bundlMsg)); } /** * Returns a list of regex patterns for the matched TLD * @param tld * @return */ private List<String> getIdnRegexChars() { List<String> regexChars = new ArrayList<String>(); regexChars.add("^[a-z0-9\\x2d]{1,63}$"); Document doc = null; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); try { InputStream validIdns = getClass().getClassLoader().getResourceAsStream("com/myapp/resources/validIDNs_1.xml"); DocumentBuilder builder = factory.newDocumentBuilder(); doc = builder.parse(validIdns); doc.getDocumentElement().normalize(); } catch (SAXException ex) { Logger.getLogger(HostnameValidator.class.getName()).log(Level.SEVERE, null, ex); } catch (IOException ex) { Logger.getLogger(HostnameValidator.class.getName()).log(Level.SEVERE, null, ex); } catch (ParserConfigurationException ex) { Logger.getLogger(HostnameValidator.class.getName()).log(Level.SEVERE, null, ex); } XPath xpath = XPathFactory.newInstance().newXPath(); NodeList nodes = null; String xpathRoute = " try { XPathExpression expr; expr = xpath.compile(xpathRoute); Object res = expr.evaluate(doc, XPathConstants.NODESET); nodes = (NodeList) res; } catch (XPathExpressionException ex) { Logger.getLogger(HostnameValidator.class.getName()).log(Level.SEVERE, null, ex); } for (int i = 0; i < nodes.getLength(); i++) { regexChars.add(nodes.item(i).getNodeValue()); } return regexChars; } /** * Decode Punycode string * @param encoded * @return */ private String decodePunycode(String encoded) { Pattern regex = Pattern.compile("([^a-z0-9\\x2d]{1,10})", Pattern.CASE_INSENSITIVE); Matcher matcher = regex.matcher(encoded); boolean found = matcher.find(); if (encoded.isEmpty() || found) { addMessage("hostname.CannotDecodePunycode"); throw new ValidatorException(messages); } int separator = encoded.lastIndexOf("-"); List<Integer> decoded = new ArrayList<Integer>(); if (separator > 0) { for (int x = 0; x < separator; ++x) { decoded.add((int) encoded.charAt(x)); } } else { addMessage("hostname.CannotDecodePunycode"); throw new ValidatorException(messages); } int lengthd = decoded.size(); int lengthe = encoded.length(); boolean init = true; int base = 72; int index = 0; int ch = 0x80; int indexeStart = (separator == 1) ? (separator + 1) : 0; for (int indexe = indexeStart; indexe < lengthe; ++lengthd) { int oldIndex = index; int pos = 1; for (int key = 36; true; key += 36) { int hex = (int) encoded.charAt(indexe++); int digit = (hex - 48 < 10) ? hex - 22 : ((hex - 65 < 26) ? hex - 65 : ((hex - 97 < 26) ? hex - 97 : 36)); index += digit * pos; int tag = (key <= base) ? 1 : ((key >= base + 26) ? 26 : (key - base)); if (digit < tag) { break; } pos = (int) (pos * (36 - tag)); } int delta = (int) (init ? ((index - oldIndex) / 700) : ((index - oldIndex) / 2)); delta += (int) (delta / (lengthd + 1)); int key; for (key = 0; delta > 910; key += 36) { delta = (int) (delta / 35); } base = (int) (key + 36 * delta / (delta + 38)); init = false; ch += (int) (index / (lengthd + 1)); index %= (lengthd + 1); if (lengthd > 0) { for (int i = lengthd; i > index; i--) { decoded.set(i, decoded.get(i - 1)); } } decoded.set(index++, ch); } StringBuilder sb = new StringBuilder(); for (int i = 0; i < decoded.size(); i++) { int value = decoded.get(i); if (value < 128) { sb.append((char) value); } else if (value < (1 << 11)) { sb.append((char) (192 + (value >> 6))); sb.append((char) (128 + (value & 63))); } else if (value < (1 << 16)) { sb.append((char) (224 + (value >> 12))); sb.append((char) (128 + ((value >> 6) & 63))); sb.append((char) (128 + (value & 63))); } else if (value < (1 << 21)) { sb.append((char) (240 + (value >> 18))); sb.append((char) (128 + ((value >> 12) & 63))); sb.append((char) (128 + ((value >> 6) & 63))); sb.append((char) (128 + (value & 63))); } else { addMessage("hostname.CannotDecodePunycode"); throw new ValidatorException(messages); } } return sb.toString(); } /** * Eliminates empty values from input array * @param data * @return */ private String[] verifyArray(String[] data) { List<String> result = new ArrayList<String>(); for (String s : data) { if (!s.equals("")) { result.add(s); } } return result.toArray(new String[result.size()]); } }
<idnlist> <idn> <tld>AC</tld> <pattern>^[\u002d0-9a-z--]{1,63}$</pattern> </idn> <idn> <tld>AR</tld> <pattern>^[\u002d0-9a-z---]{1,63}$</pattern> </idn> <idn> <tld>AS</tld> <pattern>/^[\u002d0-9a-z--]{1,63}$</pattern> </idn> <idn> <tld>AT</tld> <pattern>/^[\u002d0-9a-z--]{1,63}$</pattern> </idn> <idn> <tld>BIZ</tld> <pattern>^[\u002d0-9a-z]{1,63}$</pattern> <pattern>^[\u002d0-9a-z]{1,63}$</pattern> <pattern>^[\u002d0-9a-z]{1,63}$</pattern> </id> </idlist>
public class Validations { private Pattern regexPattern; private Matcher regMatcher; public String validateEmailAddress(String emailAddress) { regexPattern = Pattern.compile("^[(a-zA-Z-0-9-\\_\\+\\.)]+@[(a-z-A-z)]+\\.[(a-zA-z)]{2,3}$"); regMatcher = regexPattern.matcher(emailAddress); if(regMatcher.matches()) { return "Valid Email Address"; } else { return "Invalid Email Address"; } } public String validateMobileNumber(String mobileNumber) { regexPattern = Pattern.compile("^\\+[0-9]{2,3}+-[0-9]{10}$"); regMatcher = regexPattern.matcher(mobileNumber); if(regMatcher.matches()) { return "Valid Mobile Number"; } else { return "Invalid Mobile Number"; } } public static void main(String[] args) { String emailAddress = "suryaprakash.pisay@gmail.com"; String mobileNumber = "+91-9986571622"; Validations validations = new Validations(); System.out.println(validations.validateEmailAddress(emailAddress)); System.out.println(validations.validateMobileNumber(mobileNumber)); } }
public static boolean isValidEmailAddress(String email) { boolean stricterFilter = true; String stricterFilterString = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}"; String laxString = ".+@.+\\.[A-Za-z]{2}[A-Za-z]*"; String emailRegex = stricterFilter ? stricterFilterString : laxString; java.util.regex.Pattern p = java.util.regex.Pattern.compile(emailRegex); java.util.regex.Matcher m = p.matcher(email); return m.matches(); }
public static boolean isValidEmail(String enteredEmail){ String EMAIL_REGIX = "^[\\\\w! Pattern pattern = Pattern.compile(EMAIL_REGIX); Matcher matcher = pattern.matcher(enteredEmail); return ((!enteredEmail.isEmpty()) && (enteredEmail!=null) && (matcher.matches())); }
import org.hibernate.validator.internal.constraintvalidators.hv.EmailValidator; class Validator { private boolean isValidEmail(String email) { EmailValidator emailValidator = new EmailValidator(); return emailValidator.isValid(email, null); } }
public class EmailAddressValidator { private static final String domainChars = "a-z0-9\\-"; private static final String atomChars = "a-z0-9\\Q! private static final String emailRegex = "^" + dot(atomChars) + "@" + dot(domainChars) + "$"; private static final Pattern emailPattern = Pattern.compile(emailRegex); private static String dot(String chars) { return "[" + chars + "]+(?:\\.[" + chars + "]+)*"; } public static boolean isValidEmailAddress(String address) { return address != null && emailPattern.matcher(address).matches(); } }
public static String join(String s, Object... a) { StringBuilder o = new StringBuilder(); for (Iterator<Object> i = Arrays.asList(a).iterator(); i.hasNext();) o.append(i.next()).append(i.hasNext() ? s : ""); return o.toString(); }
public static String join(String s, Object... a) { return a.length == 0 ? "" : a[0] + (a.length == 1 ? "" : s + join(s, Arrays.copyOfRange(a, 1, a.length))); }
String input = "1 fish 2 fish red fish blue fish"; Scanner s = new Scanner(input).useDelimiter("\\s*fish\\s*"); System.out.println(s.nextInt()); System.out.println(s.nextInt()); System.out.println(s.next()); System.out.println(s.next()); s.close();
String input = "1 fish 2 fish red fish blue fish"; Scanner s = new Scanner(input); s.findInLine("(\\d+) fish (\\d+) fish (\\w+) fish (\\w+)"); MatchResult result = s.match(); for (int i=1; i<=result.groupCount(); i++) System.out.println(result.group(i)); s.close(); `
BufferedReader in = new BufferedReader(new FileReader("foo.in"));
InputStreamReader isr=new InputStreamReader(System.in); BufferedReader br= new BufferedReader(isr); String st= br.readLine();
Scanner sc= new Scanner(System.in); String st= sc.nextLine();
public String toString() { return getClass().getName() + "@" + Integer.toHexString(hashCode()); }
public class Person { private String name; @Override public String toString() { return name; } }
@Override public String toString() { return getClass().getSimpleName() + "[name=" + name + "]"; }
Person[] people = { new Person("Fred"), new Person("Mike") }; System.out.println(Arrays.toString(people));
List<Person> people = new ArrayList<>(); people.add(new Person("Alice")); people.add(new Person("Bob")); System.out.println(people);
{ SomeClass sc = new SomeClass(); System.out.println(sc); }
class A { String s = "I am just a object"; @Override public String toString() { return s; } } class B { public static void main(String args[]) { A obj = new A(); System.out.println(obj); } }
public class Person { private String name; public String toString(){ return name; } }
void printPersonArray(Person[] persons){ for(Person person: persons){ System.out.println(person); } }
System.out.println(Arrays.toString(persons)); System.out.println(Arrays.deepToString(persons));
Arrays.stream(persons).forEach(System.out::println);
public class Person { private String name; public Person(String name){ this.name = name; } @override public String toString(){ return name; } }
Class Test { public static void main(String... args){ Person obj = new Person("YourName"); System.out.println(obj.toString()); } }
public class test { int a; char b; String c; Test2 test2; @Override public String toString() { return "test{" + "a=" + a + ", b=" + b + ", c= ", test2=" + test2 + } }
public String toString() { return getClass().getName() + "@" + Integer.toHexString(hashCode()); }
/** * This class provides basic/common functionalities to be applied on Java Objects. */ public final class ObjectUtils { private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create(); private ObjectUtils() { throw new UnsupportedOperationException("Instantiation of this class is not permitted in case you are using reflection."); } /** * This method is responsible for de-serializing the Java Object into Json String. * * @param object Object to be de-serialized. * @return String */ public static String deserializeObjectToString(final Object object) { return GSON.toJson(object); } }
[[AAAAA, BBBBB], [6, 12], [2003-04-01 00:00:00.0, 2003-10-01 00:00:00.0], [2003-09-30 00:00:00.0, 2004-03-31 00:00:00.0], [Interim, Interim], [2003-09-30, 2004-03-31]];
private int counter; public int getNextUniqueIndex() { return counter++; }
private AtomicInteger counter; public int getNextUniqueIndex() { return counter.getAndIncrement(); }
private volatile int counter; public int getNextUniqueIndex() { return counter++; }
Integer i = 5; void incIBy5() { int temp; synchronized(i) { temp = i } synchronized(i) { i = temp + 5 } }
private int counter; public int getNextUniqueIndex() { return counter++; }
private boolean stopped; public void run() { while(!stopped) { } } public void pleaseStop() { stopped = true; }
private AtomicInteger counter = new AtomicInteger(); public int getNextUniqueIndex() { return counter.getAndIncrement(); }
int current; do { current = get(); } while(!compareAndSet(current, current + 1));
private volatile int counter; public int getNextUniqueIndex() { return counter++; }
void incIBy5() { int temp; synchronized(i) { temp = i } synchronized(i) { i = temp + 5 } }
void synchronized incIBy5() { i += 5 } void incIBy5() { synchronized(this) { i += 5 } } void incIBy5() { synchronized(this) { int temp = i; i = temp + 5; } }
package functionsiiiandiiilambdas.functions.p01tailiiirecursive tailrec fun findFixPoint(x: Double = 1.0): Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x))
package functionsiiiandiiilambdas.functions.p01tailiiirecursive; public final class ExampleKt { public static final double findFixPoint(double x) { while (x != Math.cos(x)) { x = Math.cos(x); } return x; } public static double findFixPoint$default( double d, int n, Object object) { if ((n & 1) != 0) { d = 1.0; } return ExampleKt.findFixPoint(d); } }
public List<String> stringToOneElementList(String s) { List<String> list = new ArrayList<String>(); list.add(s); return list; }
List<String> list = new ArrayList<String>(Arrays.asList(s));
List<String> list = new ArrayList<String>(Collections.nCopies(1, s));
List<String> list = new ArrayList<String>(Collections.singletonList(s));
Lists.mutable.of("Just one item"); Lists.mutable.with("Or use with"); Lists.immutable.of("Maybe it must be immutable?"); Lists.immutable.with("And use with if you want");
private static volatile int counter = 0; private void concurrentMethodWrong() { counter = counter + 5; counter = counter - 5; }
private static final Object counterLock = new Object(); private static volatile int counter = 0; private void concurrentMethodRight() { synchronized (counterLock) { counter = counter + 5; } synchronized (counterLock) { counter = counter - 5; } }
LinearLayout buttonsView = new LinearLayout(this); buttonsView.setOrientation(LinearLayout.VERTICAL); for (int r = 0; r < 6; ++r) { Button btn = new Button(this); btn.setText("A"); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.FILL_PARENT); lp.weight = 1.0f; buttonsView.addView(btn, lp); } ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT); setContentView(buttonsView, lp);
LinearLayout ll = new LinearLayout(this); ll.setOrientation(LinearLayout.VERTICAL); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT); layoutParams.setMargins(30, 20, 30, 0); Button okButton=new Button(this); okButton.setText("some text"); ll.addView(okButton, layoutParams);
LayoutParams lp = ((ViewGroup) something).getLayoutParams(); if( lp instanceof MarginLayoutParams ) { ((MarginLayoutParams) lp).topMargin = ...; ((MarginLayoutParams) lp).leftMargin = ...; } else Log.e("MyApp", "Attempted to set the margins on a class that doesn
Resources r = getResources(); float pxLeftMargin = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, r.getDisplayMetrics()); float pxTopMargin = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, r.getDisplayMetrics()); float pxRightMargin = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, r.getDisplayMetrics()); float pxBottomMargin = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, r.getDisplayMetrics()); LayoutParams params=new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); params.setMargins(Math.round(pxLeftMargin), Math.round(pxTopMargin), Math.round(pxRightMargin), Math.round(pxBottomMargin)); yourLayoutTOsetMargin.setLayoutParams(params);
LinearLayout layout = (LinearLayout)findViewById(R.id.yourrelative_layout); LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.WRAP_CONTENT); params.setMargins(3, 300, 3, 3); layout.setLayoutParams(params);
LayoutParams params = new LayoutParams( LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT ); params.setMargins(left, top, right, bottom); yourbutton.setLayoutParams(params);
MarginLayoutParams layoutParams = (MarginLayoutParams) getLayoutParams(); layoutParams.setMargins(leftMargin, topMargin, rightMargin, bottomMargin);
/* * invalid margin */ private void invalidMarginBottom() { RelativeLayout.LayoutParams lp = (RelativeLayout.LayoutParams) frameLayoutContent.getLayoutParams(); lp.setMargins(0, 0, 0, 0); frameLayoutContent.setLayoutParams(lp); }
MarginLayoutParams params = (MarginLayoutParams) view.getLayoutParams(); params.width = 250; params.leftMargin = 50; params.topMargin = 50;
((LinearLayout.LayoutParams) yourLinearLayout.getLayoutParams()).marginToAdd = ((int)(Resources.getSystem().getDisplayMetrics().density * yourDPValue));
C:\Program Files\Java\jdk1.7.0_45\jre\lib\security>keytool -importcert -trustcacerts -file PathToCert -alias ca_alias -keystore "C:\Program Files\Java\jdk1.7.0_45\jre\lib\security\cacerts"
public static void main(String[] args) throws TwitterException { ConfigurationBuilder cb = new ConfigurationBuilder(); cb.setDebugEnabled(true) .setOAuthConsumerKey("myConsumerKey") .setOAuthConsumerSecret("myConsumerSecret") .setOAuthAccessToken("myAccessToken") .setOAuthAccessTokenSecret("myAccessTokenSecret"); TwitterFactory tf = new TwitterFactory(cb.build()); Twitter twitter = tf.getInstance(); try { Query query = new Query("iphone"); QueryResult result; result = twitter.search(query); System.out.println("Total amount of tweets: " + result.getTweets().size()); List<Status> tweets = result.getTweets(); for (Status tweet : tweets) { System.out.println("@" + tweet.getUser().getScreenName() + " : " + tweet.getText()); } } catch (TwitterException te) { te.printStackTrace(); System.out.println("Failed to search tweets: " + te.getMessage()); }
sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target Relevant discussions can be found on the Internet at: http: http: TwitterException{exceptionCode=[d35baff5-1446302e 43208640-747fd158 43208640-747fd158 43208640-747fd158], statusCode=-1, message=null, code=-1, retryAfter=-1, rateLimitStatus=null, version=3.0.5} at twitter4j.internal.http.HttpClientImpl.request(HttpClientImpl.java:177) at twitter4j.internal.http.HttpClientWrapper.request(HttpClientWrapper.java:61) at twitter4j.internal.http.HttpClientWrapper.get(HttpClientWrapper.java:81) at twitter4j.TwitterImpl.get(TwitterImpl.java:1929) at twitter4j.TwitterImpl.search(TwitterImpl.java:306) at jku.cc.servlets.TweetsAnalyzer.main(TweetsAnalyzer.java:38) Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at sun.security.ssl.Alerts.getSSLException(Unknown Source) at sun.security.ssl.SSLSocketImpl.fatal(Unknown Source) at sun.security.ssl.Handshaker.fatalSE(Unknown Source) at sun.security.ssl.Handshaker.fatalSE(Unknown Source) at sun.security.ssl.ClientHandshaker.serverCertificate(Unknown Source) at sun.security.ssl.ClientHandshaker.processMessage(Unknown Source) at sun.security.ssl.Handshaker.processLoop(Unknown Source) at sun.security.ssl.Handshaker.process_record(Unknown Source) at sun.security.ssl.SSLSocketImpl.readRecord(Unknown Source) at sun.security.ssl.SSLSocketImpl.performInitialHandshake(Unknown Source) at sun.security.ssl.SSLSocketImpl.startHandshake(Unknown Source) at sun.security.ssl.SSLSocketImpl.startHandshake(Unknown Source) at sun.net.www.protocol.https.HttpsClient.afterConnect(Unknown Source) at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(Unknown Source) at sun.net.www.protocol.http.HttpURLConnection.getInputStream(Unknown Source) at java.net.HttpURLConnection.getResponseCode(Unknown Source) at sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(Unknown Source) at twitter4j.internal.http.HttpResponseImpl.<init>(HttpResponseImpl.java:34) at twitter4j.internal.http.HttpClientImpl.request(HttpClientImpl.java:141) ... 5 more Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at sun.security.validator.PKIXValidator.doBuild(Unknown Source) at sun.security.validator.PKIXValidator.engineValidate(Unknown Source) at sun.security.validator.Validator.validate(Unknown Source) at sun.security.ssl.X509TrustManagerImpl.validate(Unknown Source) at sun.security.ssl.X509TrustManagerImpl.checkTrusted(Unknown Source) at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(Unknown Source) ... 20 more Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(Unknown Source) at java.security.cert.CertPathBuilder.build(Unknown Source) ... 26 more Failed to search tweets: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
/* * Copyright 2006 Sun Microsystems, Inc. All Rights Reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * - Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * - Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * - Neither the name of Sun Microsystems nor the names of its * contributors may be used to endorse or promote products derived * from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ /** * Originally from: * http: * Use: * java InstallCert hostname * Example: *% java InstallCert ecc.fedora.redhat.com */ import javax.net.ssl.*; import java.io.*; import java.security.KeyStore; import java.security.MessageDigest; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; /** * Class used to add the server * with your trusted certificates. */ public class InstallCert { public static void main(String[] args) throws Exception { String host; int port; char[] passphrase; if ((args.length == 1) || (args.length == 2)) { String[] c = args[0].split(":"); host = c[0]; port = (c.length == 1) ? 443 : Integer.parseInt(c[1]); String p = (args.length == 1) ? "changeit" : args[1]; passphrase = p.toCharArray(); } else { System.out.println("Usage: java InstallCert [:port] [passphrase]"); return; } File file = new File("jssecacerts"); if (file.isFile() == false) { char SEP = File.separatorChar; File dir = new File(System.getProperty("java.home") + SEP + "lib" + SEP + "security"); file = new File(dir, "jssecacerts"); if (file.isFile() == false) { file = new File(dir, "cacerts"); } } System.out.println("Loading KeyStore " + file + "..."); InputStream in = new FileInputStream(file); KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); ks.load(in, passphrase); in.close(); SSLContext context = SSLContext.getInstance("TLS"); TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(ks); X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0]; SavingTrustManager tm = new SavingTrustManager(defaultTrustManager); context.init(null, new TrustManager[]{tm}, null); SSLSocketFactory factory = context.getSocketFactory(); System.out.println("Opening connection to " + host + ":" + port + "..."); SSLSocket socket = (SSLSocket) factory.createSocket(host, port); socket.setSoTimeout(10000); try { System.out.println("Starting SSL handshake..."); socket.startHandshake(); socket.close(); System.out.println(); System.out.println("No errors, certificate is already trusted"); } catch (SSLException e) { System.out.println(); e.printStackTrace(System.out); } X509Certificate[] chain = tm.chain; if (chain == null) { System.out.println("Could not obtain server certificate chain"); return; } BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); System.out.println(); System.out.println("Server sent " + chain.length + " certificate(s):"); System.out.println(); MessageDigest sha1 = MessageDigest.getInstance("SHA1"); MessageDigest md5 = MessageDigest.getInstance("MD5"); for (int i = 0; i < chain.length; i++) { X509Certificate cert = chain[i]; System.out.println (" " + (i + 1) + " Subject " + cert.getSubjectDN()); System.out.println(" Issuer " + cert.getIssuerDN()); sha1.update(cert.getEncoded()); System.out.println(" sha1 " + toHexString(sha1.digest())); md5.update(cert.getEncoded()); System.out.println(" md5 " + toHexString(md5.digest())); System.out.println(); } System.out.println("Enter certificate to add to trusted keystore or String line = reader.readLine().trim(); int k; try { k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1; } catch (NumberFormatException e) { System.out.println("KeyStore not changed"); return; } X509Certificate cert = chain[k]; String alias = host + "-" + (k + 1); ks.setCertificateEntry(alias, cert); OutputStream out = new FileOutputStream("jssecacerts"); ks.store(out, passphrase); out.close(); System.out.println(); System.out.println(cert); System.out.println(); System.out.println ("Added certificate to keystore + alias + " } private static final char[] HEXDIGITS = "0123456789abcdef".toCharArray(); private static String toHexString(byte[] bytes) { StringBuilder sb = new StringBuilder(bytes.length * 3); for (int b : bytes) { b &= 0xff; sb.append(HEXDIGITS[b >> 4]); sb.append(HEXDIGITS[b & 15]); sb.append( } return sb.toString(); } private static class SavingTrustManager implements X509TrustManager { private final X509TrustManager tm; private X509Certificate[] chain; SavingTrustManager(X509TrustManager tm) { this.tm = tm; } public X509Certificate[] getAcceptedIssuers() { throw new UnsupportedOperationException(); } public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { throw new UnsupportedOperationException(); } public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { this.chain = chain; tm.checkServerTrusted(chain, authType); } } }
keytool -import -trustcacerts -keystore cacerts -alias <new_ca_alias> -file <path_to_ca_cert_file>
keytool -trustcacerts -keystore "%JAVA_HOME%jre\lib\security\cacerts" -storepass changeit -importcert -alias <alias_name> -file <path_to_crt_file>
keytool -list -trustcacerts -keystore "%JAVA_HOME%jre\lib\security\cacerts" -storepass changeit
keytool -delete -alias <alias_name> -keystore "%JAVA_HOME%jre\lib\security\cacerts" -storepass changeit
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Could not transfer artifact com.java.project:product:jar:1.0.32 from/to repo-local (https:
keytool -importcert -file "C:/Users/sheldon/Desktop/product.cer" -alias product -keystore "C:/Program iles/Java/jdk1.8.0_141/jre/lib/security/cacerts" Enter keystore password: Trust this certificate? [no]: yes Certificate was added to keystore
-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true
Unable to read repository at http: Unable to read repository at http: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
keytool -export -keystore keystore.jks -alias selfsigned -file selfsigned.crt
keytool -importcert -file selfsigned.crt -alias selfsigned -keystore {{cacerts path}}
keytool -importcert -file selfsigned.nextgen.crt -alias selfsigned.nextgen -keystore /Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/security/cacerts
sudo /usr/share/elasticsearch/bin/plugin install file:/home/dev/Downloads/elasticsearch-kopf-master.zip
2018-08-18 11:35:00,312 Caesium-1-4 WARN anonymous Default Mail Handler [c.a.mail.incoming.mailfetcherservice] Default Mail Handler[10001]: javax.mail.MessagingException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target while connecting to host
keytool -importcert -file missing_ca.crt -alias missing_ca -keystore /opt/atlassian/jira/jre/lib/security/cacerts
<repository> <snapshots> <enabled>false</enabled> </snapshots> <id>central</id> <name>libs-release</name> <url>https: </repository>
<repository> <snapshots> <enabled>false</enabled> </snapshots> <id>central</id> <name>libs-release</name> <url>https: </repository>
public class CertificateManager { private final static Logger logger = Logger.getLogger(CertificateManager.class); private String keyStoreLocation; private String keyStorePassword; private X509TrustManager myTrustManager; private static KeyStore myTrustStore; public CertificateManager(String keyStoreLocation, String keyStorePassword) throws Exception { this.keyStoreLocation = keyStoreLocation; this.keyStorePassword = keyStorePassword; myTrustStore = createKeyStore(keyStoreLocation, keyStorePassword); } public void addCustomCertificate(String certFileName, String certificateAlias) throws Exception { TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init((KeyStore) null); Certificate certificate = myTrustStore.getCertificate(certificateAlias); if (certificate == null) { logger.info("Certificate not exists"); addCertificate(certFileName, certificateAlias); } else { logger.info("Certificate exists"); } tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(myTrustStore); for (TrustManager tm : tmf.getTrustManagers()) { if (tm instanceof X509TrustManager) { setMytrustManager((X509TrustManager) tm); logger.info("Trust manager found"); break; } } } private InputStream fullStream(String fname) throws IOException { ClassLoader classLoader = getClass().getClassLoader(); InputStream resource = classLoader.getResourceAsStream(fname); try { if (resource != null) { DataInputStream dis = new DataInputStream(resource); byte[] bytes = new byte[dis.available()]; dis.readFully(bytes); return new ByteArrayInputStream(bytes); } else { logger.info("resource not found"); } } catch (Exception e) { logger.error("exception in certificate fetching as resource", e); } return null; } public static KeyStore createKeyStore(String keystore, String pass) throws Exception { try { InputStream in = CertificateManager.class.getClass().getResourceAsStream(keystore); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(in, pass.toCharArray()); logger.info("Keystore was created from resource file"); return keyStore; } catch (Exception e) { logger.info("Fail to create keystore from resource file"); } File file = new File(keystore); KeyStore keyStore = KeyStore.getInstance("JKS"); if (file.exists()) { keyStore.load(new FileInputStream(file), pass.toCharArray()); logger.info("Default keystore loaded"); } else { keyStore.load(null, null); keyStore.store(new FileOutputStream(file), pass.toCharArray()); logger.info("New keystore created"); } return keyStore; } private void addCertificate(String certFileName, String certificateAlias) throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException { CertificateFactory cf = CertificateFactory.getInstance("X.509"); InputStream certStream = fullStream(certFileName); Certificate certs = cf.generateCertificate(certStream); myTrustStore.setCertificateEntry(certificateAlias, certs); FileOutputStream out = new FileOutputStream(getKeyStoreLocation()); myTrustStore.store(out, getKeyStorePassword().toCharArray()); out.close(); logger.info("Certificate pushed"); } public String getKeyStoreLocation() { return keyStoreLocation; } public String getKeyStorePassword() { return keyStorePassword; } public X509TrustManager getMytrustManager() { return myTrustManager; } public void setMytrustManager(X509TrustManager myTrustManager) { this.myTrustManager = myTrustManager; } }
public class CustomTrustManager implements X509TrustManager { private final static Logger logger = Logger.getLogger(CertificateManager.class); private static SSLSocketFactory socketFactory; private static CustomTrustManager instance = new CustomTrustManager(); private static List<CertificateManager> register = new ArrayList<>(); public static CustomTrustManager getInstance() { return instance; } private X509TrustManager defaultTm; public void register(CertificateManager certificateManager) { for(CertificateManager manager : register) { if(manager == certificateManager) { logger.info("Certificate manager already registered"); return; } } register.add(certificateManager); logger.info("New Certificate manager registered"); } private CustomTrustManager() { try { String algorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm); tmf.init((KeyStore) null); boolean found = false; for (TrustManager tm : tmf.getTrustManagers()) { if (tm instanceof X509TrustManager) { defaultTm = (X509TrustManager) tm; found = true; break; } } if(found) { logger.info("Default trust manager found"); } else { logger.warn("Default trust manager was not found"); } SSLContext sslContext = SSLContext.getInstance("TLS"); sslContext.init(null, new TrustManager[]{this}, null); SSLContext.setDefault(sslContext); socketFactory = sslContext.getSocketFactory(); HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory); logger.info("Custom trust manager was set"); } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) { logger.warn("Custom trust manager can e.printStackTrace(); } } @Override public X509Certificate[] getAcceptedIssuers() { List<X509Certificate> out = new ArrayList<>(); if (defaultTm != null) { out.addAll(Arrays.asList(defaultTm.getAcceptedIssuers())); } int defaultCount = out.size(); logger.info("Default trust manager contain " + defaultCount + " certficates"); for(CertificateManager manager : register) { X509TrustManager customTrustManager = manager.getMytrustManager(); X509Certificate[] issuers = customTrustManager.getAcceptedIssuers(); out.addAll(Arrays.asList(issuers)); } logger.info("Custom trust managers contain " + (out.size() - defaultCount) + " certficates"); X509Certificate[] arrayOut = new X509Certificate[out.size()]; return out.toArray(arrayOut); } @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { for(CertificateManager certificateManager : register) { X509TrustManager customTrustManager = certificateManager.getMytrustManager(); try { customTrustManager.checkServerTrusted(chain, authType); logger.info("Certificate chain (server) was aproved by custom trust manager"); return; } catch (Exception e) { } } if (defaultTm != null) { defaultTm.checkServerTrusted(chain, authType); logger.info("Certificate chain (server) was aproved by default trust manager"); } else { logger.info("Certificate chain (server) was rejected"); throw new CertificateException("Can } } @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { try { if (defaultTm != null) { defaultTm.checkClientTrusted(chain, authType); logger.info("Certificate chain (client) was aproved by default trust manager"); } else { throw new NullPointerException(); } } catch (Exception e) { for(CertificateManager certificateManager : register) { X509TrustManager customTrustManager = certificateManager.getMytrustManager(); try { customTrustManager.checkClientTrusted(chain, authType); logger.info("Certificate chain (client) was aproved by custom trust manager"); return; } catch (Exception e1) { } } logger.info("Certificate chain (client) was rejected"); throw new CertificateException("Can } } public SSLSocketFactory getSocketFactory() { return socketFactory; } }
CertificateManager certificateManager = new CertificateManager("C:\\myapplication\\mykeystore.jks", "changeit"); String certificatePath = "C:\\myapplication\\public_key_for_your_ssl_service.crt"; try { certificateManager.addCustomCertificate(certificatePath, "alias_for_public_key_for_your_ssl_service"); } catch (Exception e) { log.error("Can e.printStackTrace(); } CustomTrustManager.getInstance().register(certificateManager);
java -jar fernflower.jar [-<option>=<value>]* [<source>]+ <destination> java -jar fernflower.jar -hes=0 -hdc=0 c:\Temp\binary\ -e=c:\Java\rt.jar c:\Temp\source\
JAR=(your jar file name) unzip -d $JAR.tmp $JAR pushd $JAR.tmp for f in `find . -name jad -d $(dirname $f) -s java -lnc $f done popd
jar -xf foo.jar && find . -iname "*.class" | xargs /opt/local/bin/jad -r
function clean_target { rm -rf $unjar $src $jad_log } function clean_stuff { rm -rf $unjar $jad_log } function work { jar=$1 unjar=`basename $jar.unjar` src=`basename $jar.src` jad_log=jad.log clean_target unzip -q $jar -d $unjar jad -d $src -ff -r -lnc -o -s java $unjar/**/*.class > $jad_log 2>&1 if [ ! $debug ]; then clean_stuff fi if [ -d $src ] then echo "$jar has been decompiled to $src" else echo "Got some problems check output or run in debug mode" fi } function usage { echo "This script extract and decompile JAR file" echo "Usage: $0 some.jar [-d]" echo " where: some.jar is the target to decompile" echo " use -d for debug mode" } if [ -n "$1" ] then if [ "$2" == "-d" ]; then debug=true set -x fi work $1 else usage fi
Time to create million String objects: 41.41 (ms) Time to create million JavaException objects with stack: 608.89 (ms) Time to create million JavaException objects without stack: 43.50 (ms)
|Depth| WriteStack(ms)| !WriteStack(ms)| Diff(%)| | 16| 1428| 243| 588 (%)| | 15| 1763| 393| 449 (%)| | 14| 1746| 390| 448 (%)| | 13| 1703| 384| 443 (%)| | 12| 1697| 391| 434 (%)| | 11| 1707| 410| 416 (%)| | 10| 1226| 197| 622 (%)| | 9| 1242| 206| 603 (%)| | 8| 1251| 207| 604 (%)| | 7| 1213| 208| 583 (%)| | 6| 1164| 206| 565 (%)| | 5| 1134| 205| 553 (%)| | 4| 1106| 203| 545 (%)| | 3| 1043| 192| 543 (%)|
public class JavaException extends Exception { JavaException(String reason, int mode) { super(reason, null, false, false); } JavaException(String reason) { super(reason); } public static void main(String[] args) { int iterations = 1000000; long create_time_with = 0; long create_time_without = 0; long create_string = 0; for (int i = 0; i < iterations; i++) { long start = System.nanoTime(); JavaException jex = new JavaException("testing"); long stop = System.nanoTime(); create_time_with += stop - start; start = System.nanoTime(); JavaException jex2 = new JavaException("testing", 1); stop = System.nanoTime(); create_time_without += stop - start; start = System.nanoTime(); String str = new String("testing"); stop = System.nanoTime(); create_string += stop - start; } double interval_with = ((double)create_time_with)/1000000; double interval_without = ((double)create_time_without)/1000000; double interval_string = ((double)create_string)/1000000; System.out.printf("Time to create %d String objects: %.2f (ms)\n", iterations, interval_string); System.out.printf("Time to create %d JavaException objects with stack: %.2f (ms)\n", iterations, interval_with); System.out.printf("Time to create %d JavaException objects without stack: %.2f (ms)\n", iterations, interval_without); JavaException jex = new JavaException("testing"); int depth = 14; int i = depth; double[] with_stack = new double[20]; double[] without_stack = new double[20]; for(; i > 0 ; --i) { without_stack[i] = jex.timerLoop(i, iterations, 0)/1000000; with_stack[i] = jex.timerLoop(i, iterations, 1)/1000000; } i = depth; System.out.printf("|Depth| WriteStack(ms)| !WriteStack(ms)| Diff(%%)|\n"); for(; i > 0 ; --i) { double ratio = (with_stack[i] / (double) without_stack[i]) * 100; System.out.printf("|%5d| %14.0f| %15.0f| %2.0f (%%)| \n", i + 2, with_stack[i] , without_stack[i], ratio); } } private int thrower(int i, int mode) throws JavaException { ExArg.time_start[i] = System.nanoTime(); if(mode == 0) { throw new JavaException("without stack", 1); } throw new JavaException("with stack"); } private int catcher1(int i, int mode) throws JavaException{ return this.stack_of_calls(i, mode); } private long timerLoop(int depth, int iterations, int mode) { for (int i = 0; i < iterations; i++) { try { this.catcher1(depth, mode); } catch (JavaException e) { ExArg.time_accum[depth] += (System.nanoTime() - ExArg.time_start[depth]); } } return ExArg.time_accum[depth]; } private int bad_method14(int i, int mode) throws JavaException { if(i > 0) { this.thrower(i, mode); } return i; } private int bad_method13(int i, int mode) throws JavaException { if(i == 13) { this.thrower(i, mode); } return bad_method14(i,mode); } private int bad_method12(int i, int mode) throws JavaException{ if(i == 12) { this.thrower(i, mode); } return bad_method13(i,mode); } private int bad_method11(int i, int mode) throws JavaException{ if(i == 11) { this.thrower(i, mode); } return bad_method12(i,mode); } private int bad_method10(int i, int mode) throws JavaException{ if(i == 10) { this.thrower(i, mode); } return bad_method11(i,mode); } private int bad_method9(int i, int mode) throws JavaException{ if(i == 9) { this.thrower(i, mode); } return bad_method10(i,mode); } private int bad_method8(int i, int mode) throws JavaException{ if(i == 8) { this.thrower(i, mode); } return bad_method9(i,mode); } private int bad_method7(int i, int mode) throws JavaException{ if(i == 7) { this.thrower(i, mode); } return bad_method8(i,mode); } private int bad_method6(int i, int mode) throws JavaException{ if(i == 6) { this.thrower(i, mode); } return bad_method7(i,mode); } private int bad_method5(int i, int mode) throws JavaException{ if(i == 5) { this.thrower(i, mode); } return bad_method6(i,mode); } private int bad_method4(int i, int mode) throws JavaException{ if(i == 4) { this.thrower(i, mode); } return bad_method5(i,mode); } protected int bad_method3(int i, int mode) throws JavaException{ if(i == 3) { this.thrower(i, mode); } return bad_method4(i,mode); } private int bad_method2(int i, int mode) throws JavaException{ if(i == 2) { this.thrower(i, mode); } return bad_method3(i,mode); } private int bad_method1(int i, int mode) throws JavaException{ if(i == 1) { this.thrower(i, mode); } return bad_method2(i,mode); } private int stack_of_calls(int i, int mode) throws JavaException{ if(i == 0) { this.thrower(i, mode); } return bad_method1(i,mode); } } class ExArg { public static long[] time_start; public static long[] time_accum; static { time_start = new long[20]; time_accum = new long[20]; }; }
protected int bad_method3(int, int) throws JavaException; flags: ACC_PROTECTED Code: stack=3, locals=3, args_size=3 0: iload_1 1: iconst_3 2: if_icmpne 12 5: aload_0 6: iload_1 7: iload_2 8: invokespecial 11: pop 12: aload_0 13: iload_1 14: iload_2 15: invokespecial 18: ireturn LineNumberTable: line 63: 0 line 64: 12 StackMapTable: number_of_entries = 1 frame_type = 12 Exceptions: throws JavaException
class NoStackException extends Exception{ public NoStackException() { super("",null,false,false); } }
public class ExceptionBenchmark { private static final int NUM_TRIES = 100000; public static void main(String[] args) { long throwCatchTime = 0, newExceptionTime = 0, newObjectTime = 0, noStackExceptionTime = 0; for (int i = 0; i < 30; i++) { throwCatchTime += throwCatchLoop(); newExceptionTime += newExceptionLoop(); newObjectTime += newObjectLoop(); noStackExceptionTime += newNoStackExceptionLoop(); } System.out.println("throwCatchTime = " + throwCatchTime / 30); System.out.println("newExceptionTime = " + newExceptionTime / 30); System.out.println("newStringTime = " + newObjectTime / 30); System.out.println("noStackExceptionTime = " + noStackExceptionTime / 30); } private static long throwCatchLoop() { Exception ex = new Exception(); long start = System.currentTimeMillis(); for (int i = 0; i < NUM_TRIES; i++) { try { throw ex; } catch (Exception e) { } } long stop = System.currentTimeMillis(); return stop - start; } private static long newExceptionLoop() { long start = System.currentTimeMillis(); for (int i = 0; i < NUM_TRIES; i++) { Exception e = new Exception(); } long stop = System.currentTimeMillis(); return stop - start; } private static long newObjectLoop() { long start = System.currentTimeMillis(); for (int i = 0; i < NUM_TRIES; i++) { Object o = new Object(); } long stop = System.currentTimeMillis(); return stop - start; } private static long newNoStackExceptionLoop() { long start = System.currentTimeMillis(); for (int i = 0; i < NUM_TRIES; i++) { NoStackException e = new NoStackException(); } long stop = System.currentTimeMillis(); return stop - start; } }
throwCatchTime = 19 newExceptionTime = 77 newObjectTime = 3 noStackExceptionTime = 15
|Depth| WriteStack(ms)| !WriteStack(ms)| Diff(%)| | 16| 193| 251| 77 (%)| | 15| 390| 406| 96 (%)| | 14| 394| 401| 98 (%)| | 13| 381| 385| 99 (%)| | 12| 387| 370| 105 (%)| | 11| 368| 376| 98 (%)| | 10| 188| 192| 98 (%)| | 9| 193| 195| 99 (%)| | 8| 200| 188| 106 (%)| | 7| 187| 184| 102 (%)| | 6| 196| 200| 98 (%)| | 5| 197| 193| 102 (%)| | 4| 198| 190| 104 (%)| | 3| 193| 183| 105 (%)|
new Exception + throw/catch = 643.5 new Exception only = 510.7 throw/catch only = 115.2 new String (benchmark) = 669.8
new Exception + throw/catch = 382.6 new Exception only = 379.5 throw/catch only = 0.3 new String (benchmark) = 15.6
public class ExceptionPerformanceTest { private static final int NUM_TRIES = 1000000; public static void main(String[] args) { double numIterations = 10; long exceptionPlusCatchTime = 0, excepTime = 0, strTime = 0, throwTime = 0; for (int i = 0; i < numIterations; i++) { exceptionPlusCatchTime += exceptionPlusCatchBlock(); excepTime += createException(); throwTime += catchBlock(); strTime += createString(); } System.out.println("new Exception + throw/catch = " + exceptionPlusCatchTime / numIterations); System.out.println("new Exception only = " + excepTime / numIterations); System.out.println("throw/catch only = " + throwTime / numIterations); System.out.println("new String (benchmark) = " + strTime / numIterations); } private static long exceptionPlusCatchBlock() { long start = System.currentTimeMillis(); for (int i = 0; i < NUM_TRIES; i++) { try { throw new Exception(); } catch (Exception e) { } } long stop = System.currentTimeMillis(); return stop - start; } private static long createException() { long start = System.currentTimeMillis(); for (int i = 0; i < NUM_TRIES; i++) { Exception e = new Exception(); } long stop = System.currentTimeMillis(); return stop - start; } private static long createString() { long start = System.currentTimeMillis(); for (int i = 0; i < NUM_TRIES; i++) { Object o = new String("" + i); } long stop = System.currentTimeMillis(); return stop - start; } private static long catchBlock() { Exception ex = new Exception(); long start = System.currentTimeMillis(); for (int i = 0; i < NUM_TRIES; i++) { try { throw ex; } catch (Exception e) { } } long stop = System.currentTimeMillis(); return stop - start; } }
int i; while ((i = instr.read()) != -1) { osstr.write(i); } instr.close(); osstr.close();
File file = new File("C:/text.bin"); file.createNewFile(); DataOutputStream stream = new DataOutputStream(new FileOutputStream(file)); stream.writeBoolean(true); stream.writeInt(1234); stream.close();
File file = new File("C:/text.bin"); DataInputStream stream = new DataInputStream(new FileInputStream(file)); boolean isTrue = stream.readBoolean(); int value = stream.readInt(); stream.close(); System.out.printlin(isTrue + " " + value);
DataInputStream stream = new DataInputStream( new BufferedInputStream(new FileInputStream(file)));
MyClass myObject = new MyClass(); ObjectOutputStream stream = new ObjectOutputStream( new FileOutputStream("C:/text.obj")); stream.writeObject(myObject); stream.close();
byte[] test = new byte[] {0, 0, 1, 0, 0, 0, 1, 1, 8, 9}; DataInputStream stream = new DataInputStream(new ByteArrayInputStream(test)); int value0 = stream.readInt(); int value1 = stream.readInt(); byte value2 = stream.readByte(); byte value3 = stream.readByte(); stream.close(); System.out.println(value0 + " " + value1 + " " + value2 + " " + value3);
import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class CopyBytes { public static void main(String[] args) throws IOException { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream("xanadu.txt"); out = new FileOutputStream("outagain.txt"); int c; while ((c = in.read()) != -1) { out.write(c); } } finally { if (in != null) { in.close(); } if (out != null) { out.close(); } } } }
InputStream input = ... OutputStream output = ... byte[] buffer = new byte[1024]; int n = 0; while ((n = input.read(buffer)) != -1) output.write(buffer, 0, n); input.close(); output.close();
import java.io.printstream; class PPrint { static PPrintStream oout = new PPrintStream(); } class PPrintStream { void print(String str) { System.out.println(str) } } class outputstreamDemo { public static void main(String args[]) { System.out.println("hello world"); System.out.prinln("this is output stream demo"); } }
class M{public static void main(String[]a){System.out.print(new char[] {
"class M\u202E{public static void main(String[]a\u202D){System.out.print(new char[]\n"+ "{
Identifier: IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral IdentifierChars: JavaLetter {JavaLetterOrDigit}
String myString = " keep this "; String stripppedString = myString.strip(); System.out.println("no spaces:" + strippedString);
String leftRemoved = myString.replaceAll("^\\s+", "");
String rightRemoved = myString.replaceAll("\\s+$", "");
String stripppedString = myString.replaceAll("(^ )|( $)", "");
/** * Returns a string whose value is this string, with all leading * and trailing {@link Character * removed. * <p> * If this {@code String} object represents an empty string, * or if all code points in this string are * {@link Character * is returned. * <p> * Otherwise, returns a substring of this string beginning with the first * code point that is not a {@link Character * up to and including the last code point that is not a * {@link Character * <p> * This method may be used to strip * {@link Character * the beginning and end of a string. * * @return a string whose value is this string, with all leading * and trailing white space removed * * @see Character * * @since 11 */ public String strip()
System.out.println(" leading".strip()); System.out.println("trailing ".strip()); System.out.println(" keep this ".strip());
Bitmap bmp = intent.getExtras().get("data"); int size = bmp.getRowBytes() * bmp.getHeight(); ByteBuffer b = ByteBuffer.allocate(size); bmp.copyPixelsToBuffer(b); byte[] bytes = new byte[size]; try { b.get(bytes, 0, bytes.length); } catch (BufferUnderflowException e) { }
Bitmap bmp = intent.getExtras().get("data"); ByteArrayOutputStream stream = new ByteArrayOutputStream(); bmp.compress(Bitmap.CompressFormat.PNG, 100, stream); byte[] byteArray = stream.toByteArray(); bmp.recycle();
width = bitmap.getWidth(); height = bitmap.getHeight(); int size = bitmap.getRowBytes() * bitmap.getHeight(); ByteBuffer byteBuffer = ByteBuffer.allocate(size); bitmap.copyPixelsToBuffer(byteBuffer); byteArray = byteBuffer.array();
Bitmap.Config configBmp = Bitmap.Config.valueOf(bitmap.getConfig().name()); Bitmap bitmap_tmp = Bitmap.createBitmap(width, height, configBmp); ByteBuffer buffer = ByteBuffer.wrap(byteArray); bitmap_tmp.copyPixelsFromBuffer(buffer);
public static String encodeTobase64(Bitmap image) { Bitmap immagex = image; ByteArrayOutputStream baos = new ByteArrayOutputStream(); immagex.compress(Bitmap.CompressFormat.PNG, 90, baos); byte[] b = baos.toByteArray(); String imageEncoded = Base64.encodeToString(b, Base64.DEFAULT); return imageEncoded; } public static Bitmap decodeBase64(String input) { byte[] decodedByte = Base64.decode(input, 0); return BitmapFactory.decodeByteArray(decodedByte, 0, decodedByte.length); }
/** * Convert bitmap to byte array using ByteBuffer. */ fun Bitmap.convertToByteArray(): ByteArray { val size = this.byteCount val buffer = ByteBuffer.allocate(size) val bytes = ByteArray(size) this.copyPixelsToBuffer(buffer) buffer.rewind() buffer.get(bytes) return bytes }
public ByteBuffer get (byte[] dst, int dstOffset, int byteCount)
private byte[] getBitmapBytes(Bitmap bitmap) { int chunkNumbers = 10; int bitmapSize = bitmap.getRowBytes() * bitmap.getHeight(); byte[] imageBytes = new byte[bitmapSize]; int rows, cols; int chunkHeight, chunkWidth; rows = cols = (int) Math.sqrt(chunkNumbers); chunkHeight = bitmap.getHeight() / rows; chunkWidth = bitmap.getWidth() / cols; int yCoord = 0; int bitmapsSizes = 0; for (int x = 0; x < rows; x++) { int xCoord = 0; for (int y = 0; y < cols; y++) { Bitmap bitmapChunk = Bitmap.createBitmap(bitmap, xCoord, yCoord, chunkWidth, chunkHeight); byte[] bitmapArray = getBytesFromBitmapChunk(bitmapChunk); System.arraycopy(bitmapArray, 0, imageBytes, bitmapsSizes, bitmapArray.length); bitmapsSizes = bitmapsSizes + bitmapArray.length; xCoord += chunkWidth; bitmapChunk.recycle(); bitmapChunk = null; } yCoord += chunkHeight; } return imageBytes; } private byte[] getBytesFromBitmapChunk(Bitmap bitmap) { int bitmapSize = bitmap.getRowBytes() * bitmap.getHeight(); ByteBuffer byteBuffer = ByteBuffer.allocate(bitmapSize); bitmap.copyPixelsToBuffer(byteBuffer); byteBuffer.rewind(); return byteBuffer.array(); }
/** * @param bitmap * @return converting bitmap and return a string */ public static String BitMapToString(Bitmap bitmap){ ByteArrayOutputStream baos=new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG,100, baos); byte [] b=baos.toByteArray(); String temp=Base64.encodeToString(b, Base64.DEFAULT); return temp; } /** * @param encodedString * @return bitmap (from given string) */ public static Bitmap StringToBitMap(String encodedString){ try{ byte [] encodeByte=Base64.decode(encodedString,Base64.DEFAULT); Bitmap bitmap= BitmapFactory.decodeByteArray(encodeByte, 0, encodeByte.length); return bitmap; }catch(Exception e){ e.getMessage(); return null; } }
-Xms<size> set initial Java heap size -Xmx<size> set maximum Java heap size -Xss<size> set java thread stack size java -Xms16m -Xmx64m ClassName
export JAVA_OPTS="-Xms6144m -Xmx6144m -XX:NewSize=256m -XX:MaxNewSize=356m -XX:PermSize=256m -XX:MaxPermSize=356m"
java -jar -Xms4096M -Xmx6144M -XX:NewRatio=1 -XX:-UseAdaptiveSizePolicy pathToJarFile.jar
public void clear() { modCount++; for (int i = 0; i < size; i++) elementData[i] = null; size = 0; }
public boolean removeAll(Collection<?> c) { boolean modified = false; Iterator<?> e = iterator(); while (e.hasNext()) { if (c.contains(e.next())) { e.remove(); modified = true; } } return modified; }
abstract public class AbstractClass { abstract public void abstractMethod(); public void implementedMethod() { System.out.print("implementedMethod()"); } final public void finalMethod() { System.out.print("finalMethod()"); } }
public class ImplementingClass extends AbstractClass { }
public class ImplementingClass extends AbstractClass { public void abstractMethod() { System.out.print("abstractMethod()"); } }
public class ImplementingClass extends AbstractClass { public void abstractMethod() { System.out.print("abstractMethod()"); } public void implementedMethod() { System.out.print("Overridden!"); } }
public class ImplementingClass extends AbstractClass { public void abstractMethod() { System.out.print("abstractMethod()"); } public void implementedMethod() { System.out.print("Overridden!"); } public void finalMethod() { System.out.print("ERROR!"); } }
public class ImplementingClass extends AbstractClass { public void abstractMethod() { System.out.print("abstractMethod()"); } public void implementedMethod() { System.out.print("Overridden!"); } } public class SecondImplementingClass extends AbstractClass { public void abstractMethod() { System.out.print("second abstractMethod()"); } }
public tryItOut() { ImplementingClass a = new ImplementingClass(); AbstractClass b = new ImplementingClass(); a.abstractMethod(); a.implementedMethod(); a.finalMethod(); b.abstractMethod(); b.implementedMethod(); b.finalMethod(); SecondImplementingClass c = new SecondImplementingClass(); AbstractClass d = new SecondImplementingClass(); c.abstractMethod(); c.implementedMethod(); c.finalMethod(); d.abstractMethod(); d.implementedMethod(); d.finalMethod(); }
AbstractClass b = new ImplementingClass(); ((ImplementingClass)b).uniqueMethod();
public class ImplementingClass extends AbstractClass, SomeOtherAbstractClass { ... }
public class ImplementingClass extends AbstractClass implements InterfaceA, InterfaceB { ... }
abstract public class InterfaceA { abstract public void interfaceMethod(); }
interface InterfaceB { void interfaceMethod() { System.out.print("ERROR!"); } }
abstract class GraphicObject { void moveTo(int x, int y) { } abstract void draw(); abstract void resize(); }
class Circle extends GraphicObject { void draw() { } void resize() { } } class Rectangle extends GraphicObject { void draw() { } void resize() { } }
public static void main(String args[]){ GraphicObject c = new Circle(); c.draw(); c.resize(); c.moveTo(4,5); }
abstract class GraphicObject { GraphicObject (){ System.out.println("GraphicObject is created"); } void moveTo(int y, int x) { System.out.println("Change position according to "+ x+ " and " + y); } abstract void draw(); } class Circle extends GraphicObject { void draw() { System.out.println("Draw the Circle"); } } class TestAbstract { public static void main(String args[]){ GraphicObject grObj = new Circle (); grObj.draw(); grObj.moveTo(4,6); } }
GraphicObject is created Draw the Circle Change position according to 6 and 4
public abstract class MyAbstractClass{ public abstract void DoSomething(); }
public abstract class MyAbstractClass{ public int CalculateCost(int amount){ } public abstract void DoSomething(); }
abstract void moveTo(double deltaX, double deltaY);
public abstract class GraphicObject { abstract void draw(); }
interface IFoo { void someMethod(); } abstract class Foo2 implements IFoo { }
abstract class Foo3 { } class Bar extends Foo3 { } Foo3 myVar = new Foo3(); Foo3 myVar = new Bar();
abstract class Processor { protected abstract int[] filterInput(int[] unfiltered); public int process(int[] values) { int[] filtered = filterInput(values); } } class EvenValues extends Processor { protected int[] filterInput(int[] unfiltered) { } } class OddValues extends Processor { protected int[] filterInput(int[] unfiltered) { } }
public abstract class Place { String Name; String Postcode; String County; String Area; Place () { } public static Place make(String Incoming) { if (Incoming.length() < 61) return (null); String Name = (Incoming.substring(4,26)).trim(); String County = (Incoming.substring(27,48)).trim(); String Postcode = (Incoming.substring(48,61)).trim(); String Area = (Incoming.substring(61)).trim(); Place created; if (Name.equalsIgnoreCase(Area)) { created = new Area(Area,County,Postcode); } else { created = new District(Name,County,Postcode,Area); } return (created); } public String getName() { return (Name); } public String getPostcode() { return (Postcode); } public String getCounty() { return (County); } public abstract String getArea(); }
abstract class Bike{ abstract void run(); } class Honda4 extends Bike{ void run(){ System.out.println("running safely.."); } public static void main(String args[]){ Bike obj = new Honda4(); obj.run(); } }
int year = Calendar.getInstance().get(Calendar.YEAR);
int year = Calendar.getInstance().get(Calendar.YEAR);
int year = Calendar.getInstance().get(Calendar.YEAR);
public static int getYearFromDate(Date date) { int result = -1; if (date != null) { Calendar cal = Calendar.getInstance(); cal.setTime(date); result = cal.get(Calendar.YEAR); } return result; }
ZonedDateTime.now( ZoneId.of( "Africa/Casablanca" ) ) .getYear()
int year = ZonedDateTime.now( ZoneId.of( "Africa/Casablanca" ) ).getYear() ;
int year = DateTime.now( DateTimeZone.forID( "Africa/Casablanca" ) ).getYear() ;
DateTime oneYearAgo = DateTime.now( DateTimeZone.forID( "Africa/Casablanca" ) ).minusYears( 1 ) ;
import java.time.YearMonth; ... int year = YearMonth.now().getYear(); int month = YearMonth.now().getMonthValue();
import java.time.LocalDate; int year = LocalDate.now().getYear();
int year; year = Calendar.getInstance().get(Calendar.YEAR);
import java.util.Calendar; import java.util.Scanner; public static void main (String[] args){ Scanner scannernumber = new Scanner(System.in); int year; do{ System.out.print("Year (Between "+((Calendar.getInstance().get(Calendar.YEAR))-200)+" and "+Calendar.getInstance().get(Calendar.YEAR)+") : "); year = scannernumber.nextInt(); }while(year < ((Calendar.getInstance().get(Calendar.YEAR))-200) || year > Calendar.getInstance().get(Calendar.YEAR)); }
return (System.currentTimeMillis()/1000/3600/24/365.25 +1970);
int[] int_dmy( long timestamp ) { Calendar cal = new GregorianCalendar(); cal.setTimeInMillis( timestamp ); return new int[] { cal.get( Calendar.DATE ), cal.get( Calendar.MONTH ), cal.get( Calendar.YEAR ) }; }; int[] int_dmy( Date d ) { ... }
(decimal) (binary) 5 = 101 6 = 110 ------------------ xor 3 = 011
^ | 0 1 ^ | F T --+----- --+----- 0 | 0 1 F | F T 1 | 1 0 T | T F
8675309 = 8*10^6 + 6*10^5 + 7*10^4 + 5*10^3 + 3*10^2 + 0*10^1 + 9*10^0 = (((((8*10 + 6)*10 + 7)*10 + 5)*10 + 3)*10 + 0)*10 + 9
step result digit result*10+digit 1 init=0 8 8 2 8 6 86 3 86 7 867 4 867 5 8675 5 8675 3 86753 6 86753 0 867530 7 867530 9 8675309=final
Operator Name Example Result Description a & b and 3 & 5 1 1 if both bits are 1. a | b or 3 | 5 7 1 if either bit is 1. a ^ b xor 3 ^ 5 6 1 if both bits are different. ~a not ~3 -4 Inverts the bits. n << p left shift 3 << 2 12 Shifts the bits of n left p positions. Zero bits are shifted into the low-order positions. n >> p right shift 5 >> 2 1 Shifts the bits of n right p positions. If n is a 2 n >>> p right shift -4 >>> 28 15 Shifts the bits of n right p positions. Zeros are shifted into the high-order positions.
5 ^ 5 => 1 0 1 (5) 1 0 1 (5) ------------ 0 0 0 => (0) 5 ^ 6 => 1 0 1 (5) 1 1 0 (6) ----------- 0 1 1 => 3
a = 0011 1100 b = 0000 1101 a^b ==> 0011 1100 (a) 0000 1101 (b) ------------- XOR 0011 0001 => 49 (a ^ b) will give 49 which is 0011 0001
URL aaa = new URL("http: URLConnection ccc = aaa.openConnection();
HttpClient httpclient = HttpClients.createDefault(); HttpPost httppost = new HttpPost("http: List<NameValuePair> params = new ArrayList<NameValuePair>(2); params.add(new BasicNameValuePair("param-1", "12345")); params.add(new BasicNameValuePair("param-2", "Hello!")); httppost.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); HttpResponse response = httpclient.execute(httppost); HttpEntity entity = response.getEntity(); if (entity != null) { try (InputStream instream = entity.getContent()) { } }
HttpPost post = new HttpPost("http: NameValuePair[] data = { new NameValuePair("user", "joe"), new NameValuePair("password", "bloggs") }; post.setRequestBody(data); ... InputStream in = post.getResponseBodyAsStream();
URL url = new URL("https: URLConnection con = url.openConnection(); HttpURLConnection http = (HttpURLConnection)con; http.setRequestMethod("POST"); http.setDoOutput(true);
Map<String,String> arguments = new HashMap<>(); arguments.put("username", "root"); arguments.put("password", "sjh76HSn!"); StringJoiner sj = new StringJoiner("&"); for(Map.Entry<String,String> entry : arguments.entrySet()) sj.add(URLEncoder.encode(entry.getKey(), "UTF-8") + "=" + URLEncoder.encode(entry.getValue(), "UTF-8")); byte[] out = sj.toString().getBytes(StandardCharsets.UTF_8); int length = out.length;
http.setFixedLengthStreamingMode(length); http.setRequestProperty("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"); http.connect(); try(OutputStream os = http.getOutputStream()) { os.write(out); }
byte[] out = "{\"username\":\"root\",\"password\":\"password\"}" .getBytes(StandardCharsets.UTF_8); int length = out.length; http.setFixedLengthStreamingMode(length); http.setRequestProperty("Content-Type", "application/json; charset=UTF-8"); http.connect(); try(OutputStream os = http.getOutputStream()) { os.write(out); }
private void sendFile(OutputStream out, String name, InputStream in, String fileName) { String o = "Content-Disposition: form-data; name=\"" + URLEncoder.encode(name,"UTF-8") + "\"; filename=\"" + URLEncoder.encode(filename,"UTF-8") + "\"\r\n\r\n"; out.write(o.getBytes(StandardCharsets.UTF_8)); byte[] buffer = new byte[2048]; for (int n = 0; n >= 0; n = in.read(buffer)) out.write(buffer, 0, n); out.write("\r\n".getBytes(StandardCharsets.UTF_8)); } private void sendField(OutputStream out, String name, String field) { String o = "Content-Disposition: form-data; name=\"" + URLEncoder.encode(name,"UTF-8") + "\"\r\n\r\n"; out.write(o.getBytes(StandardCharsets.UTF_8)); out.write(URLEncoder.encode(field,"UTF-8").getBytes(StandardCharsets.UTF_8)); out.write("\r\n".getBytes(StandardCharsets.UTF_8)); }
String boundary = UUID.randomUUID().toString(); byte[] boundaryBytes = ("--" + boundary + "\r\n").getBytes(StandardCharsets.UTF_8); byte[] finishBoundaryBytes = ("--" + boundary + "--").getBytes(StandardCharsets.UTF_8); http.setRequestProperty("Content-Type", "multipart/form-data; charset=UTF-8; boundary=" + boundary); http.setChunkedStreamingMode(0); try(OutputStream out = http.getOutputStream()) { out.write(boundaryBytes); sendField(out, "username", "root"); out.write(boundaryBytes); sendField(out, "password", "toor"); out.write(boundaryBytes); try(InputStream file = new FileInputStream("test.txt")) { sendFile(out, "identification", file, "text.txt"); } out.write(finishBoundaryBytes); }
String rawData = "id=10"; String type = "application/x-www-form-urlencoded"; String encodedData = URLEncoder.encode( rawData, "UTF-8" ); URL u = new URL("http: HttpURLConnection conn = (HttpURLConnection) u.openConnection(); conn.setDoOutput(true); conn.setRequestMethod("POST"); conn.setRequestProperty( "Content-Type", type ); conn.setRequestProperty( "Content-Length", String.valueOf(encodedData.length())); OutputStream os = conn.getOutputStream(); os.write(encodedData.getBytes());
/* * Create the POST request */ HttpClient httpClient = new DefaultHttpClient(); HttpPost httpPost = new HttpPost("http: List<NameValuePair> params = new ArrayList<NameValuePair>(); params.add(new BasicNameValuePair("user", "Bob")); try { httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } /* * Execute the HTTP Request */ try { HttpResponse response = httpClient.execute(httpPost); HttpEntity respEntity = response.getEntity(); if (respEntity != null) { String content = EntityUtils.toString(respEntity); } } catch (ClientProtocolException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }
Request.Post("http: .bodyForm(Form.form().add("id", "10").build()) .execute() .returnContent();
String postURL = "http: HttpPost post = new HttpPost(postURL); List<NameValuePair> params = new ArrayList<NameValuePair>(); params.add(new BasicNameValuePair("id", "10")); UrlEncodedFormEntity ent = new UrlEncodedFormEntity(params, "UTF-8"); post.setEntity(ent); HttpClient client = new DefaultHttpClient(); HttpResponse responsePOST = client.execute(post);
BufferedReader reader = new BufferedReader(new InputStreamReader(responsePOST.getEntity().getContent()), 2048); if (responsePOST != null) { StringBuilder sb = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { System.out.println(" line : " + line); sb.append(line); } String getResponseString = ""; getResponseString = sb.toString(); }
HttpRequest<String> httpRequest = HttpRequestBuilder.createPost("http: .responseDeserializer(ResponseDeserializer.ignorableDeserializer()).build(); public void send(){ String response = httpRequest.execute("id", "10").get(); }
Map<String, ?> myMap = gpxlist.getAll(); Set<String> myset = myMap.keySet(); String[] GPXFILES1 = (String[]) myset.toArray();
String[] GPXFILES1 = myset.toArray(new String[myset.size()]);
String[] array = set.stream().toArray(String[]::new);
String[] array = set.stream().toArray(n -> new String[n]);
Set<String> myset = myMap.keySet(); FluentIterable.from(mySet).toArray(String.class);
Set<String> stringSet= new HashSet<>(); String[] s = (String[])stringSet.toArray();
Set<String> set = Set.of("one", "two", "three"); String[] array = set.toArray(String[]::new)
List list = new ArrayList(coll); Collections.sort(list);
List list; if (coll instanceof List) list = (List)coll; else list = new ArrayList(coll);
List list; if (coll instanceof List) list = (List)coll; else list = new ArrayList(coll); Collections.sort(list);
@GwtCompatible(serializable = true) public static <E> ArrayList<E> newArrayList(Iterable<? extends E> elements) { checkNotNull(elements); return (elements instanceof Collection) ? new ArrayList<E>(Collections2.cast(elements)) : newArrayList(elements.iterator()); }
class MyCustomCollection implements Map<K, V> { TreeBidiMap<K, V> map; TreeMultiset<V> multiset; public V put(K key, V value) { removeValue(map.put(key, value)); multiset.add(value); } public boolean remove(K key) { removeValue(map.remove(key)); } /** removes value that was removed/replaced in map */ private removeValue(V value) { if (value != null) { multiset.remove(value); } } public Set keySet() { return map.keySet(); } public Multiset values() { return multiset; } }
import java.util.Collections; import java.util.List; public class Person { private String name; private List<String> nicknames; public Person(String name) { this(name,Collections.emptyList()); } public Person(String name,List<String> nicknames) { this.name = name; this.nicknames = nicknames; } }
Person.java:9: The constructor Person(String, List<Object>) is undefined
public Person(String name) { this(name,(List<String>)Collections.emptyList()); }
public Person(String name) { this(name,Collections.EMPTY_LIST); }
Person.java:9: warning: [unchecked] unchecked conversion
public Person(String name) { this.name = name; this.nicknames = Collections.emptyList(); }
public Person(String name) { this(name,Collections.<String>emptyList()); }
public Person(String name) { List<String> emptyList = Collections.emptyList(); this(name, emptyList); }
Stream<String> s = ...; long emptyStrings = s.filter(String::isEmpty).count();
long nonEmptyStrings = s.filter(not(String::isEmpty)).count();
static <T> Predicate<T> not(Predicate<T> p) { return o -> !p.test(o); }
Stream<String> s = ...; long nonEmptyStrings = s.filter(Predicate.not(String::isEmpty)).count();
public static <T> Predicate<T> not(Predicate<T> t) { return t.negate(); }
Stream<String> s = ...; long nonEmptyStrings = s.filter(not(String::isEmpty)).count();
Stream<String> s = ...; int emptyStrings = s.filter(String::isEmpty).count();
Stream<String> s = ...; int notEmptyStrings = s.filter(((Predicate<String>) String::isEmpty).negate()).count()
Stream<String> s = ...; int notEmptyStrings = s.filter( it -> !it.isEmpty() ).count();
Predicate<String> notEmpty = (String it) -> !it.isEmpty(); Stream<String> s = ...; int notEmptyStrings = s.filter(notEmpty).count();
int notEmpty = 0; for(String s : list) if(!s.isEmpty()) notEmpty++;
Stream<String> s = ...; int notEmptyStrings = s.count(it -> !it.isEmpty()); or List<String> list = ...; int notEmptyStrings = lists.count(it -> !it.isEmpty());
s.filter(((Predicate<String>) String::isEmpty).negate()).count()
Object obj1 = String::isEmpty; Predicate<String> p1 = s -> s.isEmpty(); Function<String, Boolean> f1 = String::isEmpty; Object obj2 = p1; Function<String, Boolean> f2 = (Function<String, Boolean>) obj2; Function<String, Boolean> f3 = p1::test; Predicate<Integer> p2 = s -> s.isEmpty(); Predicate<Integer> p3 = String::isEmpty;
Predicate<String> blank = String::isEmpty; content.stream() .filter(blank.negate())
public static class Lambdas { public static <T> Predicate<T> as(Predicate<T> predicate){ return predicate; } public static <T> Consumer<T> as(Consumer<T> consumer){ return consumer; } public static <T> Supplier<T> as(Supplier<T> supplier){ return supplier; } public static <T, R> Function<T, R> as(Function<T, R> function){ return function; } }
int nonEmptyStrings = s.filter(StringUtils::isNotEmpty).count();
MutableList<String> strings = Lists.mutable.empty(); int nonEmptyStrings = strings.count(Predicates.not(String::isEmpty));
List<String> strings = new ArrayList<>(); int nonEmptyStrings = ListAdapter.adapt(strings).count(Predicates.not(String::isEmpty));
public class FunctionCastUtil { public static <T, U> BiConsumer<T, U> asBiConsumer(BiConsumer<T, U> biConsumer) { return biConsumer; } public static <T, U, R> BiFunction<T, U, R> asBiFunction(BiFunction<T, U, R> biFunction) { return biFunction; } public static <T> BinaryOperator<T> asBinaryOperator(BinaryOperator<T> binaryOperator) { return binaryOperator; } ... and so on... }
import org.springframework.util.StringUtils; ... .filter(StringUtils::hasLength) ...
{ "header" : { "alerts" : [ { "AlertID" : "2", "TSExpires" : null, "Target" : "1", "Text" : "woot", "Type" : "1" }, { "AlertID" : "3", "TSExpires" : null, "Target" : "1", "Text" : "woot", "Type" : "1" } ], "session" : "0bc8d0835f93ac3ebbf11560b2c5be9a" }, "result" : "4be26bc400d3c" }
import java.lang.reflect.Type; import com.google.gson.reflect.TypeToken; Type type = new TypeToken<Map<String, String>>(){}.getType(); Map<String, String> myMap = gson.fromJson("{
Gson gson = new Gson(); String json = "{\"k1\":\"v1\",\"k2\":\"v2\"}"; Map<String,Object> map = new HashMap<String,Object>(); map = (Map<String,Object>) gson.fromJson(json, map.getClass());
private static class NaturalDeserializer implements JsonDeserializer<Object> { public Object deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) { if(json.isJsonNull()) return null; else if(json.isJsonPrimitive()) return handlePrimitive(json.getAsJsonPrimitive()); else if(json.isJsonArray()) return handleArray(json.getAsJsonArray(), context); else return handleObject(json.getAsJsonObject(), context); } private Object handlePrimitive(JsonPrimitive json) { if(json.isBoolean()) return json.getAsBoolean(); else if(json.isString()) return json.getAsString(); else { BigDecimal bigDec = json.getAsBigDecimal(); try { bigDec.toBigIntegerExact(); try { return bigDec.intValueExact(); } catch(ArithmeticException e) {} return bigDec.longValue(); } catch(ArithmeticException e) {} return bigDec.doubleValue(); } } private Object handleArray(JsonArray json, JsonDeserializationContext context) { Object[] array = new Object[json.size()]; for(int i = 0; i < array.length; i++) array[i] = context.deserialize(json.get(i), Object.class); return array; } private Object handleObject(JsonObject json, JsonDeserializationContext context) { Map<String, Object> map = new HashMap<String, Object>(); for(Map.Entry<String, JsonElement> entry : json.entrySet()) map.put(entry.getKey(), context.deserialize(entry.getValue(), Object.class)); return map; } }
GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(Object.class, new NaturalDeserializer()); Gson gson = gsonBuilder.create();
Object natural = gson.fromJson(source, Object.class);
String nestedJSON = "{"id":"1","message":"web_didload","content":{"success":1}}; Gson gson = new Gson(); LinkedTreeMap result = gson.fromJson(nestedJSON , LinkedTreeMap.class);
String jsonString = "{ Map map = gson.fromJson(jsonString, Map.class); System.out.println(map.getClass().toString()); System.out.println(map);
class com.google.gson.internal.LinkedTreeMap {header={alerts=[{AlertID=2, TSExpires=null, Target=1, Text=woot, Type=1}, {AlertID=3, TSExpires=null, Target=1, Text=woot, Type=1}], session=0bc8d0835f93ac3ebbf11560b2c5be9a}, result=4be26bc400d3c}
Gson gson = new Gson(); Map jsonObject = (Map) gson.fromJson(data, Object.class);
{ "map-00": { "array-00": [ "entry-00", "entry-01" ], "value": "entry-02" } }
Map map00 = (Map) jsonObject.get("map-00"); List array00 = (List) map00.get("array-00"); String value = (String) map00.get("value"); for (int i = 0; i < array00.size(); i++) { System.out.println("map-00.array-00[" + i + "]= " + array00.get(i)); } System.out.println("map-00.value = " + value);
map-00.array-00[0]= entry-00 map-00.array-00[1]= entry-01 map-00.value = entry-02
Map json = gson.fromJson(data, Object.class); if(json.get("field") instanceof Map) { Map field = (Map)json.get("field"); } else if (json.get("field") instanceof List) { List field = (List)json.get("field"); } ...
public static Hashtable<Integer, KioskStatusResource> parseModifued(String json) { JsonObject object = (JsonObject) new com.google.gson.JsonParser().parse(json); Set<Map.Entry<String, JsonElement>> set = object.entrySet(); Iterator<Map.Entry<String, JsonElement>> iterator = set.iterator(); Hashtable<Integer, KioskStatusResource> map = new Hashtable<Integer, KioskStatusResource>(); while (iterator.hasNext()) { Map.Entry<String, JsonElement> entry = iterator.next(); Integer key = Integer.parseInt(entry.getKey()); KioskStatusResource value = new Gson().fromJson(entry.getValue(), KioskStatusResource.class); if (value != null) { map.put(key, value); } } return map; }
public static Type getMapType(Class keyType, Class valueType){ return TypeToken.getParameterized(HashMap.class, keyType, valueType).getType(); } public static <K,V> HashMap<K,V> fromMap(String json, Class<K> keyType, Class<V> valueType){ return gson.fromJson(json, getMapType(keyType,valueType)); }
public static HashMap<String, Object> parse(String json) { JsonObject object = (JsonObject) parser.parse(json); Set<Map.Entry<String, JsonElement>> set = object.entrySet(); Iterator<Map.Entry<String, JsonElement>> iterator = set.iterator(); HashMap<String, Object> map = new HashMap<String, Object>(); while (iterator.hasNext()) { Map.Entry<String, JsonElement> entry = iterator.next(); String key = entry.getKey(); JsonElement value = entry.getValue(); if (!value.isJsonPrimitive()) { map.put(key, parse(value.toString())); } else { map.put(key, value.getAsString()); } } return map; }
public class MapDeserializer<T, U> implements JsonDeserializer<Map<T, U>>
public Map<T, U> deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { if (!json.isJsonObject()) { return null; } JsonObject jsonObject = json.getAsJsonObject(); Set<Entry<String, JsonElement>> jsonEntrySet = jsonObject.entrySet(); Map<T, U> deserializedMap = new HashMap<T, U>(); for (Entry<java.lang.String, JsonElement> entry : jsonEntrySet) { try { U value = context.deserialize(entry.getValue(), getMyType()); deserializedMap.put((T) entry.getKey(), value); } catch (Exception ex) { logger.info("Could not deserialize map.", ex); } } return deserializedMap; }
HashMap<String, Object> myMap = gson.fromJson(yourJson, new TypeToken<HashMap<String, Object>>(){}.getType());
public class Utility { public static Map<String, Object> jsonToMap(Object json) throws JSONException { if(json instanceof JSONObject) return _jsonToMap_((JSONObject)json) ; else if (json instanceof String) { JSONObject jsonObject = new JSONObject((String)json) ; return _jsonToMap_(jsonObject) ; } return null ; } private static Map<String, Object> _jsonToMap_(JSONObject json) throws JSONException { Map<String, Object> retMap = new HashMap<String, Object>(); if(json != JSONObject.NULL) { retMap = toMap(json); } return retMap; } private static Map<String, Object> toMap(JSONObject object) throws JSONException { Map<String, Object> map = new HashMap<String, Object>(); Iterator<String> keysItr = object.keys(); while(keysItr.hasNext()) { String key = keysItr.next(); Object value = object.get(key); if(value instanceof JSONArray) { value = toList((JSONArray) value); } else if(value instanceof JSONObject) { value = toMap((JSONObject) value); } map.put(key, value); } return map; } public static List<Object> toList(JSONArray array) throws JSONException { List<Object> list = new ArrayList<Object>(); for(int i = 0; i < array.length(); i++) { Object value = array.get(i); if(value instanceof JSONArray) { value = toList((JSONArray) value); } else if(value instanceof JSONObject) { value = toMap((JSONObject) value); } list.add(value); } return list; } }
HashMap<String, Object> hashMap = new HashMap<>(Utility.jsonToMap(response)) ;
private Object handlePrimitive(JsonPrimitive json) { if(json.isBoolean()) { return json.getAsBoolean(); } else if(json.isString()) return json.getAsString(); } Number num = element.getAsNumber(); if(num instanceof Integer){ map.put(fieldName, num.intValue()); } else if(num instanceof Long){ map.put(fieldName, num.longValue()); } else if(num instanceof Float){ map.put(fieldName, num.floatValue()); } else { map.put(fieldName, num.doubleValue()); } }
HashMap<String, String> jsonToMap(String JsonDetectionString) throws JSONException { HashMap<String, String> map = new HashMap<String, String>(); Gson gson = new Gson(); map = (HashMap<String, String>) gson.fromJson(JsonDetectionString, map.getClass()); return map; }
JSONObject obj = JSONObject.fromObject(strRepresentation); Iterator i = obj.entrySet().iterator(); while (i.hasNext()) { Map.Entry e = (Map.Entry)i.next(); System.out.println("Key: " + e.getKey()); System.out.println("Value: " + e.getValue()); }
Gson gson = new Gson(); HashMap<String, Object> fields = gson.fromJson(json, HashMap.class);
<jsp-config> <jsp-property-group> <url-pattern>*.jspf</url-pattern> </jsp-property-group> </jsp-config>
public List<Class> getClasses() throws ClassNotFoundException { List<Class> classes = Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .map(className -> Class.forName(className)) .collect(Collectors.toList()); return classes; }
import java.util.ArrayList; import java.util.List; import java.util.stream.Stream; public class CheckedStream { public List<Class> getClasses(final List<String> names) throws ClassNotFoundException { final List<Class> classes = new ArrayList<>(); for (final String name : names) classes.add(Class.forName(name)); return classes; } public Stream<Class> getClasses(final Stream<String> names) throws ClassNotFoundException { return names.map(Class::forName); } }
cher@armor1:~/playground/Java/checkedStream$ javac CheckedStream.java CheckedStream.java:13: error: incompatible thrown types ClassNotFoundException in method reference return names.map(Class::forName); ^ 1 error
import java.io.IOException; interface Function<T, R, E extends Throwable> { R apply(T t) throws E; } interface Stream<T> { <R, E extends Throwable> Stream<R> map(Function<? super T, ? extends R, E> mapper) throws E; } class Main { public static void main(final String... args) throws ClassNotFoundException { final Stream<String> s = null; s.map(Class::forName); s.map(Main::convertClass); s.map(Main::throwSome); s.map(Main::throwSomeMore); } public static Class convertClass(final String s) { return Main.class; } static class FooException extends ClassNotFoundException {} static class BarException extends ClassNotFoundException {} public static Class throwSome(final String s) throws FooException, BarException { throw new FooException(); } public static Class throwSomeMore(final String s) throws ClassNotFoundException, IOException { throw new FooException(); } }
Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .map(rethrowFunction(Class::forName)) .collect(Collectors.toList());
public final class LambdaExceptionUtil { @FunctionalInterface public interface Consumer_WithExceptions<T, E extends Exception> { void accept(T t) throws E; } @FunctionalInterface public interface BiConsumer_WithExceptions<T, U, E extends Exception> { void accept(T t, U u) throws E; } @FunctionalInterface public interface Function_WithExceptions<T, R, E extends Exception> { R apply(T t) throws E; } @FunctionalInterface public interface Supplier_WithExceptions<T, E extends Exception> { T get() throws E; } @FunctionalInterface public interface Runnable_WithExceptions<E extends Exception> { void run() throws E; } /** .forEach(rethrowConsumer(name -> System.out.println(Class.forName(name)))); or .forEach(rethrowConsumer(ClassNameUtil::println)); */ public static <T, E extends Exception> Consumer<T> rethrowConsumer(Consumer_WithExceptions<T, E> consumer) throws E { return t -> { try { consumer.accept(t); } catch (Exception exception) { throwAsUnchecked(exception); } }; } public static <T, U, E extends Exception> BiConsumer<T, U> rethrowBiConsumer(BiConsumer_WithExceptions<T, U, E> biConsumer) throws E { return (t, u) -> { try { biConsumer.accept(t, u); } catch (Exception exception) { throwAsUnchecked(exception); } }; } /** .map(rethrowFunction(name -> Class.forName(name))) or .map(rethrowFunction(Class::forName)) */ public static <T, R, E extends Exception> Function<T, R> rethrowFunction(Function_WithExceptions<T, R, E> function) throws E { return t -> { try { return function.apply(t); } catch (Exception exception) { throwAsUnchecked(exception); return null; } }; } /** rethrowSupplier(() -> new StringJoiner(new String(new byte[]{77, 97, 114, 107}, "UTF-8"))), */ public static <T, E extends Exception> Supplier<T> rethrowSupplier(Supplier_WithExceptions<T, E> function) throws E { return () -> { try { return function.get(); } catch (Exception exception) { throwAsUnchecked(exception); return null; } }; } /** uncheck(() -> Class.forName("xxx")); */ public static void uncheck(Runnable_WithExceptions t) { try { t.run(); } catch (Exception exception) { throwAsUnchecked(exception); } } /** uncheck(() -> Class.forName("xxx")); */ public static <R, E extends Exception> R uncheck(Supplier_WithExceptions<R, E> supplier) { try { return supplier.get(); } catch (Exception exception) { throwAsUnchecked(exception); return null; } } /** uncheck(Class::forName, "xxx"); */ public static <T, R, E extends Exception> R uncheck(Function_WithExceptions<T, R, E> function, T t) { try { return function.apply(t); } catch (Exception exception) { throwAsUnchecked(exception); return null; } } @SuppressWarnings ("unchecked") private static <E extends Throwable> void throwAsUnchecked(Exception exception) throws E { throw (E)exception; } }
@Test public void test_Consumer_with_checked_exceptions() throws IllegalAccessException { Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .forEach(rethrowConsumer(className -> System.out.println(Class.forName(className)))); Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .forEach(rethrowConsumer(System.out::println)); } @Test public void test_Function_with_checked_exceptions() throws ClassNotFoundException { List<Class> classes1 = Stream.of("Object", "Integer", "String") .map(rethrowFunction(className -> Class.forName("java.lang." + className))) .collect(Collectors.toList()); List<Class> classes2 = Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .map(rethrowFunction(Class::forName)) .collect(Collectors.toList()); } @Test public void test_Supplier_with_checked_exceptions() throws ClassNotFoundException { Collector.of( rethrowSupplier(() -> new StringJoiner(new String(new byte[]{77, 97, 114, 107}, "UTF-8"))), StringJoiner::add, StringJoiner::merge, StringJoiner::toString); } @Test public void test_uncheck_exception_thrown_by_method() { Class clazz1 = uncheck(() -> Class.forName("java.lang.String")); Class clazz2 = uncheck(Class::forName, "java.lang.String"); } @Test (expected = ClassNotFoundException.class) public void test_if_correct_exception_is_still_thrown_by_method() { Class clazz3 = uncheck(Class::forName, "INVALID"); }
class WrappedException extends RuntimeException { Throwable cause; WrappedException(Throwable cause) { this.cause = cause; } } static WrappedException throwWrapped(Throwable t) { throw new WrappedException(t); } try source.stream() .filter(e -> { ... try { ... } catch (IOException e) { throwWrapped(e); } ... }) ... } catch (WrappedException w) { throw (IOException) w.cause; }
public final class LambdaExceptionUtil { @FunctionalInterface public interface Consumer_WithExceptions<T, E extends Exception> { void accept(T t) throws E; } @FunctionalInterface public interface Function_WithExceptions<T, R, E extends Exception> { R apply(T t) throws E; } /** * .forEach(rethrowConsumer(name -> System.out.println(Class.forName(name)))); */ public static <T, E extends Exception> Consumer<T> rethrowConsumer(Consumer_WithExceptions<T, E> consumer) throws E { return t -> { try { consumer.accept(t); } catch (Exception exception) { throwActualException(exception); } }; } /** * .map(rethrowFunction(name -> Class.forName(name))) or .map(rethrowFunction(Class::forName)) */ public static <T, R, E extends Exception> Function<T, R> rethrowFunction(Function_WithExceptions<T, R, E> function) throws E { return t -> { try { return function.apply(t); } catch (Exception exception) { throwActualException(exception); return null; } }; } @SuppressWarnings("unchecked") private static <E extends Exception> void throwActualException(Exception exception) throws E { throw (E) exception; } }
public class LambdaExceptionUtilTest { @Test(expected = MyTestException.class) public void testConsumer() throws MyTestException { Stream.of((String)null).forEach(rethrowConsumer(s -> checkValue(s))); } private void checkValue(String value) throws MyTestException { if(value==null) { throw new MyTestException(); } } private class MyTestException extends Exception { } @Test public void testConsumerRaisingExceptionInTheMiddle() { MyLongAccumulator accumulator = new MyLongAccumulator(); try { Stream.of(2L, 3L, 4L, null, 5L).forEach(rethrowConsumer(s -> accumulator.add(s))); fail(); } catch (MyTestException e) { assertEquals(9L, accumulator.acc); } } private class MyLongAccumulator { private long acc = 0; public void add(Long value) throws MyTestException { if(value==null) { throw new MyTestException(); } acc += value; } } @Test public void testFunction() throws MyTestException { List<Integer> sizes = Stream.of("ciao", "hello").<Integer>map(rethrowFunction(s -> transform(s))).collect(toList()); assertEquals(2, sizes.size()); assertEquals(4, sizes.get(0).intValue()); assertEquals(5, sizes.get(1).intValue()); } private Integer transform(String value) throws MyTestException { if(value==null) { throw new MyTestException(); } return value.length(); } @Test(expected = MyTestException.class) public void testFunctionRaisingException() throws MyTestException { Stream.of("ciao", null, "hello").<Integer>map(rethrowFunction(s -> transform(s))).collect(toList()); } }
stream.map(Exceptions.sneak().function(Class::forName)); stream.map(Unchecked.function(Class::forName)); stream.map(Throwing.function(Class::forName).sneakyThrow()); stream.map(FunctionWithThrowable.aFunctionThatUnsafelyThrowsUnchecked(Class::forName)); stream.map(FauxPas.throwingFunction(Class::forName));
public List<Class> getClasses() throws ClassNotFoundException { Stream<String> classNames = Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String"); return ThrowingStream.of(classNames, ClassNotFoundException.class) .map(Class::forName) .collect(Collectors.toList()); }
List test = new ArrayList(); try { test.forEach(obj -> { try { throw new IOException("test"); } catch(Exception e) { throw new RuntimeException(e); } }); } catch (RuntimeException re) { if(re.getCause() instanceof IOException) { } else throw re; }
import static com.github.fge.lambdas.functions.Functions.wrap; final ThrowingFunction<String, Class<?>> f = wrap(Class::forName); List<Class> classes = Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .map(f.orThrow(MyException.class)) .collect(Collectors.toList());
Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .map(Try.<String, Class<?>>safe(Class::forName) .handle(System.out::println) .unsafe()) .collect(toList());
final class Try { public static <T> CheckedBuilder<Supplier<T>, CheckedSupplier<T>, T> safe(CheckedSupplier<T> supplier) { return new CheckedWrapper<>(supplier, (current, next, handler, orResult) -> () -> { try { return current.get(); } catch (Exception ex) { handler.accept(ex); return next.isPresent() ? next.get().get() : orResult.apply(ex); } }); } public static <T> Supplier<T> unsafe(CheckedSupplier<T> supplier) { return supplier; } public static <T> CheckedBuilder<Consumer<T>, CheckedConsumer<T>, Void> safe(CheckedConsumer<T> consumer) { return new CheckedWrapper<>(consumer, (current, next, handler, orResult) -> t -> { try { current.accept(t); } catch (Exception ex) { handler.accept(ex); if (next.isPresent()) { next.get().accept(t); } else { orResult.apply(ex); } } }); } public static <T> Consumer<T> unsafe(CheckedConsumer<T> consumer) { return consumer; } public static <T, R> CheckedBuilder<Function<T, R>, CheckedFunction<T, R>, R> safe(CheckedFunction<T, R> function) { return new CheckedWrapper<>(function, (current, next, handler, orResult) -> t -> { try { return current.applyUnsafe(t); } catch (Exception ex) { handler.accept(ex); return next.isPresent() ? next.get().apply(t) : orResult.apply(ex); } }); } public static <T, R> Function<T, R> unsafe(CheckedFunction<T, R> function) { return function; } @SuppressWarnings ("unchecked") static <T, E extends Throwable> T throwAsUnchecked(Throwable exception) throws E { throw (E) exception; } } @FunctionalInterface interface CheckedConsumer<T> extends Consumer<T> { void acceptUnsafe(T t) throws Exception; @Override default void accept(T t) { try { acceptUnsafe(t); } catch (Exception ex) { Try.throwAsUnchecked(ex); } } } @FunctionalInterface interface CheckedFunction<T, R> extends Function<T, R> { R applyUnsafe(T t) throws Exception; @Override default R apply(T t) { try { return applyUnsafe(t); } catch (Exception ex) { return Try.throwAsUnchecked(ex); } } } @FunctionalInterface interface CheckedSupplier<T> extends Supplier<T> { T getUnsafe() throws Exception; @Override default T get() { try { return getUnsafe(); } catch (Exception ex) { return Try.throwAsUnchecked(ex); } } } interface ReduceFunction<TSafe, TUnsafe, R> { TSafe wrap(TUnsafe current, Optional<TSafe> next, Consumer<Throwable> handler, Function<Throwable, R> orResult); } interface CheckedBuilder<TSafe, TUnsafe, R> { CheckedBuilder<TSafe, TUnsafe, R> orTry(TUnsafe next); CheckedBuilder<TSafe, TUnsafe, R> handle(Consumer<Throwable> handler); <E extends Throwable> CheckedBuilder<TSafe, TUnsafe, R> handle( Class<E> exceptionType, Consumer<E> handler); CheckedBuilder<TSafe, TUnsafe, R> handleLast(Consumer<Throwable> handler); <E extends Throwable> CheckedBuilder<TSafe, TUnsafe, R> handleLast( Class<E> exceptionType, Consumer<? super E> handler); TSafe unsafe(); TSafe rethrow(Function<Throwable, Exception> transformer); TSafe suppress(); TSafe orElse(R value); TSafe orElseGet(Supplier<R> valueProvider); } final class CheckedWrapper<TSafe, TUnsafe, R> implements CheckedBuilder<TSafe, TUnsafe, R> { private final TUnsafe function; private final ReduceFunction<TSafe, TUnsafe, R> reduceFunction; private final CheckedWrapper<TSafe, TUnsafe, R> root; private CheckedWrapper<TSafe, TUnsafe, R> next; private Consumer<Throwable> handlers = ex -> { }; private Consumer<Throwable> lastHandlers = ex -> { }; CheckedWrapper(TUnsafe function, ReduceFunction<TSafe, TUnsafe, R> reduceFunction) { this.function = function; this.reduceFunction = reduceFunction; this.root = this; } private CheckedWrapper(TUnsafe function, CheckedWrapper<TSafe, TUnsafe, R> prev) { this.function = function; this.reduceFunction = prev.reduceFunction; this.root = prev.root; prev.next = this; } @Override public CheckedBuilder<TSafe, TUnsafe, R> orTry(TUnsafe next) { return new CheckedWrapper<>(next, this); } @Override public CheckedBuilder<TSafe, TUnsafe, R> handle( Consumer<Throwable> handler) { handlers = handlers.andThen(handler); return this; } @Override public <E extends Throwable> CheckedBuilder<TSafe, TUnsafe, R> handle(Class<E> exceptionType, Consumer<E> handler) { handlers = handlers.andThen(ex -> { if (exceptionType.isInstance(ex)) { handler.accept(exceptionType.cast(ex)); } }); return this; } @Override public CheckedBuilder<TSafe, TUnsafe, R> handleLast( Consumer<Throwable> handler) { lastHandlers = lastHandlers.andThen(handler); return this; } @Override public <E extends Throwable> CheckedBuilder<TSafe, TUnsafe, R> handleLast(Class<E> exceptionType, Consumer<? super E> handler) { lastHandlers = lastHandlers.andThen(ex -> { if (exceptionType.isInstance(ex)) { handler.accept(exceptionType.cast(ex)); } }); return this; } @Override public TSafe unsafe() { return root.reduce(ex -> Try.throwAsUnchecked(ex)); } @Override public TSafe rethrow(Function<Throwable, Exception> transformer) { return root.reduce(ex -> Try.throwAsUnchecked(transformer.apply(ex))); } @Override public TSafe suppress() { return root.reduce(ex -> null); } @Override public TSafe orElse(R value) { return root.reduce(ex -> value); } @Override public TSafe orElseGet(Supplier<R> valueProvider) { Objects.requireNonNull(valueProvider); return root.reduce(ex -> valueProvider.get()); } private TSafe reduce(Function<Throwable, R> orResult) { return reduceFunction.wrap(function, Optional.ofNullable(next).map(p -> p.reduce(orResult)), this::handle, orResult); } private void handle(Throwable ex) { for (CheckedWrapper<TSafe, TUnsafe, R> current = this; current != null; current = current.next) { current.handlers.accept(ex); } lastHandlers.accept(ex); } }
public class CheckedExceptionWrapper extends RuntimeException { ... public <T extends Exception> CheckedExceptionWrapper rethrow() throws T { throw (T) getCause(); } }
void method() throws IOException, ServletException { try { list.stream().forEach(object -> { ... throw new CheckedExceptionWrapper(e); ... }); } catch (CheckedExceptionWrapper e){ e.<IOException>rethrow(); e.<ServletExcepion>rethrow(); } }
public List<Class> getClasses() throws ClassNotFoundException { List<Class> classes = Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .map(className -> getClass(className)) .collect(Collectors.toList()); return classes; } @SneakyThrows private Class<?> getClass(String className) { return Class.forName(className); }
@FunctionalInterface public interface UseInstance<T, X extends Throwable> { void accept(T instance) throws X; }
import java.io.FileWriter; import java.io.IOException; public class FileWriterEAM { private final FileWriter writer; private FileWriterEAM(final String fileName) throws IOException { writer = new FileWriter(fileName); } private void close() throws IOException { System.out.println("close called automatically..."); writer.close(); } public void writeStuff(final String message) throws IOException { writer.write(message); } public static void use(final String fileName, final UseInstance<FileWriterEAM, IOException> block) throws IOException { final FileWriterEAM writerEAM = new FileWriterEAM(fileName); try { block.accept(writerEAM); } finally { writerEAM.close(); } } public static void main(final String[] args) throws IOException { FileWriterEAM.use("eam.txt", writerEAM -> writerEAM.writeStuff("sweet")); FileWriterEAM.use("eam2.txt", writerEAM -> { writerEAM.writeStuff("how"); writerEAM.writeStuff("sweet"); }); FileWriterEAM.use("eam3.txt", FileWriterEAM::writeIt); } void writeIt() throws IOException{ this.writeStuff("How "); this.writeStuff("sweet "); this.writeStuff("it is"); } }
CompletableFuture<List<Class<?>>> classes = Stream.of("java.lang.String", "java.lang.Integer", "java.lang.Double") .map(MonadUtils.applyOrDie(Class::forName)) .map(cfc -> cfc.thenApply(Class::getSuperclass)) .collect(MonadUtils.cfCollector(ArrayList::new, List::add, (List<Class<?>> l1, List<Class<?>> l2) -> { l1.addAll(l2); return l1; }, x -> x)); classes.thenAccept(System.out::println) .exceptionally(t -> { System.out.println("unable to get class: " + t); return null; });
[class java.lang.Object, class java.lang.Number, class java.lang.Number]
public List<Class> getClasses() throws ClassNotFoundException { List<Class> classes; try { classes = Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String").map(className -> { try { return Class.forName(className); } catch (ClassNotFoundException e) { throw new UndeclaredThrowableException(e); } }).collect(Collectors.toList()); } catch (UndeclaredThrowableException e) { if (e.getCause() instanceof ClassNotFoundException) { throw (ClassNotFoundException) e.getCause(); } else { throw new IllegalStateException(e.getMessage(), e); } } return classes; }
interface CheckedFunction<I, O> { O apply(I i) throws Exception; } static <I, O> Function<I, O> unchecked(CheckedFunction<I, O> f) { return i -> { try { return f.apply(i); } catch(Exception ex) { throw new RuntimeException(ex); } } } fileNamesToRead.map(unchecked(file -> Files.readAllLines(file)))
@SuppressWarnings("unchecked") private static <T, E extends Exception> T throwUnchecked(Exception e) throws E { throw (E) e; } static <I, O> Function<I, O> unchecked(CheckedFunction<I, O> f) { return arg -> { try { return f.apply(arg); } catch(Exception ex) { return throwUnchecked(ex); } }; }
System.out.println(Inet4Address.getLocalHost().getHostAddress());
System.out.println(InetAddress.getLocalHost().getHostAddress());
Enumeration e = NetworkInterface.getNetworkInterfaces(); while(e.hasMoreElements()) { NetworkInterface n = (NetworkInterface) e.nextElement(); Enumeration ee = n.getInetAddresses(); while (ee.hasMoreElements()) { InetAddress i = (InetAddress) ee.nextElement(); System.out.println(i.getHostAddress()); } }
import java.net.DatagramSocket; try(final DatagramSocket socket = new DatagramSocket()){ socket.connect(InetAddress.getByName("8.8.8.8"), 10002); ip = socket.getLocalAddress().getHostAddress(); }
/** * Returns an <code>InetAddress</code> object encapsulating what is most likely the machine * <p/> * This method is intended for use as a replacement of JDK method <code>InetAddress.getLocalHost</code>, because * that method is ambiguous on Linux systems. Linux systems enumerate the loopback network interface the same * way as regular LAN network interfaces, but the JDK <code>InetAddress.getLocalHost</code> method does not * specify the algorithm used to select the address returned under such circumstances, and will often return the * loopback address, which is not valid for network communication. Details * <a href="http: * <p/> * This method will scan all IP addresses on all network interfaces on the host machine to determine the IP address * most likely to be the machine * a site-local IP address (e.g. 192.168.x.x or 10.10.x.x, usually IPv4) if the machine has one (and will return the * first site-local address if the machine has more than one), but if the machine does not hold a site-local * address, this method will return simply the first non-loopback address found (IPv4 or IPv6). * <p/> * If this method cannot find a non-loopback address using this selection algorithm, it will fall back to * calling and returning the result of JDK method <code>InetAddress.getLocalHost</code>. * <p/> * * @throws UnknownHostException If the LAN address of the machine cannot be found. */ private static InetAddress getLocalHostLANAddress() throws UnknownHostException { try { InetAddress candidateAddress = null; for (Enumeration ifaces = NetworkInterface.getNetworkInterfaces(); ifaces.hasMoreElements();) { NetworkInterface iface = (NetworkInterface) ifaces.nextElement(); for (Enumeration inetAddrs = iface.getInetAddresses(); inetAddrs.hasMoreElements();) { InetAddress inetAddr = (InetAddress) inetAddrs.nextElement(); if (!inetAddr.isLoopbackAddress()) { if (inetAddr.isSiteLocalAddress()) { return inetAddr; } else if (candidateAddress == null) { candidateAddress = inetAddr; } } } } if (candidateAddress != null) { return candidateAddress; } InetAddress jdkSuppliedAddress = InetAddress.getLocalHost(); if (jdkSuppliedAddress == null) { throw new UnknownHostException("The JDK InetAddress.getLocalHost() method unexpectedly returned null."); } return jdkSuppliedAddress; } catch (Exception e) { UnknownHostException unknownHostException = new UnknownHostException("Failed to determine LAN address: " + e); unknownHostException.initCause(e); throw unknownHostException; } }
InetAddress IP=InetAddress.getLocalHost(); System.out.println("IP of my system is := "+IP.getHostAddress());
InetAddress IP=InetAddress.getLocalHost(); System.out.println(IP.toString());
Socket socket = new Socket(); socket.connect(new InetSocketAddress("google.com", 80)); System.out.println(socket.getLocalAddress());
import java.io.*; import java.net.*; public class GetMyIP { public static void main(String[] args) { URL url = null; BufferedReader in = null; String ipAddress = ""; try { url = new URL("http: in = new BufferedReader(new InputStreamReader(url.openStream())); ipAddress = in.readLine().trim(); /* IF not connected to internet, then * the above code will return one empty * String, we can check it * if length is not greater than zero, * then we can go for LAN IP or Local IP * or PRIVATE IP */ if (!(ipAddress.length() > 0)) { try { InetAddress ip = InetAddress.getLocalHost(); System.out.println((ip.getHostAddress()).trim()); ipAddress = (ip.getHostAddress()).trim(); } catch(Exception exp) { ipAddress = "ERROR"; } } } catch (Exception ex) { try { InetAddress ip = InetAddress.getLocalHost(); System.out.println((ip.getHostAddress()).trim()); ipAddress = (ip.getHostAddress()).trim(); } catch(Exception exp) { ipAddress = "ERROR"; } } System.out.println("IP Address: " + ipAddress); } }
private String getIP() { try { URL url = new URL("http: BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String ipAddress = new String(); ipAddress = (in.readLine()).trim(); /* IF not connected to internet, then * the above code will return one empty * String, we can check it * if length is not greater than zero, * then we can go for LAN IP or Local IP * or PRIVATE IP */ if (!(ipAddress.length() > 0)) { try { InetAddress ip = InetAddress.getLocalHost(); System.out.println((ip.getHostAddress()).trim()); return ((ip.getHostAddress()).trim()); } catch(Exception ex) { return "ERROR"; } } System.out.println("IP Address is : " + ipAddress); return (ipAddress); } catch(Exception e) { try { InetAddress ip = InetAddress.getLocalHost(); System.out.println((ip.getHostAddress()).trim()); return ((ip.getHostAddress()).trim()); } catch(Exception ex) { return "ERROR"; } } }
InetAddress iAddress = InetAddress.getLocalHost(); String currentIp = iAddress.getHostAddress(); System.out.println("Current IP address : " +currentIp);
private static InetAddress getLocalAddress(){ try { Enumeration<NetworkInterface> b = NetworkInterface.getNetworkInterfaces(); while( b.hasMoreElements()){ for ( InterfaceAddress f : b.nextElement().getInterfaceAddresses()) if ( f.getAddress().isSiteLocalAddress()) return f.getAddress(); } } catch (SocketException e) { e.printStackTrace(); } return null; }
import java.net.InetAddress; import java.net.NetworkInterface; import java.net.SocketException; import java.net.UnknownHostException; import java.util.Enumeration; /** * Class that allows a device to identify itself on the INTRANET. * * @author Decoded4620 2016 */ public class NetIdentity { private String loopbackHost = ""; private String host = ""; private String loopbackIp = ""; private String ip = ""; public NetIdentity(){ try{ Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); while(interfaces.hasMoreElements()){ NetworkInterface i = interfaces.nextElement(); if(i != null){ Enumeration<InetAddress> addresses = i.getInetAddresses(); System.out.println(i.getDisplayName()); while(addresses.hasMoreElements()){ InetAddress address = addresses.nextElement(); String hostAddr = address.getHostAddress(); if(hostAddr.indexOf("127.") == 0 ){ this.loopbackIp = address.getHostAddress(); this.loopbackHost = address.getHostName(); } if( hostAddr.indexOf("192.168") == 0 || hostAddr.indexOf("10.") == 0 || hostAddr.indexOf("172.16") == 0 ){ this.host = address.getHostName(); this.ip = address.getHostAddress(); } System.out.println("\t\t-" + address.getHostName() + ":" + address.getHostAddress() + " - "+ address.getAddress()); } } } } catch(SocketException e){ } try{ InetAddress loopbackIpAddress = InetAddress.getLocalHost(); this.loopbackIp = loopbackIpAddress.getHostName(); System.out.println("LOCALHOST: " + loopbackIp); } catch(UnknownHostException e){ System.err.println("ERR: " + e.toString()); } } public String getLoopbackHost(){ return loopbackHost; } public String getHost(){ return host; } public String getIp(){ return ip; } public String getLoopbackIp(){ return loopbackIp; } }
Software Loopback Interface 1 -127.0.0.1:127.0.0.1 - [B@19e1023e -0:0:0:0:0:0:0:1:0:0:0:0:0:0:0:1 - [B@7cef4e59 Broadcom 802.11ac Network Adapter -VIKING.yourisp.com:192.168.1.142 - [B@64b8f8f4 -fe80:0:0:0:81fa:31d:21c9:85cd%wlan0:fe80:0:0:0:81fa:31d:21c9:85cd%wlan0 - [B@2db0f6b2 Microsoft Kernel Debug Network Adapter Intel Edison USB RNDIS Device Driver for user-mode network applications Cisco Systems VPN Adapter for 64-bit Windows VirtualBox Host-Only Ethernet Adapter -VIKING:192.168.56.1 - [B@3cd1f1c8 -VIKING:fe80:0:0:0:d599:3cf0:5462:cb7%eth4 - [B@3a4afd8d LogMeIn Hamachi Virtual Ethernet Adapter -VIKING:25.113.118.39 - [B@1996cd68 -VIKING:2620:9b:0:0:0:0:1971:7627 - [B@3339ad8e -VIKING:fe80:0:0:0:51bf:994d:4656:8486%eth5 - [B@555590 Bluetooth Device (Personal Area Network) -fe80:0:0:0:4c56:8009:2bca:e16b%eth6:fe80:0:0:0:4c56:8009:2bca:e16b%eth6 - [B@3c679bde Bluetooth Device (RFCOMM Protocol TDI) Intel(R) Ethernet Connection (2) I218-V -fe80:0:0:0:4093:d169:536c:7c7c%eth7:fe80:0:0:0:4093:d169:536c:7c7c%eth7 - [B@16b4a017 Microsoft Wi-Fi Direct Virtual Adapter -fe80:0:0:0:103e:cdf0:c0ac:1751%wlan1:fe80:0:0:0:103e:cdf0:c0ac:1751%wlan1 - [B@8807e25 VirtualBox Host-Only Ethernet Adapter-HHD Software NDIS 6.0 Filter Driver-0000 VirtualBox Host-Only Ethernet Adapter-WFP Native MAC Layer LightWeight Filter-0000 VirtualBox Host-Only Ethernet Adapter-HHD Software NDIS 6.0 Filter Driver-0001 VirtualBox Host-Only Ethernet Adapter-HHD Software NDIS 6.0 Filter Driver-0002 VirtualBox Host-Only Ethernet Adapter-VirtualBox NDIS Light-Weight Filter-0000 VirtualBox Host-Only Ethernet Adapter-HHD Software NDIS 6.0 Filter Driver-0003 VirtualBox Host-Only Ethernet Adapter-QoS Packet Scheduler-0000 VirtualBox Host-Only Ethernet Adapter-HHD Software NDIS 6.0 Filter Driver-0004 VirtualBox Host-Only Ethernet Adapter-WFP 802.3 MAC Layer LightWeight Filter-0000 VirtualBox Host-Only Ethernet Adapter-HHD Software NDIS 6.0 Filter Driver-0005 Intel(R) Ethernet Connection (2) I218-V-HHD Software NDIS 6.0 Filter Driver-0000 Intel(R) Ethernet Connection (2) I218-V-WFP Native MAC Layer LightWeight Filter-0000 Intel(R) Ethernet Connection (2) I218-V-HHD Software NDIS 6.0 Filter Driver-0001 Intel(R) Ethernet Connection (2) I218-V-Shrew Soft Lightweight Filter-0000 Intel(R) Ethernet Connection (2) I218-V-HHD Software NDIS 6.0 Filter Driver-0002 Intel(R) Ethernet Connection (2) I218-V-VirtualBox NDIS Light-Weight Filter-0000 Intel(R) Ethernet Connection (2) I218-V-HHD Software NDIS 6.0 Filter Driver-0003 Intel(R) Ethernet Connection (2) I218-V-QoS Packet Scheduler-0000 Intel(R) Ethernet Connection (2) I218-V-HHD Software NDIS 6.0 Filter Driver-0004 Intel(R) Ethernet Connection (2) I218-V-WFP 802.3 MAC Layer LightWeight Filter-0000 Intel(R) Ethernet Connection (2) I218-V-HHD Software NDIS 6.0 Filter Driver-0005 Broadcom 802.11ac Network Adapter-WFP Native MAC Layer LightWeight Filter-0000 Broadcom 802.11ac Network Adapter-Virtual WiFi Filter Driver-0000 Broadcom 802.11ac Network Adapter-Native WiFi Filter Driver-0000 Broadcom 802.11ac Network Adapter-HHD Software NDIS 6.0 Filter Driver-0003 Broadcom 802.11ac Network Adapter-Shrew Soft Lightweight Filter-0000 Broadcom 802.11ac Network Adapter-HHD Software NDIS 6.0 Filter Driver-0004 Broadcom 802.11ac Network Adapter-VirtualBox NDIS Light-Weight Filter-0000 Broadcom 802.11ac Network Adapter-HHD Software NDIS 6.0 Filter Driver-0005 Broadcom 802.11ac Network Adapter-QoS Packet Scheduler-0000 Broadcom 802.11ac Network Adapter-HHD Software NDIS 6.0 Filter Driver-0006 Broadcom 802.11ac Network Adapter-WFP 802.3 MAC Layer LightWeight Filter-0000 Broadcom 802.11ac Network Adapter-HHD Software NDIS 6.0 Filter Driver-0007 Microsoft Wi-Fi Direct Virtual Adapter-WFP Native MAC Layer LightWeight Filter-0000 Microsoft Wi-Fi Direct Virtual Adapter-Native WiFi Filter Driver-0000 Microsoft Wi-Fi Direct Virtual Adapter-HHD Software NDIS 6.0 Filter Driver-0002 Microsoft Wi-Fi Direct Virtual Adapter-Shrew Soft Lightweight Filter-0000 Microsoft Wi-Fi Direct Virtual Adapter-HHD Software NDIS 6.0 Filter Driver-0003 Microsoft Wi-Fi Direct Virtual Adapter-VirtualBox NDIS Light-Weight Filter-0000 Microsoft Wi-Fi Direct Virtual Adapter-HHD Software NDIS 6.0 Filter Driver-0004 Microsoft Wi-Fi Direct Virtual Adapter-QoS Packet Scheduler-0000 Microsoft Wi-Fi Direct Virtual Adapter-HHD Software NDIS 6.0 Filter Driver-0005 Microsoft Wi-Fi Direct Virtual Adapter-WFP 802.3 MAC Layer LightWeight Filter-0000 Microsoft Wi-Fi Direct Virtual Adapter-HHD Software NDIS 6.0 Filter Driver-0006
while(interfaces.hasMoreElements()){ Enumeration<InetAddress> addresses = i.getInetAddresses(); System.out.println(i.getDisplayName()); System.out.println("\t- name:" + i.getName()); System.out.println("\t- idx:" + i.getIndex()); System.out.println("\t- max trans unit (MTU):" + i.getMTU()); System.out.println("\t- is loopback:" + i.isLoopback()); System.out.println("\t- is PPP:" + i.isPointToPoint()); System.out.println("\t- isUp:" + i.isUp()); System.out.println("\t- isVirtual:" + i.isVirtual()); System.out.println("\t- supportsMulticast:" + i.supportsMulticast()); }
Software Loopback Interface 1 - name:lo - idx:1 - max trans unit (MTU):-1 - is loopback:true - is PPP:false - isUp:true - isVirtual:false - supportsMulticast:true -ADRESS: [127.0.0.1(VIKING-192.168.56.1)]127.0.0.1:127.0.0.1 - [B@19e1023e -ADRESS: [0:0:0:0:0:0:0:1(VIKING-192.168.56.1)]0:0:0:0:0:0:0:1:0:0:0:0:0:0:0:1 - [B@7cef4e59 Broadcom 802.11ac Network Adapter - name:wlan0 - idx:2 - max trans unit (MTU):1500 - is loopback:false - is PPP:false - isUp:true - isVirtual:false - supportsMulticast:true -ADRESS: [VIKING.monkeybrains.net(VIKING-192.168.56.1)]VIKING.monkeybrains.net:192.168.1.142 - [B@64b8f8f4 -ADRESS: [fe80:0:0:0:81fa:31d:21c9:85cd%wlan0(VIKING-192.168.56.1)]fe80:0:0:0:81fa:31d:21c9:85cd%wlan0:fe80:0:0:0:81fa:31d:21c9:85cd%wlan0 - [B@2db0f6b2 Microsoft Kernel Debug Network Adapter - name:eth0 - idx:3 - max trans unit (MTU):-1 - is loopback:false - is PPP:false - isUp:false - isVirtual:false - supportsMulticast:true
import java.net.InetAddress; try { InetAddress addr = InetAddress.getLocalHost(); System.out.println(addr.getHostAddress()); } catch (UnknownHostException e) { }
import java.net.InetAddress; import java.net.NetworkInterface; import java.util.Enumeration; public class IpAddress { NetworkInterface ifcfg; Enumeration<InetAddress> addresses; String address; public String getIpAddress(String host) { try { ifcfg = NetworkInterface.getByName(host); addresses = ifcfg.getInetAddresses(); while (addresses.hasMoreElements()) { address = addresses.nextElement().toString(); address = address.replace("/", ""); } } catch (Exception e) { e.printStackTrace(); } return ifcfg.toString(); } }
String getPublicIPv4() throws UnknownHostException, SocketException{ Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces(); String ipToReturn = null; while(e.hasMoreElements()) { NetworkInterface n = (NetworkInterface) e.nextElement(); Enumeration<InetAddress> ee = n.getInetAddresses(); while (ee.hasMoreElements()) { InetAddress i = (InetAddress) ee.nextElement(); String currentAddress = i.getHostAddress(); logger.trace("IP address "+currentAddress+ " found"); if(!i.isSiteLocalAddress()&&!i.isLoopbackAddress() && validate(currentAddress)){ ipToReturn = currentAddress; }else{ System.out.println("Address not validated as public IPv4"); } } } return ipToReturn; } private static final Pattern IPv4RegexPattern = Pattern.compile( "^(([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d\\d?|2[0-4]\\d|25[0-5])$"); public static boolean validate(final String ip) { return IPv4RegexPattern.matcher(ip).matches(); }
public static String myPublicIp() { String ipAdressDns = ""; try { String command = "nslookup myip.opendns.com resolver1.opendns.com"; Process proc = Runtime.getRuntime().exec(command); BufferedReader stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream())); String s; while ((s = stdInput.readLine()) != null) { ipAdressDns += s + "\n"; } } catch (IOException e) { e.printStackTrace(); } return ipAdressDns ; }
public static String getIpAddress() { String ipAddress = null; try { Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces(); while (networkInterfaces.hasMoreElements()) { NetworkInterface networkInterface = networkInterfaces.nextElement(); byte[] hardwareAddress = networkInterface.getHardwareAddress(); if (null == hardwareAddress || 0 == hardwareAddress.length || (0 == hardwareAddress[0] && 0 == hardwareAddress[1] && 0 == hardwareAddress[2])) continue; Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses(); if (inetAddresses.hasMoreElements()) ipAddress = inetAddresses.nextElement().toString(); break; } } catch (SocketException e) { e.printStackTrace(); } return ipAddress; }
AtomicReference<Object> cache = new AtomicReference<Object>(); Object cachedValue = new Object(); cache.set(cachedValue); Object cachedValueToUpdate = cache.get(); Object newValue = someFunctionOfOld(cachedValueToUpdate); boolean success = cache.compareAndSet(cachedValue,cachedValueToUpdate);
volatile String sharedValue; static final Object lock=new Object(); void modifyString(){ synchronized(lock){ sharedValue=sharedValue+"something to add"; } }
public static AtomicReference<String> shared = new AtomicReference<>(); String init="Inital Value"; shared.set(init); boolean success=false; while(!success){ String prevValue=shared.get(); String newValue=shared.get()+"lets add something"; success=shared.compareAndSet(prevValue,newValue); }
public class NumberRange { private final AtomicInteger lower = new AtomicInteger(0); private final AtomicInteger upper = new AtomicInteger(0); public void setLower(int i) { if (i > upper.get()) throw new IllegalArgumentException( "can lower.set(i); } public void setUpper(int i) { if (i < lower.get()) throw new IllegalArgumentException( "can upper.set(i); } public boolean isInRange(int i) { return (i >= lower.get() && i <= upper.get()); } }
public class CasNumberRange { private static class IntPair { final int lower; final int upper; ... } private final AtomicReference<IntPair> values = new AtomicReference<IntPair>(new IntPair(0, 0)); public int getLower() { return values.get().lower; } public int getUpper() { return values.get().upper; } public void setLower(int i) { while (true) { IntPair oldv = values.get(); if (i > oldv.upper) throw new IllegalArgumentException( "Can IntPair newv = new IntPair(i, oldv.upper); if (values.compareAndSet(oldv, newv)) return; } } }
public void doSomethingUsingLambdas() { AtomicReference<YourObject> yourObjectRef = new AtomicReference<>(); soSomethingThatTakesALambda(() -> { yourObjectRef.set(youObject); }); soSomethingElseThatTakesALambda(() -> { YourObject yourObject = yourObjectRef.get(); }); }
public final boolean compareAndSet(V expect, V update) { return unsafe.compareAndSwapObject(this, valueOffset, expect, update); }
for (int i = 0; i < 20; i++) { seats.add(new AtomicReference<Integer>()); } Thread[] ths = new Thread[22]; for (int i = 0; i < ths.length; i++) { ths[i] = new MyTh(seats, i); ths[i].start(); }
import java.util.ArrayList; import java.util.List; import java.util.concurrent.ThreadLocalRandom; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicReference; public class Solution { static List<AtomicReference<Integer>> seats; public static void main(String[] args) throws InterruptedException { seats = new ArrayList<>(); for (int i = 0; i < 20; i++) { seats.add(new AtomicReference<Integer>()); } Thread[] ths = new Thread[22]; for (int i = 0; i < ths.length; i++) { ths[i] = new MyTh(seats, i); ths[i].start(); } for (Thread t : ths) { t.join(); } for (AtomicReference<Integer> seat : seats) { System.out.print(" " + seat.get()); } } /** * id is the id of the user * * @author sankbane * */ static class MyTh extends Thread { static AtomicInteger full = new AtomicInteger(0); List<AtomicReference<Integer>> l; int id; int seats; public MyTh(List<AtomicReference<Integer>> list, int userId) { l = list; this.id = userId; seats = list.size(); } @Override public void run() { boolean reserved = false; try { while (!reserved && full.get() < seats) { Thread.sleep(50); int r = ThreadLocalRandom.current().nextInt(0, seats); // AtomicReference<Integer> el = l.get(r); reserved = el.compareAndSet(null, id); if (reserved) full.getAndIncrement(); } if (!reserved && full.get() == seats) System.out.println("user " + id + " did not get a seat"); } catch (InterruptedException ie) { } } } }
String initialReference = "value 1"; AtomicReference<String> someRef = new AtomicReference<String>(initialReference); String newReference = "value 2"; boolean exchanged = someRef.compareAndSet(initialReference, newReference); System.out.println("exchanged: " + exchanged);
public PlayerScore getHighScore() { ServletContext ctx = getServletConfig().getServletContext(); AtomicReference<PlayerScore> holder = (AtomicReference<PlayerScore>) ctx.getAttribute("highScore"); return holder.get(); } public void updateHighScore(PlayerScore newScore) { ServletContext ctx = getServletConfig().getServletContext(); AtomicReference<PlayerScore> holder = (AtomicReference<PlayerScore>) ctx.getAttribute("highScore"); while (true) { HighScore old = holder.get(); if (old.score >= newScore.score) break; else if (holder.compareAndSet(old, newScore)) break; } }
TAuthor a = T_AUTHOR.as("a"); create.selectFrom(a) .whereExists(create.selectOne() .from(T_BOOK) .where(T_BOOK.STATUS.equal(TBookStatus.SOLD_OUT) .and(T_BOOK.AUTHOR_ID.equal(a.ID))))));
List<Person> boys = Ebean.find(Person.class) .where() .eq("gender", "M") .le("age", 18) .orderBy("firstName") .findList();
public class IndexProcessor implements Runnable { private static final Logger LOGGER = LoggerFactory.getLogger(IndexProcessor.class); @Override public void run() { boolean run = true; while (run) { try { LOGGER.debug("Sleeping..."); Thread.sleep((long) 15000); LOGGER.debug("Processing"); } catch (InterruptedException e) { LOGGER.error("Exception", e); run = false; } } } }
public class SearchEngineContextListener implements ServletContextListener { private static final Logger LOGGER = LoggerFactory.getLogger(SearchEngineContextListener.class); private Thread thread = null; @Override public void contextInitialized(ServletContextEvent event) { thread = new Thread(new IndexProcessor()); LOGGER.debug("Starting thread: " + thread); thread.start(); LOGGER.debug("Background process successfully started."); } @Override public void contextDestroyed(ServletContextEvent event) { LOGGER.debug("Stopping thread: " + thread); if (thread != null) { thread.interrupt(); LOGGER.debug("Thread successfully stopped."); } } }
2012-06-09 17:04:50,671 [Thread-3] ERROR IndexProcessor Exception java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at lt.ccl.searchengine.processor.IndexProcessor.run(IndexProcessor.java:22) at java.lang.Thread.run(Unknown Source)
public class IndexProcessor implements Runnable { private static final Logger LOGGER = LoggerFactory.getLogger(IndexProcessor.class); private volatile boolean running = true; public void terminate() { running = false; } @Override public void run() { while (running) { try { LOGGER.debug("Sleeping..."); Thread.sleep((long) 15000); LOGGER.debug("Processing"); } catch (InterruptedException e) { LOGGER.error("Exception", e); running = false; } } } }
public class SearchEngineContextListener implements ServletContextListener { private static final Logger LOGGER = LoggerFactory.getLogger(SearchEngineContextListener.class); private Thread thread = null; private IndexProcessor runnable = null; @Override public void contextInitialized(ServletContextEvent event) { runnable = new IndexProcessor(); thread = new Thread(runnable); LOGGER.debug("Starting thread: " + thread); thread.start(); LOGGER.debug("Background process successfully started."); } @Override public void contextDestroyed(ServletContextEvent event) { LOGGER.debug("Stopping thread: " + thread); if (thread != null) { runnable.terminate(); thread.join(); LOGGER.debug("Thread successfully stopped."); } } }
public class IndexProcessor implements Runnable { private static final Logger LOGGER = LoggerFactory.getLogger(IndexProcessor.class); private volatile boolean execute; @Override public void run() { this.execute = true; while (this.execute) { try { LOGGER.debug("Sleeping..."); Thread.sleep((long) 15000); LOGGER.debug("Processing"); } catch (InterruptedException e) { LOGGER.error("Exception", e); this.execute = false; } } } public void stopExecuting() { this.execute = false; } }
... try { LOGGER.debug("Sleeping..."); for (int i = 0; (i < 150) && this.execute; i++) { Thread.sleep((long) 100); } LOGGER.debug("Processing"); } catch (InterruptedException e) { ...
public class IndexProcessor implements Runnable { private static final Logger LOGGER = LoggerFactory.getLogger(IndexProcessor.class); private final CountDownLatch countdownlatch; public IndexProcessor(CountDownLatch countdownlatch) { this.countdownlatch = countdownlatch; } public void run() { try { while (!countdownlatch.await(15000, TimeUnit.MILLISECONDS)) { LOGGER.debug("Processing..."); } } catch (InterruptedException e) { LOGGER.error("Exception", e); run = false; } } }
public class SearchEngineContextListener implements ServletContextListener { private static final Logger LOGGER = LoggerFactory.getLogger(SearchEngineContextListener.class); private Thread thread = null; private IndexProcessor runnable = null; private CountDownLatch countdownLatch = null; @Override public void contextInitialized(ServletContextEvent event) { countdownLatch = new CountDownLatch(1); Thread thread = new Thread(new IndexProcessor(countdownLatch)); LOGGER.debug("Starting thread: " + thread); thread.start(); LOGGER.debug("Background process successfully started."); } @Override public void contextDestroyed(ServletContextEvent event) { LOGGER.debug("Stopping thread: " + thread); if (countdownLatch != null) { countdownLatch.countDown(); } if (thread != null) { try { thread.join(); } catch (InterruptedException e) { LOGGER.error("Exception", e); } LOGGER.debug("Thread successfully stopped."); } } }
Thread loop = new Thread(new Runnable() { @Override public void run() { while (true) { if (Thread.interrupted()) { break; } } }}); loop.start(); loop.interrupt();
private volatile Thread blinker; public void stop() { blinker = null; } public void run() { Thread thisThread = Thread.currentThread(); while (blinker == thisThread) { try { Thread.sleep(interval); } catch (InterruptedException e){ } repaint(); } }
public void stop() { Thread moribund = waiter; waiter = null; moribund.interrupt(); }
boolean shouldCheckUpdates = true; private void startupCheckForUpdatesEveryFewSeconds() { threadCheckChat = new Thread(new CheckUpdates()); threadCheckChat.start(); } private class CheckUpdates implements Runnable{ public void run() { while (shouldCheckUpdates){ System.out.println("Do your thing here"); } } } public void stop(){ shouldCheckUpdates = false; }
Thread t = new Thread(new Runnable(){ @Override public void run() { while(!Thread.currentThread().isInterrupted()){ } }}); t.start(); try { Thread.sleep(1000); } catch (InterruptedException e) {} t.interrupt();
Map mymap = new HashMap(); mymap.put("1","one"); mymap.put("1","not one"); mymap.put("1","surely not one"); System.out.println(mymap.get("1"));
Map mymap = new HashMap(); mymap.put("1","one"); mymap.put("1","not one"); mymap.put("1","surely not one"); mymap.put("1","one"); System.out.println(mymap.get("1"));
import org.apache.commons.collections.MultiHashMap; import java.util.Set; import java.util.Map; import java.util.Iterator; import java.util.List; public class MultiMapExample { public static void main(String[] args) { MultiHashMap mp=new MultiHashMap(); mp.put("a", 10); mp.put("a", 11); mp.put("a", 12); mp.put("b", 13); mp.put("c", 14); mp.put("e", 15); List list = null; Set set = mp.entrySet(); Iterator i = set.iterator(); while(i.hasNext()) { Map.Entry me = (Map.Entry)i.next(); list=(List)mp.get(me.getKey()); for(int j=0;j<list.size();j++) { System.out.println(me.getKey()+": value :"+list.get(j)); } } } }
import java.util.ArrayList; import java.util.HashMap; import java.util.Map; public class DuplicateMap<K, V> { private Map<K, ArrayList<V>> m = new HashMap<>(); public void put(K k, V v) { if (m.containsKey(k)) { m.get(k).add(v); } else { ArrayList<V> arr = new ArrayList<>(); arr.add(v); m.put(k, arr); } } public ArrayList<V> get(K k) { return m.get(k); } public V get(K k, int index) { return m.get(k).size()-1 < index ? null : m.get(k).get(index); } }
public static void main(String[] args) { DuplicateMap<String,String> dm=new DuplicateMap<>(); dm.put("1", "one"); dm.put("1", "not one"); dm.put("1", "surely not one"); System.out.println(dm.get("1")); System.out.println(dm.get("1",1)); System.out.println(dm.get("1", 5)); }
HashMap<String, ArrayList<String>> hashy = new HashMap<String, ArrayList<String>>();
public void MultiHash(){ HashMap<String, ArrayList<String>> hashy = new HashMap<String, ArrayList<String>>(); String key = "Your key"; ArrayList<String> yourarraylist = hashy.get(key); for(String valuessaved2key : yourarraylist){ System.out.println(valuessaved2key); } }
public void LOOK_AT_ALL_THESE_HASHMAPS(){ HashMap<String, HashMap<String, HashMap<String, HashMap<String, String>>>> theultimatehashmap = new HashMap <String, HashMap<String, HashMap<String, HashMap<String, String>>>>(); String ballsdeep_into_the_hashmap = theultimatehashmap.get("firststring").get("secondstring").get("thirdstring").get("forthstring"); }
HashMap<Emp, Emp> empHashMap = new HashMap<Emp, Emp>(); empHashMap.put(new Emp(1), new Emp(1)); empHashMap.put(new Emp(1), new Emp(1)); empHashMap.put(new Emp(1), new Emp()); empHashMap.put(new Emp(1), new Emp()); System.out.println(empHashMap.size()); } } class Emp{ public Emp(){ } public Emp(int id){ this.id = id; } public int id; @Override public boolean equals(Object obj) { return this.id == ((Emp)obj).id; } @Override public int hashCode() { return id; } } OUTPUT : is 1
public class HashSet{ public HashSet() { map = new HashMap<>(); } }
MyClass myClass = applicationContext.getBean("myClass");
public void setMyClass(MyClass myClass) { this.myClass = myClass; }
public class AutowireThisDriver { private MySpringBean mySpringBean; public static void main(String[] args) { AutowireThisDriver atd = new AutowireThisDriver(); ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext( "/WEB-INF/applicationContext.xml"); ctx.getAutowireCapableBeanFactory().autowireBeanProperties(atd, AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE, true); mySpringBean.doStuff() } public void setMySpringBean(MySpringBean bean) { this.mySpringBean = bean; } }
ApplicationContext context = new ClassPathXmlApplicationContext("AppContext.xml");
interface HttpLoader { String load(String url); } interface StringOutput { void print(String txt); } @Component class MyBean { @Autowired MyBean(HttpLoader loader, StringOutput out) { out.print(loader.load("http: } }
class MyBeanTest { public void creatingMyBean_writesStackoverflowPageToOutput() { String stackOverflowHtml = "dummy"; StringBuilder result = new StringBuilder(); new MyBean(Collections.singletonMap("https: assertEquals(result.toString(), stackOverflowHtml); } }
@Component class MyBean { @Autowired MyBean(ApplicationContext context) { HttpLoader loader = context.getBean(HttpLoader.class); StringOutput out = context.getBean(StringOutput.class); out.print(loader.load("http: } } class MyBeanTest { public void creatingMyBean_writesStackoverflowPageToOutput() { String stackOverflowHtml = "dummy"; StringBuilder result = new StringBuilder(); ApplicationContext context = Mockito.mock(ApplicationContext.class); Mockito.when(context.getBean(HttpLoader.class)) .thenReturn(Collections.singletonMap("https: Mockito.when(context.getBean(StringOutput.class)).thenReturn(result::append); new MyBean(context); assertEquals(result.toString(), stackOverflowHtml); } }
@Component class MyBean { @Autowired MyBean(StringOutput out) { out.print(new HttpLoader().load("http: } }
CollectionUtils.containsAny(someCollection1, someCollection2)
@Override public boolean onKeyDown(int keyCode, KeyEvent event) { if ((keyCode == KeyEvent.KEYCODE_BACK)) { Log.d(this.getClass().getName(), "back button pressed"); } return super.onKeyDown(keyCode, event); }
@Override public void onBackPressed() { moveTaskToBack(true); } @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_BACK) { moveTaskToBack(true); return true; } return super.onKeyDown(keyCode, event); }
public void onBackPressed() { Intent intent = new Intent(); intent.setAction(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_HOME); startActivity(intent); }
@Override public void onBackPressed() { RelativeLayout page2layout = (RelativeLayout)findViewById(R.id.page2layout); if(page2layout.getVisibility() == View.VISIBLE){ togglePageLayout(); return; }else{ super.onBackPressed(); } }
@Override public void onBackPressed() { Log.d("CDA", "onBackPressed Called"); Intent setIntent = new Intent(Intent.ACTION_MAIN); setIntent.addCategory(Intent.CATEGORY_HOME); setIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(setIntent); }
@Override public void onBackPressed() { moveTaskToBack(true); }
public class EditViewCustom extends EditText { Button cancelBtn; RelativeLayout titleReleLayout; public EditViewCustom(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } public EditViewCustom(Context context, AttributeSet attrs) { super(context, attrs); } public EditViewCustom(Context context) { super(context); } public void setViews(Button cancelBtn,RelativeLayout titleReleLayout){ this.cancelBtn = cancelBtn; this.titleReleLayout = titleReleLayout; } @Override public boolean onKeyPreIme(int keyCode, KeyEvent event) { if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) { Log.d("KEYCODE_BACK","KEYCODE_BACK"); cancelBtn.setVisibility(View.GONE); this.setFocusableInTouchMode(false); this.setFocusable(false); titleReleLayout.setVisibility(View.VISIBLE); return super.onKeyPreIme(keyCode, event); } return super.onKeyPreIme(keyCode, event); } }
searchEditView.setViews(cancelBtn, titleRelativeLayout);
ScheduledExecutorService ex = Executors.newSingleThreadScheduledExecutor();
private final ThreadFactory threadFactory = new ThreadFactory() { public Thread newThread(Runnable r) { Thread t = new Thread(r); t.setDaemon(true); return t; } }; private final ScheduledExecutorService timer = Executors.newSingleThreadScheduledExecutor(threadFactory);
class Foo { public void Non() {} public virtual void Virt() {} } class Bar : Foo { public new void Non() {} public override void Virt() {} } class Baz { public static Foo GetFoo() { return new Bar(); } } var foo = Baz.GetFoo(); foo.Non(); foo.Virt(); var bar = (Bar)foo; bar.Non(); bar.Virt();
var foo1 = "bar"; var foo2; var foo3 = null; var foo4 = default(var); var foo5 = (object)null;
var list = new ArrayList<String>(); var stream = list.stream();
var i = 0; var var = 1; for (var i = 0; i < 10; i++) { } public int var() { return 0; } package var;
List<> list = new ArrayList<String>(); Stream<> stream = myStream();
var list = new ArrayList<String>(); var stream = myStream();
$ docker run -it marounbassam/ubuntu-java10 bash root@299d86f1c39a:/ Mar 30, 2018 9:07:07 PM java.util.prefs.FileSystemPreferences$1 run INFO: Created user preferences directory. | Welcome to JShell -- Version 10 | For an introduction type: /help intro jshell> var list = new ArrayList<String>(); list ==> []
import lombok.experimental.var; var number = 1; number = 2; number = "Hi"; System.out.println(number);
Object object = 12; Object object1 = "Aditya"; Object object2 = 12.12; System.out.println(Integer.parseInt(object.toString()) + 2); System.out.println(object1.toString() + " Kumar"); System.out.println(Double.parseDouble(object2.toString()) + 2.12);
public static void main(String args[]) { int period = 2000; int delay = 2000; double lastPrice = 0; Price priceObject = new Price(); double price = 0; Timer timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() { public void run() { price = priceObject.getNextPrice(lastPrice); System.out.println(); lastPrice = price; } }, delay, period); }
public static void main(String args[]) { int period = 2000; int delay = 2000; Timer timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() { private double lastPrice = 0; private Price priceObject = new Price(); private double price = 0; public void run() { price = priceObject.getNextPrice(lastPrice); System.out.println(); lastPrice = price; } }, delay, period); }
public class Foo { private PriceObject priceObject; private double lastPrice; private double price; public Foo(PriceObject priceObject) { this.priceObject = priceObject; } public void tick() { price = priceObject.getNextPrice(lastPrice); lastPrice = price; } }
public static void main(String args[]){ int period = 2000; int delay = 2000; Price priceObject = new Price(); final Foo foo = new Foo(priceObject); Timer timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() { public void run() { foo.tick(); } }, delay, period); }
price[0] = priceObject.getNextPrice(lastPrice[0]); System.out.println(); lastPrice[0] = price[0];
public class foo { static class priceInfo { public double lastPrice = 0; public double price = 0; public Price priceObject = new Price (); } public static void main ( String args[] ) { int period = 2000; int delay = 2000; final priceInfo pi = new priceInfo (); Timer timer = new Timer (); timer.scheduleAtFixedRate ( new TimerTask () { public void run () { pi.price = pi.priceObject.getNextPrice ( pi.lastPrice ); System.out.println (); pi.lastPrice = pi.price; } }, delay, period ); } }
public class EnclosingClass { public void someMethod() { String shared = "hello"; new Thread() { public void run() { System.out.println(shared); } }.start(); shared = "other hello"; System.out.println(shared); } }
public void someMethod() { String shared = "hello"; new EnclosingClass$1(shared).start(); shared = "other hello"; System.out.println(shared); }
public class EnclosingClass$1 extends Thread { String shared; public EnclosingClass$1(String shared) { this.shared = shared; } public void run() { System.out.println(shared); } }
public class EnclosingClass { String shared = "hello"; public void someMethod() { new Thread() { public void run() { System.out.println(shared); } }.start(); shared = "other hello"; System.out.println(shared); } }
public void someMethod() { new EnclosingClass$1(this).start(); shared = "other hello"; System.out.println(shared); } public class EnclosingClass$1 extends Thread { EnclosingClass enclosing; public EnclosingClass$1(EnclosingClass enclosing) { this.enclosing = enclosing; } public void run() { System.out.println(enclosing.shared); } }
public class PriceData { private double lastPrice = 0; private double price = 0; public void setlastPrice(double lastPrice) { this.lastPrice = lastPrice; } public double getLastPrice() { return lastPrice; } public void setPrice(double price) { this.price = price; } public double getPrice() { return price; } } public class PriceTimerTask extends TimerTask { private PriceData priceData; private Price priceObject; public PriceTimerTask(PriceData priceData, Price priceObject) { this.priceData = priceData; this.priceObject = priceObject; } public void run() { priceData.setPrice(priceObject.getNextPrice(lastPrice)); System.out.println(); priceData.setLastPrice(priceData.getPrice()); } } public static void main(String args[]) { int period = 2000; int delay = 2000; PriceData priceData = new PriceData(); Price priceObject = new Price(); Timer timer = new Timer(); timer.scheduleAtFixedRate(new PriceTimerTask(priceData, priceObject), delay, period); }
List<String> lst = new ArrayList<String>(); lst.add("1"); lst.add("2"); SomeAbstractClass p = new SomeAbstractClass (lst, "another parameter", 20, true) { public void perform( ) { ArrayList<String> lst = (ArrayList<String>)getArgs()[0]; } }; public abstract class SomeAbstractClass{ private Object[] args; public SomeAbstractClass(Object ... args) { this.args = args; } public abstract void perform(); public Object[] getArgs() { return args; } }
SortedSet<String> sortedNames = new TreeSet<String>(); eachLine(randomFile0, new V1<String>(sortedNames) { public void call(String line) { SortedSet<String> sortedNames = castFirst(); sortedNames.add(extractName(line)); } });
... final SettableFuture<Integer> myvalue = SettableFuture<Integer>.create(); ... someclass.run(new Runnable(){ public void run(){ ... myvalue.set(value); ... } } return myvalue.get();
public class Test { protected String var1; protected String var2; public void doSomething() { new Thread() { public void run() { System.out.println("In Thread variable 1: " + var1); System.out.println("In Thread variable 2: " + var2); } }.start(); } }
public class WorkerService extends Service { Worker _worker; ExecutorService _executorService; ScheduledExecutorService _scheduledStopService; TextView _statusTextView; @Override public void onCreate() { _worker = new Worker(this); _worker.monitorGpsInBackground(); _executorService = Executors.newSingleThreadExecutor(); _scheduledStopService = Executors.newSingleThreadScheduledExecutor(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { ServiceRunnable runnable = new ServiceRunnable(this, startId); _executorService.execute(runnable); return Service.START_NOT_STICKY; } @Override public void onDestroy() { _worker.stopGpsMonitoring(); } @Override public IBinder onBind(Intent intent) { return null; } class ServiceRunnable implements Runnable { WorkerService _theService; int _startId; String _statusMessage; public ServiceRunnable(WorkerService theService, int startId) { _theService = theService; _startId = startId; } @Override public void run() { _statusTextView = MyActivity.getActivityStatusView(); Location location = _worker.getLocation(); updateStatus("Starting"); String address = _worker.reverseGeocode(location); updateStatus("Reverse geocoding"); _worker.save(location, address, "ResponsiveUx.out"); updateStatus("Done"); DelayedStopRequest stopRequest = new DelayedStopRequest(_theService, _startId); _theService._scheduledStopService.schedule(stopRequest, 10, TimeUnit.SECONDS); } void updateStatus(String message) { _statusMessage = message; if (_statusTextView != null) { _statusTextView.post(new Runnable() { @Override public void run() { _statusTextView.setText(_statusMessage); } }); } } }
Double price; public static void main(String []args(){ -------- -------- }
public class Outer{ public static void main(String[] args){ Outer o = new Outer(); o.m1(); o=null; } public void m1(){ class Inner{ Thread t = new Thread(new Runnable(){ public void run(){ for(int i=0;i<10;i++){ try{ Thread.sleep(2000); }catch(InterruptedException e){ } System.out.println("Thread t running"); } } }); } new Inner().t.start(); System.out.println("m1 Completes"); } }
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint { @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { response.sendError( HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized: Authentication token was either missing or invalid." ); } }
public class AuthenticationTokenProcessingFilter extends GenericFilterBean { @Autowired UserService userService; @Autowired TokenUtils tokenUtils; AuthenticationManager authManager; public AuthenticationTokenProcessingFilter(AuthenticationManager authManager) { this.authManager = authManager; } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { @SuppressWarnings("unchecked") Map<String, String[]> parms = request.getParameterMap(); if(parms.containsKey("token")) { String token = parms.get("token")[0]; if (tokenUtils.validate(token)) { UserDetails userDetails = tokenUtils.getUserFromToken(token); UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails.getUsername(), userDetails.getPassword()); authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails((HttpServletRequest) request)); SecurityContextHolder.getContext().setAuthentication(authManager.authenticate(authentication)); } } chain.doFilter(request, response); } }
public interface TokenUtils { String getToken(UserDetails userDetails); String getToken(UserDetails userDetails, Long expiration); boolean validate(String token); UserDetails getUserFromToken(String token); }
for (int i = 0; i < MAX_I; i++) { for (int j = 0; j < MAX_J; j++) { goto outsideloops; } } outsideloops:
loops: for (int i = 0; i < MAX_I; i++) { for (int j = 0; j < MAX_J; j++) { break loops; } }
public class Label { public static void main(String[] args) { int temp = 0; out: for (int i = 0; i < 3; ++i) { System.out.println("I am here"); for (int j = 0; j < 20; ++j) { if(temp==0) { System.out.println("j: " + j); if (j == 1) { temp = j; continue out; } } } } System.out.println("temp = " + temp); } }
public static void main(String [] args) { boolean t = true; first: { second: { third: { System.out.println("Before the break"); if (t) { break second; } System.out.println("Not executed"); } System.out.println("Not executed - end of second block"); } System.out.println("End of third block"); } }
int line = 1; boolean running = true; while(running) { switch(line++) { case 1: break; case 2: break; ... case 42: line = 1337; break; ... default: running = false; break; } }
public static void main(String[] args) { GOTO me; me: } }
String content = new Scanner(new File("filename")).useDelimiter("\\Z").next(); System.out.println(content);
FileInputStream fisTargetFile = new FileInputStream(new File("test.txt")); String targetFileStr = IOUtils.toString(fisTargetFile, "UTF-8");
import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; public static void main(String[] args) throws IOException { String content = new String(Files.readAllBytes(Paths.get("abc.java"))); }
import org.apache.commons.io.FileUtils; String contents = FileUtils.readFileToString(new File("/path/to/the/file"), "UTF-8")
String content = new Scanner(file, "UTF-8") .useDelimiter(UUID.randomUUID().toString()).next();
Connector port="8010" protocol="AJP/1.3" redirectPort="8443"
netstat -a -o -n ` | select -skip 4 ` | % {$a = $_ -split | ? {$_.Fields[1] -match | % {Write-Host "Killing PID" $_.Fields[4] "..."; taskkill /F /PID $_.Fields[4] }
cd /Library/Java/JavaVirtualMachines sudo rm -rf jdk1.8.0_45.jdk
Fruit{Apple,Orange,Banana,Pear, ... } NetworkConnectionType{LAN,Data_3g,Data_4g, ... }
private enum PropertyKeys { alt, coords, shape, targetImage; }
public enum PropertyKeys { ALT("alt"), COORDS("coords"), SHAPE("shape"), TARGET_IMAGE("targetImage"); private final String val; private PropertyKeys(String val) { this.val = val; } @Override public String toString() { return val; } }
class MyEnum { public static final MyEnum VALUE_1 = new MyEnum("VALUE_1"); public static final MyEnum VALUE_2 = new MyEnum("VALUE_2"); private final name; private MyEnum(String name) { this.name = name; } public String name() { return this.name } }
UndirectedGraph<String, DefaultEdge> g = new SimpleGraph<String, DefaultEdge>(DefaultEdge.class); String v1 = "v1"; String v2 = "v2"; String v3 = "v3"; String v4 = "v4"; g.addVertex(v1); g.addVertex(v2); g.addVertex(v3); g.addVertex(v4); g.addEdge(v1, v2); g.addEdge(v2, v3); g.addEdge(v3, v4); g.addEdge(v4, v1);
class SparseGraph { int[] nodeValues; List<Integer>[] edges; }
class DenseGraph { int[] nodeValues; int[][] edges; }
Map source = new HashMap(){{ put("firstName", "John"); put("lastName", "Smith"); put("organizations", new HashMap(){{ put("0", new HashMap(){{ put("id", "1234"); }}); put("abc", new HashMap(){{ put("id", "5678"); }}); }}); }};
Test$1$1$1.class Test$1$1$2.class Test$1$1.class Test$1.class Test.class
public class ReallyHeavyObject { private int[] tonsOfValues; private Resource[] tonsOfResources; public Map quickHarmlessMethod() { Map source = new HashMap(){{ put("firstName", "John"); put("lastName", "Smith"); put("organizations", new HashMap(){{ put("0", new HashMap(){{ put("id", "1234"); }}); put("abc", new HashMap(){{ put("id", "5678"); }}); }}); }}; return source; } }
String[] array = { "John", "Doe" }; Map map = new HashMap() {{ put("John", "Doe"); }};
public class TestHashMap { public static void main(String[] args) { HashMap<String,String> map = new HashMap<String,String>(){ { put("1", "ONE"); }{ put("2", "TWO"); }{ put("3", "THREE"); } }; Set<String> keySet = map.keySet(); for (String string : keySet) { System.out.println(string+" ->"+map.get(string)); } } }
private static class IndustrialRaverMonkey extends Creature.Base {{ life = 46; strength = 35; charisma = 91; weapon = 2; }} private static class DwarvenAngel extends Creature.Base {{ life = 540; strength = 6; charisma = 144; weapon = 50; }}
public class MyClass { public static class Builder { public int first = -1 ; public double second = Double.NaN; public String third = null ; public MyClass create() { return new MyClass(first, second, third); } } protected final int first ; protected final double second; protected final String third ; protected MyClass( int first , double second, String third ) { this.first = first ; this.second= second; this.third = third ; } public int first () { return first ; } public double second() { return second; } public String third () { return third ; } }
MyClass my = new MyClass.Builder(){{ first = 1; third = "3"; }}.create();
List<String> blah = new ArrayList<String>(){{add("asdfa");add("bbb");}};
List<Character> characters = new ArrayList<Character>() { { for (char c = } };
Random rnd = new Random(); List<Integer> integers = new ArrayList<Integer>() { { while (size() < 10) add(rnd.nextInt(1_000_000)); } };
ArrayList<String> friends = new ArrayList<>(); friends.add("Mark"); friends.add("Steve"); invite(friends);
invite(new ArrayList<String>({{ add("Mark"); add("Steve");}});
@JsonProperty(access = Access.WRITE_ONLY) private String password;
class User{ @JsonIgnore private String password; @JsonIgnore public String getPassword() { return password; } @JsonProperty public void setPassword(String password) { this.password = password; } }
@JsonProperty(access = Access.WRITE_ONLY) private String myField;
/** * Access setting that means that the property may only be written (set) * for deserialization, * but will not be read (get) on serialization, that is, the value of the property * is not included in serialization. */ WRITE_ONLY
"user": { "firstName": "Musa", "lastName": "Aliyev", "email": "klaudi2012@gmail.com", "passwordIn": "98989898", (or encoded version in front if we not using https) "country": "Azeribaijan", "phone": "+994707702747" }
@CrossOrigin(methods=RequestMethod.POST) @RequestMapping("/public/register") public @ResponseBody MsgKit registerNewUsert(@RequestBody User u){ root.registerUser(u); return new MsgKit("registered"); }
@Service @Transactional public class RootBsn { @Autowired UserRepository userRepo; public void registerUser(User u) throws Exception{ u.setPassword(u.getPasswordIn()); User u=userRepo.save(u); System.out.println("Registration information saved"); } }
@Entity @JsonIgnoreProperties({"recordDate","modificationDate","status","createdBy","modifiedBy","salt","password"}) public class User implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long id; private String country; @Column(name="CREATED_BY") private String createdBy; private String email; @Column(name="FIRST_NAME") private String firstName; @Column(name="LAST_LOGIN_DATE") private Timestamp lastLoginDate; @Column(name="LAST_NAME") private String lastName; @Column(name="MODIFICATION_DATE") private Timestamp modificationDate; @Column(name="MODIFIED_BY") private String modifiedBy; private String password; @Transient private String passwordIn; private String phone; @Column(name="RECORD_DATE") private Timestamp recordDate; private String salt; private String status; @Column(name="USER_STATUS") private String userStatus; public User() { } }
public class Generation3List extends Generation2List { }
@interface ClassPreamble { String author(); String date(); int currentRevision() default 1; String lastModified() default "N/A"; String lastModifiedBy() default "N/A"; String[] reviewers(); }
@ClassPreamble ( author = "John Doe", date = "3/17/2002", currentRevision = 6, lastModified = "4/12/2004", lastModifiedBy = "Jane Doe", reviewers = {"Alice", "Bob", "Cindy"} ) public class Generation3List extends Generation2List { }
public class Test { static{ System.out.println("Static"); } { System.out.println("Non-static block"); } public static void main(String[] args) { Test t = new Test(); Test t2 = new Test(); } }
public class Foo { private static final int widgets; static { int first = Widgets.getFirstCount(); int second = Widgets.getSecondCount(); widgets = first + second; } }
public class Foo { private static final int widgets = getWidgets(); static int getWidgets() { int first = Widgets.getFirstCount(); int second = Widgets.getSecondCount(); return first + second; } }
private static final HashMap<String, String> MAP = new HashMap<String, String>(); static { MAP.put("banana", "honey"); MAP.put("peanut butter", "jelly"); MAP.put("rice", "beans"); }
static { try { Class.forName("com.example.jdbc.Driver"); } catch (ClassNotFoundException e) { throw new ExceptionInInitializerError("Cannot load JDBC driver.", e); } }
private static Properties config = new Properties(); static { try { config.load(Thread.currentThread().getClassLoader().getResourceAsStream("config.properties"); } catch (IOException e) { throw new ExceptionInInitializerError("Cannot load properties file.", e); } }
private static final HashMap<String, String> MAP; static { MAP.put("banana", "honey"); MAP.put("peanut butter", "jelly"); MAP.put("rice", "beans"); }
private static final HashMap<String, String> MAP = getMap(); private static HashMap<String, String> getMap() { HashMap<String, String> ret = new HashMap<>(); ret.put("banana", "honey"); ret.put("peanut butter", "jelly"); ret.put("rice", "beans"); return ret; }
class A { static int var1 = 6; static int var2 = 9; static int var3; static long var4; static Date date1; static Date date2; static { date1 = new Date(); for(int cnt = 0; cnt < var2; cnt++){ var3 += var1; } System.out.println("End first static init: " + new Date()); } }
public enum Language { ENGLISH("eng", "en", "en_GB", "en_US"), GERMAN("de", "ge"), CROATIAN("hr", "cro"), RUSSIAN("ru"), BELGIAN("be",";-)"); static final private Map<String,Language> ALIAS_MAP = new HashMap<String,Language>(); static { for (Language l:Language.values()) { ALIAS_MAP.put(l.name().toUpperCase(),l); for (String alias:l.aliases) ALIAS_MAP.put(alias.toUpperCase(),l); } } static public boolean has(String value) { return ALIAS_MAP.containsKey(value.toUpper()); } static public Language fromString(String value) { if (value == null) throw new NullPointerException("alias null"); Language l = ALIAS_MAP.get(value); if (l == null) throw new IllegalArgumentException("Not an alias: "+value); return l; } private List<String> aliases; private Language(String... aliases) { this.aliases = Arrays.asList(aliases); } }
public class Foo { static { System.out.println("Static Block 1"); } public static final Foo FOO = new Foo(); static { System.out.println("Static Block 2"); } public Foo() { System.out.println("Constructor"); } static public void main(String p[]) { System.out.println("In Main"); new Foo(); } }
public static int x=initializeX(); private static int initializeX(){ return 3; }
class A{ public static int a =f(); private static int f(){ return 3; } static { a=5; } public static void main(String args[]) { System.out.print(A.a); } }
class A{ static { a=5; } public static int a =f(); private static int f(){ return 3; } public static void main(String args[]) { System.out.print(A.a); } }
public class Main { private static int myInt; static { myInt = 1; System.out.println("myInt is 1"); } public static void main(String[] args) { } }
Eg:-class Solution{ static int x; static{ try{ x=System.out.println(); } catch(Exception e){} } } class Solution1{ public static void main(String a[]){ System.out.println(Solution.x); } }
ArrayList<Dog> dogs = getDogs(); ArrayList<Dog> clonedList = ....something to do with dogs....
public static List<Dog> cloneList(List<Dog> list) { List<Dog> clone = new ArrayList<Dog>(list.size()); for (Dog item : list) clone.add(item.clone()); return clone; }
class Dog { public Dog() { ... } public Dog(Dog dog) { } }
public static List<Dog> cloneList(List<Dog> dogList) { List<Dog> clonedList = new ArrayList<Dog>(dogList.size()); for (Dog dog : dogList) { clonedList.add(new Dog(dog)); } return clonedList; }
List<Double> original = List<Double> copy = new ArrayList<Double>(original);
List<Dog> clonedDogs = dogs.stream().map(Dog::new).collect(toList());
List<Dog> clonedDogs = dogs.stream().map(d -> d.clone()).collect(toList());
ArrayList<Dog> clonedDogs = dogs.stream().map(Dog::new).collect(toCollection(ArrayList::new));
ArrayList<Dog> clonedDogs = dogs.stream().map(d -> d.clone()).collect(toArrayList()); public static <T> Collector<T, ?, ArrayList<T>> toArrayList() { return Collectors.toCollection(ArrayList::new); }
List<Dog> clonedDogs = dogs.stream().map(Dog::clone).collect(toList());
ArrayList<Dog> dogs = getDogs(); ArrayList<Dog> clonedList = new ArrayList<Dog>(dogs);
ArrayList<Dog> dogs = getDogs(); ArrayList<Dog> clonedList = new ArrayList<Dog>(); clonedList.addAll(dogs);
ArrayList<Dog> dogs = getDogs(); ArrayList<Dog> clonedList = new ArrayList<Dog>(); clonedList.addAll(0, dogs);
Cloner cloner=new Cloner(); XX clone = cloner.deepClone(someObjectOfTypeXX);
public static <T extends Cloneable> List<T> deepCloneList(List<T> original) { if (original == null || original.size() < 1) { return new ArrayList<>(); } try { int originalSize = original.size(); Method cloneMethod = original.get(0).getClass().getDeclaredMethod("clone"); List<T> clonedList = new ArrayList<>(); for (int i = 0; i < originalSize; i++) { clonedList.add((T) cloneMethod.invoke(original.get(i))); } return clonedList; } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) { System.err.println("Couldn return new ArrayList<>(); } }
List<CategoryModel> originalList = new ArrayList<>(); String listAsJson = gson.toJson(originalList); List<CategoryModel> newList = new Gson().fromJson(listAsJson, new TypeToken<List<CategoryModel>>() {}.getType());
public static <T> List<T> copyList(List<T> source) { List<T> dest = new ArrayList<T>(); for (T item : source) { dest.add(item); } return dest; }
class You_class { int a; @Override public You_class clone() { You_class you_class = new You_class(); you_class.a = this.a; return you_class; } }
oldList......... List<YourObject> newList = new ArrayList<YourObject>(); foreach(YourObject obj : oldList){ newList.add((YourObject)SerializationUtils.clone(obj)); }
this.myObjectCloned = SerializationUtils.clone(this.object);
ArrayList<Dog> clonedList = new ArrayList<Dog>(name_of_arraylist_that_you_need_to_Clone);
ArrayList<String>arrayB = new ArrayList<String>(); arrayB.addAll(arrayA);
@Test (expected = RuntimeException.class, message = "Employee ID is null") public void shouldThrowRuntimeExceptionWhenEmployeeIDisNull() {}
@Rule public ExpectedException expectedEx = ExpectedException.none(); @Test public void shouldThrowRuntimeExceptionWhenEmployeeIDisNull() throws Exception { expectedEx.expect(RuntimeException.class); expectedEx.expectMessage("Employee ID is null"); }
@Test (expected = RuntimeException.class) public void myTestMethod() { try { } catch(RuntimeException re) { String message = "Employee ID is null"; assertEquals(message, re.getMessage()); throw re; } fail("Employee Id Null exception did not throw!"); }
@Test public void myTestMethod() { try { final Integer employeeId = null; new Employee(employeeId); fail("Should have thrown SomeException but did not!"); } catch( final SomeException e ) { final String msg = "Employee ID is null"; assertEquals(msg, e.getMessage()); } }
@Test (expected = RuntimeException.class) public void someTest() { }
import org.junit.Assert; public abstract class ExpectedRuntimeExceptionAsserter { private String expectedExceptionMessage; public ExpectedRuntimeExceptionAsserter(String expectedExceptionMessage) { this.expectedExceptionMessage = expectedExceptionMessage; } public final void run(){ try{ expectException(); Assert.fail(String.format("Expected a RuntimeException } catch (RuntimeException e){ Assert.assertEquals("RuntimeException caught, but unexpected message", expectedExceptionMessage, e.getMessage()); } } protected abstract void expectException(); }
@Test public void verifyAnonymousUserCantAccessPrivilegedResourceTest(){ new ExpectedRuntimeExceptionAsserter("anonymous user can @Override protected void expectException() { throw new RuntimeException("anonymous user can } }.run(); }
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertThrows; ... @Test void exceptionTesting() { IllegalArgumentException exception = assertThrows( IllegalArgumentException.class, () -> { throw new IllegalArgumentException("a message"); } ); assertEquals("a message", exception.getMessage()); }
import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; ...
public abstract class ExpectedThrowableAsserter implements Runnable { private final Class<? extends Throwable> throwableClass; private final String expectedExceptionMessage; protected ExpectedThrowableAsserter(Class<? extends Throwable> throwableClass, String expectedExceptionMessage) { this.throwableClass = throwableClass; this.expectedExceptionMessage = expectedExceptionMessage; } public final void run() { try { expectException(); } catch (Throwable e) { assertTrue(String.format("Caught unexpected %s", e.getClass().getSimpleName()), throwableClass.isInstance(e)); assertEquals(String.format("%s caught, but unexpected message", throwableClass.getSimpleName()), expectedExceptionMessage, e.getMessage()); return; } fail(String.format("Expected %s, but no exception was thrown.", throwableClass.getSimpleName())); } protected abstract void expectException(); }
import static com.googlecode.catchexception.CatchException.*; import static com.googlecode.catchexception.apis.CatchExceptionHamcrestMatchers.*; List myList = new ArrayList(); catchException(myList).get(1); assertThat(caughtException(), allOf( instanceOf(IndexOutOfBoundsException.class), hasMessage("Index: 1, Size: 0"), hasNoCause() ) );
return (Number) session.createCriteria("Book") .setProjection(Projections.rowCount()) .uniqueResult();
int count = ((Long)getSession().createQuery("select count(*) from Book").uniqueResult()).intValue();
( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue()
Integer count = (Integer) session.createQuery("select count(*) from Books").uniqueResult();
Long count = session.createQuery("select count(1) from Book") .getSingleResult();
Long count = session.createQuery("select count(1) from Book",Long.class) .getSingleResult();
String hql="select count(*) from Book"; Query query= getCurrentSession().createQuery(hql); Long count=(Long) query.uniqueResult(); return count;
@Autowired private SessionFactory sessionFactory; private Session getCurrentSession(){ return sessionFactory.getCurrentSession(); }
int count = ( (Number) entityManager .createQuery( "select count(b) " + "from Book b") .getSingleResult() ).intValue();
void setUpEnvironment(ProcessBuilder builder) { Map<String, String> env = builder.environment(); }
protected static void setEnv(Map<String, String> newenv) throws Exception { try { Class<?> processEnvironmentClass = Class.forName("java.lang.ProcessEnvironment"); Field theEnvironmentField = processEnvironmentClass.getDeclaredField("theEnvironment"); theEnvironmentField.setAccessible(true); Map<String, String> env = (Map<String, String>) theEnvironmentField.get(null); env.putAll(newenv); Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField("theCaseInsensitiveEnvironment"); theCaseInsensitiveEnvironmentField.setAccessible(true); Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null); cienv.putAll(newenv); } catch (NoSuchFieldException e) { Class[] classes = Collections.class.getDeclaredClasses(); Map<String, String> env = System.getenv(); for(Class cl : classes) { if("java.util.Collections$UnmodifiableMap".equals(cl.getName())) { Field field = cl.getDeclaredField("m"); field.setAccessible(true); Object obj = field.get(env); Map<String, String> map = (Map<String, String>) obj; map.clear(); map.putAll(newenv); } } } }
public static void set(Map<String, String> newenv) throws Exception { Class[] classes = Collections.class.getDeclaredClasses(); Map<String, String> env = System.getenv(); for(Class cl : classes) { if("java.util.Collections$UnmodifiableMap".equals(cl.getName())) { Field field = cl.getDeclaredField("m"); field.setAccessible(true); Object obj = field.get(env); Map<String, String> map = (Map<String, String>) obj; map.clear(); map.putAll(newenv); } } }
Libcore.os.setenv("VAR", "value", bOverwrite); Libcore.os.getenv("VAR"));
package libcore.io; public final class Libcore { private Libcore() { } public static Os os; } package libcore.io; public interface Os { public String getenv(String name); public void setenv(String name, String value, boolean overwrite) throws ErrnoException; }
private void setNewEnvironmentHack(Map<String, String> newenv) throws Exception { Class<?> processEnvironmentClass = Class.forName("java.lang.ProcessEnvironment"); Field theEnvironmentField = processEnvironmentClass.getDeclaredField("theEnvironment"); theEnvironmentField.setAccessible(true); Map<String, String> env = (Map<String, String>) theEnvironmentField.get(null); env.clear(); env.putAll(newenv); Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField("theCaseInsensitiveEnvironment"); theCaseInsensitiveEnvironmentField.setAccessible(true); Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null); cienv.clear(); cienv.putAll(newenv); }
public static void setEnv(String key, String value) { try { Map<String, String> env = System.getenv(); Class<?> cl = env.getClass(); Field field = cl.getDeclaredField("m"); field.setAccessible(true); Map<String, String> writableEnv = (Map<String, String>) field.get(env); writableEnv.put(key, value); } catch (Exception e) { throw new IllegalStateException("Failed to set environment variable", e); } }
JNIEXPORT jint JNICALL Java_com_example_posixtest_Posix_setenv (JNIEnv* env, jclass clazz, jstring key, jstring value, jboolean overwrite) { char* k = (char *) (*env)->GetStringUTFChars(env, key, NULL); char* v = (char *) (*env)->GetStringUTFChars(env, value, NULL); int err = setenv(k, v, overwrite); (*env)->ReleaseStringUTFChars(env, key, k); (*env)->ReleaseStringUTFChars(env, value, v); return err; }
public class Posix { public static native int setenv(String key, String value, boolean overwrite); private void runTest() { Posix.setenv("LD_LIBRARY_PATH", "foo", true); } }
java version "1.8.0_92" Java(TM) SE Runtime Environment (build 1.8.0_92-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)
openjdk version "1.8.0_91" OpenJDK Runtime Environment (build 1.8.0_91-b14) OpenJDK 64-Bit Server VM (build 25.91-b14, mixed mode)
/** * Sets an environment variable FOR THE CURRENT RUN OF THE JVM * Does not actually modify the system * but rather only the copy of the variables that java has taken, * and hence should only be used for testing purposes! * @param key The Name of the variable to set * @param value The value of the variable to set */ @SuppressWarnings("unchecked") public static <K,V> void setenv(final String key, final String value) { try { final Class<?> processEnvironmentClass = Class.forName("java.lang.ProcessEnvironment"); final Field theEnvironmentField = processEnvironmentClass.getDeclaredField("theEnvironment"); final boolean environmentAccessibility = theEnvironmentField.isAccessible(); theEnvironmentField.setAccessible(true); final Map<K,V> env = (Map<K, V>) theEnvironmentField.get(null); if (SystemUtils.IS_OS_WINDOWS) { if (value == null) { env.remove(key); } else { env.put((K) key, (V) value); } } else { final Class<K> variableClass = (Class<K>) Class.forName("java.lang.ProcessEnvironment$Variable"); final Method convertToVariable = variableClass.getMethod("valueOf", String.class); final boolean conversionVariableAccessibility = convertToVariable.isAccessible(); convertToVariable.setAccessible(true); final Class<V> valueClass = (Class<V>) Class.forName("java.lang.ProcessEnvironment$Value"); final Method convertToValue = valueClass.getMethod("valueOf", String.class); final boolean conversionValueAccessibility = convertToValue.isAccessible(); convertToValue.setAccessible(true); if (value == null) { env.remove(convertToVariable.invoke(null, key)); } else { env.put((K) convertToVariable.invoke(null, key), (V) convertToValue.invoke(null, value)); convertToValue.setAccessible(conversionValueAccessibility); convertToVariable.setAccessible(conversionVariableAccessibility); } } theEnvironmentField.setAccessible(environmentAccessibility); final Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField("theCaseInsensitiveEnvironment"); final boolean insensitiveAccessibility = theCaseInsensitiveEnvironmentField.isAccessible(); theCaseInsensitiveEnvironmentField.setAccessible(true); final Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null); if (value == null) { cienv.remove(key); } else { cienv.put(key, value); } theCaseInsensitiveEnvironmentField.setAccessible(insensitiveAccessibility); } catch (final ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { throw new IllegalStateException("Failed setting environment variable <"+key+"> to <"+value+">", e); } catch (final NoSuchFieldException e) { final Map<String, String> env = System.getenv(); Stream.of(Collections.class.getDeclaredClasses()) .filter(c1 -> "java.util.Collections$UnmodifiableMap".equals(c1.getName())) .map(c1 -> { try { return c1.getDeclaredField("m"); } catch (final NoSuchFieldException e1) { throw new IllegalStateException("Failed setting environment variable <"+key+"> to <"+value+"> when locating in-class memory map of environment", e1); } }) .forEach(field -> { try { final boolean fieldAccessibility = field.isAccessible(); field.setAccessible(true); final Map<String, String> map = (Map<String, String>) field.get(env); if (value == null) { map.remove(key); } else { map.put(key, value); } field.setAccessible(fieldAccessibility); } catch (final ConcurrentModificationException e1) { LOGGER.info("Attempted to modify source map: "+field.getDeclaringClass()+" } catch (final IllegalAccessException e1) { throw new IllegalStateException("Failed setting environment variable <"+key+"> to <"+value+">. Unable to access field!", e1); } }); } LOGGER.info("Set environment variable <"+key+"> to <"+value+">. Sanity Check: "+System.getenv(key)); }
java.lang.String cannot be cast to java.lang.ProcessEnvironment$Variable
def setEnv(newenv: java.util.Map[String, String]): Unit = { try { val processEnvironmentClass = JavaClass.forName("java.lang.ProcessEnvironment") val theEnvironmentField = processEnvironmentClass.getDeclaredField("theEnvironment") theEnvironmentField.setAccessible(true) val variableClass = JavaClass.forName("java.lang.ProcessEnvironment$Variable") val convertToVariable = variableClass.getMethod("valueOf", classOf[java.lang.String]) convertToVariable.setAccessible(true) val valueClass = JavaClass.forName("java.lang.ProcessEnvironment$Value") val convertToValue = valueClass.getMethod("valueOf", classOf[java.lang.String]) convertToValue.setAccessible(true) val sampleVariable = convertToVariable.invoke(null, "") val sampleValue = convertToValue.invoke(null, "") val env = theEnvironmentField.get(null).asInstanceOf[java.util.Map[sampleVariable.type, sampleValue.type]] newenv.foreach { case (k, v) => { val variable = convertToVariable.invoke(null, k).asInstanceOf[sampleVariable.type] val value = convertToValue.invoke(null, v).asInstanceOf[sampleValue.type] env.put(variable, value) } } val theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField("theCaseInsensitiveEnvironment") theCaseInsensitiveEnvironmentField.setAccessible(true) val cienv = theCaseInsensitiveEnvironmentField.get(null).asInstanceOf[java.util.Map[String, String]] cienv.putAll(newenv); } catch { case e : NoSuchFieldException => { try { val classes = classOf[java.util.Collections].getDeclaredClasses val env = System.getenv() classes foreach (cl => { if("java.util.Collections$UnmodifiableMap" == cl.getName) { val field = cl.getDeclaredField("m") field.setAccessible(true) val map = field.get(env).asInstanceOf[java.util.Map[String, String]] map.putAll(newenv) } }) } catch { case e2: Exception => e2.printStackTrace() } } case e1: Exception => e1.printStackTrace() } }
private Map<String, String> getModifiableEnvironmentMap() { try { Map<String,String> unmodifiableEnv = System.getenv(); Class<?> cl = unmodifiableEnv.getClass(); Field field = cl.getDeclaredField("m"); field.setAccessible(true); Map<String,String> modifiableEnv = (Map<String,String>) field.get(unmodifiableEnv); return modifiableEnv; } catch(Exception e) { throw new RuntimeException("Unable to access writable environment variable map."); } } private Map<String, String> getModifiableEnvironmentMap2() { try { Class<?> processEnvironmentClass = Class.forName("java.lang.ProcessEnvironment"); Field theUnmodifiableEnvironmentField = processEnvironmentClass.getDeclaredField("theUnmodifiableEnvironment"); theUnmodifiableEnvironmentField.setAccessible(true); Map<String,String> theUnmodifiableEnvironment = (Map<String,String>)theUnmodifiableEnvironmentField.get(null); Class<?> theUnmodifiableEnvironmentClass = theUnmodifiableEnvironment.getClass(); Field theModifiableEnvField = theUnmodifiableEnvironmentClass.getDeclaredField("m"); theModifiableEnvField.setAccessible(true); Map<String,String> modifiableEnv = (Map<String,String>) theModifiableEnvField.get(theUnmodifiableEnvironment); return modifiableEnv; } catch(Exception e) { throw new RuntimeException("Unable to access writable environment variable map."); } } private Map<String, String> clearEnvironmentVars(String[] keys) { Map<String,String> modifiableEnv = getModifiableEnvironmentMap(); HashMap<String, String> savedVals = new HashMap<String, String>(); for(String k : keys) { String val = modifiableEnv.remove(k); if (val != null) { savedVals.put(k, val); } } return savedVals; } private void setEnvironmentVars(Map<String, String> varMap) { getModifiableEnvironmentMap().putAll(varMap); } @Test public void myTest() { String[] keys = { "key1", "key2", "key3" }; Map<String, String> savedVars = clearEnvironmentVars(keys); setEnvironmentVars(savedVars); }
fun setEnv(newEnv: Map<String, String>) { val unmodifiableMapClass = Collections.unmodifiableMap<Any, Any>(mapOf()).javaClass with(unmodifiableMapClass.getDeclaredField("m")) { isAccessible = true @Suppress("UNCHECKED_CAST") get(System.getenv()) as MutableMap<String, String> }.apply { clear() putAll(newEnv) } }
javac Foo.java Note: Foo.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details.
@SuppressWarnings("unchecked") public void myMethod() { }
javac YourFile.java -Xlint:unchecked Main.java:7: warning: [unchecked] unchecked cast clone.mylist = (ArrayList<String>)this.mylist.clone(); ^ required: ArrayList<String> found: Object 1 warning
List<String> getNames() List names = obj.getNames();
allprojects { gradle.projectsEvaluated { tasks.withType(JavaCompile) { options.compilerArgs << "-Xlint:unchecked" } } }
import java.io.Serializable; public class SimpleGenericClass<T> implements Serializable { public Serializable getInstance() { return this; } public static void main() { SimpleGenericClass<String> original = new SimpleGenericClass<String>(); SimpleGenericClass<String> returned = (SimpleGenericClass<String>) original.getInstance(); } }
File curfolder = new File( "C:\\Users\\username\\Desktop"); File[] file = curfolder.listFiles(); ArrayList filename = Arrays.asList(file);
File curfolder = new File( "C:\\Users\\username\\Desktop"); File[] file = curfolder.listFiles(); ArrayList<File> filename = Arrays.asList(file);
private static final Logger LOGGER = Logger.getLogger( ClassName.class.getName() );
LOGGER.log( Level.FINE, "processing {0} entries in loop", list.size() );
LOGGER.log( Level.FINER, "processing[{0}]: {1}", new Object[]{ i, list.get(i) } );
try { ...something that can throw an ignorable exception } catch( Exception ex ) { LOGGER.log( Level.SEVERE, ex.toString(), ex ); }
private final static Logger LOGGER = Logger.getLogger(MyClass.class.getName());
import java.util.logging.Logger; public class Main { private static Logger LOGGER = Logger.getLogger("InfoLogging"); public static void main(String[] args) { LOGGER.info("Logging an INFO-level message"); } }
import java.util.logging.Logger; public class Main { private static final Logger LOGGER = Logger.getLogger( Thread.currentThread().getStackTrace()[0].getClassName() ); public static void main(String[] args) { LOGGER.info("Logging an INFO-level message"); } }
when(fooDao.getBar(new Bazoo())).thenReturn(myFoo);
when( fooDao.getBar( any(Bazoo.class) ) ).thenReturn(myFoo);
when( fooDao.getBar( (Bazoo)notNull() ) ).thenReturn(myFoo);
when( fooDao.getBar( Matchers.<Bazoo>any() ) ).thenReturn(myFoo);
The output will be so long and not precise, becasue it is precissed by the hardware e.g JVM and JIT has the license as long as we dont have specify it Strictfp Marking it Strictfp will make the result Uniform on every hardware and platform, because its precised value will be same One scenario I can see is in a distributed application (or multiplayer game) where all floating-point calculations need to be deterministic no matter what the underlying hardware or CPU is.
public static Iterable<T> getIterable(Stream<T> s) { return new Iterable<T> { @Override public Iterator<T> iterator() { return s.iterator(); } }; } for (T element : getIterable(s)) { ... }
Stream<X> stream = null; Iterable<X> iterable = stream::iterator
Stream<SomeType> stream = ...; Iterable<SomeType> iterable = stream.collect(toList()):
Stream<T> stream = ...; for (T x : (Iterable<T>) stream::iterator) { ... }
Supplier<Stream<Integer>> streamSupplier = () -> Stream.of(10); Iterable<Integer> iterable = () -> streamSupplier.get().iterator(); for(int i : iterable) { System.out.println(i); } for(int i : iterable) { System.out.println(i); }
Stream<String> stream = ReactiveSeq.of("hello","world") .map(s->"prefix-"+s);
Iterable<String> stream = ReactiveSeq.of("hello","world") .map(s->"prefix-"+s); stream.forEach(System.out::println); stream.forEach(System.out::println);
Path path = Paths.get("..."); Stream<Path> files = Files.list(path); for (Iterator<Path> it = files.iterator(); it.hasNext(); ) { Object file = it.next(); }
public class Foo { public void foo(){ Bar bar = new Bar(); bar.someMethod(); } }
public class Foo { private BarFactory barFactory; public Foo(BarFactory factory) { this.barFactory = factory; } public void foo() { Bar bar = this.barFactory.createBar(); bar.someMethod(); } }
@Test public void testDoFoo() { Bar bar = mock(Bar.class); BarFactory myFactory = new BarFactory() { public Bar createBar() { return bar;} }; Foo foo = new Foo(myFactory); foo.foo(); verify(bar, times(1)).someMethod(); }
public class Foo { private Bar bar; public void foo(Bar bar){ this.bar = (bar != null) ? bar : new Bar(); bar.someMethod(); this.bar = null; } }
@RunWith(MockitoJUnitRunner.class) public class FooTest { @Mock Bar barMock; Foo foo; @Test public void testFoo() { foo = new Foo(); foo.foo(barMock); verify(barMock, times(1)).someMethod(); } }
public class thirdClass { public void someOtherMethod() { Foo myFoo = new Foo(); myFoo.foo(null); } }
package foo; import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.Mockito; import org.powermock.api.mockito.PowerMockito; import org.powermock.core.classloader.annotations.PrepareForTest; import org.powermock.modules.junit4.PowerMockRunner; @RunWith(PowerMockRunner.class) @PrepareForTest({ Foo.class }) public class FooTest { Foo cut; @Mock Bar barMock; @Before public void setUp() throws Exception { cut = new Foo(); } @After public void tearDown() { cut = null; } @Test public void testFoo() throws Exception { PowerMockito.whenNew(Bar.class).withNoArguments() .thenReturn(this.barMock); cut.foo(); Mockito.verify(this.barMock, Mockito.times(1)).someMethod(); } }
public class Foo { private Bar bar = new Bar(); public void foo() { bar.someMethod(); } } public class Bar { public void someMethod() { } }
@RunWith(MockitoJUnitRunner.class) public class FooTest { @Mock Bar bar; @InjectMocks Foo foo; @Test public void FooTest() { doNothing().when( bar ).someMethod(); foo.foo(); verify(bar, times(1)).someMethod(); } }
Random r = new Random(); int i1 = (r.nextInt(80) + 65);
Random r = new Random(); int i1 = r.nextInt(80 - 65) + 65;
int min = 65; int max = 80; Random r = new Random(); int i1 = r.nextInt(max - min + 1) + min;
sort(T[] a, Comparator<? super T> c) Arrays.sort(a, Collections.reverseOrder());
Collections.sort(list, Collections.reverseOrder());
Collections.sort(list, Collections.reverseOrder());
Collections.sort(list, Collections.reverseOrder(new Comparator()));
public int compareTo(freq arg0) { int ret=0; if(this.magnitude>arg0.magnitude) ret= 1; else if (this.magnitude==arg0.magnitude) ret= 0; else if (this.magnitude<arg0.magnitude) ret= -1; return ret; }
public int compareTo(freq arg0) { int ret=0; if(this.magnitude>arg0.magnitude) ret= -1; else if (this.magnitude==arg0.magnitude) ret= 0; else if (this.magnitude<arg0.magnitude) ret= 1; return ret; }
Arrays.sort(array, (o1, o2) -> o2.getValue() - o1.getValue());
package doublearraysort; import java.util.Arrays; import java.util.Collections; public class Gpa { public static void main(String[] args) { Double[] dArr = new Double[] { new Double(3.2), new Double(1.2), new Double(4.7), new Double(3.3), new Double(4.6), }; for (double number : dArr) { System.out.println("GPA = " + number); } Arrays.sort(dArr, Collections.reverseOrder()); System.out.println("The sorted GPA Scores are:"); for (double number : dArr) { System.out.println("GPA = " + number); } } }
GPA = 3.2 GPA = 1.2 GPA = 4.7 GPA = 3.3 GPA = 4.6 The sorted GPA Scores are: GPA = 4.7 GPA = 4.6 GPA = 3.3 GPA = 3.2 GPA = 1.2
public double[] sortArrayAlgorithm(double[] array) { for (int i = 0; i < array.length; i++) { for (int j = 0; j < array.length; j++) { if (array[i] >= array[j]) { double x = array[i]; array[i] = array[j]; array[j] = x; } } } return array; }
throw new java.lang.UnsupportedOperationException("Not supported yet.");
String[] where; where.append(ContactsContract.Contacts.HAS_PHONE_NUMBER + "=1"); where.append(ContactsContract.Contacts.IN_VISIBLE_GROUP + "=1");
List<String> where = new ArrayList<String>(); where.add( ContactsContract.Contacts.HAS_PHONE_NUMBER+"=1" ); where.add( ContactsContract.Contacts.IN_VISIBLE_GROUP+"=1" );
String[] simpleArray = new String[ where.size() ]; where.toArray( simpleArray );
for( String oneItem : where ) { ... } where.get( 1 );
import java.util.*; List<String> list = new ArrayList<String>(); list.add("1"); list.add("2"); list.add("3"); System.out.println(list);
static <T> T[] append(T[] arr, T element) { final int N = arr.length; arr = Arrays.copyOf(arr, N + 1); arr[N] = element; return arr; } String[] arr = { "1", "2", "3" }; System.out.println(Arrays.toString(arr)); arr = append(arr, "4"); System.out.println(Arrays.toString(arr));
String[] array1 = new String[]{"one", "two"}; String[] array2 = new String[]{"three"}; String[] array = new String[array1.length + array2.length]; System.arraycopy(array1, 0, array, 0, array1.length); System.arraycopy(array2, 0, array, array1.length, array2.length);
List<String> where = new ArrayList<String>(); where.add(ContactsContract.Contacts.HAS_PHONE_NUMBER + "=1"); where.add(ContactsContract.Contacts.IN_VISIBLE_GROUP + "=1");
String[] where = new String[]{ ContactsContract.Contacts.HAS_PHONE_NUMBER + "=1", ContactsContract.Contacts.IN_VISIBLE_GROUP + "=1" };
String[] source = new String[] { "a", "b", "c", "d" }; String[] destination = new String[source.length + 2]; destination[0] = "/bin/sh"; destination[1] = "-c"; System.arraycopy(source, 0, destination, 2, source.length); for (String parts : destination) { System.out.println(parts); }
StringBuilder phoneNumber = new StringBuilder(); phoneNumber.append("1"); phoneNumber.append("2"); where[0] = phoneNumber.toString();
String[] myArray = new String[] {"x", "y"}; List<String> listFromArray = Arrays.asList(myArray); List<String> tempList = new ArrayList<String>(listFromArray); tempList.add("z"); String[] tempArray = new String[tempList.size()]; myArray = tempList.toArray(tempArray);
public String[] AddToStringArray(String[] oldArray, String newString) { String[] newArray = Arrays.copyOf(oldArray, oldArray.length+1); newArray[oldArray.length] = newString; return newArray; }
System.arraycopy(initialArray, 0, newArray, 0, initialArray.length);
String[] arr = {"a", "b", "c"}; System.out.println(Arrays.toString(arr)); arr = Arrays.copyOf(arr, 10); arr[3] = "d"; arr[4] = "e"; arr[5] = "f"; System.out.println(Arrays.toString(arr));
public static <T> T[] append2Array(T[] elements, T element) { T[] newArray = Arrays.copyOf(elements, elements.length + 1); newArray[elements.length] = element; return newArray; }
String[] numbers = new String[]{"one", "two", "three"}; System.out.println(Arrays.toString(numbers)); numbers = append2Array(numbers, "four"); System.out.println(Arrays.toString(numbers));
public static <T> T[] append2Array(T[] elements, T[] newElements) { T[] newArray = Arrays.copyOf(elements, elements.length + newElements.length); System.arraycopy(newElements, 0, newArray, elements.length, newElements.length); return newArray; }
String[] numbers = new String[]{"one", "two", "three"}; String[] moreNumbers = new String[]{"four", "five", "six"}; System.out.println(Arrays.toString(numbers)); numbers = append2Array(numbers, moreNumbers); System.out.println(Arrays.toString(numbers));
public static <T> T[] append2Array(Class<T[]> clazz, List<T> elements, T element) { elements.add(element); return clazz.cast(elements.toArray()); }
String[] numbers = new String[]{"one", "two", "three"}; System.out.println(Arrays.toString(numbers)); numbers = append2Array(String[].class, Arrays.asList(numbers), "four"); System.out.println(Arrays.toString(numbers));
synchronized(lock){ while(!condition){ lock.wait(); } }
class BlockingQueue { Queue<String> buffer = new LinkedList<String>(); public void give(String data) { buffer.add(data); notify(); } public String take() throws InterruptedException { while (buffer.isEmpty()) wait(); return buffer.remove(); } }
class A { private Object X; makeChangeOnX(){ while (! x.getCondition()){ wait(); } } setConditionToTrue(){ x.condition = true; notifyAll(); } setConditionToFalse(){ x.condition = false; notifyAll(); } bool getCondition(){ return x.condition; } }
boolean wasNotified = false; while(!wasNotified) { wait(); }
synchronized(monitor) { boolean wasNotified = false; while(!wasNotified) { wait(); } }
java.util.Date date = ... DateTime dateTime = new DateTime(date);
* Date - a JDK instant * Calendar - a JDK calendar * String - in ISO8601 format * Long - in milliseconds * any Joda-Time datetime class
-bash-3.2$ javac -Xmx256M HelloWorldApp.java Error occurred during initialization of VM Could not reserve enough space for object heap Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.
-bash-3.2$ export _JAVA_OPTIONS="-Xmx256M" -bash-3.2$ javac HelloWorldApp.java Picked up _JAVA_OPTIONS: -Xmx256M
set "JAVA_OPTS=-Xms512m -Xmx512m -XX:MaxPermSize=256m
MemTotal: 49300620 kB MemFree: 146376 kB ... SwapTotal: 4192956 kB SwapFree: 1364 kB
MemTotal: 49300620 kB MemFree: 2908664 kB ... SwapTotal: 4192956 kB SwapFree: 1016052 kB
java -Xms128M -Xmx512M JAVA_OPTS="-Xms128M -Xmx512M"
REM JVM Opts we set JAVA_OPTS=-ea^ -javaagent:"%CASSANDRA_HOME%\lib\jamm-0.3.0.jar"^ -Xms**2G**^ -Xmx**2G**^
<configuration> <maxmemory>1024M</maxmemory> </configuration>
int iVal; ResultSet rs = magicallyAppearingStmt.executeQuery(query); if (rs.next()) { if (rs.getObject("ID_PARENT") != null && !rs.wasNull()) { iVal = rs.getInt("ID_PARENT"); } }
int iVal = 0; ResultSet rs = magicallyAppearingStmt.executeQuery(query); if (rs.next()) { iVal = rs.getInt("ID_PARENT"); if (rs.wasNull()) { } }
public class DaoTools { static public Integer getInteger(ResultSet rs, String strColName) throws SQLException { int nValue = rs.getInt(strColName); return rs.wasNull() ? null : nValue; } }
if (rs.next()) { Integer idParent = (Integer) rs.getObject("ID_PARENT"); if (idParent != null) { iVal = idParent; } else { } }
int foo = resultSet.getObject("foo") != null ? resultSet.getInt("foo") : -1;
Integer foo = (Integer) resultSet.getObject("foo");
iVal = rs.getInt("ID_PARENT"); if (rs.wasNull()) { }
public final class ResultSetWrapper { private final ResultSet rs; public ResultSetWrapper(ResultSet rs) { this.rs = rs; } public ResultSet getResultSet() { return rs; } public Boolean getBoolean(String label) throws SQLException { final boolean b = rs.getBoolean(label); if (rs.wasNull()) { return null; } return b; } public Byte getByte(String label) throws SQLException { final byte b = rs.getByte(label); if (rs.wasNull()) { return null; } return b; } }
public <T> T getOptionalValue(final ResultSet rs, final String columnName, final Class<T> clazz) throws SQLException { final T value = rs.getObject(columnName, clazz); return rs.wasNull() ? null : value; }
final Integer columnValue = getOptionalValue(rs, Integer.class); if (columnValue == null) { } else { }
Long nVal = Optional.ofNullable(resultSet.getBigDecimal("col_name")) .map(BigDecimal::longValue).orElse(null));
class MyProgram { int count = 0; public static void main(String[] args) { System.out.println(count); } }
Main.java:6: error: non-static variable count cannot be referenced from a static context System.out.println(count); ^
public static void main (String[] args) { try { MyProgram7 obj = new MyProgram7 (); obj.run (args); } catch (Exception e) { e.printStackTrace (); } } public void run (String[] args) throws Exception { }
class Programm { public static void main(String[] args){ Programm programm = new Programm(); programm.start(); } public void start(){ } }
import java.io.*; class helloworld { int myInt; static int myInt2; static void main (String [] args) { System.out.println ("Hello, World\n"); myInt2 = 14; helloworld myWorld = new helloworld(); myWorld.myInt = 32; } }
public class MyProgram7 { static Scanner scan = new Scanner(System.in); static int compareCount = 0; static int low = 0; static int high = 0; static int mid = 0; static int key = 0; static Scanner temp; static int[]list; static String menu, outputString; static int option = 1; static boolean found = false; public static void main (String[]args) throws IOException { ...
public class Myprogram7 { Scanner scan; int compareCount = 0; int low = 0; int high = 0; int mid = 0; int key = 0; Scanner temp; int[]list; String menu, outputString; int option = 1; boolean found = false; private void readLine() { } private void findkey() { } private void printCount() { } public static void main(String[] args){ Myprogram7 myprg=new Myprogram7(); myprg.readLine(); myprg.findkey(); myprg.printCount(); } }
NamCls NamObjVar = new NamCls(); NamObjVar.NamFnc();
public class NamCls { public static void main(String[] args) { PlsPrnFnc("Tst Txt"); NamCls NamObjVar = new NamCls(); NamObjVar.PrnFnc("Tst Txt"); } static void PlsPrnFnc(String SrgPsgVal) { System.out.println(SrgPsgVal); } void PrnFnc(String SrgPsgVal) { System.out.println(SrgPsgVal); } }
public class NamCls { public static void main(String[] args) { NamTicCls NamTicVaj = new NamTicCls(); NamTicVaj.PrnFnc("Tst Txt"); NamCls NamObjVar = new NamCls(); NamNicCls NamNicVar = NamObjVar.new NamNicCls(); NamNicVar.PrnFnc("Tst Txt"); } static class NamTicCls { void PrnFnc(String SrgPsgVal) { System.out.println(SrgPsgVal); } } class NamNicCls { void PrnFnc(String SrgPsgVal) { System.out.println(SrgPsgVal); } } }
class StaticTest { public void display() { System.out.println("Static Test"); } public static void main(String []cmd) { display(); } }
class StaticTest { public static void main(String []cmd) { display(); } }
logger.error( "\ncontext info one two three: {} {} {}\n", new Object[] {"1", "2", "3"}, new Exception("something went wrong"));
context info one two three: 1 2 3 java.lang.Exception: something went wrong stacktrace 0 stacktrace 1 stacktrace ...
logger.error("one two three: {} {} {}", "a", "b", "c", new Exception("something went wrong"));
logger.error("one two three: {} {} {}", new Object[] {"a", "b", "c", new Exception("something went wrong")});
one two three: a b c java.lang.Exception: something went wrong at Example.main(Example.java:13) at java.lang.reflect.Method.invoke(Method.java:597) at ...
<encoder> <pattern>%date |%-5level| [%thread] [%file:%line] - %msg%n%ex{full}</pattern> </encoder>
[ { "updated_at":"2012-03-02 21:06:01", "fetched_at":"2012-03-02 21:28:37.728840", "description":null, "language":null, "title":"JOHN", "url":"http: "icon_url":null, "logo_url":null, "id":"4f4791da203d0c2d76000035", "modified":"2012-03-02 23:28:58.840076" }, { "updated_at":"2012-03-02 14:07:44", "fetched_at":"2012-03-02 21:28:37.033108", "description":null, "language":null, "title":"PETER", "url":"http: "icon_url":null, "logo_url":null, "id":"4f476f61203d0c2d89000253", "modified":"2012-03-02 23:28:57.928001" } ]
List<ChannelSearchEnum> lcs = (List<ChannelSearchEnum>) new Gson().fromJson( jstring , ChannelSearchEnum.class);
import com.google.gson.annotations.SerializedName; public class ChannelSearchEnum { @SerializedName("updated_at") private String updated_at; @SerializedName("fetched_at") private String fetched_at; @SerializedName("description") private String description; @SerializedName("language") private String language; @SerializedName("title") private String title; @SerializedName("url") private String url; @SerializedName("icon_url") private String icon_url; @SerializedName("logo_url") private String logo_url; @SerializedName("id") private String id; @SerializedName("modified") private String modified; public final String get_Updated_at() { return this.updated_at; } public final String get_Fetched_at() { return this.fetched_at; } public final String get_Description() { return this.description; } public final String get_Language() { return this.language; } public final String get_Title() { return this.title; } public final String get_Url() { return this.url; } public final String get_Icon_url() { return this.icon_url; } public final String get_Logo_url() { return this.logo_url; } public final String get_Id() { return this.id; } public final String get_Modified() { return this.modified; } }
com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was BEGIN_ARRAY at line 1 column 2
ChannelSearchEnum[] enums = gson.fromJson(yourJson, ChannelSearchEnum[].class);
Type collectionType = new TypeToken<Collection<ChannelSearchEnum>>(){}.getType(); Collection<ChannelSearchEnum> enums = gson.fromJson(yourJson, collectionType);
Type collectionType = new TypeToken<List<ChannelSearchEnum>>(){}.getType(); List<ChannelSearchEnum> lcs = (List<ChannelSearchEnum>) new Gson() .fromJson( jstring , collectionType);
[{"category":"College Affordability", "uid":"150151", "body":"Ended more than $60 billion in wasteful subsidies for big banks and used the savings to put the cost of college within reach for more families.", "url":"http:\/\/www.whitehouse.gov\/economy\/middle-class\/helping middle-class-families-pay-for-college", "url_title":"ending subsidies for student loan lenders", "type":"Progress", "path":"node\/150385"}]
import com.google.gson.annotations.Expose; import com.google.gson.annotations.SerializedName; public class Datum { @SerializedName("category") @Expose private String category; @SerializedName("uid") @Expose private String uid; @SerializedName("url_title") @Expose private String urlTitle; /** * @return The category */ public String getCategory() { return category; } /** * @param category The category */ public void setCategory(String category) { this.category = category; } /** * @return The uid */ public String getUid() { return uid; } /** * @param uid The uid */ public void setUid(String uid) { this.uid = uid; } /** * @return The urlTitle */ public String getUrlTitle() { return urlTitle; } /** * @param urlTitle The url_title */ public void setUrlTitle(String urlTitle) { this.urlTitle = urlTitle; } }
import java.util.List; import retrofit2.Call; import retrofit2.http.GET;
public interface RequestInterface { @GET("facts/json/progress/all") Call<List<Datum>> getJSON();
import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.ArrayList; import java.util.List;
public class DataAdapter extends RecyclerView.Adapter<DataAdapter.MyViewHolder>{ private Context context; private List<Datum> dataList; public DataAdapter(Context context, List<Datum> dataList) { this.context = context; this.dataList = dataList; } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view= LayoutInflater.from(parent.getContext()).inflate(R.layout.data,parent,false); return new MyViewHolder(view); } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.categoryTV.setText(dataList.get(position).getCategory()); holder.urltitleTV.setText(dataList.get(position).getUrlTitle()); } @Override public int getItemCount() { return dataList.size(); } public class MyViewHolder extends RecyclerView.ViewHolder{ public TextView categoryTV, urltitleTV; public MyViewHolder(View itemView) { super(itemView); categoryTV = (TextView) itemView.findViewById(R.id.txt_category); urltitleTV = (TextView) itemView.findViewById(R.id.txt_urltitle); } } }
import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.util.Log; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; import retrofit2.Retrofit; import retrofit2.converter.gson.GsonConverterFactory; public class MainActivity extends AppCompatActivity { private RecyclerView recyclerView; private DataAdapter dataAdapter; private List<Datum> dataArrayList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); } private void initViews(){ recyclerView=(RecyclerView) findViewById(R.id.recycler_view); recyclerView.setLayoutManager(new LinearLayoutManager(getApplicationContext())); loadJSON(); } private void loadJSON(){ dataArrayList = new ArrayList<>(); Retrofit retrofit=new Retrofit.Builder().baseUrl("https: RequestInterface requestInterface=retrofit.create(RequestInterface.class); Call<List<Datum>> call= requestInterface.getJSON(); call.enqueue(new Callback<List<Datum>>() { @Override public void onResponse(Call<List<Datum>> call, Response<List<Datum>> response) { dataArrayList = response.body(); dataAdapter=new DataAdapter(getApplicationContext(),dataArrayList); recyclerView.setAdapter(dataAdapter); } @Override public void onFailure(Call<List<Datum>> call, Throwable t) { Log.e("Error",t.getMessage()); } }); } }
{"master":[ { "updated_at":"2012-03-02 21:06:01", "fetched_at":"2012-03-02 21:28:37.728840", "description":null, "language":null, "title":"JOHN", "url":"http: "icon_url":null, "logo_url":null, "id":"4f4791da203d0c2d76000035", "modified":"2012-03-02 23:28:58.840076" }, { "updated_at":"2012-03-02 14:07:44", "fetched_at":"2012-03-02 21:28:37.033108", "description":null, "language":null, "title":"PETER", "url":"http: "icon_url":null, "logo_url":null, "id":"4f476f61203d0c2d89000253", "modified":"2012-03-02 23:28:57.928001" } ] }
[ { "updated_at":"2012-03-02 21:06:01", "fetched_at":"2012-03-02 21:28:37.728840", "description":null, "language":null, "title":"JOHN", "url":"http: "icon_url":null, "logo_url":null, "id":"4f4791da203d0c2d76000035", "modified":"2012-03-02 23:28:58.840076" }, { "updated_at":"2012-03-02 14:07:44", "fetched_at":"2012-03-02 21:28:37.033108", "description":null, "language":null, "title":"PETER", "url":"http: "icon_url":null, "logo_url":null, "id":"4f476f61203d0c2d89000253", "modified":"2012-03-02 23:28:57.928001" } ]
String server_JSONResponse =.... String myCustom_JSONResponse=""; MyClass apiResponse = new MyClass(); myCustom_JSONResponse="{\"master\":"+server_JSONResponse+"}"; apiResponse = gson.fromJson(myCustom_JSONResponse, MyClass .class);
String[] name = { "tom", "dick", "harry" }; for (int i = 0; i <= name.length; i++) { System.out.println(name[i]); }
int[] array = new int[5]; for (int index = 1; index <= array.length; index++) { System.out.println(array[index]); }
if (index < 0 || index >= array.length) { } else { Object element = array[index]; }
String[] name = {"tom", "dick", "harry"}; for(int i = 0; i< name.length; i++) { System.out.print(name[i] + "\n"); }
String[] name = {"tom", "dick", "harry"}; for(String firstName : name) { System.out.println(firstName + "\n"); }
for (int i = 1; i <= myArray.length; i++) { final int someint = myArray[i - 1]
public Integer getArrayElement(final int index) { if (index < 0 || index >= myArray.length) { return null; } return myArray[index]; }
String[] a={"str1", "str2", str3" ..., "strn"}; for(int i=0;i<a.length()i++) System.out.println(a[i]);
String[] name = {"tom", "dick", "harry"}; for(int i = 0; i<=name.length; i++) { System.out.print(name[i] + }
int[] array = new int[5]; Arrays.stream(array).forEach(item -> { println(item); }); IntStream.range(0, array.length).forEach(index -> { println(array[index]); })
String[] name = {"tom", "dick", "harry"}; for(int i = 0; i < name.length; i++) { System.out.print(name[i] + }
public class MyController { SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy"); public void handleRequest(ServletRequest req, ServletResponse res) { Date date = dateFormat.parse(req.getParameter("date")); } }
int [][][] a = new int [2][3][4]; for(int i = 0; i < a.length; i++){ for(int j = 0; j < a[i].length; j++){ for(int k = 0; k < a[j].length; k++){ System.out.print(a[i][j][k]); } System.out.println(); } System.out.println(); }
String[] name = { "tom", "dick", "harry" }; for (int i = 0; i <= name.length; i++) { System.out.println(name[i]); }
for(int i = 0; i<=name.length; i++) { System.out.print(name[i] + }
for(int i = 0; i < name.length; i++) { System.out.print(name[i] + }
for(int count = 0; count < array.length; count++) { System.out.println(array[count]); }
int count = 0; while(count < array.length) { System.out.println(array[count]); count++; }
for(String str : array) { System.out.println(str); }
String[] name = {"tom", "dick", "harry"}; for(int i = 0; i<=name.length; i++) { System.out.print(name[i] + }
String[] name = {"tom", "dick", "harry"}; for(int i = 0; i<name.length; i++) { System.out.print(name[i] + }
class demo{ public static void main(String a[]){ int[] numberArray={4,8,2,3,89,5}; int i; for(i=0;i<numberArray.length;i++){ System.out.print(numberArray[i+1]+" "); } }
class Box<T> { final T x; Box(T x) { this.x = x; } } class Loophole { public static void main(String[] args) { Box<String>[] bsa = new Box<String>[3]; Object[] oa = bsa; oa[0] = new Box<Integer>(3); String s = bsa[0].x; } }
T t; int length; T[] ts = (T[]) Array.newInstance(t.getClass(), length);
Number[] numbers = newNumber[3]; numbers[0] = newInteger(10); numbers[1] = newDouble(3.14); numbers[2] = newByte(0);
Integer[] myInts = {1,2,3,4}; Number[] myNumber = myInts;
List<Integer> myInts = newArrayList<Integer>(); myInts.add(1); myInts.add(2); List<Number> myNums = myInts; myNums.add(3.14);
class Box<T> { final T x; Box(T x) { this.x = x; } } class Loophole { public static <T> T[] array(final T... values) { return (values); } public static void main(String[] args) { Box<String> a = new Box("Hello"); Box<String> b = new Box("World"); Box<String> c = new Box("!!!!!!!!!!!"); Box<String>[] bsa = array(a, b, c); System.out.println("I created an array of generics."); Object[] oa = bsa; oa[0] = new Box<Integer>(3); System.out.println("error not caught by array store check"); try { String s = bsa[0].x; } catch (ClassCastException cause) { System.out.println("BOOM!"); cause.printStackTrace(); } } }
I created an array of generics. error not caught by array store check BOOM! java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at Loophole.main(Box.java:26)
List<Integer>[] arrayOfLists = new List<Integer>[2];
Object[] strings = new String[2]; strings[0] = "hi"; strings[1] = 100;
Object[] stringLists = new List<String>[]; stringLists[0] = new ArrayList<String>(); stringLists[1] = new ArrayList<Integer>();
package myList; import java.lang.reflect.Array; public class MyList<TYPE> { private Node<TYPE> header = null; public void clear() { header = null; } public void add(TYPE t) { header = new Node<TYPE>(t,header); } public TYPE get(int position) { return getNode(position).getObject(); } @SuppressWarnings("unchecked") public TYPE[] toArray() { TYPE[] result = (TYPE[])Array.newInstance(header.getObject().getClass(),size()); for(int i=0 ; i<size() ; i++) result[i] = get(i); return result; } public int size(){ int i = 0; Node<TYPE> current = header; while(current != null) { current = current.getNext(); i++; } return i; }
TYPE[] result = (TYPE[])Array.newInstance(header.getObject().getClass(),size());
static <T> T[] foo(T... args){ return args; } static <T> T[] foo2(T a1, T a2){ return foo(a1, a2); } public static void main(String[] args){ String[] x2 = foo2("a", "b"); }
Glide.with(context).load(GIF_URI).into(new GlideDrawableImageViewTarget(IMAGE_VIEW));
<html style="margin: 0;"> <body style="margin: 0;"> <img src="name.gif" style="width: 100%; height: 100%" /> </body> </html>
<WebView android:layout_width="70dp" android:layout_height="70dp" android:id="@+id/webView" android:layout_gravity="center_horizontal" />
web = (WebView) findViewById(R.id.webView); web.setBackgroundColor(Color.TRANSPARENT); web.loadUrl("file:
String gifName = "name.gif"; String yourData = "<html style=\"margin: 0;\">\n" + " <body style=\"margin: 0;\">\n" + " <img src=" + gifName + " style=\"width: 100%; height: 100%\" />\n" + " </body>\n" + " </html>"; webView.getSettings().setAllowFileAccess(true); webView.loadDataWithBaseURL("file: String base = Environment.getExternalStorageDirectory().getAbsolutePath().toString(); webView.loadDataWithBaseURL(base +
@Override public void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceStated); setContentView(new MYGIFView()); } }
is = context.getResources().openRawResource(R.drawable.earth); movie = Movie.decodeStream(is); }
Ion.with(imgView) .error(R.drawable.default_image) .animateGif(AnimateGifMode.ANIMATE) .load("file:
<RelativeLayout xmlns:android="http: xmlns:tools="http: android:id="@+id/container" android:layout_width="match_parent" android:layout_height="match_parent" android:background=" <ProgressBar android:id="@+id/progressBar" style="?android:attr/progressBarStyleLarge" android:layout_width="70dp" android:layout_height="70dp" android:layout_centerHorizontal="true" android:layout_centerVertical="true" android:indeterminate="true" android:indeterminateDrawable="@drawable/custom_loading" android:visibility="gone" /> </RelativeLayout>
<?xml version="1.0" encoding="utf-8"?> <animated-rotate xmlns:android="http: android:drawable="@drawable/black_gif" android:pivotX="50%" android:pivotY="50%" />
public class LoadingActivity extends Activity { ProgressBar bar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_loading); bar = (ProgressBar) findViewById(R.id.progressBar); bar.setVisibility(View.VISIBLE); } }
<activity android:hardwareAccelerated="false" android:name="foo.GifActivity" android:label="The state of computer animation 2014"> </activity>
import android.app.Activity; import android.content.Context; import android.graphics.*; import android.os.*; import android.view.View; public class GifActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(new GifView(this)); } static class GifView extends View { Movie movie; GifView(Context context) { super(context); movie = Movie.decodeStream( context.getResources().openRawResource( R.drawable.some_gif)); } @Override protected void onDraw(Canvas canvas) { if (movie != null) { movie.setTime( (int) SystemClock.uptimeMillis() % movie.duration()); movie.draw(canvas, 0, 0); invalidate(); } } } }
GlideApp.with(context) .load(R.raw.gif) .into(imageview);
GlideApp.with(context) .asGif() .load(R.raw.gif) .into(new SimpleTarget<GifDrawable>() { @Override public void onResourceReady(@NonNull GifDrawable resource, @Nullable Transition<? super GifDrawable> transition) { resource.start(); imageView.setImageDrawable(resource); } });
val ima : ImageView = findViewById(R.id.img_gif) val decodedAnimation = ImageDecoder.decodeDrawable( ImageDecoder.createSource(resources, R.drawable.tenor)) ima.setImageDrawable(decodedAnimation) (decodedAnimation as? AnimatedImageDrawable)?.start()
<ImageView android:id="@+id/img_gif" android:background="@drawable/ic_launcher_background" <!--Default background--> app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" android:layout_width="200dp" android:layout_height="200dp" />
static ImageDecoder.Source createSource(AssetManager assets, String fileName) static ImageDecoder.Source createSource(ByteBuffer buffer) static ImageDecoder.Source createSource(File file) static ImageDecoder.Source createSource(Resources res, int resId) static ImageDecoder.Source createSource(ContentResolver cr, Uri uri)
String urlGif = "https: ImageView imageView = (ImageView)findViewById(R.id.imageView); Uri uri = Uri.parse(urlGif); Glide.with(getApplicationContext()).load(uri).into(imageView);
<html style="margin: 0;"> <body style="margin: 0;"> <img src="https: </body> </html>
WebView webView = (WebView)findViewById(R.id.webView); webView = (WebView) findViewById(R.id.webView); webView.loadUrl("file:
<com.whygraphics.gifview.gif.GIFView xmlns:gif_view="http: android:id="@+id/main_activity_gif_vie" android:layout_width="200dp" android:layout_height="200dp" android:scaleType="center" gif_view:gif_src="url:http:
GIFView mGifView = (GIFView) findViewById(R.id.main_activity_gif_vie); mGifView.setOnSettingGifListener(new GIFView.OnSettingGifListener() { @Override public void onSuccess(GIFView view, Exception e) { Toast.makeText(MainActivity.this, "onSuccess()", Toast.LENGTH_SHORT).show(); } @Override public void onFailure(GIFView view, Exception e) { } });
int imagePosition = 1; Handler handler = new Handler(); Runnable runnable = new Runnable() { public void run() { updateImage(); } }; public void updateImage() { appInstance.runOnUiThread(new Runnable() { @Override public void run() { int resId = getResources().getIdentifier("image_" + imagePosition, "drawable", appInstance.getPackageName()); gifImageViewDummy.setImageResource(resId); imagePosition++; if (imagePosition == 30) { handler.removeCallbacks(runnable); } else { handler.postDelayed(runnable, 50); } } }); }
public class Test extends GraphicsActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(new SampleView(this)); } private static class SampleView extends View { private Bitmap mBitmap; private Bitmap mBitmap2; private Bitmap mBitmap3; private Bitmap mBitmap4; private Drawable mDrawable; private Movie mMovie; private long mMovieStart; private static final boolean DECODE_STREAM = true; private static byte[] streamToBytes(InputStream is) { ByteArrayOutputStream os = new ByteArrayOutputStream(1024); byte[] buffer = new byte[1024]; int len; try { while ((len = is.read(buffer)) >= 0) { os.write(buffer, 0, len); } } catch (java.io.IOException e) { } return os.toByteArray(); } public SampleView(Context context) { super(context); setFocusable(true); java.io.InputStream is; is = context.getResources().openRawResource(R.drawable.icon); BitmapFactory.Options opts = new BitmapFactory.Options(); Bitmap bm; opts.inJustDecodeBounds = true; bm = BitmapFactory.decodeStream(is, null, opts); opts.inJustDecodeBounds = false; opts.inSampleSize = 4; bm = BitmapFactory.decodeStream(is, null, opts); mBitmap = bm; is = context.getResources().openRawResource(R.drawable.icon); mBitmap2 = BitmapFactory.decodeStream(is); int w = mBitmap2.getWidth(); int h = mBitmap2.getHeight(); int[] pixels = new int[w * h]; mBitmap2.getPixels(pixels, 0, w, 0, 0, w, h); mBitmap3 = Bitmap.createBitmap(pixels, 0, w, w, h, Bitmap.Config.ARGB_8888); mBitmap4 = Bitmap.createBitmap(pixels, 0, w, w, h, Bitmap.Config.ARGB_4444); mDrawable = context.getResources().getDrawable(R.drawable.icon); mDrawable.setBounds(150, 20, 300, 100); is = context.getResources().openRawResource(R.drawable.animated_gif); if (DECODE_STREAM) { mMovie = Movie.decodeStream(is); } else { byte[] array = streamToBytes(is); mMovie = Movie.decodeByteArray(array, 0, array.length); } } @Override protected void onDraw(Canvas canvas) { canvas.drawColor(0xFFCCCCCC); Paint p = new Paint(); p.setAntiAlias(true); canvas.drawBitmap(mBitmap, 10, 10, null); canvas.drawBitmap(mBitmap2, 10, 170, null); canvas.drawBitmap(mBitmap3, 110, 170, null); canvas.drawBitmap(mBitmap4, 210, 170, null); mDrawable.draw(canvas); long now = android.os.SystemClock.uptimeMillis(); if (mMovieStart == 0) { mMovieStart = now; } if (mMovie != null) { int dur = mMovie.duration(); if (dur == 0) { dur = 1000; } int relTime = (int) ((now - mMovieStart) % dur); mMovie.setTime(relTime); mMovie.draw(canvas, getWidth() - mMovie.width(), getHeight() - mMovie.height()); invalidate(); } } } } class GraphicsActivity extends Activity { private static final boolean TEST_PICTURE = false; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); } @Override public void setContentView(View view) { if (TEST_PICTURE) { ViewGroup vg = new PictureLayout(this); vg.addView(view); view = vg; } super.setContentView(view); } } class PictureLayout extends ViewGroup { private final Picture mPicture = new Picture(); public PictureLayout(Context context) { super(context); } public PictureLayout(Context context, AttributeSet attrs) { super(context, attrs); } @Override public void addView(View child) { if (getChildCount() > 1) { throw new IllegalStateException( "PictureLayout can host only one direct child"); } super.addView(child); } @Override public void addView(View child, int index) { if (getChildCount() > 1) { throw new IllegalStateException( "PictureLayout can host only one direct child"); } super.addView(child, index); } @Override public void addView(View child, LayoutParams params) { if (getChildCount() > 1) { throw new IllegalStateException( "PictureLayout can host only one direct child"); } super.addView(child, params); } @Override public void addView(View child, int index, LayoutParams params) { if (getChildCount() > 1) { throw new IllegalStateException( "PictureLayout can host only one direct child"); } super.addView(child, index, params); } @Override protected LayoutParams generateDefaultLayoutParams() { return new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int count = getChildCount(); int maxHeight = 0; int maxWidth = 0; for (int i = 0; i < count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } maxWidth += getPaddingLeft() + getPaddingRight(); maxHeight += getPaddingTop() + getPaddingBottom(); Drawable drawable = getBackground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec), resolveSize(maxHeight, heightMeasureSpec)); } private void drawPict(Canvas canvas, int x, int y, int w, int h, float sx, float sy) { canvas.save(); canvas.translate(x, y); canvas.clipRect(0, 0, w, h); canvas.scale(0.5f, 0.5f); canvas.scale(sx, sy, w, h); canvas.drawPicture(mPicture); canvas.restore(); } @Override protected void dispatchDraw(Canvas canvas) { super.dispatchDraw(mPicture.beginRecording(getWidth(), getHeight())); mPicture.endRecording(); int x = getWidth() / 2; int y = getHeight() / 2; if (false) { canvas.drawPicture(mPicture); } else { drawPict(canvas, 0, 0, x, y, 1, 1); drawPict(canvas, x, 0, x, y, -1, 1); drawPict(canvas, 0, y, x, y, 1, -1); drawPict(canvas, x, y, x, y, -1, -1); } } @Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) { location[0] = getLeft(); location[1] = getTop(); dirty.set(0, 0, getWidth(), getHeight()); return getParent(); } @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { final int count = super.getChildCount(); for (int i = 0; i < count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { final int childLeft = getPaddingLeft(); final int childTop = getPaddingTop(); child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + child.getMeasuredHeight()); } } } }
for(String s : stringArray) { doSomethingWith(s); }
int i = 0; for(String s : stringArray) { doSomethingWith(s); i++; }
for (Index<String> each: With.index(stringArray)) { each.value; each.index; ... }
class With { public static <T> Iterable<Index<T>> index(final T[] array) { return new Iterable<Index<T>>() { public Iterator<Index<T>> iterator() { return new Iterator<Index<T>>() { index = 0; public boolean hasNext() { return index < array.size } public Index<T> next() { return new Index(array[index], index++); } ... } } } } }
int i = 0; for (String s : stringArray) { doSomethingWith(s, i); i++; }
import java.util.*; public class TestApp { public static void AddAndDump(AbstractSet<String> set, String str) { System.out.println("Adding [" + str + "]"); set.add(str); int i = 0; for(String s : set) { System.out.println(" " + i + ": " + s); i++; } } public static void main(String[] args) { AbstractSet<String> coll = new HashSet<String>(); AddAndDump(coll, "Hello"); AddAndDump(coll, "My"); AddAndDump(coll, "Name"); AddAndDump(coll, "Is"); AddAndDump(coll, "Pax"); } }
Adding [Hello] 0: Hello Adding [My] 0: Hello 1: My Adding [Name] 0: Hello 1: My 2: Name Adding [Is] 0: Hello 1: Is 2: My 3: Name Adding [Pax] 0: Hello 1: Pax 2: Is 3: My 4: Name
List<String> strings = Arrays.asList("one", "two","three","four"); forEach(strings, (x, i, n) -> System.out.println("" + (i+1) + "/"+n+": " + x));
@FunctionalInterface public interface LoopWithIndexAndSizeConsumer<T> { void accept(T t, int i, int n); } public static <T> void forEach(Collection<T> collection, LoopWithIndexAndSizeConsumer<T> consumer) { int index = 0; for (T object : collection){ consumer.accept(object, index++, collection.size()); } }
forEachHeadTail(strings, (head) -> System.out.print(head), (tail) -> System.out.print(","+tail));
public static <T> void forEachHeadTail(Collection<T> collection, Consumer<T> headFunc, Consumer<T> tailFunc) { int index = 0; for (T object : collection){ if (index++ == 0){ headFunc.accept(object); } else{ tailFunc.accept(object); } } }
List<String> l = new ArrayList<String>(); l.add("a"); l.add("b"); l.add("c"); l.add("d"); String[] array = new String[l.size()]; for(ListIterator<String> it =l.listIterator(); it.hasNext() ;) { array[it.nextIndex()] = it.next(); }
for(ListIterator<String> it =l.listIterator(); it.hasNext() ;) { int i = it.nextIndex(); doSomethingWith(it.next(), i); }
final AtomicInteger indexHolder = new AtomicInteger(); map.forEach((k, v) -> { final int index = indexHolder.getAndIncrement(); });
for (String str : list : it) { if (str.length() > 100) { it.remove(); } }
final Set<Double> doubles; final Iterator<Double> iterator = doubles.iterator(); for (int ordinal = 0; iterator.hasNext(); ordinal++) { System.out.printf("%d:%f",ordinal,iterator.next()); System.out.println(); }
int i = -1; for(String s : stringArray) { doSomethingWith(s, ++i); }
int i = 0; for(String s : stringArray) { doSomethingWith(s,i); ++i; }
for(String s : stringArray) { try { doSomethingWith(s); } catch (Exception e) { LOGGER.warn("Had some kind of problem with string " + stringArray.indexOf(s) + ": " + s, e); } }
Object[] obj = {1,2,3,4,5,6,7}; IntStream.range(0, obj.length).forEach(idx -> { System.out.println("index: " + index); System.out.println("value: " + obj[index]); });
List<String> strings = new ArrayList<String>(); Collections.addAll(strings,"A","B","C","D"); IntStream.range(0, strings.size()).forEach(idx -> { System.out.println("index: " + index); System.out.println("value: " + strings.get(idx)); });
Warning Description - Warning Name "Magic character" MagicCharacter "Magic number" MagicNumber
public class Test { final static int CALLS = 710; public static void main(String[] args) { final Functor[] functors = new Functor[CALLS]; for (int i = 0; i < CALLS; i++) { final int finalInt = i; functors[i] = new Functor() { @Override public void fun() { System.out.print(finalInt + " "); if (finalInt != CALLS - 1) { functors[finalInt + 1].fun(); } } }; } functors[0].fun(); } interface Functor { void fun(); } }
Exception in thread "main" java.lang.StackOverflowError
VARIABLES=4000 NAME=Test FILE=$NAME.java SOURCE="public class $NAME{public static void main(String[] args){double " for i in $(seq 1 $VARIABLES); do SOURCE=$SOURCE"a$i," done SOURCE=$SOURCE"b=0;System.out.println(b);}}" echo $SOURCE > $FILE javac $FILE java -Xss104k $NAME
public class Test { Test test = new Test(); public static void main(String[] args) { new Test(); } }
private double hours; public double Hours { get { return Hours; } set { Hours = value; } }
export MALLOC_ARENA_MAX=2 export MALLOC_MMAP_THRESHOLD_=131072 export MALLOC_TRIM_THRESHOLD_=131072 export MALLOC_TOP_PAD_=131072 export MALLOC_MMAP_MAX_=65536
java -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=25 HelloWorld
public enum Gender { MALE, FEMALE, UNKNOWN } @Entity public Person { private Gender g; private long id; @Id @GeneratedValue(strategy=GenerationType.AUTO) public long getId() { return id; } public void setId(long id) { this.id = id; } public Gender getGender() { return g; } public void setGender(Gender g) { this.g = g; } @Transient public boolean isMale() { return Gender.MALE.equals(g); } @Transient public boolean isFemale() { return Gender.FEMALE.equals(g); } }
@Entity public class ProgressReport implements Serializable{ private static final long serialVersionUID = 1L; @Transient long estimatedMinutesRemaining; String statusMessage; Solution currentBestSolution; }
@Entity public class Solution implements Serializable{ private static final long serialVersionUID = 1L; double[][] dataArray; Properties properties; }
ArgumentCaptor<ArrayList<SomeType>> argument = ArgumentCaptor.forClass(ArrayList.class);
@RunWith(MockitoJUnitRunner.class) public class Test{ @Mock private Service service; @Captor private ArgumentCaptor<ArrayList<SomeType>> captor; @Test public void shouldDoStuffWithListValues() { verify(service).doStuff(captor.capture())); } }
Class<ArrayList<SomeType>> listClass = (Class<ArrayList<SomeType>>)(Class)ArrayList.class; ArgumentCaptor<ArrayList<SomeType>> argument = ArgumentCaptor.forClass(listClass);
final ArgumentCaptor<List<SomeType>> listCaptor = ArgumentCaptor.forClass((Class) List.class);
ArgumentCaptor<List> argument = ArgumentCaptor.forClass(List.class); verify(subject.method(argument.capture()); List<SomeType> list = argument.getValue();
List<String> mockedList = mock(List.class); List<String> l = new ArrayList(); l.add("someElement"); mockedList.addAll(l); ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class); verify(mockedList).addAll(argumentCaptor.capture()); List<String> capturedArgument = argumentCaptor.<List<String>>getValue(); assertThat(capturedArgument, hasItem("someElement"));
@SuppressWarnings("unchecked") final ArgumentCaptor<List<SomeType>> someTypeListArgumentCaptor = ArgumentCaptor.forClass(List.class);
class CaptorHolder { @Captor ArgumentCaptor<Callback<AuthResponse>> captor; public CaptorHolder() { MockitoAnnotations.initMocks(this); } }
HubstaffService hubstaffService = mock(HubstaffService.class); fragment.setHubstaffService(hubstaffService); CaptorHolder captorHolder = new CaptorHolder(); ArgumentCaptor<Callback<AuthResponse>> captor = captorHolder.captor; onView(withId(R.id.signInBtn)) .perform(click()); verify(hubstaffService).authorize(anyString(), anyString(), captor.capture()); Callback<AuthResponse> callback = captor.getValue();
Class<Map<String, String>> mapClass = (Class) Map.class; ArgumentCaptor<Map<String, String>> mapCaptor = ArgumentCaptor.forClass(mapClass);
export HADOOP_OPTS="$HADOOP_OPTS -Djava.library.path=$HADOOP_HOME/lib/native"
[hadoop@VMWHADTEST01 native]$ ldd libhadoop.so.1.0.0 ./libhadoop.so.1.0.0: /lib64/libc.so.6: version `GLIBC_2.14 linux-vdso.so.1 => (0x00007fff43510000) libdl.so.2 => /lib64/libdl.so.2 (0x00007f9be553a000) libc.so.6 => /lib64/libc.so.6 (0x00007f9be51a5000) /lib64/ld-linux-x86-64.so.2 (0x00007f9be5966000)
15/06/18 18:59:23 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
log4j.logger.org.apache.hadoop.util.NativeCodeLoader=DEBUG
15/06/18 19:05:19 DEBUG util.NativeCodeLoader: Failed to load native-hadoop with error: java.lang.UnsatisfiedLinkError: /opt/hadoop/lib/native/libhadoop.so.1.0.0: /lib64/libc.so.6: version `GLIBC_2.14
[hadoop@VMWHADTEST01 hadoop]$ ldd --version ldd (GNU libc) 2.12
log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native export HADOOP_OPTS="-Djava.library.path=$HADOOP_HOME/lib"
hduser@ubuntu:~$ cd /usr/local/hadoop hduser@ubuntu:/usr/local/hadoop$ ls bin include libexec logs README.txt share etc lib LICENSE.txt NOTICE.txt sbin hduser@ubuntu:/usr/local/hadoop$ cd lib hduser@ubuntu:/usr/local/hadoop/lib$ ls native hduser@ubuntu:/usr/local/hadoop/lib$ cd native/ hduser@ubuntu:/usr/local/hadoop/lib/native$ ls libhadoop.a libhadoop.so libhadooputils.a libhdfs.so libhadooppipes.a libhadoop.so.1.0.0 libhdfs.a libhdfs.so.0.0.0 hduser@ubuntu:/usr/local/hadoop/lib/native$ sudo mv * ../
wget http: tar xvf hadoop-2.7.1-src.tar.gz cd hadoop-2.7.1-src mvn package -Pdist,native -DskipTests -Dtar mv lib /usr/local/Cellar/hadoop/2.7.1/
export HADOOP_OPTS="$HADOOP_OPTS -Djava.net.preferIPv4Stack=true -Djava.security.krb5.realm= -Djava.security.krb5.kdc= -Djava.library.path=/usr/local/Cellar/hadoop/2.7.1/lib/native"
mvn package -Dmaven.javadoc.skip=true -Pdist,native -DskipTests -Dtar
export JAVA_HOME=/home/hadoop/software/java/jdk1.7.0_80 export HADOOP_HOME=/usr/local/hadoop export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native export HADOOP_OPTS="-Djava.library.path=$HADOOP_COMMON_LIB_NATIVE_DIR"
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib export HADOOP_OPTS="$HADOOP_OPTS -Djava.library.path=$HADOOP_HOME/lib"
export HADOOP_HOME=/home/hadoop/hadoop-2.4.1 export PATH=$HADOOP_HOME/bin:$PATH export HADOOP_PREFIX=$HADOOP_HOME export HADOOP_COMMON_HOME=$HADOOP_PREFIX export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_PREFIX/lib/native export HADOOP_CONF_DIR=$HADOOP_PREFIX/etc/hadoop export HADOOP_HDFS_HOME=$HADOOP_PREFIX export HADOOP_MAPRED_HOME=$HADOOP_PREFIX export HADOOP_YARN_HOME=$HADOOP_PREFIX export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native:$JAVA_LIBRARY_PATH
export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native:$JAVA_LIBRARY_PATH
export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native:$JAVA_LIBRARY_PATH
:hadoop-2.8.0-src/hadoop-common-project/hadoop-common $ touch HADOOP-9320-v2.8.patch :hadoop-2.8.0-src/hadoop-common-project/hadoop-common $ vim HADOOP-9320-v2.8.patch :hadoop-2.8.0-src/hadoop-common-project/hadoop-common $ patch < HADOOP-9320-v2.8.patch patching file HadoopCommon.cmake patching file HadoopJNI.cmake :hadoop-2.8.0-src/hadoop-common-project/hadoop-common $ cd ../.. :hadoop-2.8.0-src $ sudo mvn package -Pdist,native -DskipTests -Dtar
:hadoop-2.8.0-src/hadoop-dist/target/hadoop-2.8.0/lib/native $ tar -cvf nativelibs.tar *
[nova]:file /opt/hadoop-2.6.0/lib/native/libhadoop.so.1.0.0 /opt/hadoop-2.6.0/lib/native/libhadoop.so.1.0.0: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=3a80422c78d708c9a1666c1a8edd23676ed77dbb, not stripped
export HADOOP_OPTS="$HADOOP_OPTS -Djava.net.preferIPv4Stack=true -Djava.library.path=/opt/hadoop-2.6.0/lib/native"
ldd --version ldd /opt/hadoop/lib/native/libhadoop.so.1.0.0
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native export HADOOP_OPTS="-Djava.library.path=$HADOOP_HOME/lib"
# export JAVA_HOME=/j01/sys/jdk export JRE_HOME=/j01/sys/jdk/jre export PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin:${PATH}:. # export HADOOP_HOME=/j01/srv/hadoop export HADOOP_MAPRED_HOME=$HADOOP_HOME export HADOOP_COMMON_HOME=$HADOOP_HOME export HADOOP_HDFS_HOME=$HADOOP_HOME export YARN_HOME=$HADOOP_HOME export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin
sudo apt install openssh-server openssh-client ssh-keygen -t rsa ssh-copy-id user@localhost
package com.stackoverflow.q2275443; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; public class Test { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future<String> future = executor.submit(new Task()); try { System.out.println("Started.."); System.out.println(future.get(3, TimeUnit.SECONDS)); System.out.println("Finished!"); } catch (TimeoutException e) { future.cancel(true); System.out.println("Terminated!"); } executor.shutdownNow(); } } class Task implements Callable<String> { @Override public String call() throws Exception { Thread.sleep(4000); return "Ready!"; } }
import java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; /** * TimeOut class - used for stopping a thread that is taking too long * @author Peter Goransson * */ public class TimeOut { Thread interrupter; Thread target; long timeout; boolean success; boolean forceStop; CyclicBarrier barrier; /** * * @param target The Runnable target to be executed * @param timeout The time in milliseconds before target will be interrupted or stopped * @param forceStop If true, will Thread.stop() this target instead of just interrupt() */ public TimeOut(Runnable target, long timeout, boolean forceStop) { this.timeout = timeout; this.forceStop = forceStop; this.target = new Thread(target); this.interrupter = new Thread(new Interrupter()); barrier = new CyclicBarrier(2); } public boolean execute() throws InterruptedException { target.start(); interrupter.start(); target.join(); interrupter.interrupt(); try { barrier.await(); } catch (BrokenBarrierException e) { success = false; } return success; } private class Interrupter implements Runnable { Interrupter() {} public void run() { try { Thread.sleep(timeout); if (forceStop) { target.stop(); } else { target.interrupt(); } System.out.println("done"); success = false; } catch (InterruptedException e) { success = true; } try { barrier.await(); } catch (InterruptedException e) { success = false; } catch (BrokenBarrierException e) { success = false; } } } }
long timeout = 10000; TimeOut t = new TimeOut(new PhotoProcessor(filePath, params), timeout, true); try { boolean sucess = t.execute(); if (!sucess) { } else { } } catch (InterruptedException e) {}
import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; /** * Main class * * @author el * */ public class Main { /** * Thread which perform the task which should be timed out. * * @author el * */ public static class MainThread extends Thread { /** * For example reading a file. File to read. */ final private File fileToRead; /** * InputStream from the file. */ final private InputStream myInputStream; /** * Thread for timeout. */ final private TimeOutThread timeOutThread; /** * true if the thread has not ended. */ boolean isRunning = true; /** * true if all tasks where done. */ boolean everythingDone = false; /** * if every thing could not be done, an {@link Exception} may have * Happens. */ Throwable endedWithException = null; /** * Constructor. * * @param file * @throws FileNotFoundException */ MainThread(File file) throws FileNotFoundException { setDaemon(false); fileToRead = file; myInputStream = new FileInputStream(fileToRead); timeOutThread = new TimeOutThread(10000, this); } /** * Used by the {@link TimeOutThread}. */ public void kill() { if (isRunning) { isRunning = false; if (myInputStream != null) { try { myInputStream.close(); } catch (IOException e) { System.out.println(e.toString()); } } synchronized (this) { notify(); } } } /** * The task which should be timed out. */ @Override public void run() { timeOutThread.start(); int bytes = 0; try { while (myInputStream.read() >= 0) { myInputStream.read(); bytes++; synchronized (this) { wait(10); } } everythingDone = true; } catch (IOException e) { endedWithException = e; } catch (InterruptedException e) { endedWithException = e; } finally { timeOutThread.kill(); System.out.println("-->read " + bytes + " bytes."); isRunning = false; synchronized (this) { notifyAll(); } } } } /** * Timeout Thread. Kill the main task if necessary. * * @author el * */ public static class TimeOutThread extends Thread { final long timeout; final MainThread controlledObj; TimeOutThread(long timeout, MainThread controlledObj) { setDaemon(true); this.timeout = timeout; this.controlledObj = controlledObj; } boolean isRunning = true; /** * If we done need the {@link TimeOutThread} thread, we may kill it. */ public void kill() { isRunning = false; synchronized (this) { notify(); } } /** * */ @Override public void run() { long deltaT = 0l; try { long start = System.currentTimeMillis(); while (isRunning && deltaT < timeout) { synchronized (this) { wait(Math.max(100, timeout - deltaT)); } deltaT = System.currentTimeMillis() - start; } } catch (InterruptedException e) { } finally { isRunning = false; } controlledObj.kill(); } } /** * Start the main task and wait for the end. * * @param args * @throws FileNotFoundException */ public static void main(String[] args) throws FileNotFoundException { long start = System.currentTimeMillis(); MainThread main = new MainThread(new File(args[0])); main.start(); try { while (main.isRunning) { synchronized (main) { main.wait(1000); } } long stop = System.currentTimeMillis(); if (main.everythingDone) System.out.println("all done in " + (stop - start) + " ms."); else { System.out.println("could not do everything in " + (stop - start) + " ms."); if (main.endedWithException != null) main.endedWithException.printStackTrace(); } } catch (InterruptedException e) { System.out.println("You } } }
ExecutorService executorService = getExecutorService(); Future<SomeClass> future = executorService.submit(new Callable<SomeClass>() { public SomeClass call() { } }); try { SomeClass result = future.get(10, TimeUnit.SECONDS); } catch (TimeoutException e) { future.cancel(true); }
package com.mycompany.util.concurrent; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; /** * Calling {@link Callable * with a timeout based on {@link Future * @author pascaldalfarra * */ public class CallableHelper { private CallableHelper() { } public static final void run(final Runnable runnable, int timeoutInSeconds) { run(runnable, null, timeoutInSeconds); } public static final void run(final Runnable runnable, Runnable timeoutCallback, int timeoutInSeconds) { call(new Callable<Void>() { @Override public Void call() throws Exception { runnable.run(); return null; } }, timeoutCallback, timeoutInSeconds); } public static final <T> T call(final Callable<T> callable, int timeoutInSeconds) { return call(callable, null, timeoutInSeconds); } public static final <T> T call(final Callable<T> callable, Runnable timeoutCallback, int timeoutInSeconds) { ExecutorService executor = Executors.newSingleThreadExecutor(); try { Future<T> future = executor.submit(callable); T result = future.get(timeoutInSeconds, TimeUnit.SECONDS); System.out.println("CallableHelper - Finished!"); return result; } catch (TimeoutException e) { System.out.println("CallableHelper - TimeoutException!"); if(timeoutCallback != null) { timeoutCallback.run(); } } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } finally { executor.shutdownNow(); executor = null; } return null; } }
package com.stackoverflow.q2275443; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; public class Test { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future<String> future = executor.submit(new Task()); try { System.out.println("Started.."); System.out.println(future.get(3, TimeUnit.SECONDS)); System.out.println("Finished!"); } catch (TimeoutException e) { future.cancel(); System.out.println("Terminated!"); } executor.shutdownNow(); } } class Task implements Callable<String> { @Override public String call() throws Exception { while(!Thread.currentThread.isInterrupted()){ System.out.println("Im still running baby!!"); } } }
public class Main { private static final class TimeoutTask extends Thread { private final long _timeoutMs; private Runnable _runnable; private TimeoutTask(long timeoutMs, Runnable runnable) { _timeoutMs = timeoutMs; _runnable = runnable; } @Override public void run() { long start = System.currentTimeMillis(); while (System.currentTimeMillis() < (start + _timeoutMs)) { _runnable.run(); } System.out.println("execution took " + (System.currentTimeMillis() - start) +" ms"); } } public static void main(String[] args) throws Exception { new TimeoutTask(2000L, new Runnable() { @Override public void run() { System.out.println("doing something ..."); try { Thread.sleep(100); } catch (InterruptedException e) { throw new RuntimeException(e); } } }).start(); } }
public class TimedExecutorService extends ThreadPoolExecutor { long timeout; public TimedExecutorService(int numThreads, long timeout, TimeUnit unit) { super(numThreads, numThreads, 0L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(numThreads + 1)); this.timeout = unit.toMillis(timeout); } @Override protected void beforeExecute(Thread thread, Runnable runnable) { Thread interruptionThread = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(timeout); System.out.println("The runnable times out."); thread.interrupt(); } catch (InterruptedException e) { e.printStackTrace(); } } }); interruptionThread.start(); } }
public static void main(String[] args) { Runnable abcdRunnable = new Runnable() { @Override public void run() { System.out.println("abcdRunnable started"); try { Thread.sleep(20000); } catch (InterruptedException e) { } System.out.println("abcdRunnable ended"); } }; Runnable xyzwRunnable = new Runnable() { @Override public void run() { System.out.println("xyzwRunnable started"); try { Thread.sleep(20000); } catch (InterruptedException e) { } System.out.println("xyzwRunnable ended"); } }; int numThreads = 2, timeout = 5; ExecutorService timedExecutor = new TimedExecutorService(numThreads, timeout, TimeUnit.SECONDS); timedExecutor.execute(abcdRunnable); timedExecutor.execute(xyzwRunnable); timedExecutor.shutdown(); }
ExecutorService executor = Executors.newSingleThreadExecutor(); Future<Bitmap> future = executor.submit(new Callable<Bitmap>() { @Override public Bitmap call() throws Exception { Bitmap bitmap = decodeAndScaleBitmapFromStream(context, inputUri); return null; } }); try { Bitmap result = future.get(1, TimeUnit.SECONDS); } catch (TimeoutException e){ future.cancel(true); } executor.shutdown(); return (bitmap!= null);
public class TimeoutBlock { private final long timeoutMilliSeconds; private long timeoutInteval=100; public TimeoutBlock(long timeoutMilliSeconds){ this.timeoutMilliSeconds=timeoutMilliSeconds; } public void addBlock(Runnable runnable) throws Throwable{ long collectIntervals=0; Thread timeoutWorker=new Thread(runnable); timeoutWorker.start(); do{ if(collectIntervals>=this.timeoutMilliSeconds){ timeoutWorker.stop(); throw new Exception("<<<<<<<<<<****>>>>>>>>>>> Timeout Block Execution Time Exceeded In "+timeoutMilliSeconds+" Milli Seconds. Thread Block Terminated."); } collectIntervals+=timeoutInteval; Thread.sleep(timeoutInteval); }while(timeoutWorker.isAlive()); System.out.println("<<<<<<<<<< } /** * @return the timeoutInteval */ public long getTimeoutInteval() { return timeoutInteval; } /** * @param timeoutInteval the timeoutInteval to set */ public void setTimeoutInteval(long timeoutInteval) { this.timeoutInteval = timeoutInteval; } }
try { TimeoutBlock timeoutBlock = new TimeoutBlock(10 * 60 * 1000); Runnable block=new Runnable() { @Override public void run() { } }; timeoutBlock.addBlock(block); } catch (Throwable e) { }
import java.util.List; import java.util.concurrent.*; public class TimeoutThreadPoolDecorator extends ThreadPoolExecutor { private final ThreadPoolExecutor commandThreadpool; private final long timeout; private final TimeUnit unit; public TimeoutThreadPoolDecorator(ThreadPoolExecutor threadpool, long timeout, TimeUnit unit ){ super( threadpool.getCorePoolSize(), threadpool.getMaximumPoolSize(), threadpool.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, threadpool.getQueue()); this.commandThreadpool = threadpool; this.timeout=timeout; this.unit=unit; } @Override public void execute(Runnable command) { super.execute(() -> { Future<?> future = commandThreadpool.submit(command); try { future.get(timeout, unit); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } catch (ExecutionException | TimeoutException e) { throw new RejectedExecutionException(e); } finally { future.cancel(true); } }); } @Override public void setCorePoolSize(int corePoolSize) { super.setCorePoolSize(corePoolSize); commandThreadpool.setCorePoolSize(corePoolSize); } @Override public void setThreadFactory(ThreadFactory threadFactory) { super.setThreadFactory(threadFactory); commandThreadpool.setThreadFactory(threadFactory); } @Override public void setMaximumPoolSize(int maximumPoolSize) { super.setMaximumPoolSize(maximumPoolSize); commandThreadpool.setMaximumPoolSize(maximumPoolSize); } @Override public void setKeepAliveTime(long time, TimeUnit unit) { super.setKeepAliveTime(time, unit); commandThreadpool.setKeepAliveTime(time, unit); } @Override public void setRejectedExecutionHandler(RejectedExecutionHandler handler) { super.setRejectedExecutionHandler(handler); commandThreadpool.setRejectedExecutionHandler(handler); } @Override public List<Runnable> shutdownNow() { List<Runnable> taskList = super.shutdownNow(); taskList.addAll(commandThreadpool.shutdownNow()); return taskList; } @Override public void shutdown() { super.shutdown(); commandThreadpool.shutdown(); } }
import java.util.concurrent.SynchronousQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public class Main { public static void main(String[] args){ long timeout = 2000; ThreadPoolExecutor threadPool = new ThreadPoolExecutor(3, 10, 0, TimeUnit.MILLISECONDS, new SynchronousQueue<>(true)); threadPool = new TimeoutThreadPoolDecorator( threadPool , timeout, TimeUnit.MILLISECONDS); threadPool.execute(command(1000)); threadPool.execute(command(1500)); threadPool.execute(command(2100)); threadPool.execute(command(2001)); while(threadPool.getActiveCount()>0); threadPool.shutdown(); } private static Runnable command(int i) { return () -> { System.out.println("Running Thread:"+Thread.currentThread().getName()); System.out.println("Starting command with sleep:"+i); try { Thread.sleep(i); } catch (InterruptedException e) { System.out.println("Thread "+Thread.currentThread().getName()+" with sleep of "+i+" is Interrupted!!!"); return; } System.out.println("Completing Thread "+Thread.currentThread().getName()+" after sleep of "+i); }; } }
BufferedImage thumbnail = Scalr.resize(image, 150);
import static org.imgscalr.Scalr.*; public static BufferedImage createThumbnail(BufferedImage img) { img = resize(img, Method.SPEED, 125, OP_ANTIALIAS, OP_BRIGHTER); return pad(img, 4); }
FastBitmap fb = new FastBitmap(bitmap); Grayscale g = new Grayscale(); g.applyInPlace(fb); Threshold t = new Threshold(120); t.applyInPlace(fb); bitmap = fb.toBitmap();
int arr[] = new int[10]; for(int i=0;i<arr.length;i++) arr[i] = 0;
int [] myarray = new int[num_elts]; Arrays.fill(myarray, 42);
Integer[] arr = Collections.nCopies(3, 42).toArray(new Integer[0]);
int arr[] = new int[10]; for(int i=0;i<arr.length;i++) arr[i] = 0;
Integer[] data = new Integer[20]; Arrays.fill(data,new Integer(0));
package com.array.zero; public class ArrayZero { public static void main(String[] args) { int[] yourArray = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int[] tempArray = new int[yourArray.length]; Assigning temp array to replace values by zero [0] yourArray = tempArray; for (int item : yourArray) { System.out.println(item); } } }
static private int[] zeros = new float[64]; ... int[] values = ... if (zeros.length < values.length) zeros = new int[values.length]; System.arraycopy(zeros, 0, values, 0, values.length);
Arrays.stream(new Integer[nodelist.size()]).map(e -> Integer.MAX_VALUE).toArray(Integer[]::new);
import java.util.Arrays; public class Main { public static void main(String[] args) { int ar[] = {2, 2, 1, 8, 3, 2, 2, 4, 2}; Arrays.fill(ar, 10); System.out.println("Array completely filled" + " with 10\n" + Arrays.toString(ar)); } }
int a=7, b=7 ,c=0,d=0; int dizi[][]=new int[a][b]; for(int i=0;i<a;i++){ for(int q=d;q<b;q++){ dizi[i][q]=c; System.out.print(dizi[i][q]); c++; } c-=b+1; System.out.println(); }
Date now = new Date(); Long longTime = new Long(now.getTime()/1000); return longTime.intValue();
long unixTime = System.currentTimeMillis() / 1000L;
import java.time.Instant ... long unixTimestamp = Instant.now().getEpochSecond();
Iterator iter = set.iterator(); while (iter.hasNext()) { System.out.println(iter.next()); }
Set<String> set = new HashSet<String>(); for (String s : set) { System.out.println(s); }
Enumeration e = new Vector(movies).elements(); while (e.hasMoreElements()) { System.out.println(e.nextElement()); }
for (String movie : movies) { System.out.println(movie); }
String[] movieArray = movies.toArray(new String[movies.size()]); for (int i = 0; i < movieArray.length; i++) { System.out.println(movieArray[i]); }
movies.stream().forEach((movie) -> { System.out.println(movie); });
movies.stream().forEach(movie -> System.out.println(movie));
Set<String> movies = new HashSet<>(); movies.add("Avatar"); movies.add("The Lord of the Rings"); movies.add("Titanic");
Object[] array = set.toArray(); for(int i=0; i<array.length; i++) Object o = array[i];
Set<Person> people = new HashSet<Person>(); people.add(new Person("Tharindu", 10)); people.add(new Person("Martin", 20)); people.add(new Person("Fowler", 30));
public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } }
for(Person p:people){ System.out.println(p.getName()); }
people.forEach(p -> System.out.println(p.getName()));
default void forEach(Consumer<? super T> action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of iteration (if an iteration order is specified). Exceptions thrown by the action are relayed to the caller. Implementation Requirements: The default implementation behaves as if: for (T t : this) action.accept(t); Parameters: action - The action to be performed for each element Throws: NullPointerException - if the specified action is null Since: 1.8
public class IterateSet { public static void main(String[] args) { Set<String> set = new HashSet<>(); set.add("Jack"); set.add("John"); set.add("Joe"); set.add("Josh"); long startTime = System.nanoTime(); long endTime = System.nanoTime(); System.out.println("Using Iterator"); startTime = System.nanoTime(); Iterator<String> setIterator = set.iterator(); while(setIterator.hasNext()){ System.out.println(setIterator.next()); } endTime = System.nanoTime(); long durationIterator = (endTime - startTime); System.out.println("Using Lambda"); startTime = System.nanoTime(); set.forEach((s) -> System.out.println(s)); endTime = System.nanoTime(); long durationLambda = (endTime - startTime); System.out.println("Using Stream API"); startTime = System.nanoTime(); set.stream().forEach((s) -> System.out.println(s)); endTime = System.nanoTime(); long durationStreamAPI = (endTime - startTime); System.out.println("Using Split Iterator"); startTime = System.nanoTime(); Spliterator<String> splitIterator = set.spliterator(); splitIterator.forEachRemaining((s) -> System.out.println(s)); endTime = System.nanoTime(); long durationSplitIterator = (endTime - startTime); System.out.println("Iterator Duration:" + durationIterator); System.out.println("Lamda Duration:" + durationLambda); System.out.println("Stream API:" + durationStreamAPI); System.out.println("Split Iterator:"+ durationSplitIterator); } }
Iterator Duration: 495287 Lambda Duration: 50207470 Stream Api: 2427392 Split Iterator: 567294
Set<String> set = new HashSet<String>(); set.forEach((s) -> { System.out.println(s); });
Enumeration e = new Vector(set).elements(); while (e.hasMoreElements()) { System.out.println(e.nextElement()); }
for (Enumeration e1 = Collections.enumeration(set); e1.hasMoreElements();) { System.out.println(e1.nextElement()); }
set.forEach(element -> System.out.println(element));
set.stream().forEach((elem) -> { System.out.println(elem); });
public static void main(String[] args) throws IOException { String os = System.getProperty("os.name").toLowerCase(); if (os.contains("win")) { System.out.println("Windows computer name through env:\"" + System.getenv("COMPUTERNAME") + "\""); System.out.println("Windows computer name through exec:\"" + execReadToString("hostname") + "\""); } else if (os.contains("nix") || os.contains("nux") || os.contains("mac os x")) { System.out.println("Unix-like computer name through env:\"" + System.getenv("HOSTNAME") + "\""); System.out.println("Unix-like computer name through exec:\"" + execReadToString("hostname") + "\""); System.out.println("Unix-like computer name through /etc/hostname:\"" + execReadToString("cat /etc/hostname") + "\""); } } public static String execReadToString(String execCommand) throws IOException { try (Scanner s = new Scanner(Runtime.getRuntime().exec(execCommand).getInputStream()).useDelimiter("\\A")) { return s.hasNext() ? s.next() : ""; } }
Unix-like computer name through env:"null" Unix-like computer name through exec:"machinename " Unix-like computer name through /etc/hostname:""
Unix-like computer name through env:"machinename" Unix-like computer name through exec:"machinename " Unix-like computer name through /etc/hostname:""
Unix-like computer name through env:"null" Unix-like computer name through exec:"machinename " Unix-like computer name through /etc/hostname:"machinename "
Windows computer name through env:"MACHINENAME" Windows computer name through exec:"machinename "
Windows computer name through env:"MACHINENAME" Windows computer name through exec:"machinename "
import java.net.InetAddress; import java.net.UnknownHostException; try { String result = InetAddress.getLocalHost().getHostName(); if (StringUtils.isNotEmpty( result)) return result; } catch (UnknownHostException e) { } String host = System.getenv("COMPUTERNAME"); if (host != null) return host; host = System.getenv("HOSTNAME"); if (host != null) return host; return null;
import java.net.InetAddress; import java.net.UnknownHostException; public class getHostName { public static void main(String[] args) throws UnknownHostException { InetAddress iAddress = InetAddress.getLocalHost(); String hostName = iAddress.getHostName(); String canonicalHostName = iAddress.getCanonicalHostName(); System.out.println("HostName:" + hostName); System.out.println("Canonical Host Name:" + canonicalHostName); } }
hostName == null; Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); { while (interfaces.hasMoreElements()) { NetworkInterface nic = interfaces.nextElement(); Enumeration<InetAddress> addresses = nic.getInetAddresses(); while (hostName == null && addresses.hasMoreElements()) { InetAddress address = addresses.nextElement(); if (!address.isLoopbackAddress()) { hostName = address.getHostName(); } } } }
package com.stackoverflow.q1688099; import java.util.List; import com.google.gson.Gson; public class Test { public static void main(String... args) throws Exception { String json = "{" + " + " + " + " + " + " + " + " + " + " + " + " + "}]" + "}]" + "}"; Data data = new Gson().fromJson(json, Data.class); System.out.println(data); } } class Data { private String title; private Long id; private Boolean children; private List<Data> groups; public String getTitle() { return title; } public Long getId() { return id; } public Boolean getChildren() { return children; } public List<Data> getGroups() { return groups; } public void setTitle(String title) { this.title = title; } public void setId(Long id) { this.id = id; } public void setChildren(Boolean children) { this.children = children; } public void setGroups(List<Data> groups) { this.groups = groups; } public String toString() { return String.format("title:%s,id:%d,children:%s,groups:%s", title, id, children, groups); } }
String json = "... ObjectMapper m = new ObjectMapper(); Set<Product> products = m.readValue(json, new TypeReference<Set<Product>>() {});
import com.restfb.json.JsonObject; ... JsonObject json = new JsonObject(jsonString); json.get("title");
HashMap keyArrayList = new HashMap(); Iterator itr = yourJson.keys(); while (itr.hasNext()) { String key =(String) itr.next(); keyArrayList.put(key, yourJson.get(key).toString()); }
import java.util.HashMap; import java.util.Map; import javax.annotation.Generated; import com.fasterxml.jackson.annotation.JsonAnyGetter; import com.fasterxml.jackson.annotation.JsonAnySetter; import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonInclude; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.annotation.JsonPropertyOrder; @JsonInclude(JsonInclude.Include.NON_NULL) @Generated("org.jsonschema2pojo") @JsonPropertyOrder({ "id", "firstName", "lastName" }) public class Employee { @JsonProperty("id") private Integer id; @JsonProperty("firstName") private String firstName; @JsonProperty("lastName") private String lastName; @JsonIgnore private Map<String, Object> additionalProperties = new HashMap<String, Object>(); /** * * @return * The id */ @JsonProperty("id") public Integer getId() { return id; } /** * * @param id * The id */ @JsonProperty("id") public void setId(Integer id) { this.id = id; } /** * * @return * The firstName */ @JsonProperty("firstName") public String getFirstName() { return firstName; } /** * * @param firstName * The firstName */ @JsonProperty("firstName") public void setFirstName(String firstName) { this.firstName = firstName; } /** * * @return * The lastName */ @JsonProperty("lastName") public String getLastName() { return lastName; } /** * * @param lastName * The lastName */ @JsonProperty("lastName") public void setLastName(String lastName) { this.lastName = lastName; } @JsonAnyGetter public Map<String, Object> getAdditionalProperties() { return this.additionalProperties; } @JsonAnySetter public void setAdditionalProperty(String name, Object value) { this.additionalProperties.put(name, value); } }
import org.codehaus.jettison.json.JSONObject; import com.fasterxml.jackson.databind.ObjectMapper; public class LoadFromJSON { public static void main(String args[]) throws Exception { JSONObject json = new JSONObject(); json.put("id", 2); json.put("firstName", "hello"); json.put("lastName", "world"); byte[] jsonData = json.toString().getBytes(); ObjectMapper mapper = new ObjectMapper(); Employee employee = mapper.readValue(jsonData, Employee.class); System.out.print(employee.getLastName()); } }
JSONObject jsonObject = new JSONObject(someJsonString); JSONArray jsonArray = jsonObject.getJSONArray("someJsonArray"); String value = jsonArray.optJSONObject(i).getString("someJsonValue");
String source = "The less than sign (<) and ampersand (&) must be escaped before using them in HTML"; String escaped = source.replace("<", "&lt;").replace("&", "&amp;");
import static org.apache.commons.lang.StringEscapeUtils.escapeHtml; String source = "The less than sign (<) and ampersand (&) must be escaped before using them in HTML"; String escaped = escapeHtml(source);
import static org.apache.commons.lang3.StringEscapeUtils.escapeHtml4; String escaped = escapeHtml4(source);
public static String escapeHTML(String s) { StringBuilder out = new StringBuilder(Math.max(16, s.length())); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 127 || c == out.append("& out.append((int) c); out.append( } else { out.append(c); } } return out.toString(); }
import static org.apache.commons.lang3.StringEscapeUtils.escapeHtml4; String output = escapeHtml4("The less than sign (<) and ampersand (&) must be escaped before using them in HTML");
import com.google.common.html.HtmlEscapers; [...] String source = "The less than sign (<) and ampersand (&) must be escaped before using them in HTML"; String escaped = HtmlEscapers.htmlEscaper().escape(source);
import org.springframework.web.util.HtmlUtils; [...] HtmlUtils.htmlEscapeDecimal("&")` HtmlUtils.htmlEscape("&")`
<dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-text</artifactId> <version>${commons.text.version}</version> </dependency>
System.out.println( "largest long is " + Long.MAX_VALUE ); System.out.println( "largest int is " + Integer.MAX_VALUE ); long x = (long)Integer.MAX_VALUE; x++; System.out.println("long x=" + x); int y = (int) x; System.out.println("int y=" + y);
largest long is 9223372036854775807 largest int is 2147483647 long x=2147483648 int y=-2147483648
if ( x > (long)Integer.MAX_VALUE ) { } else { y = (int)x; }
public static int toIntExact(long value) { if ((int)value != value) { throw new ArithmeticException("integer overflow"); } return (int)value; }
Long l = 1234567L; int i = org.springframework.util.NumberUtils.convertNumberToTargetClass(l, Integer.class);
public static final String ANSI_RESET = "\u001B[0m"; public static final String ANSI_BLACK = "\u001B[30m"; public static final String ANSI_RED = "\u001B[31m"; public static final String ANSI_GREEN = "\u001B[32m"; public static final String ANSI_YELLOW = "\u001B[33m"; public static final String ANSI_BLUE = "\u001B[34m"; public static final String ANSI_PURPLE = "\u001B[35m"; public static final String ANSI_CYAN = "\u001B[36m"; public static final String ANSI_WHITE = "\u001B[37m";
System.out.println(ANSI_RED + "This text is red!" + ANSI_RESET);
public static final String ANSI_BLACK_BACKGROUND = "\u001B[40m"; public static final String ANSI_RED_BACKGROUND = "\u001B[41m"; public static final String ANSI_GREEN_BACKGROUND = "\u001B[42m"; public static final String ANSI_YELLOW_BACKGROUND = "\u001B[43m"; public static final String ANSI_BLUE_BACKGROUND = "\u001B[44m"; public static final String ANSI_PURPLE_BACKGROUND = "\u001B[45m"; public static final String ANSI_CYAN_BACKGROUND = "\u001B[46m"; public static final String ANSI_WHITE_BACKGROUND = "\u001B[47m";
System.out.println(ANSI_GREEN_BACKGROUND + "This text has a green background but default text!" + ANSI_RESET); System.out.println(ANSI_RED + "This text has red text but a default background!" + ANSI_RESET); System.out.println(ANSI_GREEN_BACKGROUND + ANSI_RED + "This text has a green background and red text!" + ANSI_RESET);
print("Hello World!", Attribute.BOLD, FColor.YELLOW, BColor.GREEN);
System.out.println(ConsoleColors.RED + "RED COLORED" + ConsoleColors.RESET + " NORMAL");
public class ConsoleColors { public static final String RESET = "\033[0m"; public static final String BLACK = "\033[0;30m"; public static final String RED = "\033[0;31m"; public static final String GREEN = "\033[0;32m"; public static final String YELLOW = "\033[0;33m"; public static final String BLUE = "\033[0;34m"; public static final String PURPLE = "\033[0;35m"; public static final String CYAN = "\033[0;36m"; public static final String WHITE = "\033[0;37m"; public static final String BLACK_BOLD = "\033[1;30m"; public static final String RED_BOLD = "\033[1;31m"; public static final String GREEN_BOLD = "\033[1;32m"; public static final String YELLOW_BOLD = "\033[1;33m"; public static final String BLUE_BOLD = "\033[1;34m"; public static final String PURPLE_BOLD = "\033[1;35m"; public static final String CYAN_BOLD = "\033[1;36m"; public static final String WHITE_BOLD = "\033[1;37m"; public static final String BLACK_UNDERLINED = "\033[4;30m"; public static final String RED_UNDERLINED = "\033[4;31m"; public static final String GREEN_UNDERLINED = "\033[4;32m"; public static final String YELLOW_UNDERLINED = "\033[4;33m"; public static final String BLUE_UNDERLINED = "\033[4;34m"; public static final String PURPLE_UNDERLINED = "\033[4;35m"; public static final String CYAN_UNDERLINED = "\033[4;36m"; public static final String WHITE_UNDERLINED = "\033[4;37m"; public static final String BLACK_BACKGROUND = "\033[40m"; public static final String RED_BACKGROUND = "\033[41m"; public static final String GREEN_BACKGROUND = "\033[42m"; public static final String YELLOW_BACKGROUND = "\033[43m"; public static final String BLUE_BACKGROUND = "\033[44m"; public static final String PURPLE_BACKGROUND = "\033[45m"; public static final String CYAN_BACKGROUND = "\033[46m"; public static final String WHITE_BACKGROUND = "\033[47m"; public static final String BLACK_BRIGHT = "\033[0;90m"; public static final String RED_BRIGHT = "\033[0;91m"; public static final String GREEN_BRIGHT = "\033[0;92m"; public static final String YELLOW_BRIGHT = "\033[0;93m"; public static final String BLUE_BRIGHT = "\033[0;94m"; public static final String PURPLE_BRIGHT = "\033[0;95m"; public static final String CYAN_BRIGHT = "\033[0;96m"; public static final String WHITE_BRIGHT = "\033[0;97m"; public static final String BLACK_BOLD_BRIGHT = "\033[1;90m"; public static final String RED_BOLD_BRIGHT = "\033[1;91m"; public static final String GREEN_BOLD_BRIGHT = "\033[1;92m"; public static final String YELLOW_BOLD_BRIGHT = "\033[1;93m"; public static final String BLUE_BOLD_BRIGHT = "\033[1;94m"; public static final String PURPLE_BOLD_BRIGHT = "\033[1;95m"; public static final String CYAN_BOLD_BRIGHT = "\033[1;96m"; public static final String WHITE_BOLD_BRIGHT = "\033[1;97m"; public static final String BLACK_BACKGROUND_BRIGHT = "\033[0;100m"; public static final String RED_BACKGROUND_BRIGHT = "\033[0;101m"; public static final String GREEN_BACKGROUND_BRIGHT = "\033[0;102m"; public static final String YELLOW_BACKGROUND_BRIGHT = "\033[0;103m"; public static final String BLUE_BACKGROUND_BRIGHT = "\033[0;104m"; public static final String PURPLE_BACKGROUND_BRIGHT = "\033[0;105m"; public static final String CYAN_BACKGROUND_BRIGHT = "\033[0;106m"; public static final String WHITE_BACKGROUND_BRIGHT = "\033[0;107m"; }
public enum Color { RESET("\033[0m"), BLACK("\033[0;30m"), RED("\033[0;31m"), GREEN("\033[0;32m"), YELLOW("\033[0;33m"), BLUE("\033[0;34m"), MAGENTA("\033[0;35m"), CYAN("\033[0;36m"), WHITE("\033[0;37m"), BLACK_BOLD("\033[1;30m"), RED_BOLD("\033[1;31m"), GREEN_BOLD("\033[1;32m"), YELLOW_BOLD("\033[1;33m"), BLUE_BOLD("\033[1;34m"), MAGENTA_BOLD("\033[1;35m"), CYAN_BOLD("\033[1;36m"), WHITE_BOLD("\033[1;37m"), BLACK_UNDERLINED("\033[4;30m"), RED_UNDERLINED("\033[4;31m"), GREEN_UNDERLINED("\033[4;32m"), YELLOW_UNDERLINED("\033[4;33m"), BLUE_UNDERLINED("\033[4;34m"), MAGENTA_UNDERLINED("\033[4;35m"), CYAN_UNDERLINED("\033[4;36m"), WHITE_UNDERLINED("\033[4;37m"), BLACK_BACKGROUND("\033[40m"), RED_BACKGROUND("\033[41m"), GREEN_BACKGROUND("\033[42m"), YELLOW_BACKGROUND("\033[43m"), BLUE_BACKGROUND("\033[44m"), MAGENTA_BACKGROUND("\033[45m"), CYAN_BACKGROUND("\033[46m"), WHITE_BACKGROUND("\033[47m"), BLACK_BRIGHT("\033[0;90m"), RED_BRIGHT("\033[0;91m"), GREEN_BRIGHT("\033[0;92m"), YELLOW_BRIGHT("\033[0;93m"), BLUE_BRIGHT("\033[0;94m"), MAGENTA_BRIGHT("\033[0;95m"), CYAN_BRIGHT("\033[0;96m"), WHITE_BRIGHT("\033[0;97m"), BLACK_BOLD_BRIGHT("\033[1;90m"), RED_BOLD_BRIGHT("\033[1;91m"), GREEN_BOLD_BRIGHT("\033[1;92m"), YELLOW_BOLD_BRIGHT("\033[1;93m"), BLUE_BOLD_BRIGHT("\033[1;94m"), MAGENTA_BOLD_BRIGHT("\033[1;95m"), CYAN_BOLD_BRIGHT("\033[1;96m"), WHITE_BOLD_BRIGHT("\033[1;97m"), BLACK_BACKGROUND_BRIGHT("\033[0;100m"), RED_BACKGROUND_BRIGHT("\033[0;101m"), GREEN_BACKGROUND_BRIGHT("\033[0;102m"), YELLOW_BACKGROUND_BRIGHT("\033[0;103m"), BLUE_BACKGROUND_BRIGHT("\033[0;104m"), MAGENTA_BACKGROUND_BRIGHT("\033[0;105m"), CYAN_BACKGROUND_BRIGHT("\033[0;106m"), WHITE_BACKGROUND_BRIGHT("\033[0;107m"); private final String code; Color(String code) { this.code = code; } @Override public String toString() { return code; } } System.out.print(Color.BLACK_BOLD); System.out.println("111111111aaaaaaaaaaaaaaaa=============="); System.out.print(Color.RESET); System.out.print(Color.BLUE_BACKGROUND); System.out.print(Color.YELLOW); System.out.println("111111111aaaaaaaaaaaaaaaa=============="); System.out.println("111111111aaaaaaaaaaaaaaaa=============="); System.out.println("111111111aaaaaaaaaaaaaaaa=============="); System.out.println("111111111aaaaaaaaaaaaaaaa=============="); System.out.print(Color.RESET);
String ansiColoredString = ColorCodes.parseColors("Hello, This :blue,n:is[RC] a :red,white:response[RC].");
String ansiColoredString = ColorCodes.RED + "Hello" + ColorCodes.WHITE + ", This is a " + ColorCodes.BLUE + "test";
public class Log { public static final String ANSI_RESET = "\u001B[0m"; public static final String ANSI_BLACK = "\u001B[30m"; public static final String ANSI_RED = "\u001B[31m"; public static final String ANSI_GREEN = "\u001B[32m"; public static final String ANSI_YELLOW = "\u001B[33m"; public static final String ANSI_BLUE = "\u001B[34m"; public static final String ANSI_PURPLE = "\u001B[35m"; public static final String ANSI_CYAN = "\u001B[36m"; public static final String ANSI_WHITE = "\u001B[37m"; public static void i(String className, String message) { System.out.println(ANSI_GREEN + className + " : " + message + ANSI_RESET); } public static void e(String className, String message) { System.out.println(ANSI_RED + className + " : " + message + ANSI_RESET); } public static void d(String className, String message) { System.out.println(ANSI_BLUE + className + " : " + message + ANSI_RESET); } public static void w(String className, String message) { System.out.println(ANSI_YELLOW + className + " : " + message + ANSI_RESET); } }
Log.i(TAG,"This is an info message"); Log.e(TAG,"This is an error message"); Log.w(TAG,"This is a warning message"); Log.d(TAG,"This is a debug message");
RelativeLayout layout =(RelativeLayout)findViewById(R.id.background); layout.setBackgroundResource(R.drawable.ready);
final int sdk = android.os.Build.VERSION.SDK_INT; if(sdk < android.os.Build.VERSION_CODES.JELLY_BEAN) { layout.setBackgroundDrawable(ContextCompat.getDrawable(context, R.drawable.ready) ); } else { layout.setBackground(ContextCompat.getDrawable(context, R.drawable.ready)); }
ContextCompat.getDrawable(context, R.drawable.ready)
/** * Return a drawable object associated with a particular resource ID. * <p> * Starting in {@link android.os.Build.VERSION_CODES * drawable will be styled for the specified Context * * @param id The desired resource identifier, as generated by the aapt tool. * This integer encodes the package, type, and resource entry. * The value 0 is an invalid identifier. * @return Drawable An object that can be used to draw this resource. */ public static final Drawable getDrawable(Context context, int id) { final int version = Build.VERSION.SDK_INT; if (version >= 21) { return ContextCompatApi21.getDrawable(context, id); } else { return context.getResources().getDrawable(id); } }
ContextCompat.getDrawable(context, R.drawable.ready)
import android.support.v4.content.res.ResourcesCompat; ResourcesCompat.getDrawable(getResources(), R.drawable.name_of_drawable, null);
layout.setBackground(ContextCompat.getDrawable(context, R.drawable.ready));
layout.setBackgroundDrawable(ContextCompat.getDrawable(context, R.drawable.ready));
relativeLayout = new RelativeLayout(this); relativeLayout.setBackgroundResource(R.drawable.view); setContentView(relativeLayout);
View v; Drawable image=(Drawable)getResources().getDrawable(R.drawable.img); (ImageView)v.setBackground(image);
@Bind(R.id.some_layout) RelativeLayout layout; @BindDrawable(R.drawable.some_drawable) Drawable background;
if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) layout.setBackgroundDrawable(getResources().getDrawable(R.drawable.ready)); else if(android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP_MR1) layout.setBackground(getResources().getDrawable(R.drawable.ready)); else layout.setBackground(ContextCompat.getDrawable(this, R.drawable.ready));
Drawable thumb = ContextCompat.getDrawable(getActivity(), R.mipmap.cir_32); mSeekBar.setThumb(thumb);
Class<?> enclosingClass = getClass().getEnclosingClass(); if (enclosingClass != null) { System.out.println(enclosingClass.getName()); } else { System.out.println(getClass().getName()); }
String className = this.getClass().getSimpleName();
import java.lang.reflect.Field; public class Test { int x; int y; public void getClassName() { String className = this.getClass().getSimpleName(); System.out.println("Name:" + className); } public void getAttributes() { Field[] attributes = this.getClass().getDeclaredFields(); for(int i = 0; i < attributes.length; i++) { System.out.println("Declared Fields" + attributes[i]); } } public static void main(String args[]) { Test t = new Test(); t.getClassName(); t.getAttributes(); } }
class A { void foo() { obj.addHandler(new Handler() { void bar() { String className=A.this.getClass().getName(); } }); } }
Class thisClass = new Object(){}.getClass(); String className = thisClass.getEnclosingClass().getSimpleName(); String methodName = thisClass.getEnclosingMethod().getName(); Log.d("app", className + ":" + methodName);
String className=""; className = list[i].getClass().getCanonicalName(); System.out.print(className);
Class.getSuperclass() Returns the super class for the given class. Class c = javax.swing.JButton.class.getSuperclass(); The super class of javax.swing.JButton is javax.swing.AbstractButton. Class.getClasses()
Class.getDeclaredClasses() Returns all of the classes interfaces, and enums that are explicitly declared in this class. Class<?>[] c = Character.class.getDeclaredClasses(); Character contains two public member classes Character.Subset and Character.UnicodeBlock and one private class
Class.getDeclaringClass() java.lang.reflect.Field.getDeclaringClass() java.lang.reflect.Method.getDeclaringClass() java.lang.reflect.Constructor.getDeclaringClass() Returns the Class in which these members were declared. Anonymous Class Declarations will not have a declaring class but will
import java.lang.reflect.Field; Field f = System.class.getField("out"); Class c = f.getDeclaringClass(); The field out is declared in System. public class MyClass { static Object o = new Object() { public void m() {} }; static Class<c> = o.getClass().getEnclosingClass(); } The declaring class of the anonymous class defined by o is null. Class.getEnclosingClass() Returns the immediately enclosing class of the class. Class c = Thread.State.class().getEnclosingClass(); The enclosing class of the enum Thread.State is Thread. public class MyClass { static Object o = new Object() { public void m() {} }; static Class<c> = o.getClass().getEnclosingClass(); } The anonymous class defined by o is enclosed by MyClass.
String a = "abc"; String b = "abc"; System.out.println(a == b);
String c = new String("abc"); String d = new String("abc"); System.out.println(c == d);
String s1 = "abcde"; String s2 = new String("abcde"); String s3 = "abcde";
String str = "abc"; String str2 = "abc"; boolean identity = str == str2;
String str = new String("abc"); String str2 = new String("abc"); boolean identity = str == str2;
String st2 = new String("Hello"); String st3 = new String("Hello");
$ cat Test.java public class Test { public static void main(String... args) { String abc = "abc"; String def = new String("def"); } } $ javap -c -v Test Compiled from "Test.java" public class Test extends java.lang.Object SourceFile: "Test.java" minor version: 0 major version: 50 Constant pool: const const const const const const const const ... { public Test(); ... public static void main(java.lang.String[]); Code: Stack=3, Locals=3, Args_size=1 0: ldc 2: astore_1 3: new 6: dup 7: ldc 9: invokespecial 12: astore_2 13: return }
String s1 = "Hello"; String s2 = "Hello"; String s3 = new String("Hello"); System.out.println(s1 == s2); System.out.println(s1.equals(s2)); System.out.println(s1 == s3); System.out.println(s1.equals(s3)); s3 = s3.intern(); System.out.println(s1 == s3); System.out.println(s1.equals(s3));
public interface Actionable { public static boolean isActionable = false; public void performAction(); } public NuclearAction implements Actionable { public void performAction() { if (isActionable) { } } }
public CleanAction implements Actionable { public void performAction() { isActionable = true; } }
public interface A{ int x=65; } public interface B{ int x=66; } public class D implements A,B { public static void main(String[] a){ System.out.println(x); } }
public interface IMyClass { void methodA(); String methodB(); Integer methodC(); } public abstract class myAbstractClass implements IMyClass { protected String varA, varB; myAbstractClass(String varA, String varB) { this.varA = varA; this.varB = VarB; } protected void methodA() { } protected abstract Long methodD(); protected Float methodE() { return 42.0; } } public class myConcreteClass extends myAbstractClass { myClass(String varA, String varB) { super(varA, varB); } }
public interface Addable { static int count = 6; public int add(int i); } public class Impl implements Addable { @Override public int add(int i) { return i+count; } } public class Test { public static void main(String... args) { Impl impl = new Impl(); System.out.println(impl.add(4)); } }
private int age = 10; public int getAge() { return age; } public void setAge(int age) { this.age = age; }
public class BaseVO { protected Long id; @Override public boolean equals(Object obj) { if (obj == null || id == null) return false; if (obj instanceof BaseVO) return ((BaseVO) obj).getId().equals(id); return false; } @Override public int hashCode() { return id == null ? null : id.hashCode(); } } public class Subclass extends BaseVO { protected String name; protected String category; }
open class BaseVO(var id: Long? = null) { override fun hashCode(): Int { if (id != null) return id.hashCode() return super.hashCode() } override fun equals(other: Any?): Boolean { if (id == null || other == null || other !is BaseVO) return false return id.hashCode() == other.id?.hashCode() } } @Suppress("unused") class Subclass( var name: String? = null, var category: String? = null ) : BaseVO()
public class UTF8Control extends Control { public ResourceBundle newBundle (String baseName, Locale locale, String format, ClassLoader loader, boolean reload) throws IllegalAccessException, InstantiationException, IOException { String bundleName = toBundleName(baseName, locale); String resourceName = toResourceName(bundleName, "properties"); ResourceBundle bundle = null; InputStream stream = null; if (reload) { URL url = loader.getResource(resourceName); if (url != null) { URLConnection connection = url.openConnection(); if (connection != null) { connection.setUseCaches(false); stream = connection.getInputStream(); } } } else { stream = loader.getResourceAsStream(resourceName); } if (stream != null) { try { bundle = new PropertyResourceBundle(new InputStreamReader(stream, "UTF-8")); } finally { stream.close(); } } return bundle; } }
ResourceBundle bundle = ResourceBundle.getBundle("com.example.i18n.text", new UTF8Control());
return new String(val.getBytes("ISO-8859-1"), "UTF-8");
InputStreamReader isr = new InputStreamReader(stream, "UTF-8");
InputStream stream = this.class.getClassLoader().getResourceAsStream("a.properties");
native2ascii -encoding utf8 resources.utf8 resources.properties
package com.varaneckas.utils; import java.io.UnsupportedEncodingException; import java.util.Enumeration; import java.util.PropertyResourceBundle; import java.util.ResourceBundle; /** * UTF-8 friendly ResourceBundle support * * Utility that allows having multi-byte characters inside java .property files. * It removes the need for Sun * UTF-8 encoded editable .property files. * * Use: * ResourceBundle bundle = Utf8ResourceBundle.getBundle("bundle_name"); * * @author Tomas Varaneckas <tomas.varaneckas@gmail.com> */ public abstract class Utf8ResourceBundle { /** * Gets the unicode friendly resource bundle * * @param baseName * @see ResourceBundle * @return Unicode friendly resource bundle */ public static final ResourceBundle getBundle(final String baseName) { return createUtf8PropertyResourceBundle( ResourceBundle.getBundle(baseName)); } /** * Creates unicode friendly {@link PropertyResourceBundle} if possible. * * @param bundle * @return Unicode friendly property resource bundle */ private static ResourceBundle createUtf8PropertyResourceBundle( final ResourceBundle bundle) { if (!(bundle instanceof PropertyResourceBundle)) { return bundle; } return new Utf8PropertyResourceBundle((PropertyResourceBundle) bundle); } /** * Resource Bundle that does the hard work */ private static class Utf8PropertyResourceBundle extends ResourceBundle { /** * Bundle with unicode data */ private final PropertyResourceBundle bundle; /** * Initializing constructor * * @param bundle */ private Utf8PropertyResourceBundle(final PropertyResourceBundle bundle) { this.bundle = bundle; } @Override @SuppressWarnings("unchecked") public Enumeration getKeys() { return bundle.getKeys(); } @Override protected Object handleGetObject(final String key) { final String value = bundle.getString(key); if (value == null) return null; try { return new String(value.getBytes("ISO-8859-1"), "UTF-8"); } catch (final UnsupportedEncodingException e) { throw new RuntimeException("Encoding not supported", e); } } } }
File file = new File("/path/to/example.properties"); Properties properties = new Properties(); if (file.exists()) { try (Reader reader = Files.newReader(file, Charsets.UTF_8)) { properties.load(reader); } catch (IOException e) { } }
File file = new File("/path/to/example.properties"); try (Writer writer = Files.newWriter(file, Charsets.UTF_8)) { properties.store(writer, "Your title here"); writer.flush(); } catch (IOException e) { }
public String message(String key, boolean toUTF8) throws Throwable{ String result = ""; try{ FacesContext context = FacesContext.getCurrentInstance(); String message = context.getApplication().getResourceBundle(context, "messages").getString(key); result = message==null ? "" : toUTF8 ? new String(message.getBytes("iso8859-1"), "utf-8") : message; }catch(Throwable t){} return result; }
Properties prop = new Properties(); String fileName = "./src/test/resources/predefined.properties"; FileInputStream inputStream = new FileInputStream(fileName); InputStreamReader reader = new InputStreamReader(inputStream,"UTF-8");
iconv -f ISO-8859-15 -t UTF-8 messages_nl.properties > messages_nl.properties.new
import java.io.UnsupportedEncodingException; import java.util.Locale; import java.util.ResourceBundle; public class MyResourceBundle { private ResourceBundle bundle; private String fileEncoding; public MyResourceBundle(Locale locale, String fileEncoding){ this.bundle = ResourceBundle.getBundle("com.app.Bundle", locale); this.fileEncoding = fileEncoding; } public MyResourceBundle(Locale locale){ this(locale, "UTF-8"); } public String getString(String key){ String value = bundle.getString(key); try { return new String(value.getBytes("ISO-8859-1"), fileEncoding); } catch (UnsupportedEncodingException e) { return value; } } }
private MyResourceBundle labels = new MyResourceBundle("es", "UTF-8"); String label = labels.getString(key)
private MyResourceBundle labels = new MyResourceBundle("es");
Information:Using javac 1.7.0_55 to compile java sources Information:java: Errors occurred while compiling module Information:Compilation completed with 1 error and 0 warnings in 3 sec Information:1 error Information:0 warnings Error:java: invalid source release: 8
targetCompatibility = 1.6 sourceCompatibility = 1.6
<plugin> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin>
grails.project.target.level = 1.6 grails.project.source.level = 1.6
class TimeTest1 { public static void main(String[] args) { long startTime = System.currentTimeMillis(); long total = 0; for (int i = 0; i < 10000000; i++) { total += i; } long stopTime = System.currentTimeMillis(); long elapsedTime = stopTime - startTime; System.out.println(elapsedTime); } }
class TimeTest2 { public static void main(String[] args) { Stopwatch timer = new Stopwatch().start(); long total = 0; for (int i = 0; i < 10000000; i++) { total += i; } timer.stop(); System.out.println(timer.getElapsedTime()); } }
long startTime = System.nanoTime(); myCall(); long stopTime = System.nanoTime(); System.out.println(stopTime - startTime);
Instant start = Instant.now(); Thread.sleep(63553); Instant end = Instant.now(); System.out.println(Duration.between(start, end));
Stopwatch stopwatch = Stopwatch.createStarted(); myCall(); stopwatch.stop(); System.out.println("Time elapsed for myCall() is "+ stopwatch.elapsed(MILLISECONDS));
long start = System.currentTimeMillis(); class.method(); long time = System.currentTimeMillis() - start;
public class MyService { public void doSomething() { for (int i = 1; i < 10000; i++) { System.out.println("i=" + i); } } }
public class ServiceMethodInterceptor implements MethodInterceptor { public Object invoke(MethodInvocation methodInvocation) throws Throwable { long startTime = System.currentTimeMillis(); Object result = methodInvocation.proceed(); long duration = System.currentTimeMillis() - startTime; Method method = methodInvocation.getMethod(); String methodName = method.getDeclaringClass().getName() + "." + method.getName(); System.out.println("Method return null; } }
long start1 = System.nanoTime(); long start2 = System.nanoTime(); myCall(); long stop = System.nanoTime(); long diff = stop - 2*start2 + start1; System.out.println(diff + " ns");
try{ } catch(InterruptedException e) { Thread.currentThread().interrupt(); }
try{ } catch(InterruptedException e) { throw new RuntimeException(e); }
int computeSum(Server server) throws InterruptedException { int a = server.getValueA(); int b = server.getValueB(); return a + b; }
void printSum(Server server) { try { int sum = computeSum(server); System.out.println("Sum: " + sum); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println("Failed to compute sum"); } }
String tryToReadFile(File f) throws InterruptedException { for (int i = 0; i < 10; i++) { if (f.exists()) return readFile(f); Thread.sleep(1000); } return null; }
String[] names = new String[] {"Ryan", "Julie", "Bob"};
new ArrayList<Integer>(Arrays.asList(1,2,3,5,8,13,21));
ArrayList<String> list = new ArrayList(Arrays.asList("Ryan", "Julie", "Bob"));
List<String> list = Arrays.asList("Ryan", "Julie", "Bob")
ArrayList<String> list = (ArrayList<String>)Arrays.asList("Ryan", "Julie", "Bob")
String[] elements = new String[] {"Ryan", "Julie", "Bob"}; List list = new ArrayList(Arrays.asList(elements));
public ArrayList(Collection<? extends E> collection) { ...... Object[] a = collection.toArray(); }
if (a.getClass() != Object[].class) { Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; } array = a; size = a.length;
(List<Integer>)(List<?>) new ArrayList<>(Arrays.asList((Object) 1, 2 ,3, 4, 5));
ArrayList<String> names = new ArrayList<String>(); Collections.addAll(names, "Ryan", "Julie", "Bob");
List<String> names = Op.onListFor("Ryan", "Julie", "Bob").get();
if (newCapacity - minCapacity < 0) newCapacity = minCapacity;
if (newCapacity < minCapacity) newCapacity = minCapacity;
int a = Integer.MAX_VALUE; int b = Integer.MIN_VALUE; if (a < b) { System.out.println("a < b"); } if (a - b < 0) { System.out.println("a - b < 0"); }
int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity < 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity);
if (oldCapacity > RESIZE_OVERFLOW_THRESHOLD) { } else { }
int newcount = count + len; ensureCapacity(newcount);
ensureCapacity(count, len); int newcount = count + len;
/** * Increases the capacity of this <tt>ArrayList</tt> instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) { modCount++; if (minCapacity - elementData.length > 0) grow(minCapacity); } /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity < 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } private int hugeCapacity(int minCapacity) { if (minCapacity < 0) throw new OutOfMemoryError(); return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; }
int newcount = count + len; ensureCapacity(newcount);
int newCapacity = oldCapacity + (oldCapacity >> 1);
CharSequence cs = "string"; String s = cs.toString(); foo(s); public void foo(CharSequence cs) { System.out.println(cs); }
CharSequence[] cs = String[] {"String to CharSequence"};
scala> cols res8: Iterable[String] = List(Item, a, b) scala> val header = String.join(",", cols) <console>:13: error: overloaded method value join with alternatives: (x$1: CharSequence,x$2: java.lang.Iterable[_ <: CharSequence])String <and> (x$1: CharSequence,x$2: CharSequence*)String cannot be applied to (String, Iterable[String]) val header = String.join(",", cols)
scala> val header = String.join(",", coll: _*) header: String = Item,a,b
private static final DecimalFormat timeFormat4 = new DecimalFormat("0000;0000"); public static byte[] getSidWithCalendar() { Calendar cal = Calendar.getInstance(); String val = String.valueOf(cal.get(Calendar.YEAR)); val += timeFormat4.format(cal.get(Calendar.DAY_OF_YEAR)); val += UUID.randomUUID().toString().replaceAll("-", ""); return val.getBytes(); }
public class Foo { @Inject Logger LOG; @PostConstruct public void fooInit(){ LOG.info("This will be printed; LOG has already been injected"); } public Foo() { LOG.info("This will NOT be printed, LOG is still null"); } }
public class Car { @Inject private Engine engine; public Car() { engine.initialize(); } ... }
public class Car { @Inject private Engine engine; @PostConstruct public void postConstruct() { engine.initialize(); } ... }
private void processPostConstruct(Class type, T targetInstance) { Method[] declaredMethods = type.getDeclaredMethods(); Arrays.stream(declaredMethods) .filter(method -> method.getAnnotation(PostConstruct.class) != null) .forEach(postConstructMethod -> { try { postConstructMethod.setAccessible(true); postConstructMethod.invoke(targetInstance, new Object[]{}); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) { throw new RuntimeException(ex); } }); }
keytool -keypasswd -alias <key_name> -keystore my.keystore
keytool -storepasswd -keystore /path/to/keystore Enter keystore password: changeit New keystore password: new-password Re-enter new keystore password: new-password
$ keytool -storepasswd -keystore keystorename Enter keystore password: <old password> New keystore password: <new password> Re-enter new keystore password: <new password>
$keytool -keypasswd -keystore keystorename -alias aliasname Enter keystore password: New key password for <aliasname>: Re-enter new key password for <aliasname>:
**Keystorename**: name of your keystore(with path if you are indifferent folder) **aliasname**: alias name you used when creating (if name has space you can use \) for example: $keytool -keypasswd -keystore keystorename -alias stop\ watch
keytool -keystore mykeyfile -keypasswd -alias myalias
keytool -importkeystore -srckeystore mystore.jck -destkeystore myotherstore.jks -srcstoretype jceks -deststoretype jks -srcstorepass mystorepass -deststorepass myotherstorepass -srcalias myserverkey -destalias myotherserverkey -srckeypass mykeypass -destkeypass myotherkeypass
List<String> stringList = new ArrayList<String>(); List<Integer> integerList = new ArrayList<Integer>();
package test; import java.lang.reflect.Field; import java.lang.reflect.ParameterizedType; import java.util.ArrayList; import java.util.List; public class Test { List<String> stringList = new ArrayList<String>(); List<Integer> integerList = new ArrayList<Integer>(); public static void main(String... args) throws Exception { Field stringListField = Test.class.getDeclaredField("stringList"); ParameterizedType stringListType = (ParameterizedType) stringListField.getGenericType(); Class<?> stringListClass = (Class<?>) stringListType.getActualTypeArguments()[0]; System.out.println(stringListClass); Field integerListField = Test.class.getDeclaredField("integerList"); ParameterizedType integerListType = (ParameterizedType) integerListField.getGenericType(); Class<?> integerListClass = (Class<?>) integerListType.getActualTypeArguments()[0]; System.out.println(integerListClass); } }
Type[] types = method.getGenericParameterTypes(); ParameterizedType pType = (ParameterizedType) types[0]; Class<?> clazz = (Class<?>) pType.getActualTypeArguments()[0]; System.out.println(clazz);
import java.lang.reflect.Method; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.util.Collection; import java.util.List; public class Test { public List<String> test() { return null; } public static void main(String[] args) throws Exception { for (Method method : Test.class.getMethods()) { Class returnClass = method.getReturnType(); if (Collection.class.isAssignableFrom(returnClass)) { Type returnType = method.getGenericReturnType(); if (returnType instanceof ParameterizedType) { ParameterizedType paramType = (ParameterizedType) returnType; Type[] argTypes = paramType.getActualTypeArguments(); if (argTypes.length > 0) { System.out.println("Generic type is " + argTypes[0]); } } } } } }
((Class)((ParameterizedType)field.getGenericType()).getActualTypeArguments()[0]).getSimpleName()
Collection<?> myCollection = getUnknownCollectionFromSomewhere(); Class genericClass = null; Iterator it = myCollection.iterator(); if (it.hasNext()){ genericClass = it.next().getClass(); } if (genericClass != null) {
/** * Performs a forced cast. * Returns null if the collection type does not match the items in the list. * @param data The list to cast. * @param listType The type of list to cast to. */ static <T> List<? super T> castListSafe(List<?> data, Class<T> listType){ List<T> retval = null; if(data!=null && !data.isEmpty() && listType.isInstance(data.iterator().next().getClass())) { @SuppressWarnings("unchecked") List<T> foo = (List<T>)data; return retval; } return retval; } Usage: protected WhateverClass add(List<?> data) { if(data==null) || data.isEmpty(){ throw new IllegalArgumentException("add() " + data==null?"null":"empty" + " collection"); } Class<?> colType = data.iterator().next().getClass(); aMethod(castListSafe(data, colType)); } aMethod(List<Foo> foo){ for(Foo foo: List){ System.out.println(Foo); } } aMethod(List<Bar> bar){ for(Bar bar: List){ System.out.println(Bar); } }
for(Field field : this.getDeclaredFields()) { System.out.println(field.getGenericType()) }
List<Object> listCheck = (List<Object>)(Object) stringList; if (!listCheck.isEmpty()) { if (listCheck.get(0) instanceof String) { System.out.println("List type is String"); } if (listCheck.get(0) instanceof Integer) { System.out.println("List type is Integer"); } } }
import org.junit.Assert; import org.junit.Test; import java.lang.reflect.Field; import java.lang.reflect.ParameterizedType; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class GenericTypeOfCollectionTest { public class FormBean { } public class MyClazz { private List<FormBean> list = new ArrayList<FormBean>(); } @Test public void testName() throws Exception { Field[] fields = MyClazz.class.getFields(); for (Field field : fields) { if (Collection.class.isAssignableFrom(field.getType())) { Class fieldGenericType = getFieldGenericType(field); Assert.assertTrue("List<FormBean>", FormBean.class.isAssignableFrom(fieldGenericType)); } } } public Class getFieldGenericType(Field field) { if (ParameterizedType.class.isAssignableFrom(field.getGenericType().getClass())) { ParameterizedType genericType = (ParameterizedType) field.getGenericType(); return ((Class) (genericType.getActualTypeArguments()[0])).getSuperclass(); } return new Boolean(false).getClass(); } }
public String openFileToString(byte[] _bytes) { String file_string = ""; for(int i = 0; i < _bytes.length; i++) { file_string += (char)_bytes[i]; } return file_string; }
String str = new String(bytes, StandardCharsets.UTF_8);
String str = IOUtils.toString(inputStream, StandardCharsets.UTF_8);
byte[] byteArray = new byte[] {87, 79, 87, 46, 46, 46}; String value = new String(byteArray, "UTF-8");
public String openFileToString(String fileName) throws IOException { InputStream is = new BufferedInputStream(new FileInputStream(fileName)); try { InputStreamReader rdr = new InputStreamReader(is, "UTF-8"); StringBuilder contents = new StringBuilder(); char[] buff = new char[4096]; int len = rdr.read(buff); while (len >= 0) { contents.append(buff, 0, len); } return buff.toString(); } finally { try { is.close(); } catch (Exception e) { } } }
static final int BUFF_SIZE = 2048; static final String DEFAULT_ENCODING = "utf-8"; public static String readFileToString(String filePath, String encoding) throws IOException { if (encoding == null || encoding.length() == 0) encoding = DEFAULT_ENCODING; StringBuffer content = new StringBuffer(); FileInputStream fis = new FileInputStream(new File(filePath)); byte[] buffer = new byte[BUFF_SIZE]; int bytesRead = 0; while ((bytesRead = fis.read(buffer)) != -1) content.append(new String(buffer, 0, bytesRead, encoding)); fis.close(); return content.toString(); }
public String openFileToString(String fileName) { String file_string; try { file_string = new String(_bytes, "UTF-8"); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } return file_string; }
public String openFileToString(String fileName) { StringBuilder s = new StringBuilder(_bytes.length); for(int i = 0; i < _bytes.length; i++) { s.append((char)_bytes[i]); } return s.toString(); }
BufferedReader in = new BufferedReader(new InputStreamReader( new FileInputStream( "foo.txt"), Charset.forName( "UTF-8"));
Foo mockFoo = mock(Foo.class); when(mockFoo.getValue).thenReturn(new Bar());
Foo<Bar> mockFoo = (Foo<Bar>) mock(Foo.class); when(mockFoo.getValue).thenReturn(new Bar());
@RunWith(MockitoJUnitRunner.class) public class FooTests { @Mock public Foo<Bar> fooMock; @Test public void testFoo() { when(fooMock.getValue()).thenReturn(new Bar()); } }
Foo<Bar> mockFoo = mock(FooBar.class); when(mockFoo.getValue()).thenReturn(new Bar());
@Test public void testMyTest() { Foo<Bar> mockFooBar = mockFoo(); when(mockFooBar.getValue).thenReturn(new Bar()); Foo<Baz> mockFooBaz = mockFoo(); when(mockFooBaz.getValue).thenReturn(new Baz()); Foo<Qux> mockFooQux = mockFoo(); when(mockFooQux.getValue).thenReturn(new Qux()); } @SuppressWarnings("unchecked") private <T> Foo<T> mockFoo() { return mock(Foo.class); }
Collection<? extends Assertion> map(Collection<? extends Assertion> assertions);
when(mockedObject.map(anyCollectionOf(Assertion.class))).thenAnswer( new Answer<Collection<Assertion>>() { @Override public Collection<Assertion> answer(InvocationOnMock invocation) throws Throwable { return new ArrayList<Assertion>(); } });
frame.dispatchEvent(new WindowEvent(frame, WindowEvent.WINDOW_CLOSING));
frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
public void pullThePlug() { WindowEvent wev = new WindowEvent(this, WindowEvent.WINDOW_CLOSING); Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(wev); setVisible(false); dispose(); System.exit(0); }
import java.awt.event.*; import javax.swing.*; public class ExitApp extends JFrame { public ExitApp() { addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { dispose(); System.exit(0); } }); } public static void main(String[] args) { ExitApp app=new ExitApp(); app.setBounds(133,100,532,400); app.setVisible(true); } }
System.exit(0); frame.dispose(); frame.setVisible(false);
myFrame.dispatchEvent(new WindowEvent(myFrame, WindowEvent.WINDOW_CLOSING));
private WindowAdapter windowAdapter = null; private void initFrame() { this.windowAdapter = new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { super.windowClosing(e); int res = JOptionPane.showConfirmDialog(ClosableFrame.this, "Are you sure you want to close?", "Close?", JOptionPane.YES_NO_OPTION); if ( res == 0 ) { ClosableFrame.this.dispose(); } } @Override public void windowClosed(WindowEvent e) { super.windowClosed(e); } }; this.setDefaultCloseOperation(ClosableFrame.DO_NOTHING_ON_CLOSE); this.addWindowListener(this.windowAdapter); }
WindowEvent closingEvent = new WindowEvent(targetFrame, WindowEvent.WINDOW_CLOSING); Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(closingEvent);
myFrame.dispatchEvent(new WindowEvent(myFrame, WindowEvent.WINDOW_CLOSING));
public class WindowConfirmedCloseAdapter extends WindowAdapter { public void windowClosing(WindowEvent e) { Object options[] = {"Yes", "No"}; int close = JOptionPane.showOptionDialog(e.getComponent(), "Really want to close this application?\n", "Attention", JOptionPane.YES_NO_OPTION, JOptionPane.INFORMATION_MESSAGE, null, options, null); if(close == JOptionPane.YES_OPTION) { ((JFrame)e.getSource()).setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE); } else { ((JFrame)e.getSource()).setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE); } } } public class ConfirmedCloseWindow extends JFrame { public ConfirmedCloseWindow() { addWindowListener(new WindowConfirmedCloseAdapter()); } private void closeWindow() { processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING)); } }
JFrame frame= new JFrame() frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.dispatchEvent(new WindowEvent(frame, WindowEvent.WINDOW_CLOSING));
public void closeWindow() { if(awtWindow_ != null) { EventQueue.invokeLater(new Runnable() { public void run() { awtWindow_.dispatchEvent(new WindowEvent(awtWindow_, WindowEvent.WINDOW_CLOSING)); } }); } }
private void formWindowClosing(java.awt.event.WindowEvent evt) { int selectedOption = JOptionPane.showConfirmDialog(null, "Do you want to exit?", "FrameToClose", JOptionPane.YES_NO_OPTION); if (selectedOption == JOptionPane.YES_OPTION) { setVisible(false); dispose(); } else { setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE); } }
public class FooWindow extends JFrame { public FooWindow() { setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(5, 5, 400, 300); setVisible(true); } public void pullThePlug() { WindowEvent wev = new WindowEvent(this, WindowEvent.WINDOW_CLOSING); Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(wev); } } FooWindow fooey = new FooWindow(); ... fooey.pullThePlug();
<p>The length of the companies collection is : ${fn:length(companies)}</p>
<c:if test="${fn:length(companies) gt 0}"> <p>It is greater than 0</p> </c:if>
public class Foo { public interface Bar { void callback(); } public static void registerCallback(Bar bar) {...} } Foo.registerCallback(new Foo.Bar() { public void callback() {...} });
class ConcreteA implements A { : } class ConcreteB implements B { : } class ConcreteC implements C { : } class Zoo implements A, C { : } class DoSomethingAlready { interface AC extends A, C { } private final AC ac; DoSomethingAlready(AC ac) { this.ac = ac; } }
class LangF<This extends LangF<This>> { interface Visitor<R> { public R forNum(int n); } interface Exp { public <R> R visit(This.Visitor<R> v); } }
import java.io.*; import java.util.*; class GFG { public static void main (String[] args) { HashSet <Integer> mySet=new HashSet<Integer>(); mySet.add(100); mySet.add(100); int n = mySet.size(); Integer arr[] = new Integer[n]; arr = mySet.toArray(arr); System.out.println(arr[0]); } }
public T getElement(Set<T> set, T element) { T result = null; if (set instanceof TreeSet<?>) { T floor = ((TreeSet<T>) set).floor(element); if (floor != null && floor.equals(element)) result = floor; } else { boolean found = false; for (Iterator<T> it = set.iterator(); !found && it.hasNext();) { if (true) { T current = it.next(); if (current.equals(element)) { result = current; found = true; } } } } return result; }
class DizzyDean { int pitch() { throw new RuntimeException("90 mph?!"); } }
public java.lang.String getBar(); Code: 0: aload_0 1: getfield 4: areturn
public String getBar(); Code: 0: iconst_1 1: ireturn
Optional<String> firstElement = collection.stream().findFirst();
List<String> myList = new ArrayList<String>(); ... String first = myList.get(0);
/** * Operator that limit the total number of items emitted through the pipeline * Shall print * [1] * @throws InterruptedException */ @Test public void limitStream() throws InterruptedException { List<Integer> list = Arrays.asList(1, 2, 3, 1, 4, 2, 3) .stream() .limit(1) .collect(toList()); System.out.println(list); }
List<String> listString = (List) getStrings(); String firstElement = (listString.isEmpty() ? null : listString.get(0));
Collection<String> stringCollection = ...; String string = collection.stream().collect(MoreCollectors.onlyElement())
Optional<String> optionalString = collection.stream().findFirst();
String strz[] = strs.toArray(String[strs.size()]); String theFirstOne = strz[0];
Object Object_Array[]=new Object[100]; String String_Array[]=new String[Object_Array.length]; for (int i=0;i<String_Array.length;i++) String_Array[i]=Object_Array[i].toString();
String[] stringArray = Arrays.copyOf(objectArray, objectArray.length, String[].class);
Arrays.asList(Object_Array).toArray(new String[Object_Array.length]);
String[] strings = Arrays.stream(objects).toArray(String[]::new);
String[] strings = Arrays.stream(obj).map(Object::toString). toArray(String[]::new);
* <p>The returned array will be "safe" in that no references to it are * maintained by this list. (In other words, this method must * allocate a new array even if this list is backed by an array). * The caller is thus free to modify the returned array.
List<String> tList = new ArrayList<String>(); tList.add("4"); tList.add("5"); String tArray[] = (String[]) tList.toArray();
Object tSObjectArray[] = new String[2]; String tStringArray[] = (String[]) tSObjectArray;
Object tSObjectArray[] = new Object[2]; String tStringArray[] = (String[]) tSObjectArray;
Iterable<Object> objects = ....... Iterable<String> strings = com.google.common.collect.Iterables.transform(objects, new Function<Object, String>(){ String apply(Object from){ return from.toString(); } });
for (int i=0;i<String_Array.length;i++) String_Array[i]= (String) Object_Array[i];
Object[] o = new String[10]; String[] s = (String[]) o;
for (int i=0;i<String_Array.length;i++) String_Array[i]=(String)Object_Array[i];
Object arr3[]=list1.toArray(); String common[]=new String[arr3.length]; for (int i=0;i<arr3.length;i++) { common[i]=(String)arr3[i]; }
TypeConverter.registerConverter(Object[].class, String[].class, new Converter<Object[], String[]>() { @Override public String[] convert(Object[] source) { String[] strings = new String[source.length]; for(int i = 0; i < source.length ; i++) { strings[i] = source[i].toString(); } return strings; } });
Object[] objects = new Object[] {1, 23.43, true, "text", String[] strings = TypeConverter.convert(objects, String[].class);
for(int i=0; i<drive.length ; i++) { Str[i]= drivex[i].toString(); System.out.println(Str[i]); }
class A { private String extraVar; public String myFormat(String format, Object ... args){ return String.format(format, extraVar, args); } }
public static String ezFormat(Object... args) { String format = new String(new char[args.length]) .replace("\0", "[ %s ]"); return String.format(format, args); } public static void main(String... args) { System.out.println(ezFormat("A", "B", "C")); }
static void count(Object... objs) { System.out.println(objs.length); } count(null, null, null); count(null, null); count(null);
count(new Object[] { null }); count((Object) null);
String[] myArgs = { "A", "B", "C" }; System.out.println(ezFormat(myArgs, "Z"));
static <T> T[] append(T[] arr, T lastElement) { final int N = arr.length; arr = java.util.Arrays.copyOf(arr, N+1); arr[N] = lastElement; return arr; } static <T> T[] prepend(T[] arr, T firstElement) { final int N = arr.length; arr = java.util.Arrays.copyOf(arr, N+1); System.arraycopy(arr, 0, arr, 1, N); arr[0] = firstElement; return arr; }
String[] myArgs = { "A", "B", "C" }; System.out.println(ezFormat(append(myArgs, "Z"))); System.out.println(ezFormat(prepend(myArgs, "Z")));
int[] myNumbers = { 1, 2, 3 }; System.out.println(ezFormat(myNumbers));
Integer[] myNumbers = { 1, 2, 3 }; System.out.println(ezFormat(myNumbers));
String.format("%s %s", new Object[] { "hello", "world!"});
Object newArgs = new Object[args.length+1]; System.arraycopy(args, 0, newArgs, 1, args.length); newArgs[0] = extraVar; String.format(format, extraVar, args);
String[] arr= new String[] { "A", "B", "C" }; Object obj = arr;
C:\java -X -Xmixed mixed mode execution (default) -Xint interpreted mode execution only -Xbootclasspath:<directories and zip/jar files separated by ;> set search path for bootstrap classes and resources -Xbootclasspath/a:<directories and zip/jar files separated by ;> append to end of bootstrap class path -Xbootclasspath/p:<directories and zip/jar files separated by ;> prepend in front of bootstrap class path -Xnoclassgc disable class garbage collection -Xincgc enable incremental garbage collection -Xloggc:<file> log GC status to a file with time stamps -Xbatch disable background compilation -Xms<size> set initial Java heap size -Xmx<size> set maximum Java heap size -Xss<size> set java thread stack size -Xprof output cpu profiling data -Xfuture enable strictest checks, anticipating future default -Xrs reduce use of OS signals by Java/VM (see documentation) -Xcheck:jni perform additional checks for JNI functions -Xshare:off do not attempt to use shared class data -Xshare:auto use shared class data if possible (default) -Xshare:on require using shared class data, otherwise fail. The -X options are non-standard and subject to change without notice.
Invalid format: "04/02/2011 14:42:17" is malformed at "/02/2011 14:42:17"
DateTimeFormatter formatter = DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss"); DateTime dt = formatter.parseDateTime(string);
DateTime date = DateTime.parse("04/02/2011 20:27:05", DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss"));
DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss").parseDateTime("04/02/2011 20:27:05");
String dateTime = "2015-07-18T13:32:56.971-0400"; DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd .withLocale(Locale.ROOT) .withChronology(ISOChronology.getInstanceUTC()); DateTime dt = formatter.parseDateTime(dateTime);
DateTimeFormatter format = DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss"); DateTime time = format.parseDateTime("04/02/2011 20:27:05");
Date startDate = null; Date endDate = null; try { if (validDateStart!= null) startDate = new SimpleDateFormat("MM/dd/yyyy HH:mm", Locale.ENGLISH).parse(validDateStart + " " + validDateStartTime); if (validDateEnd!= null) endDate = new SimpleDateFormat("MM/dd/yyyy HH:mm", Locale.ENGLISH).parse(validDateEnd + " " + validDateEndTime); } catch (ParseException e) { e.printStackTrace(); }
java.time.LocalDateTime.parse( "04/02/2011 20:27:05" , DateTimeFormatter.ofPattern( "dd/MM/uuuu HH:mm:ss" ) )
String input = "04/02/2011 20:27:05" ; DateTimeFormatter f = DateTimeFormatter.ofPattern( "dd/MM/uuuu HH:mm:ss" ) ; LocalDateTime ldt = LocalDateTime.parse( input , f ) ;
public static DateTime transfStringToDateTime(String dateParam, Session session) throws NotesException { DateTime dateRetour; dateRetour = session.createDateTime(dateParam); return dateRetour; }
DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss").parseDateTime("04/02/2011 20:27:05");
String dateValue = "04/02/2011 20:27:05"; SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss"); Date date = sdf.parse(dateValue); System.out.println(date);
double a = 0.02; double b = 0.03; double c = b - a; System.out.println(c); BigDecimal _a = new BigDecimal("0.02"); BigDecimal _b = new BigDecimal("0.03"); BigDecimal _c = _b.subtract(_a); System.out.println(_c);
1/7 = 0.142857142857142857142857142857142857142857...
1/10 = binary 0.0001100110011001100110011001100110...
static void theDoubleProblem1() { double d1 = 0.3; double d2 = 0.2; System.out.println("Double:\t 0,3 - 0,2 = " + (d1 - d2)); float f1 = 0.3f; float f2 = 0.2f; System.out.println("Float:\t 0,3 - 0,2 = " + (f1 - f2)); BigDecimal bd1 = new BigDecimal("0.3"); BigDecimal bd2 = new BigDecimal("0.2"); System.out.println("BigDec:\t 0,3 - 0,2 = " + (bd1.subtract(bd2))); }
Double: 0,3 - 0,2 = 0.09999999999999998 Float: 0,3 - 0,2 = 0.10000001 BigDec: 0,3 - 0,2 = 0.1
static void theDoubleProblem2() { double d1 = 10; double d2 = 3; System.out.println("Double:\t 10 / 3 = " + (d1 / d2)); float f1 = 10f; float f2 = 3f; System.out.println("Float:\t 10 / 3 = " + (f1 / f2)); BigDecimal bd3 = new BigDecimal("10"); BigDecimal bd4 = new BigDecimal("3"); System.out.println("BigDec:\t 10 / 3 = " + (bd3.divide(bd4))); }
Double: 10 / 3 = 3.3333333333333335 Float: 10 / 3 = 3.3333333 Exception in thread "main" java.lang.ArithmeticException: Non-terminating decimal expansion
static void theDoubleProblem2() { BigDecimal bd3 = new BigDecimal("10"); BigDecimal bd4 = new BigDecimal("3"); System.out.println("BigDec:\t 10 / 3 = " + (bd3.divide(bd4, 4, BigDecimal.ROUND_HALF_UP))); }
package j2ee.java.math; /** * Generated from IDL definition of "valuetype "BigDecimal"" * TomORB IDL compiler v1.0 */ public abstract class BigDecimal extends j2ee.java.lang.Number implements org.omg.CORBA.portable.StreamableValue, j2ee.java.lang.Comparable { private String[] _truncatable_ids = {"RMI:java.math.BigDecimal:11F6D308F5398BBD:54C71557F981284F"}; protected int scale_; protected j2ee.java.math.BigInteger intVal; int ROUND_UP = 0; int ROUND_DOWN = 1; int ROUND_CEILING = 2; int ROUND_FLOOR = 3; int ROUND_HALF_UP = 4; int ROUND_HALF_DOWN = 5; int ROUND_HALF_EVEN = 6; int ROUND_UNNECESSARY = 7; public abstract int _hashCode(); public abstract int scale(); public abstract int signum(); public abstract boolean _equals(org.omg.CORBA.Any arg0); public abstract java.lang.String _toString(); public abstract j2ee.java.math.BigDecimal abs(); public abstract j2ee.java.math.BigDecimal negate(); public abstract j2ee.java.math.BigDecimal movePointLeft(int arg0); public abstract j2ee.java.math.BigDecimal movePointRight(int arg0); public abstract j2ee.java.math.BigDecimal setScale(int arg0); public abstract j2ee.java.math.BigDecimal setScale(int arg0, int arg1); public abstract j2ee.java.math.BigDecimal valueOf(long arg0); public abstract j2ee.java.math.BigDecimal valueOf(long arg0, int arg1); public abstract int compareTo(j2ee.java.math.BigDecimal arg0); public abstract j2ee.java.math.BigInteger toBigInteger(); public abstract j2ee.java.math.BigInteger unscaledValue(); public abstract j2ee.javax.rmi.CORBA.ClassDesc classU0024(java.lang.String arg0); public abstract j2ee.java.math.BigDecimal add(j2ee.java.math.BigDecimal arg0); public abstract j2ee.java.math.BigDecimal max(j2ee.java.math.BigDecimal arg0); public abstract j2ee.java.math.BigDecimal min(j2ee.java.math.BigDecimal arg0); public abstract j2ee.java.math.BigDecimal multiply(j2ee.java.math.BigDecimal arg0); public abstract j2ee.java.math.BigDecimal subtract(j2ee.java.math.BigDecimal arg0); public abstract j2ee.java.math.BigDecimal divide(j2ee.java.math.BigDecimal arg0, int arg1); public abstract j2ee.java.math.BigDecimal divide(j2ee.java.math.BigDecimal arg0, int arg1, int arg2); public void _write (org.omg.CORBA.portable.OutputStream os) { super._write( os ); os.write_long(scale_); ((org.omg.CORBA_2_3.portable.OutputStream)os).write_value( new java.lang.String("intVal") ); } public void _read (final org.omg.CORBA.portable.InputStream os) { super._read( os ); scale_=os.read_long(); intVal=(j2ee.java.math.BigInteger)((org.omg.CORBA_2_3.portable.InputStream)os).read_value ( "RMI:java.math.BigInteger:E2F79B6E7A470003:8CFC9F1FA93BFB1D".toString() ); } public String[] _truncatable_ids() { return _truncatable_ids; } public org.omg.CORBA.TypeCode _type() { return j2ee.java.math.BigDecimalHelper.type(); } }
Window -> Preferences -> Java -> Editor -> Mark Occurrences
window > preferences > java > editor > mark occurrences
Preferences > General > Editors > Text Editors > Annotations
Java > Editor > Mark Occurrences: Check "Mark occurrences of te selected element in the current file." ... and maybe all the ones below.
window > preferences > PHP > editor > mark occurrences
Preferences > General > Editors > Text Editors > Annotations
<LinearLayout android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="wrap_content" android:paddingLeft="20dip" android:paddingRight="20dip"> <EditText android:id="@+id/username" android:singleLine="true" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="Username" android:imeOptions="actionDone" android:inputType="text" android:maxLines="1"/> <EditText android:id="@+id/password" android:password="true" android:singleLine="true" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="Password" /> </LinearLayout>
class AppLogin extends Activity{ private EditText mUserNameEdit = null; private EditText mPasswordEdit = null; @Override public void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.app_login); mUserNameEdit = (EditText) findViewById(R.id.username); mPasswordEdit = (EditText) findViewById(R.id.password); InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(mUserNameEdit, InputMethodManager.SHOW_IMPLICIT); } }
<LinearLayout android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" > <EditText android:id="@+id/filter_edittext" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="Search" android:inputType="text" android:maxLines="1"/> <ListView android:id="@id/android:list" android:layout_height="fill_parent" android:layout_weight="1.0" android:layout_width="fill_parent" android:focusable="true" android:descendantFocusability="beforeDescendants"/> </LinearLayout>
public class MyListActivity extends ListActivity{ private EditText mfilterEditText; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.app_list_view); mFilterEditText = (EditText) findViewById(R.id.filter_edittext); InputMethodManager imm = InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(mFilterEditText.getWindowToken(), 0); } }
mUserNameEdit.postDelayed(new Runnable() { @Override public void run() { InputMethodManager keyboard = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE); keyboard.showSoftInput(mUserNameEdit, 0); } },50);
getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
<LinearLayout android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" android:focusableInTouchMode="true"> <EditText android:id="@+id/filter_edittext" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="Search" android:inputType="text" android:maxLines="1"/> <ListView android:id="@id/android:list" android:layout_height="fill_parent" android:layout_weight="1.0" android:layout_width="fill_parent" android:focusable="true" android:descendantFocusability="beforeDescendants"/> </LinearLayout>
<LinearLayout android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" android:focusableInTouchMode="true"> <EditText android:id="@+id/filter_edittext" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="Search" android:inputType="text" android:maxLines="1"/> <ListView android:id="@id/android:list" android:layout_height="fill_parent" android:layout_weight="1.0" android:layout_width="fill_parent" android:focusable="true" android:descendantFocusability="beforeDescendants"/> </LinearLayout>
<?xml version="1.0" encoding="utf-8"?> <LinearLayout xmlns:android="http: android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="wrap_content" android:paddingLeft="20dip" android:paddingRight="20dip"> <EditText android:id="@+id/userName" android:singleLine="true" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="Username" android:imeOptions="actionDone" android:inputType="text" android:maxLines="1" /> <EditText android:id="@+id/password" android:password="true" android:singleLine="true" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="Password" /> <ScrollView android:id="@+id/ScrollView01" android:layout_height="fill_parent" android:layout_width="fill_parent"> </ScrollView> </LinearLayout>
@Override protected void onResume() { super.onResume(); mUserNameEdit.requestFocus(); mUserNameEdit.postDelayed(new Runnable() { @Override public void run() { InputMethodManager keyboard = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); keyboard.showSoftInput(mUserNameEdit, 0); } },200); }
<activity android:name=".AppLogin" android:configChanges="keyboardHidden|orientation"></activity> <activity android:name=".AppList" android:configChanges="keyboard|orientation"></activity>
InputMethodManager imm = (InputMethodManager)this.getSystemService(Service.INPUT_METHOD_SERVICE);
imm.hideSoftInputFromWindow(ed.getWindowToken(), 0);
InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); if(imm != null){ imm.toggleSoftInput(InputMethodManager.SHOW_IMPLICIT, 0); }
InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); if(imm != null){ imm.toggleSoftInput(0, InputMethodManager.HIDE_IMPLICIT_ONLY); }
@override public void onFinishInflate() { InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(mUserNameEdit, InputMethodManager.SHOW_IMPLICIT); }
import java.awt.*; import java.awt.image.BufferedImage; import java.awt.event.ActionListener; import java.awt.event.ActionEvent; import javax.swing.*; import javax.swing.table.DefaultTableModel; import javax.swing.border.TitledBorder; /** A short example of a nested layout that can change PLAF at runtime. The TitledBorder of each JPanel shows the layouts explicitly set. @author Andrew Thompson @version 2011-04-12 */ class NestedLayoutExample { public static void main(String[] args) { Runnable r = new Runnable() { public void run() { final JFrame frame = new JFrame("Nested Layout Example"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); final JPanel gui = new JPanel(new BorderLayout(5,5)); gui.setBorder( new TitledBorder("BorderLayout(5,5)") ); JPanel plafComponents = new JPanel( new FlowLayout(FlowLayout.RIGHT, 3,3)); plafComponents.setBorder( new TitledBorder("FlowLayout(FlowLayout.RIGHT, 3,3)") ); final UIManager.LookAndFeelInfo[] plafInfos = UIManager.getInstalledLookAndFeels(); String[] plafNames = new String[plafInfos.length]; for (int ii=0; ii<plafInfos.length; ii++) { plafNames[ii] = plafInfos[ii].getName(); } final JComboBox plafChooser = new JComboBox(plafNames); plafComponents.add(plafChooser); final JCheckBox pack = new JCheckBox("Pack on PLAF change", true); plafComponents.add(pack); plafChooser.addActionListener( new ActionListener(){ public void actionPerformed(ActionEvent ae) { int index = plafChooser.getSelectedIndex(); try { UIManager.setLookAndFeel( plafInfos[index].getClassName() ); SwingUtilities.updateComponentTreeUI(frame); if (pack.isSelected()) { frame.pack(); frame.setMinimumSize(frame.getSize()); } } catch(Exception e) { e.printStackTrace(); } } } ); gui.add(plafComponents, BorderLayout.NORTH); JPanel dynamicLabels = new JPanel(new BorderLayout(4,4)); dynamicLabels.setBorder( new TitledBorder("BorderLayout(4,4)") ); gui.add(dynamicLabels, BorderLayout.WEST); final JPanel labels = new JPanel(new GridLayout(0,2,3,3)); labels.setBorder( new TitledBorder("GridLayout(0,2,3,3)") ); JButton addNew = new JButton("Add Another Label"); dynamicLabels.add( addNew, BorderLayout.NORTH ); addNew.addActionListener( new ActionListener(){ private int labelCount = 0; public void actionPerformed(ActionEvent ae) { labels.add( new JLabel("Label " + ++labelCount) ); frame.validate(); } } ); dynamicLabels.add( new JScrollPane(labels), BorderLayout.CENTER ); String[] header = {"Name", "Value"}; String[] a = new String[0]; String[] names = System.getProperties(). stringPropertyNames().toArray(a); String[][] data = new String[names.length][2]; for (int ii=0; ii<names.length; ii++) { data[ii][0] = names[ii]; data[ii][1] = System.getProperty(names[ii]); } DefaultTableModel model = new DefaultTableModel(data, header); JTable table = new JTable(model); try { table.setAutoCreateRowSorter(true); } catch(Exception continuewithNoSort) { } JScrollPane tableScroll = new JScrollPane(table); Dimension tablePreferred = tableScroll.getPreferredSize(); tableScroll.setPreferredSize( new Dimension(tablePreferred.width, tablePreferred.height/3) ); JPanel imagePanel = new JPanel(new GridBagLayout()); imagePanel.setBorder( new TitledBorder("GridBagLayout()") ); BufferedImage bi = new BufferedImage( 200,200,BufferedImage.TYPE_INT_ARGB); Graphics2D g = bi.createGraphics(); GradientPaint gp = new GradientPaint( 20f,20f,Color.red, 180f,180f,Color.yellow); g.setPaint(gp); g.fillRect(0,0,200,200); ImageIcon ii = new ImageIcon(bi); JLabel imageLabel = new JLabel(ii); imagePanel.add( imageLabel, null ); JSplitPane splitPane = new JSplitPane( JSplitPane.VERTICAL_SPLIT, tableScroll, new JScrollPane(imagePanel)); gui.add( splitPane, BorderLayout.CENTER ); frame.setContentPane(gui); frame.pack(); frame.setLocationRelativeTo(null); try { frame.setLocationByPlatform(true); frame.setMinimumSize(frame.getSize()); } catch(Throwable ignoreAndContinue) { } frame.setVisible(true); } }; SwingUtilities.invokeLater(r); } }
JPanel panel=new JPanel(new FlowLayout()); panel.add(new aComponent()); panel.add(new bComponent()); panel.add(new JTable());
int x=2,y=2; JPanel panel=new JPanel(new GridLayout(y,x)); panel.add(new aComponent()); panel.add(new bComponent()); panel.add(new JTable());
import java.awt.Dimension; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTable; import javax.swing.table.DefaultTableModel; public class JTableInNullLayout { public static void main(String[] argv) throws Exception { DefaultTableModel model = new DefaultTableModel( new String[][] { { "a", "123"} , {"b", "456"} }, new String[] { "name", "value" } ); JTable t = new JTable(model); JPanel panel = new JPanel(null); JScrollPane scroll = new JScrollPane(t); scroll.setBounds( 0, 20, 150, 100 ); panel.add(scroll); JFrame frame = new JFrame(); frame.add(panel); frame.setPreferredSize( new Dimension(200,200)); frame.pack(); frame.setVisible(true); } }
JPanel panel = new JPanel(); this.setContentPane(panel); panel.setLayout(null); String data[][] = {{"1.", "ABC"}, {"2.", "DEF"}, {"3.", "GHI" }}; String col[] = {"Sr. No", "Name"}; JTable table = new JTable(data,col); table.setBounds(100, 100, 100, 80); panel.add(table); setVisible(true); setSize(300,300);
JPanel panel = new JPanel(); JTable table = new JTable(rowData, colData); JScrollPane scrollPane = new JScrollPane(table); panel.add(scrollPane, BorderLayout.CENTER); panel.setSize(800, 150); panel.add(table); panel.setLocationRelativeTo(null); panel.setVisible(true);
JFrame frame = new JFrame("Sample Frame"); frame.setSize(600, 600); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); DefaultTableModel dfm = new DefaultTableModel(data, columnNames); JTable table = new JTable(dfm); JScrollPane scrollPane = new JScrollPane(table); panel.add(scrollPane); frame.add(panel); frame.setVisible(true);
this.setTitle("Sample"); JPanel p = new JPanel(new BorderLayout()); WindowEvent we = new WindowEvent(this, WindowEvent.WINDOW_CLOSED); this.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent we) { System.exit(0); } }); String columnNames[] = { "FirstCol", "SecondCol", "ThirdCol", "FourthCol" }; dataModel = new DefaultTableModel(); for (int col = 0; col < columnNames.length; col++) { dataModel.addColumn(columnNames[col]); } table = new JTable(dataModel); table.setPreferredScrollableViewportSize(new Dimension(200, 120)); table.setFillsViewportHeight(true); table.setShowGrid(true); table.setAutoscrolls(true); scrollPane = new JScrollPane(table, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); scrollPane.setPreferredSize(new Dimension(700, 700)); JPanel jpResultPanel = new JPanel(); jpResultPanel.setBorder(BorderFactory.createTitledBorder( BorderFactory.createEtchedBorder(), "Result", TitledBorder.CENTER, TitledBorder.TOP)); jpResultPanel.add(scrollPane); add(jpResultPanel); pack(); setSize(720, 720); setVisible(true);
private int score; public void setScore(int score) { this.score = score; } public int getScore() { return score; } game.setScore(game.getScore() + ENEMY_DESTROYED_SCORE);
private int score; public int getScore() { return score; } public void addScore(int delta) { score += delta; } game.addScore(ENEMY_DESTROYED_SCORE);
private boolean alive = true; public boolean isAlive() { return alive; } public void kill() { alive = false; }
private int hp; public boolean isAlive() { return hp > 0; } public void kill() { hp = 0; } public void damage(int damage) { hp -= damage; }
public void setValue(int value) { this.value = value; }
public void setValue(int value) { this.value = value; count++; }
ImmutableArray a = new ImmutableArray(); int[] b = a.myArray; b[0] = 10;
public int[] getArray() { return myArray.clone(); }
ImmutableArray a = new ImmutableArray(); int[] b = a.getArray(); b[0] = 10;
public void kill(){ isAlive = false; removeFromWorld(this); }
public void setAlive(boolean isAlive){ this.isAlive = isAlive; if (isAlive) addToWorld(this); else removeFromWorld(this); }
public void setValue(int value) { this.value = value; }
public void setValue(int value) { this.value = value; count++; }
def my_value=(value) @my_value = value @count++ end
public boolean dispatchTouchEvent(MotionEvent ev) { if(!onInterceptTouchEvent()){ for(View child : children){ if(child.dispatchTouchEvent(ev)) return true; } } return super.dispatchTouchEvent(ev); }
public override bool DispatchTouchEvent(MotionEvent e) { switch (e.ActionMasked) { case MotionEventActions.Down: _processingSwipe = false; _touchStartPosition = e.RawX; break; case MotionEventActions.Move: if (!_processingSwipe) { float move = e.RawX - _touchStartPosition; if (move >= _swipeSize) { _processingSwipe = true; _cancelChildren = true; ProcessSwipe(); } } break; } return base.DispatchTouchEvent(e); } public override bool OnTouchEvent(MotionEvent e) { return true; } public override bool OnInterceptTouchEvent(MotionEvent e) { if (_cancelChildren) { _cancelChildren = false; return true; } return false; }
main = new LinearLayout(this){ @Override public boolean onInterceptTouchEvent(MotionEvent ev) { System.out.println("Event - onInterceptTouchEvent"); return super.onInterceptTouchEvent(ev); } @Override public boolean dispatchTouchEvent(MotionEvent ev) { System.out.println("Event - dispatchTouchEvent"); return super.dispatchTouchEvent(ev); } }; main.setBackgroundColor(Color.GRAY); main.setLayoutParams(new LinearLayout.LayoutParams(320,480)); viewA = new EditText(this); viewA.setBackgroundColor(Color.YELLOW); viewA.setTextColor(Color.BLACK); viewA.setTextSize(16); viewA.setLayoutParams(new LinearLayout.LayoutParams(320,80)); main.addView(viewA); setContentView(main);
I/System.out(25900): Event - dispatchTouchEvent I/System.out(25900): Event - onInterceptTouchEvent
@Override public boolean dispatchTouchEvent(MotionEvent ev) { super.dispatchTouchEvent(ev); return true; }
public boolean dispatchTouchEvent(MotionEvent ev){ boolean consume =false; if(onInterceptTouchEvent(ev){ consume = onTouchEvent(ev); }else{ consume = child.dispatchTouchEvent(ev); } }
return Arrays.asList(enclosingInfo.getEnclosingClass().getDeclaredMethods()) .stream() .filter(m -> Objects.equals(m.getName(), enclosingInfo.getName()) .filter(m -> Arrays.equals(m.getParameterTypes(), parameterClasses)) .filter(m -> Objects.equals(m.getReturnType(), returnType)) .findFirst() .getOrThrow(() -> new InternalError(...));
Method matching = Arrays.asList(enclosingInfo.getEnclosingClass().getDeclaredMethods()) .stream() .filter(m -> Objects.equals(m.getName(), enclosingInfo.getName()) .filter(m -> Arrays.equals(m.getParameterTypes(), parameterClasses)) .filter(m -> Objects.equals(m.getReturnType(), returnType)) .getFirst(); if (matching == null) throw new InternalError("Enclosing method not found"); return matching;
RelationalExpression: RelationalExpression instanceof ReferenceType
String line; while ((line = reader.readLine()) != null) { process(line); }
boolean nope = (null instanceof String); String x = null; "abc".startsWith(null);
public class X { void f(Object o) { System.out.println(o instanceof String); } public static void main(String[] args) { new X().f(null); } }
class Point { private: int x; int y; public: Point(int ix, int iy) { x = ix; y = iy; } void print() { std::cout << }; int main() { Point* p = new Point(3,5); if (p != nullptr) { p->print(); p = nullptr; } else { std::cout << "p is null" << std::endl; } return 0; }
public class Point { private int x; private int y; public Point(int ix, int iy) { x = ix; y = iy; } public void print() { System.out.print("(" + x + "," + y + ")"); } } class Program { public static void main(String[] args) { Point p = new Point(3,5); if (p != null) { p.print(); p = null; } else { System.out.println("p is null"); } } }
import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors; class Answer { private int id; private Boolean answer; Answer() { } Answer(int id, Boolean answer) { this.id = id; this.answer = answer; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Boolean getAnswer() { return answer; } public void setAnswer(Boolean answer) { this.answer = answer; } } public class Main { public static void main(String[] args) { List<Answer> answerList = new ArrayList<>(); answerList.add(new Answer(1, true)); answerList.add(new Answer(2, true)); answerList.add(new Answer(3, null)); Map<Integer, Boolean> answerMap = answerList .stream() .collect(Collectors.toMap(Answer::getId, Answer::getAnswer)); } }
Exception in thread "main" java.lang.NullPointerException at java.util.HashMap.merge(HashMap.java:1216) at java.util.stream.Collectors.lambda$toMap$168(Collectors.java:1320) at java.util.stream.Collectors$$Lambda$5/1528902577.accept(Unknown Source) at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169) at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1359) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502) at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) at Main.main(Main.java:48) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
Map<Integer, Boolean> answerMap = new HashMap<>(); answerList.forEach((answer) -> answerMap.put(answer.getId(), answer.getAnswer()));
Map<Integer, Boolean> answerMap = new HashMap<>(); for (Answer answer : answerList) { answerMap.put(answer.getId(), answer.getAnswer()); }
Map<Integer, Boolean> collect = list.stream() .collect(HashMap::new, (m,v)->m.put(v.getId(), v.getAnswer()), HashMap::putAll);
public static <T, K, U> Collector<T, ?, Map<K, U>> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper) { return Collectors.collectingAndThen( Collectors.toList(), list -> { Map<K, U> result = new HashMap<>(); for (T item : list) { K key = keyMapper.apply(item); if (result.putIfAbsent(key, valueMapper.apply(item)) != null) { throw new IllegalStateException(String.format("Duplicate key %s", key)); } } return result; }); }
public class LambdaUtilities { /** * In contrast to {@link Collectors * may have null values. */ public static <T, K, U, M extends Map<K, U>> Collector<T, M, M> toMapWithNullValues(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper) { return toMapWithNullValues(keyMapper, valueMapper, HashMap::new); } /** * In contrast to {@link Collectors * the result map may have null values. */ public static <T, K, U, M extends Map<K, U>> Collector<T, M, M> toMapWithNullValues(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, Supplier<Map<K, U>> supplier) { return new Collector<T, M, M>() { @Override public Supplier<M> supplier() { return () -> { @SuppressWarnings("unchecked") M map = (M) supplier.get(); return map; }; } @Override public BiConsumer<M, T> accumulator() { return (map, element) -> { K key = keyMapper.apply(element); if (map.containsKey(key)) { throw new IllegalStateException("Duplicate key " + key); } map.put(key, valueMapper.apply(element)); }; } @Override public BinaryOperator<M> combiner() { return (map1, map2) -> { map1.putAll(map2); return map1; }; } @Override public Function<M, M> finisher() { return Function.identity(); } @Override public Set<Collector.Characteristics> characteristics() { return Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH)); } }; } }
@Test public void testToMapWithNullValues() throws Exception { Map<Integer, Integer> result = Stream.of(1, 2, 3) .collect(LambdaUtilities.toMapWithNullValues(Function.identity(), x -> x % 2 == 1 ? x : null)); assertThat(result) .isExactlyInstanceOf(HashMap.class) .hasSize(3) .containsEntry(1, 1) .containsEntry(2, null) .containsEntry(3, 3); } @Test public void testToMapWithNullValuesWithSupplier() throws Exception { Map<Integer, Integer> result = Stream.of(1, 2, 3) .collect(LambdaUtilities.toMapWithNullValues(Function.identity(), x -> x % 2 == 1 ? x : null, LinkedHashMap::new)); assertThat(result) .isExactlyInstanceOf(LinkedHashMap.class) .hasSize(3) .containsEntry(1, 1) .containsEntry(2, null) .containsEntry(3, 3); } @Test public void testToMapWithNullValuesDuplicate() throws Exception { assertThatThrownBy(() -> Stream.of(1, 2, 3, 1) .collect(LambdaUtilities.toMapWithNullValues(Function.identity(), x -> x % 2 == 1 ? x : null))) .isExactlyInstanceOf(IllegalStateException.class) .hasMessage("Duplicate key 1"); } @Test public void testToMapWithNullValuesParallel() throws Exception { Map<Integer, Integer> result = Stream.of(1, 2, 3) .parallel() .collect(LambdaUtilities.toMapWithNullValues(Function.identity(), x -> x % 2 == 1 ? x : null)); assertThat(result) .isExactlyInstanceOf(HashMap.class) .hasSize(3) .containsEntry(1, 1) .containsEntry(2, null) .containsEntry(3, 3); }
public static <T, K, U> Collector<T, ?, Map<K, U>> toMapNullFriendly( Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper) { @SuppressWarnings("unchecked") U none = (U) new Object(); return Collectors.collectingAndThen( Collectors.<T, K, U> toMap(keyMapper, valueMapper.andThen(v -> v == null ? none : v)), map -> { map.replaceAll((k, v) -> v == none ? null : v); return map; }); }
Exception in thread "main" java.lang.NullPointerException at java.util.HashMap.merge(HashMap.java:1216) at java.util.stream.Collectors.lambda$toMap$148(Collectors.java:1320) at java.util.stream.Collectors$$Lambda$5/391359742.accept(Unknown Source) at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169) at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1359) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502) at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) at com.guice.Main.main(Main.java:28) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
BiConsumer<M, T> accumulator = (map, element) -> map.merge(keyMapper.apply(element), valueMapper.apply(element), mergeFunction);
if (value == null) throw new NullPointerException();
Map<Integer, Boolean> answerMap = answerList .stream() .filter((a) -> a.getAnswer() != null) .collect(Collectors.toMap(Answer::getId, Answer::getAnswer));
answerList .stream() .collect(Collectors.toMap(Answer::getId, Answer::getAnswer));
answerList .stream() .filter(a -> a.getAnswer() != null) .collect(Collectors.toMap(Answer::getId, Answer::getAnswer));
Map<Integer, Boolean> answerMap = answerList.stream() .collect(Collectors.toMap(Answer::getId, a -> Boolean.TRUE.equals(a.getAnswer())));
class Answer { private int id; private Optional<Boolean> answer; Answer() { } Answer(int id, Boolean answer) { this.id = id; this.answer = Optional.ofNullable(answer); } public int getId() { return id; } public void setId(int id) { this.id = id; } /** * Gets the answer which can be a null value. Use {@link * * @return the answer which can be a null value */ public Boolean getAnswer() { return answer.orElse(null); } /** * Gets the optional answer. * * @return the answer which is contained in {@code Optional}. */ public Optional<Boolean> getAnswerAsOptional() { return answer; } /** * Gets the answer or the supplied default value. * * @return the answer or the supplied default value. */ public boolean getAnswerOrDefault(boolean defaultValue) { return answer.orElse(defaultValue); } public void setAnswer(Boolean answer) { this.answer = Optional.ofNullable(answer); } } public class Main { public static void main(String[] args) { List<Answer> answerList = new ArrayList<>(); answerList.add(new Answer(1, true)); answerList.add(new Answer(2, true)); answerList.add(new Answer(3, null)); Map<Integer, Optional<Boolean>> answerMapWithOptionals = answerList.stream() .collect(Collectors.toMap(Answer::getId, Answer::getAnswerAsOptional)); Map<Integer, Boolean> answerMapWithoutNulls = answerList.stream() .filter(a -> a.getAnswerAsOptional().isPresent()) .collect(Collectors.toMap(Answer::getId, Answer::getAnswer)); Map<Integer, Boolean> answerMapWithDefaults = answerList.stream() .collect(Collectors.toMap(a -> a.getId(), a -> a.getAnswerOrDefault(false))); System.out.println("With Optional: " + answerMapWithOptionals); System.out.println("Without Nulls: " + answerMapWithoutNulls); System.out.println("Wit Defaults: " + answerMapWithDefaults); } }
public class Hand implements Iterable<Card> { private final List<Card> list = new ArrayList<>(); private final int capacity; @Override public Iterator<Card> iterator() { return list.iterator(); } }
public interface Iterable<T> { Iterator<T> iterator(); default void forEach(Consumer<? super T> action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } default Spliterator<T> spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } }
Stream<Hand> stream = StreamSupport.stream(hand.spliterator(), false);
default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); }
Stream s = StreamSupport.stream(iter.spliterator(), false);
default Stream<E> stream() { return StreamSupport.stream(spliterator(), false); }
public class Hand extends AbstractCollection<Card> { private final List<Card> list = new ArrayList<>(); private final int capacity; @Override public Iterator<Card> iterator() { return list.iterator(); } @Override public int size() { return list.size(); } }
spring.datasource.url=... spring.datasource.username=user spring.datasource.password=1234 spring.datasource.driver-class-name=net.sourceforge.jtds.jdbc.Driver spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true security.ignored=true security.basic.enabled=false logging.level.org.springframework.web=INFO logging.level.org.hibernate=INFO logging.file=c:/temp/my-log/app.log
logging.level.org.hibernate.SQL=DEBUG logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
spring.jpa.properties.hibernate.show_sql=true spring.jpa.properties.hibernate.use_sql_comments=true spring.jpa.properties.hibernate.format_sql=true
spring: jpa: properties: hibernate: show_sql: true format_sql: true logging: level: org: hibernate: type: trace
<logger name="org.hibernate.SQL" level="trace" additivity="false"> <appender-ref ref="file" /> </logger>
<logger name="org.hibernate.type.descriptor.sql" level="trace"> <appender-ref ref="file" /> </logger>
logging.level.org.hibernate.SQL=DEBUG logging.level.org.hibernate.type=TRACE spring.jpa.show-sql=true
logging.level.com.microsoft.sqlserver.jdbc=info logging.level.com.microsoft.sqlserver.jdbc.internals=debug
logging.level.org.hibernate.SQL=DEBUG logging.level.org.hibernate.type.descriptor.sql=TRACE
2018-08-07 14:14:36.079 DEBUG 44804 --- [ main] org.hibernate.SQL : select employee0_.id as id1_0_, employee0_.department as departme2_0_, employee0_.joining_date as joining_3_0_, employee0_.name as name4_0_ from employee employee0_ where employee0_.joining_date=? 2018-08-07 14:14:36.079 TRACE 44804 --- [ main] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [TIMESTAMP] - [Tue Aug 07 00:00:00 SGT 2018]
logging.level.org.hibernate.SQL=debug example : 2018-11-23 12:28:02.990 DEBUG 12972 --- [nio-8086-exec-2] org.hibernate.SQL : select country0_.id as id1_0_, country0_.name as name2_0_ from country country0_
public class Main { public static void main(String[] args) { String line = "foo,bar,c;qual=\"baz,blurb\",d;junk=\"quux,syzygy\""; String[] tokens = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", -1); for(String t : tokens) { System.out.println("> "+t); } } }
> foo > bar > c;qual="baz,blurb" > d;junk="quux,syzygy"
public class Main { public static void main(String[] args) { String line = "foo,bar,c;qual=\"baz,blurb\",d;junk=\"quux,syzygy\""; String otherThanQuote = " [^\"] "; String quotedString = String.format(" \" %s* \" ", otherThanQuote); String regex = String.format("(?x) "+ ", "+ "(?= "+ " (?: "+ " %s* "+ " %s "+ " )* "+ " %s* "+ " $ "+ ") ", otherThanQuote, quotedString, otherThanQuote); String[] tokens = line.split(regex, -1); for(String t : tokens) { System.out.println("> "+t); } } }
Splitter.on(Pattern.compile(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)"))
String input = "foo,bar,c;qual=\"baz,blurb\",d;junk=\"quux,syzygy\""; List<String> result = new ArrayList<String>(); int start = 0; boolean inQuotes = false; for (int current = 0; current < input.length(); current++) { if (input.charAt(current) == boolean atLastChar = (current == input.length() - 1); if(atLastChar) result.add(input.substring(start)); else if (input.charAt(current) == result.add(input.substring(start, current)); start = current + 1; } }
String input = "foo,bar,c;qual=\"baz,blurb\",d;junk=\"quux,syzygy\""; StringBuilder builder = new StringBuilder(input); boolean inQuotes = false; for (int currentIndex = 0; currentIndex < builder.length(); currentIndex++) { char currentChar = builder.charAt(currentIndex); if (currentChar == if (currentChar == builder.setCharAt(currentIndex, } } List<String> result = Arrays.asList(builder.toString().split(","));
String tested = "foo,bar,c;qual=\"baz,blurb\",d;junk=\"quux,syzygy\","; long start = System.nanoTime(); String[] tokens = tested.split(",(?=([^\"]*\"[^\"]*\")*[^\"]*$)"); long timeWithSplitting = System.nanoTime() - start; start = System.nanoTime(); List<String> tokensList = new ArrayList<String>(); boolean inQuotes = false; StringBuilder b = new StringBuilder(); for (char c : tested.toCharArray()) { switch (c) { case if (inQuotes) { b.append(c); } else { tokensList.add(b.toString()); b = new StringBuilder(); } break; case inQuotes = !inQuotes; default: b.append(c); break; } } tokensList.add(b.toString()); long timeWithParsing = System.nanoTime() - start; System.out.println(Arrays.toString(tokens)); System.out.println(tokensList.toString()); System.out.printf("Time with splitting:\t%10d\n",timeWithSplitting); System.out.printf("Time with parsing:\t%10d\n",timeWithParsing);
final static private Pattern splitSearchPattern = Pattern.compile("[\",]"); private List<String> splitByCommasNotInQuotes(String s) { if (s == null) return Collections.emptyList(); List<String> list = new ArrayList<String>(); Matcher m = splitSearchPattern.matcher(s); int pos = 0; boolean quoteMode = false; while (m.find()) { String sep = m.group(); if ("\"".equals(sep)) { quoteMode = !quoteMode; } else if (!quoteMode && ",".equals(sep)) { int toPos = m.start(); list.add(s.substring(pos, toPos)); pos = m.end(); } } if (pos < s.length()) list.add(s.substring(pos)); return list; }
boolean foundQuote = false; if(charAtIndex(currentStringIndex) == { foundQuote = true; } if(foundQuote == true) { } else { string[] split = currentString.split( }
String data = "5|6|7||8|9||"; String[] split = data.split("\\|"); System.out.println(split.length);
String data = "5|6|7||8|9||"; Iterable<String> results = Splitter.on( String[] asArray = Iterables.toArray(results, String.class);
Scenerio 1: When all data are present: String data = "5|6|7||8|9|10|"; String[] split = data.split("\\|"); String[] splt = data.split("\\|",-1); System.out.println(split.length); System.out.println(splt.length);
Scenerio 2: Data Missing String data = "5|6|7||8|||"; String[] split = data.split("\\|"); String[] splt = data.split("\\|",-1); System.out.println(split.length); System.out.println(splt.length);
String data = "5|6|7||8|||"; String[] split = data.split("\\|"); String[] splt = data.replaceAll("\\|$","").split("\\|",-1); System.out.println(split.length); System.out.println(splt.length);
public class Main { public static void main(String[] args) { System.out.println("Available processors (cores): " + Runtime.getRuntime().availableProcessors()); System.out.println("Free memory (bytes): " + Runtime.getRuntime().freeMemory()); long maxMemory = Runtime.getRuntime().maxMemory(); System.out.println("Maximum memory (bytes): " + (maxMemory == Long.MAX_VALUE ? "no limit" : maxMemory)); System.out.println("Total memory available to JVM (bytes): " + Runtime.getRuntime().totalMemory()); File[] roots = File.listRoots(); for (File root : roots) { System.out.println("File system root: " + root.getAbsolutePath()); System.out.println("Total space (bytes): " + root.getTotalSpace()); System.out.println("Free space (bytes): " + root.getFreeSpace()); System.out.println("Usable space (bytes): " + root.getUsableSpace()); } } }
public class PerformanceMonitor { private int availableProcessors = getOperatingSystemMXBean().getAvailableProcessors(); private long lastSystemTime = 0; private long lastProcessCpuTime = 0; public synchronized double getCpuUsage() { if ( lastSystemTime == 0 ) { baselineCounters(); return; } long systemTime = System.nanoTime(); long processCpuTime = 0; if ( getOperatingSystemMXBean() instanceof OperatingSystemMXBean ) { processCpuTime = ( (OperatingSystemMXBean) getOperatingSystemMXBean() ).getProcessCpuTime(); } double cpuUsage = (double) ( processCpuTime - lastProcessCpuTime ) / ( systemTime - lastSystemTime ); lastSystemTime = systemTime; lastProcessCpuTime = processCpuTime; return cpuUsage / availableProcessors; } private void baselineCounters() { lastSystemTime = System.nanoTime(); if ( getOperatingSystemMXBean() instanceof OperatingSystemMXBean ) { lastProcessCpuTime = ( (OperatingSystemMXBean) getOperatingSystemMXBean() ).getProcessCpuTime(); } } }
System.getenv("PROCESSOR_IDENTIFIER") System.getenv("PROCESSOR_ARCHITECTURE") System.getenv("PROCESSOR_ARCHITEW6432") System.getenv("NUMBER_OF_PROCESSORS")
com.sun.management.OperatingSystemMXBean os = (com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean(); long physicalMemorySize = os.getTotalPhysicalMemorySize(); long freePhysicalMemory = os.getFreePhysicalMemorySize(); long freeSwapSize = os.getFreeSwapSpaceSize(); long commitedVirtualMemorySize = os.getCommittedVirtualMemorySize();
<dependency> <groupId>com.github.dblock</groupId> <artifactId>oshi-core</artifactId> <version>2.2</version> </dependency>
SystemInfo si = new SystemInfo(); HardwareAbstractionLayer hal = si.getHardware(); for (PowerSource pSource : hal.getPowerSources()) { System.out.println(String.format("%n %s @ %.1f%%", pSource.getName(), pSource.getRemainingCapacity() * 100d)); }
ProcessorInfo info = HardwareInfo.getProcessorInfo(); System.out.println("Cache size: " + info.getCacheSize()); System.out.println("Family: " + info.getFamily()); System.out.println("Speed (Mhz): " + info.getMhz());
JMXServiceURL url = new JMXServiceURL("service:jmx:rmi: JMXConnector jmxc = JMXConnectorFactory.connect(url, null); MBeanServerConnection conn = jmxc.getMBeanServerConnection(); ObjectName name = new ObjectName("oracle.jrockit.management:type=Runtime"); Double jvmCpuLoad =(Double)conn.getAttribute(name, "VMGeneratedCPULoad");
private static class WindowsSystemInformation { static String get() throws IOException { Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec("systeminfo"); BufferedReader systemInformationReader = new BufferedReader(new InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = systemInformationReader.readLine()) != null) { stringBuilder.append(line); stringBuilder.append(System.lineSeparator()); } return stringBuilder.toString().trim(); } }
SimpleDateFormat format = new SimpleDateFormat( "yyyy-MM-dd format.setTimeZone(TimeZone.getTimeZone("UTC"));
Instant instant = Instant.parse ( "2011-08-12T20:17:46.384Z" ) ;
DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE_TIME; ZonedDateTime zdt = ZonedDateTime.parse("2011-08-12T20:17:46.384Z", dtf);
String pattern = "yyyy-MM-dd DateFormat df = new SimpleDateFormat(pattern); Date myDate = df.parse("2011-08-12T20:17:46.384Z");
Instant ins = Instant.parse("2011-08-12T20:17:46.384Z");
String date = "2011-08-12T20:17:46.384Z"; String inputPattern = "yyyy-MM-dd String outputPattern = "yyyy-MM-dd HH:mm:ss"; LocalDateTime inputDate = null; String outputDate = null; DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern(inputPattern, Locale.ENGLISH); DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(outputPattern, Locale.ENGLISH); inputDate = LocalDateTime.parse(date, inputFormatter); outputDate = outputFormatter.format(inputDate); System.out.println("inputDate: " + inputDate); System.out.println("outputDate: " + outputDate);
public static String getTime(String time) { if (time != null) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); if (time.toUpperCase().contains("T") && time.toUpperCase().contains("Z")) { time = time.toUpperCase().replace("T", " "); String[] str = time.split("\\."); if (str.length != 0) { return str[0]; } } try { Date date = new Date(time); time = simpleDateFormat.format(date); } catch (Exception e) { // } } return time; }
package Dump; public class Parent { private String reallyHidden; private String notReallyHidden; public String getNotReallyHidden() { return notReallyHidden; } public void setNotReallyHidden(String notReallyHidden) { this.notReallyHidden = notReallyHidden; } }
package Dump; public class Child extends Parent { private String childOnly; public String getChildOnly() { return childOnly; } public void setChildOnly(String childOnly) { this.childOnly = childOnly; } public static void main(String [] args){ System.out.println("Testing..."); Child c1 = new Child(); c1.setChildOnly("childOnly"); c1.setNotReallyHidden("notReallyHidden"); c1.reallyHidden; } }
class Some { private int count; public void increment() { count++; } public String toString() { return Integer.toString( count ); } } class UseIt { void useIt() { Some s = new Some(); s.increment(); s.increment(); s.increment(); int v = Integer.parseInt( s.toString() ); } }
class SomeOther extends Some { private int count = 1000; @Override public void increment() { super.increment(); count *= 10000; } } class UseIt { public static void main( String ... args ) { s = new SomeOther(); s.increment(); s.increment(); s.increment(); v = Integer.parseInt( s.toString() ); } }
class A { private int i; public String toString() { return ""+ i; } } class B extends A {} class Main { public static void main( String [] args ) { System.out.println( new B().toString() ); } } javac A.java B.java Main.java java Main 0 class A { public String toString() { return "Nothing here"; } } javac A.java java Main Output: Nothing here
public class ParentClass { private int x; public int getX() { return x; } public void setX(int x) { this.x = x; } } class SubClass extends ParentClass { private int y; public int getY() { return y; } public void setY(int y) { this.y = y; } public void setXofParent(int x) { setX(x); } } class Main { public static void main(String[] args) { SubClass s = new SubClass(); s.setX(10); s.setY(12); System.out.println("X is :"+s.getX()); System.out.println("Y is :"+s.getY()); s.setXofParent(13); System.out.println("Now X is :"+s.getX()); } } Output: X is :10 Y is :12 Now X is :13
import java.io.Serializable; public class ParentClass implements Serializable { public ParentClass() { } public int a=32131,b,c; private int bhavesh=5555,rr,weq,refw; }
import java.io.*; import java.io.Serializable; public class ChildClass extends ParentClass{ public ChildClass() { super(); } public static void main(String[] args) { ChildClass childObj = new ChildClass(); ObjectOutputStream oos; try { oos = new ObjectOutputStream(new FileOutputStream("C:\\MyData1.txt")); oos.writeObject(childObj); System.out.println("Writing complete !"); } catch (IOException e) { } } }
public class Foo { private int x; public Foo() { x = 0; } public final void update() { x++; } public final int getX() { return x; } } public class Bar extends Foo { public Bar() { super(); update(); update(); System.out.println(getX()); } }
public class DbConnection{ private static final int MAX_CONNS = 100; private static int totalConnections = 0; private static Set<DbConnection> availableConnections = new HashSet<DbConnection>(); private DbConnection(){ totalConnections++; } public static DbConnection getDbConnection(){ if(totalConnections < MAX_CONNS){ return new DbConnection(); }else if(availableConnections.size() > 0){ DbConnection dbc = availableConnections.iterator().next(); availableConnections.remove(dbc); return dbc; }else { throw new NoDbConnections(); } } public static void returnDbConnection(DbConnection dbc){ availableConnections.add(dbc); } }
Coordinate c = Coordinate.createFromCartesian(double x, double y)
Coordinate c = Coordinate.createFromPolar(double distance, double angle)
public class Foo{ public Foo(boolean withBar){ } } Foo foo = new Foo(true);
public class Foo{ public static Foo createWithBar(){ } public static Foo createWithoutBar(){ } } Foo foo = Foo.createWithBar();
class Test{ int x, y; private Test(){ ....... ....... } }
public static Test getObject(){ return new Test(); }
Vinoth vin = new Vinoth(); Class Vinoth{ private Vinoth(){ } public static Vinoth getInstance(){ if(someCondition) return new Vinoth(); } }
public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE); }
public class Singleton{ private static final Singleton INSTANCE = new Singleton(); private Singleton(){} public static Singleton getSingleton(){ return INSTANCE; } }
import java.util.Map; final class MyEntry<K, V> implements Map.Entry<K, V> { private final K key; private V value; public MyEntry(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } @Override public V setValue(V value) { V old = this.value; this.value = value; return old; } }
Map.Entry<String, Object> entry = new MyEntry<String, Object>("Hello", 123); System.out.println(entry.getKey()); System.out.println(entry.getValue());
Map.Entry<String,Integer> entry = new AbstractMap.SimpleEntry<String, Integer>("exmpleString", 42);
import java.util.Map; import java.util.AbstractMap; import java.util.AbstractMap.SimpleEntry;
ArrayList<Map.Entry<Integer, Integer>> arr = new ArrayList<Map.Entry<Integer, Integer>>();
arr.add(new AbstractMap.SimpleEntry(2, 3)); arr.add(new AbstractMap.SimpleEntry(20, 30)); arr.add(new AbstractMap.SimpleEntry(2, 4));
System.out.println(arr.get(0).getKey()); System.out.println(arr.get(0).getValue()); System.out.println(arr.get(1).getKey()); System.out.println(arr.get(1).getValue()); System.out.println(arr.get(2).getKey()); System.out.println(arr.get(2).getValue());
Entry<String, String> entry = Map.entry("foo", "bar");
public class Pair<A, B> { private A component1; private B component2; public Pair() { super(); } public Pair(A component1, B component2) { this.component1 = component1; this.component2 = component2; } public A fst() { return component1; } public void setComponent1(A component1) { this.component1 = component1; } public B snd() { return component2; } public void setComponent2(B component2) { this.component2 = component2; } @Override public String toString() { return "<" + component1 + "," + component2 + ">"; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((component1 == null) ? 0 : component1.hashCode()); result = prime * result + ((component2 == null) ? 0 : component2.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; final Pair<?, ?> other = (Pair<?, ?>) obj; if (component1 == null) { if (other.component1 != null) return false; } else if (!component1.equals(other.component1)) return false; if (component2 == null) { if (other.component2 != null) return false; } else if (!component2.equals(other.component2)) return false; return true; } public static <A, B> Pair<A, B> create(A component1, B component2) { return new Pair<A, B>(component1, component2); } }
(defn map-entry [k v] (clojure.lang.MapEntry/create k v))
System.out.println ("starting loop:"); for (int n = 0; n < 7; ++n) { System.out.println ("in loop: " + n); if (n == 2) { continue; } System.out.println (" survived first guard"); if (n == 4) { break; } System.out.println (" survived second guard"); } System.out.println ("end of loop or exit via break");
starting loop: in loop: 0 survived first guard survived second guard in loop: 1 survived first guard survived second guard in loop: 2 in loop: 3 survived first guard survived second guard in loop: 4 survived first guard end of loop or exit via break
first: for (int i = 0; i < 4; ++i) { second: for (int j = 0; j < 4; ++j) { third: for (int k = 0; k < 4; ++k) { System.out.println ("inner start: i+j+k " + (i + j + k)); if (i + j + k == 5) continue third; if (i + j + k == 7) continue second; if (i + j + k == 8) break second; if (i + j + k == 9) break first; System.out.println ("inner stop: i+j+k " + (i + j + k)); } } }
http: for (int i = 0; i < 4; ++i) { if (i == 2) break http;
public static void main(String[] args) { for(int i=0;i<10;i++) { if (i==4) { break; } System.out.print(i+"\t"); } System.out.println(); for(int i=0;i<10;i++) { if (i==4) { continue; } System.out.print(i+"\t"); } }
C:\oreyes\samples\java\breakcontinue>type BreakContinue.java class BreakContinue { public static void main( String [] args ) { for( int i = 0 ; i < 10 ; i++ ) { if( i % 2 == 0) { continue; } System.out.println("The number is " + i ); if( i == 7 ) { break; } } } } C:\oreyes\samples\java\breakcontinue>java BreakContinue The number is 1 The number is 3 The number is 5 The number is 7
public static void main(String[] args) { for(int i = 0; i < 5; i++){ if (i == 3) { continue; } System.out.print(i); } } public static void main(String[] args) { for(int i = 0; i < 5; i++){ if (i == 3) { break; } System.out.print(i); } }
int n; for(n = 0; n < 10; ++n) { break; } System.out.println(n);
int n; for(n = 0; n < 10; ++n) { continue; } System.out.println(n);
int m; for(m = 0; m < 5; ++m) { int n; for(n = 0; n < 5; ++n) { break; } System.out.println(n); } System.out.println(m);
for(int i=0; i<10; i++) { System.out.println(i); if(i==4) { break; } }
for(int i=0; i<10; i++) { if(i==4) { continue; } System.out.println(i); }
0 1 2 3 5 <---- SKIPPED OVER 4 and continued with next loop iteration 6 7 8 9
outer1: for(int i=0; i<5; i++) { for(int j=0; j<4; j++) { for(int k=0; k<2; k++) { System.out.println("[" + i + "][" + j + "][" + k + "]"); if(j == 3) { break outer1; } } } }
[0][0][0] [0][0][1] [0][1][0] [0][1][1] [0][2][0] [0][2][1] [0][3][0]
outer1: for(int i=0; i<5; i++) { for(int j=0; j<4; j++) { for(int k=0; k<2; k++) { System.out.println("[" + i + "][" + j + "][" + k + "]"); if(j == 3) { continue outer1; } } } [0][0][0] [0][0][1] [0][1][0] [0][1][1] [0][2][0] [0][2][1] [0][3][0] <---- CONTINUE WITH LABEL CALLED HERE [1][0][0] <---- CONTINUES FROM NEXT ITERATION OF OUTER LOOP [1][0][1] [1][1][0] [1][1][1] [1][2][0] [1][2][1] [1][3][0] <---- CONTINUE WITH LABEL CALLED HERE [2][0][0] <---- CONTINUES FROM NEXT ITERATION OF OUTER LOOP [2][0][1] [2][1][0] [2][1][1] [2][2][0] [2][2][1] [2][3][0] <---- CONTINUE WITH LABEL CALLED HERE [3][0][0] <---- CONTINUES FROM NEXT ITERATION OF OUTER LOOP [3][0][1] [3][1][0] [3][1][1] [3][2][0] [3][2][1] [3][3][0] <---- CONTINUE WITH LABEL CALLED HERE [4][0][0] <---- CONTINUES FROM NEXT ITERATION OF OUTER LOOP [4][0][1] [4][1][0] [4][1][1] [4][2][0] [4][2][1] [4][3][0]
for(int i=0;i<5;i++){ if(i==3){ continue; } System.out.println(i); }
for(int i=0;i<5;i++){ if(i==3){ break; } System.out.println(i); }
int[] a = new int[] { 1, 3, 4, 6, 7, 9, 10 }; for(int i = 0; i < a.Length; i++) { if (a[i] == 9) goto goBreak; Console.WriteLine(a[i].ToString()); } goBreak:;
int[] a = new int[] { 1, 3, 4, 6, 7, 9, 10 }; for(int i = 0; i < a.Length; i++) { if (a[i] % 2 == 1) goto goContinue; Console.WriteLine(a[i].ToString()); goContinue:; }
class BreakDemo { public static void main(String[] args) { int[] arrayOfInts = { 32, 87, 3, 589, 12, 1076, 2000, 8, 622, 127 }; int searchfor = 12; int i; boolean foundIt = false; for (i = 0; i < arrayOfInts.length; i++) { if (arrayOfInts[i] == searchfor) { foundIt = true; break; } } if (foundIt) { System.out.println("Found " + searchfor + " at index " + i); } else { System.out.println(searchfor + " not in the array"); } }
public class BreakWithLabelDemo { public static void main(String[] args) { search: for (int i = 0; i < 3; i++) { for (int j = 0; j < 5; j++) { System.out.println(i + " - " + j); if (j == 3) break search; } } }
class ContinueDemo { public static void main(String[] args) { String searchMe = "peter piper picked a " + "peck of pickled peppers"; int max = searchMe.length(); int numPs = 0; for (int i = 0; i < max; i++) { if (searchMe.charAt(i) != continue; numPs++; } System.out.println("Found " + numPs + " p }
public class ContinueWithLabelDemo { public static void main(String[] args) { search: for (int i = 0; i < 3; i++) { for (int j = 0; j < 5; j++) { System.out.println(i + " - " + j); if (j == 3) continue search; } } }
int m = 0; for(int n = 0; n < 5; ++n){ if(n == 2){ break; } m++; } System.out.printl("m:"+m);
int m = 0; for(int n = 0; n < 5; ++n){ if(n == 2){ continue; } m++; } System.out.printl("m:"+m);
for (int i = 1; i <= 3; i++) { if (i == 2) { continue; } System.out.print("[i:" + i + "]");
for (int i = 1; i <= 3; i++) { if (i == 2) { break; } System.out.print("[i:" + i + "]");
public static void main(String[] args) { System.out.println("HelloWorld"); for (int i = 0; i < 5; i++){ System.out.println("Start For loop i = " + i); if(i==2){ System.out.println("Inside if Statement for i = "+i); continue; } System.out.println("End For loop i = " + i); } System.out.println("Completely out of For loop"); } OutPut: HelloWorld Start For loop i = 0 End For loop i = 0 Start For loop i = 1 End For loop i = 1 Start For loop i = 2 Inside if Statement for i = 2 Start For loop i = 3 End For loop i = 3 Start For loop i = 4 End For loop i = 4 Completely out of For loop
public static void main(String[] args) { System.out.println("HelloWorld"); for (int i = 0; i < 5; i++){ System.out.println("Start For loop i = " + i); if(i==2){ System.out.println("Inside if Statement for i = "+i); break; } System.out.println("End For loop i = " + i); } System.out.println("Completely out of For loop"); } Output: HelloWorld Start For loop i = 0 End For loop i = 0 Start For loop i = 1 End For loop i = 1 Start For loop i = 2 Inside if Statement for i = 2 Completely out of For loop
System.out.println("continue when i is 2:"); for (int i = 1; i <= 3; i++) { if (i == 2) { System.out.print("[continue]"); continue; } System.out.print("[i:" + i + "]"); }
for (int i = nodes.size() - 1; i >= 0; i--) { final Node each = (Node) nodes.get(i); ... }
ArrayList<...> a = new ArrayList<...>(); ListIterator li = a.listIterator(a.size()); while(li.hasPrevious()) { System.out.println(li.previous()); }
List reversed = ImmutableList.copyOf(myList).reverse();
Collections.reverse(list); for (Object o : list) { ... }
import java.util.Iterator; import java.util.List; public class ReverseIterator<T> implements Iterator<T>, Iterable<T> { private final List<T> list; private int position; public ReverseIterator(List<T> list) { this.list = list; this.position = list.size() - 1; } @Override public Iterator<T> iterator() { return this; } @Override public boolean hasNext() { return position >= 0; } @Override public T next() { return list.get(position--); } @Override public void remove() { throw new UnsupportedOperationException(); } } List<String> list = new ArrayList<String>(); list.add("A"); list.add("B"); list.add("C"); list.add("D"); list.add("E"); for (String s : new ReverseIterator<String>(list)) { System.out.println(s); }
LinkedList<String > linkedList; for( Iterator<String > it = linkedList.descendingIterator(); it.hasNext(); ) { String text = it.next(); }
List<Integer> list = new ArrayList<Integer>(Arrays.asList(1, 3, 3, 7, 5)); list.stream().forEach(System.out::println); int size = list.size(); ListIterator<Integer> it = list.listIterator(size); Stream.generate(it::previous).limit(size) .forEach(System.out::println); ListIterator<Integer> it2 = list.listIterator(size); Stream.iterate(it2.previous(), i -> it2.previous()).limit(size) .forEach(System.out::println); IntStream.range(0, size).map(i -> size - i - 1).map(list::get) .forEach(System.out::println); IntStream.range(0, size).boxed().sorted(Comparator.reverseOrder()) .map(list::get).forEach(System.out::println);
import com.google.common.collect.Lists; [...] final List<String> myList = Lists.newArrayList("one", "two", "three"); final List<String> myReverseList = Lists.reverse(myList); System.out.println(myList); System.out.println(myReverseList); myList.add("four"); System.out.println(myList); System.out.println(myReverseList);
[one, two, three] [three, two, one] [one, two, three, four] [four, three, two, one]
for (final String someString : Lists.reverse(myList)) { }
ArrayList<String> l = ... for (String s : new ReverseIterable(l)) { System.err.println(s); }
public class ReverseIterable<T> implements Iterable<T> { private static class ReverseIterator<T> implements Iterator { private final ListIterator<T> it; public boolean hasNext() { return it.hasPrevious(); } public T next() { return it.previous(); } public void remove() { it.remove(); } } private final ArrayList<T> l; public ReverseIterable(ArrayList<T> l) { this.l = l; } public Iterator<T> iterator() { return new ReverseIterator(l.listIterator(l.size())); } }
List<String> list = new ArrayList<String>(); list.add("ravi"); list.add("kant"); list.add("soni"); for (String name : list) { ... } Collections.reverse(list); for (String name : list) { ... }
List<Item> items; ... for (Item item : In.reverse(items)) { ... }
import java.util.*; public enum In {; public static final <T> Iterable<T> reverse(final List<T> list) { return new ListReverseIterable<T>(list); } class ListReverseIterable<T> implements Iterable<T> { private final List<T> mList; public ListReverseIterable(final List<T> list) { mList = list; } public Iterator<T> iterator() { return new Iterator<T>() { final ListIterator<T> it = mList.listIterator(mList.size()); public boolean hasNext() { return it.hasPrevious(); } public T next() { return it.previous(); } public void remove() { it.remove(); } }; } } }
import java.util.*; public class Main { public static class ReverseIterating<T> implements Iterable<T> { private final LinkedList<T> list; public ReverseIterating(LinkedList<T> list) { this.list = list; } @Override public Iterator<T> iterator() { return list.descendingIterator(); } } public static void main(String... args) { LinkedList<String> list = new LinkedList<String>(); list.add("A"); list.add("B"); list.add("C"); list.add("D"); list.add("E"); for (String s : new ReverseIterating<String>(list)) { System.out.println(s); } } }
List<String> list = new LinkedList<String>(); list.add("ravi"); list.add("kant"); list.add("soni"); for (String name : list) { ... } Collections.reverse(list); for (String name : list) { ... }
List<Integer> x = new ArrayList<Integer>(); int[] n = (int[])x.toArray(int[x.size()]);
public static int[] convertIntegers(List<Integer> integers) { int[] ret = new int[integers.size()]; for (int i=0; i < ret.length; i++) { ret[i] = integers.get(i).intValue(); } return ret; }
public static int[] convertIntegers(List<Integer> integers) { int[] ret = new int[integers.size()]; Iterator<Integer> iterator = integers.iterator(); for (int i = 0; i < ret.length; i++) { ret[i] = iterator.next().intValue(); } return ret; }
int[] arr = list.stream().mapToInt(i -> i).toArray();
int[] arr = list.stream().mapToInt(Integer::intValue).toArray();
int[] arr = list.stream().filter(i -> i != null).mapToInt(i -> i).toArray();
List<Integer> list = Arrays.asList(1, 2, 3, 4); int[] arr = list.stream().mapToInt(i -> i).toArray(); list.set(1, null); arr = list.stream().filter(i -> i != null).mapToInt(i -> i).toArray();
import org.apache.commons.lang.ArrayUtils; ... List<Integer> list = new ArrayList<Integer>(); list.add(new Integer(1)); list.add(new Integer(2)); int[] intArray = ArrayUtils.toPrimitive(list.toArray(new Integer[0]));
List<Integer> list = ...; int[] values = Ints.toArray(list);
private int[] buildIntArray(List<Integer> integers) { int[] ints = new int[integers.size()]; int i = 0; for (Integer n : integers) { ints[i++] = n; } return ints; }
List<Integer> list = $(5).toList(); int[] array = $($(list).toArray()).toIntArray();
List<Integer> integers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5)); MutableIntList intList = ListAdapter.adapt(integers).collectInt(i -> i); Assert.assertArrayEquals(new int[]{1, 2, 3, 4, 5}, intList.toArray());
Assert.assertArrayEquals( new int[]{1, 2, 3, 4, 5}, Lists.mutable.with(1, 2, 3, 4, 5) .collectInt(i -> i).toArray());
int[] arr = new int[list.size()]; for(int i = 0; i < list.size(); i++) { arr[i] = list.get(i); }
List<Integer> list = new ArrayList<Integer>(); list.add(1); list.add(2); int[] result = null; StringBuffer strBuffer = new StringBuffer(); for (Object o : list) { strBuffer.append(o); result = new int[] { Integer.parseInt(strBuffer.toString()) }; for (Integer i : result) { System.out.println(i); } strBuffer.delete(0, strBuffer.length()); }
Integer[] arr = (Integer[]) x.toArray(new Integer[x.size()]);
ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(<DO_YOU_WANT_TO_USE_DEFALT_FILTER>); scanner.addIncludeFilter(new AnnotationTypeFilter(<TYPE_YOUR_ANNOTATION_HERE>.class)); for (BeanDefinition bd : scanner.findCandidateComponents(<TYPE_YOUR_BASE_PACKAGE_HERE>)) System.out.println(bd.getBeanClassName());
ClassIndex.getAnnotated(com.test.YourCustomAnnotation.class)
Class<?> clazz = AnnotationUtils.findAnnotationDeclaringClass(Target.class, null);
public class ElementScanner { public void scanElements(){ try { String packageName = readConfig(); ClassLoader classLoader = getClass().getClassLoader(); String packagePath = packageName.replace( URL urls = classLoader.getResource(packagePath); File folder = new File(urls.getPath()); File[] classes = folder.listFiles(); int size = classes.length; List<Class<?>> classList = new ArrayList<Class<?>>(); for(int i=0;i<size;i++){ int index = classes[i].getName().indexOf("."); String className = classes[i].getName().substring(0, index); String classNamePath = packageName+"."+className; Class<?> repoClass; repoClass = Class.forName(classNamePath); Annotation[] annotations = repoClass.getAnnotations(); for(int j =0;j<annotations.length;j++){ System.out.println("Annotation in class "+repoClass.getName()+ " is "+annotations[j].annotationType().getName()); } classList.add(repoClass); } } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * Unmarshall the configuration file * @return */ public String readConfig(){ try{ URL url = getClass().getClassLoader().getResource("WEB-INF/config.xml"); JAXBContext jContext = JAXBContext.newInstance(RepositoryConfig.class); Unmarshaller um = jContext.createUnmarshaller(); RepositoryConfig rc = (RepositoryConfig) um.unmarshal(new File(url.getFile())); return rc.getRepository().getPackageName(); }catch(Exception e){ e.printStackTrace(); } return null; } }
AnnotationsScanner scanner = AnnotationsScanner.createScanner() .includeSources(ExampleApplication.class) .build(); AnnotationsScannerProcess process = scanner.createWorker() .addDefaultProjectFilters("net.dzikoysk") .fetch(); Set<Class<?>> classes = process.createSelector() .selectTypesAnnotatedWith(AnnotationTest.class);
for (SomeObject obj : someObjects) { if (some_condition_met) { break; } }
Optional<SomeObject> result = someObjects.stream().filter(obj -> some_condition_met).findFirst();
boolean result = someObjects.stream().anyMatch(obj -> some_condition_met);
try { someObjects.forEach(obj -> { if(some_exceptional_condition_met) { throw new BreakException(); } } } catch (BreakException e) { }
Consumer<? super SomeObject> action = obj -> { if(some_exceptional_condition_met) { throw new BreakException(); } }); try { someObjects.forEach(action); } catch (BreakException e) { }
someObjects.forEach(obj -> { if (some_condition_met) { return; } })
someObjects.allMatch(obj -> { return !some_condition_met; });
public static <T> void forEachConditional(Iterable<T> source, Predicate<T> action) { for (T item : source) { if (!action.test(item)) { break; } } }
IntStream intStream = IntStream.range(1,10000000); Observable.from(() -> intStream.iterator()) .takeWhile(n -> n < 10) .forEach(n-> System.out.println(n));
Optional<SomeObject> result = someObjects.stream().filter(obj -> some_condition_met).findAny();
private void doSomething() { List<Action> actions = actionRepository.findAll(); boolean actionHasFormFields = actions.stream().anyMatch(actionHasMyFieldsPredicate()); if (actionHasFormFields){ context.addError(someError); } } } private Predicate<Action> actionHasMyFieldsPredicate(){ return action -> action.getMyField1() != null; }
someObjects.stream().peek(obj -> { <your code here> }).anyMatch(obj -> !<some_condition_met>);
public static <T> void streamWhile(Stream<T> stream, Predicate<? super T> predicate, Consumer<? super T> consumer) { stream.peek(consumer).anyMatch(predicate.negate()); }
streamWhile(someObjects.stream(), obj -> <some_condition_met>, obj -> { <your code here> });
Stream.of("a", "b", "c", "d", "e").peek(N::println) // .forEach("", (r, e) -> r + e, (e, r) -> e.equals("c"));
someObjects.forEach(obj -> { if (condition.ok()) { condition.stop(); } });
public Employee setName(String name){ this.name = name; return this; }
list.add(new Employee().setName("Jack Sparrow").setId(1).setFoo("bacon!"));
Employee e = new Employee(); e.setName("Jack Sparrow"); ...and so on... list.add(e);
String s = new StringBuilder().append("testing ").append(1) .append(" 2 ").append(3).toString();
public String getFoo() { return foo; } public void setFoo(String foo) { this.foo = foo; } public Employee withFoo(String foo) { setFoo(foo); return this; }
list.add(new Employee().withName("Jack Sparrow") .withId(1) .withFoo("bacon!"));
list.add(new Employee() {{ setName("Jack Sparrow"); setId(1); setFoo("bacon!"); }});
list.Add(new Employee() { Name = "Jack Sparrow", Id = 1, Foo = "bacon!" });
list.add(new Employee() .setName("Jack Sparrow") .setId(1) .setFoo("bacon!"));
list.add( new Employee("Jack Sparrow") .Id(1) .foo("bacon!"));
public class Some { public String getValue() { return value; } public void setValue(final String value) { this.value = value; } public String value() { return getValue(); } public Some value(final String value) { setValue(value); return this; } private String value; }
public class Some { public static class Builder { public Some build() { return new Some(value); } public Builder value(final String value) { this.value = value; return this; } private String value; } private Some(final String value) { super(); this.value = value; } public String getValue() { return value; } public String value() { return getValue();} private final String value; }
new Some.Builder().value("value").build().getValue();
public class NutritionalFacts { private final int sodium; private final int fat; private final int carbo; public int getSodium(){ return sodium; } public int getfat(){ return fat; } public int getCarbo(){ return carbo; } public static class Builder { private int sodium; private int fat; private int carbo; public Builder sodium(int s) { this.sodium = s; return this; } public Builder fat(int f) { this.fat = f; return this; } public Builder carbo(int c) { this.carbo = c; return this; } public NutritionalFacts build() { return new NutritionalFacts(this); } } private NutritionalFacts(Builder b) { this.sodium = b.sodium; this.fat = b.fat; this.carbo = b.carbo; } }
list.add(new Employee().setName("Jack Sparrow").setId(1).setFoo("bacon!"));
Employee anEmployee = new Employee(); anEmployee.setName("xxx"); ... list.add(anEmployee);
class People { private String name; public People setName(String name) { this.name = name; return this; } } class Friend extends People { private String nickName; public Friend setNickName(String nickName) { this.nickName = nickName; return this; } }
new Friend().setNickName("Bart").setName("Barthelemy");
new Friend().setName("Barthelemy").setNickName("Bart");
class People { private String name; public SELF setName(String name) { this.name = name; return this; } }
list.add(new Employee().setName("Jack Sparrow").setId(1).setFoo("bacon!"));
list.add(new Employee().setName("Jack Sparrow").setId(1).setFoo("bacon!"));
list.add(new Employee() .setName("Jack Sparrow") .setId(1) .setFoo("bacon!"));
Employee employee = new Employee(); employee.setName("Jack Sparrow") employee.setId(1) employee.setFoo("bacon!")); list.add(employee);
ProxyFactory factory = new ProxyFactory(); factory.setSuperclass(Foo.class); factory.setFilter(new MethodFilter() { ...
ProxyFactory factory = new ProxyFactory() .setSuperclass(Properties.class); .setFilter(new MethodFilter() { ...
val employee = Employee().apply { name = "Jack Sparrow" id = 1 foo = "bacon" } val employee = Employee() with(employee) { name = "Jack Sparrow" id = 1 foo = "bacon" } val employee = Employee() employee.let { it.name = "Jack Sparrow" it.id = 1 it.foo = "bacon" }
setPropertyFromParams(array $hashParamList) { ... }
public void setAllComponents(Component[] myComponentArray, Method myMethod) { for (Component leaf : myComponentArray) { if (leaf instanceof Container) { Container node = (Container) leaf; setAllComponents(node.getComponents(), myMethod); } myMethod(leaf); } }
setAllComponents(this.getComponents(), changeColor()); setAllComponents(this.getComponents(), changeSize());
public class CommandExample { public interface Command { public void execute(Object data); } public class PrintCommand implements Command { public void execute(Object data) { System.out.println(data.toString()); } } public static void callCommand(Command command, Object data) { command.execute(data); } public static void main(String... args) { callCommand(new PrintCommand(), "hello world"); } }
obj.aMethod(new AFunctionalInterface() { @Override public boolean anotherMethod(int i) { return i == 982 } });
p -> p.getGender() == Person.Sex.MALE && p.getAge() >= 18 && p.getAge() <= 25
p.getGender() == Person.Sex.MALE && p.getAge() >= 18 && p.getAge() <= 25
p -> { return p.getGender() == Person.Sex.MALE && p.getAge() >= 18 && p.getAge() <= 25; }
interface I { public void myMethod(Component component); } class A { public void changeColor(Component component) { } public void changeSize(Component component) { } }
class B { public void setAllComponents(Component[] myComponentArray, I myMethodsInterface) { for(Component leaf : myComponentArray) { if(leaf instanceof Container) { Container node = (Container)leaf; setAllComponents(node.getComponents(), myMethodInterface); } myMethodsInterface.myMethod(leaf); } } }
class C { A a = new A(); B b = new B(); public C() { b.setAllComponents(this.getComponents(), component -> a.changeColor(component)); b.setAllComponents(this.getComponents(), component -> a.changeSize(component)); } }
class C { A a = new A(); B b = new B(); public C() { b.setAllComponents(this.getComponents(), a::changeColor); b.setAllComponents(this.getComponents(), a::changeSize); } }
public interface Callable { public void call(int param); }
class Test implements Callable { public void call(int param) { System.out.println( param ); } }
public invoke( Callable callable ) { callable.call( 5 ); }
public interface ComponentMethod { public abstract void PerfromMethod(Container c); } public class ChangeColor implements ComponentMethod { @Override public void PerfromMethod(Container c) { } } public class ChangeSize implements ComponentMethod { @Override public void PerfromMethod(Container c) { } } public void setAllComponents(Component[] myComponentArray, ComponentMethod myMethod) { for (Component leaf : myComponentArray) { if (leaf instanceof Container) { Container node = (Container) leaf; setAllComponents(node.getComponents(), myMethod); } myMethod.PerfromMethod(leaf); } }
setAllComponents(this.getComponents(), new ChangeColor()); setAllComponents(this.getComponents(), new ChangeSize());
public interface NewVersionTest{ String returnAString(Object oIn, String str); }
public static void printOutput(NewVersionTest t, Object o, String s){ System.out.println(t.returnAString(o, s)); }
public static void main(String[] args){ printOutput( (Object oIn, String sIn) -> { System.out.println("Lambda reached!"); return "lambda return"; } ); }
public class HelperClass{ public static String testOtherSig(Object o, String s){ return "real static method"; } }
public static void main(String[] args){ printOutput(HelperClass::testOtherSig); }
private Runnable methodName (final int arg){ return new Runnable(){ public void run(){ } } }
private void otherMethodName (Runnable arg){ arg.run(); }
public void setAllComponents(Component[] myComponentArray, Consumer<Component> myMethod) { for (Component leaf : myComponentArray) { if (leaf instanceof Container) { Container node = (Container) leaf; setAllComponents(node.getComponents(), myMethod); } myMethod.accept(leaf); } }
setAllComponents(this.getComponents(), this::changeColor); setAllComponents(this.getComponents(), this::changeSize);
public interface Function4<A, B, C, D, R> { R apply(A a, B b, C c, D d); }
interface ComponentDelegate { void doSomething(Component component); } public void setAllComponents(Component[] myComponentArray, ComponentDelegate delegate) { delegate.doSomething(leaf); } setAllComponents(this.getComponents(), new ComponentDelegate() { void doSomething(Component component) { changeColor(component); } });
public void YouMethod(..... Method methodToCall, Object objWithAllMethodsToBeCalled) { ... Object retobj = methodToCall.invoke(objWithAllMethodsToBeCalled, arglist); ... }
public class TestMethodPassing { private static void println() { System.out.println("Do println"); } private static void print() { System.out.print("Do print"); } private static void performTask(BasicFunctionalInterface functionalInterface) { functionalInterface.performTask(); } @FunctionalInterface interface BasicFunctionalInterface { void performTask(); } public static void main(String[] arguments) { performTask(TestMethodPassing::println); performTask(TestMethodPassing::print); } }
@FunctionalInterface public interface AutoCompleteCallable<T> { String call(T model) throws Exception; }
public <T> void initialize(List<T> entries, AutoCompleteCallable getSearchText) {....... String value = getSearchText.call(item); ... }
initialize(getMessageContactModelList(), new AutoCompleteCallable() { @Override public String call(Object model) throws Exception { return "custom string" + ((xxxModel)model.getTitle()); } })
public abstract class Function { public abstract double f(double x); }
public class ArrayMap { public static double[] apply_to_array(double[] arr, Function fun) { for(int i=0; i<arr.length;i++) { arr[i]=fun.f(arr[i]); } return arr; } }
public class Testclass extends Function { public static void main(String[] args) { double[] myarr = {1,2,3,4}; ArrayMap.apply_to_array(myarr, new Testclass()); for (double k : myarr) { System.out.println(k); } } @Override public double f(double x) { return Math.log(x); } }
import java.util.function.Function; public class Foo { private Foo(String parameter) { System.out.println("I } public static Foo method(final String parameter) { return new Foo(parameter); } private static Function parametrisedMethod(Function<String, Foo> function) { return function; } public static void main(String[] args) { parametrisedMethod(Foo::method).apply("from a method"); } }
public GregorianCalendar(TimeZone zone, Locale aLocale) { super(zone, aLocale); gdate = (BaseCalendar.Date) gcal.newCalendarDate(zone); setTimeInMillis(System.currentTimeMillis()); }
public Date() { this(System.currentTimeMillis()); }
long start = System.currentTimeMillis(); .... do something ... long elapsed = System.currentTimeMillis() -start;
long now = System.currentTimeMillis(); for (int i = 0; i < 10000000; i++) { new Date().getTime(); } long result = System.currentTimeMillis() - now; System.out.println("Date(): " + result); now = System.currentTimeMillis(); for (int i = 0; i < 10000000; i++) { System.currentTimeMillis(); } result = System.currentTimeMillis() - now; System.out.println("currentTimeMillis(): " + result);
for (Object key : map.keySet()) if (something) map.remove(key);
for (Object key : new ArrayList<Object>(map.keySet())) if (something) map.remove(key);
map.entrySet().removeIf(e-> <boolean expression> );
Map<String, String> map = new HashMap<String, String>() { { put("test", "test123"); put("test2", "test456"); } }; for(Iterator<Map.Entry<String, String>> it = map.entrySet().iterator(); it.hasNext(); ) { Map.Entry<String, String> entry = it.next(); if(entry.getKey().equals("test")) { it.remove(); } }
Iterator<Object> it = map.keySet().iterator(); while (it.hasNext()) { it.next(); if (something) it.remove(); }
map.values().removeAll(Collections.singleton("test"));
map.entrySet().removeIf(e-> <boolean expression> );
Map<Object, Content> map = new ConcurrentHashMap<Object, Content>(); for (Object key : map.keySet()) { if (something) { map.remove(key); } }
public static void mapRemove() { Map<Integer, String> map = new HashMap<Integer, String>() { { put(1, "one"); put(2, "two"); put(3, "three"); } }; map.forEach( (key, value) -> { System.out.println( "Key: " + key + "\t" + " Value: " + value ); }); map.keySet().removeIf(e->(e>2)); System.out.println("After removing element"); map.forEach( (key, value) -> { System.out.println( "Key: " + key + "\t" + " Value: " + value ); }); }
Key: 1 Value: one Key: 2 Value: two Key: 3 Value: three After removing element Key: 1 Value: one Key: 2 Value: two
Iterator<Integer> it = map.keySet().iterator(); while(it.hasNext()) { Integer key = it.next(); Object val = map.get(key); if (val.shouldBeRemoved()) { it.remove(); } }
List<SomeObject> toRemove = new ArrayList<SomeObject>(); for (SomeObject key: map.keySet()) { if (something) { toRemove.add(key); } } for (SomeObject key: toRemove) { map.remove(key); }
ConcurrentMap<Integer, String> running = ... create and populate map Set<Entry<Integer, String>> set = running.entrySet(); for (Entry<Integer, String> entry : set) { if (entry.getKey()>600000) { set.remove(entry); } }
Set s=map.entrySet(); Iterator iter = s.iterator(); while (iter.hasNext()) { Map.Entry entry =(Map.Entry)iter.next(); if("value you need to remove".equals(entry.getKey())) { map.remove(); } }
int x = 100; System.out.println(Integer.toBinaryString(x));
Integer.toString(100,8) Integer.toString(100,2) Integer.toString(100,16)
n = 5463 output = 0000 0000 0000 0000 0001 0101 0101 0111
/** * Converts an integer to a 32-bit binary string * @param number * The number to convert * @param groupSize * The number of bits in a group * @return * The 32-bit long bit string */ public static String intToString(int number, int groupSize) { StringBuilder result = new StringBuilder(); for(int i = 31; i >= 0 ; i--) { int mask = 1 << i; result.append((number & mask) != 0 ? "1" : "0"); if (i % groupSize == 0) result.append(" "); } result.replace(result.length() - 1, result.length(), ""); return result.toString(); }
public static void main(String[] args) { System.out.println(intToString(5463, 4)); }
int value = 28; for(int i = 1, j = 0; i < 256; i = i << 1, j++) System.out.println(j + " " + ((value & i) > 0 ? 1 : 0));
public static void toBase(int number, int base) { String binary = ""; int temp = number/2+1; for (int j = 0; j < temp ; j++) { try { binary += "" + number % base; number /= base; } catch (Exception e) { } } for (int j = binary.length() - 1; j >= 0; j--) { System.out.print(binary.charAt(j)); } }
StringBuilder binary = new StringBuilder(); int n=15; while (n>0) { if((n&1)==1){ binary.append(1); }else binary.append(0); n>>=1; } System.out.println(binary.reverse());
void bitPattern(int n) { int mask = 1 << 31; int count = 0; while(mask != 0) { if(count%4 == 0) System.out.print(" "); if((mask&n) == 0) System.out.print("0"); else System.out.print("1"); count++; mask = mask >>> 1; } System.out.println(); }
int decimalOrBinary = 345; StringBuilder builder = new StringBuilder(); do { builder.append(decimalOrBinary % 2); decimalOrBinary = decimalOrBinary / 2; } while (decimalOrBinary > 0); System.out.println(builder.reverse().toString());
public static void main(String[] args) { int i = 13; short s = 13; byte b = 13; System.out.println("i: " + String.format("%32s", Integer.toBinaryString(i)).replaceAll(" ", "0")); System.out.println("s: " + String.format("%16s", Integer.toBinaryString(0xFFFF & s)).replaceAll(" ", "0")); System.out.println("b: " + String.format("%8s", Integer.toBinaryString(0xFFFFFF & b)).replaceAll(" ", "0")); }
i: 00000000000000000000000000001101 s: 0000000000001101 b: 00001101
public static String convertNumber(int a) { StringBuilder sb=new StringBuilder(); sb.append(a & 1); while ((a>>=1) != 0) { sb.append(a & 1); } sb.append("b0"); return sb.reverse().toString(); }
for(int i = 1; i <= 256; i++) { System.out.print(i + " "); System.out.println(Integer.toBinaryString(i) + " "); System.out.print(Integer.toOctalString(i) + " "); System.out.print(Integer.toHexString(i) + " "); }
public class Bin { public static void main(String[] args) { System.out.println(toBinary(0x94, 8)); } public static String toBinary(int a, int bits) { if (--bits > 0) return toBinary(a>>1, bits)+((a&0x1)==0?"0":"1"); else return (a&0x1)==0?"0":"1"; }
org.apache.commons.lang3.StringUtils.leftPad(Integer.toBinaryString(x), 32,
public static void main(String[] args) { Scanner sc = new Scanner(System.in); int integer ; String binary = ""; System.out.print("Enter the binary Number: "); integer = sc.nextInt(); while(integer>0) { int x = integer % 2; binary = x + binary; integer = integer / 2; } System.out.println("Your binary number is : "+binary); System.out.println("your binary length : " + binary.length()); } }
public static void printBinaryNumbers(int n) { char[] arr = Integer.toBinaryString(n).toCharArray(); StringBuilder sb = new StringBuilder(); for (Character c : arr) { sb.append(c); } System.out.println(sb); }
public static String toBinaryString(int n){ StringBuilder res=new StringBuilder(); int displayMask=1<<31; for (int i=1;i<=32;i++){ res.append((n & displayMask)==0? n=n<<1; if (i%8==0) res.append( } return res.toString(); } System.out.println(BitUtil.toBinaryString(30)); O/P: 00000000 00000000 00000000 00011110
public static String representDigits(int num) { int checkBit = 1 << (Integer.SIZE * 8 - 2 ); StringBuffer sb = new StringBuffer(); if (num < 0 ) { sb.append("1"); } else { sb.append("0"); } while(checkBit != 0) { if ((num & checkBit) == checkBit){ sb.append("1"); } else { sb.append("0"); } checkBit >>= 1; } return sb.toString(); }
Collection c; Iterator iter = c.iterator(); Object first = iter.next();
com.google.common.collect.Iterables.get(collection, 0) com.google.common.collect.Iterables.get(collection, 0, defaultValue) com.google.common.collect.Iterables.getFirst(collection, defaultValue)
com.google.common.collect.Iterables.getOnlyElement(collection, defaultValue) com.google.common.collect.Iterables.getOnlyElement(collection)
String firstElement = null; if (!strings.isEmpty() && strings.size() > 0) { firstElement = strings.get(0); }
Optional<String> firstElement = strings.stream().findFirst();
String firstElement = Iterables.getFirst(strings, null);
String firstElement = (String) IteratorUtils.get(strings, 0);
String firstElement = (String) CollectionUtils.get(strings, 0);
val stringsList: List<String?> = listOf("a", "b", null) val first: String? = stringsList.first()
val stringArray: Array<String?> = arrayOf("a", "b", null) val first: String? = stringArray.first()
SortedSet<String> sortedSet = new TreeSet<String>(); sortedSet.add("2"); sortedSet.add("1"); sortedSet.add("3"); String first = sortedSet.first();
Set<String> set = new TreeSet<>(); set.add("2"); set.add("1"); set.add("3"); String first = set.stream().findFirst().get();
String first = set.stream().findFirst().orElse(""); set.removeIf(String::isEmpty);
Optional<String> firstString = set.stream().findFirst(); if(firstString.isPresent()){ String first = firstString.get(); }
Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try { conn = stmt = conn.prepareStatement( rs = stmt.executeQuery(); } catch(Exception e) { } finally { try { if (rs != null) rs.close(); } catch (Exception e) {}; try { if (stmt != null) stmt.close(); } catch (Exception e) {}; try { if (conn != null) conn.close(); } catch (Exception e) {}; }
try (Connection connection = dataSource.getConnection(); Statement statement = connection.createStatement()) { try (ResultSet resultSet = statement.executeQuery("some query")) { } try (ResultSet resultSet = statement.executeQuery("some query")) { } }
Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try { conn = stmt = conn.prepareStatement( rs = stmt.executeQuery(); } catch(Exception e) { } finally { DbUtils.closeQuietly(rs); DbUtils.closeQuietly(stmt); DbUtils.closeQuietly(conn); }
Connection connection = dataSource.getConnection(); try { Statement statement = connection.createStatement(); try { ResultSet resultSet = statement.executeQuery("some query"); try { } finally { resultSet.close(); } } finally { statement.close(); } } finally { connection.close(); }
try { ... return resp; } finally { if (rs != null && !rs.isClosed()) { try { rs.close(); } catch (Exception e2) { log.warn("Cannot close resultset: " + e2.getMessage()); } } if (stmt != null && !stmt.isClosed()) { try { stmt.close(); } catch (Exception e2) { log.warn("Cannot close statement " + e2.getMessage()); } } if (con != null && !conn.isClosed()) { try { con.close(); } catch (Exception e2) { log.warn("Cannot close connection: " + e2.getMessage()); } }
Class.getDeclaredConstructor(String.class).newInstance("HERESMYARG");
myObject.getClass().getDeclaredConstructors(types list).newInstance(args list);
class MyClass { public MyClass(Long l, String s, int i) { } }
Class classToLoad = MyClass.class; Class[] cArg = new Class[3]; cArg[0] = Long.class; cArg[1] = String.class; cArg[2] = int.class; Long l = new Long(88); String s = "text"; int i = 5; classToLoad.getDeclaredConstructor(cArg).newInstance(l, s, i);
import java.lang.reflect.*; class NewInstanceWithReflection{ public NewInstanceWithReflection(){ System.out.println("Default constructor"); } public NewInstanceWithReflection( String a){ System.out.println("Constructor :String => "+a); } public static void main(String args[]) throws Exception { NewInstanceWithReflection object = (NewInstanceWithReflection)Class.forName("NewInstanceWithReflection").newInstance(); Constructor constructor = NewInstanceWithReflection.class.getDeclaredConstructor( new Class[] {String.class}); NewInstanceWithReflection object1 = (NewInstanceWithReflection)constructor.newInstance(new Object[]{"StackOverFlow"}); } }
java NewInstanceWithReflection Default constructor Constructor :String => StackOverFlow
public static JFrame createJFrame(Class c, String name, Component parentComponent) { try { JFrame frame = (JFrame)c.getDeclaredConstructor(new Class[] {String.class}).newInstance("name"); if (parentComponent != null) { frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } else { frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); } frame.setLocationRelativeTo(parentComponent); frame.pack(); frame.setVisible(true); } catch (InstantiationException instantiationException) { ExceptionHandler.handleException(instantiationException, parentComponent, Language.messages.get(Language.InstantiationExceptionKey), c.getName()); } catch(NoSuchMethodException noSuchMethodException) { ExceptionHandler.handleException(noSuchMethodException, parentComponent, Language.messages.get(Language.NoSuchMethodExceptionKey), "(Constructor or a JFrame method)"); } catch (IllegalAccessException illegalAccessException) { ExceptionHandler.handleException(illegalAccessException, parentComponent, Language.messages.get(Language.IllegalAccessExceptionKey)); } catch (InvocationTargetException invocationTargetException) { ExceptionHandler.handleException(invocationTargetException, parentComponent, Language.messages.get(Language.InvocationTargetExceptionKey)); } finally { return null; } }
@GET @Path("/employee/{dept}") Patient getEmployee(@PathParam("dept")Long dept, @QueryParam("id")Long id) ;
@GET @Path("/employee/{dept}/{id}") Patient getEmployee(@PathParam("dept")Long dept, @PathParam("id")Long id) ;
@GET @Path("/employee") Patient getEmployee(@QueryParam("dept")Long dept, @QueryParam("id")Long id) ;
GET: myserver.com/myblog/posts?page=2&order=backward
/inventory?make=toyota&model=corolla /inventory?year=2014
/inventory/makes/toyota/models/corolla?year=2014 /inventory/years/2014?make=toyota&model=corolla /inventory?make=toyota&model=corolla&year=2014
@Path("/rest") public class Abc { @GET @Path("/msg/{p0}/{p1}") @Produces("text/plain") public String add(@PathParam("p0") Integer param1, @PathParam("p1") Integer param2 ) { return String.valueOf(param1+param2); } }
@Path("/car") class CarResource { @Get @produces("text/plain") @Path("/search/{carmodel}") public String getCarSearch(@PathParam("carmodel")String model,@QueryParam("carcolor")String color) { ----- return cars } }
package com.example.multiple; public class PublicClass { PrivateImpl impl = new PrivateImpl(); } class PrivateImpl { int implementationData; }
Foo.java:2: cannot find symbol symbol : class Baz location: class Foo private Baz baz; ^ 1 error
public class Fun { Fun() { System.out.println("Fun constructor"); } void fun() { System.out.println("Fun mathod"); } public static void main(String[] args) { Fun fu = new Fun(); fu.fun(); Fen fe = new Fen(); fe.fen(); Fin fi = new Fin(); fi.fin(); Fon fo = new Fon(); fo.fon(); Fan fa = new Fan(); fa.fan(); fa.run(); } } class Fen { Fen() { System.out.println("fen construuctor"); } void fen() { System.out.println("Fen method"); } } class Fin { void fin() { System.out.println("Fin method"); } } class Fon { void fon() { System.out.println("Fon method"); } } class Fan { void fan() { System.out.println("Fan method"); } public void run() { System.out.println("run"); } }
public class Foo { public static class FooChild extends Z { String foo; } public static class ZeeChild extends Z { } }
public class Bar { public static void main(String[] args){ Foo.FooChild f = new Foo.FooChild(); System.out.println(f); } }
class Foo {val bar = "a"} class Bar {val foo = "b"}
workspace\.metadata\.plugins\org.eclipse.core.resources\.root\.indexes
<workspace>\.metadata\.plugins\org.eclipse.core.resources\.projects\<project>\.markers.snap
find $WORKSPACE_DIR/.metadata/.plugins/org.eclipse.core.resources/.projects \ -name .indexes -exec rm -fr {} \;
rm $WORKSPACE_DIR/.metadata/.plugins/org.eclipse.e4.workbench/workbench.xmi
<eclipse workspace>/.metadata/.plugins/org.eclipse.core.resources/.projects
find <eclipse_workspace>/.metadata/.plugins/org.eclipse.core.resources/.projects -name "*.snap" -exec rm -f {} \;
-clean -refresh -startup ../../../plugins/org.eclipse.equinox.launcher_1.3.0.v20130327-1440.jar --launcher.library
ex. E:\workspaceFolder\.metadata\.plugins\org.eclipse.core.resources
getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
this.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
android:focusable="false" android:focusableInTouchMode="false"
<activity android:name=".HomeActivity" android:label="@string/app_name" android:windowSoftInputMode="stateAlwaysHidden" >
<activity android:name=".HomeActivity" android:windowSoftInputMode="stateHidden"> </activity>
@Override public void onResume() { this.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN); super.onResume(); } @Override public void onStart() { this.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN); super.onStart(); }
android:focusable="true" android:focusableInTouchMode="true"
<?xml version="1.0" encoding="utf-8"?> <LinearLayout xmlns:android="http: android:layout_width="match_parent" ... android:focusable="true" android:focusableInTouchMode="true" > <EditText android:id="@+id/myEditText" ... android:hint="@string/write_here" /> <Button android:id="@+id/button_ok" ... android:text="@string/ok" /> </LinearLayout>
public static void hideKeyboard(Activity activity) { View view = activity.getCurrentFocus(); if (view != null) { InputMethodManager inputManager = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE); inputManager.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); } }
<activity android:name=".MainActivity" android:label="@string/app_name" android:theme="@style/AppTheme" android:windowSoftInputMode="stateHidden">
<activity android:name=".MainActivity" android:windowSoftInputMode="stateHidden">
override fun onResume() { super.onResume() window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN) }
InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
@Override public boolean dispatchTouchEvent(MotionEvent ev) { if (getCurrentFocus() != null) { InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(getCurrentFocus().getWindowToken(), 0); } return super.dispatchTouchEvent(ev); }
TextView mtextView = findViewById(R.id.myTextView); mtextView.setShowSoftInputOnFocus(false);
<Button android:id="@+id/mybutton"> <requestFocus /> </Button>
for i in *.jar; do jar -tvf "$i" | grep -Hsi ClassName && echo "$i"; done
$ find . -name "*.jar" -exec grep -Hsli IdentityHashingStrategy {} \; ./trove-3.0.3.jar
for i in $(locate "*.jar"); do echo $i; jar -tvf $i | grep -Hsi ClassName; done
for /R %G in (*.jar) do @jar -tvf "%G" | find "ClassName" > NUL && echo %G
find . -name "*.jar" -exec jar -t -f {} \; | grep "classname"
pattern=$1 shift for jar in $(find $* -type f -name "*.jar") do match=`jar -tvf $jar | grep $pattern` if [ ! -z "$match" ] then echo "Found in: $jar" echo "$match" fi done
public class Main { /** * */ private static String CLASS_FILE_TO_FIND = "class.to.find.Here"; private static List<String> foundIn = new LinkedList<String>(); /** * @param args the first argument is the path of the file to search in. The second may be the * class file to find. */ public static void main(String[] args) { if (!CLASS_FILE_TO_FIND.endsWith(".class")) { CLASS_FILE_TO_FIND = CLASS_FILE_TO_FIND.replace( } File start = new File(args[0]); if (args.length > 1) { CLASS_FILE_TO_FIND = args[1]; } search(start); System.out.println("------RESULTS------"); for (String s : foundIn) { System.out.println(s); } } private static void search(File start) { try { final FileFilter filter = new FileFilter() { public boolean accept(File pathname) { return pathname.getName().endsWith(".jar") || pathname.isDirectory(); } }; for (File f : start.listFiles(filter)) { if (f.isDirectory()) { search(f); } else { searchJar(f); } } } catch (Exception e) { System.err.println("Error at: " + start.getPath() + " " + e.getMessage()); } } private static void searchJar(File f) { try { System.out.println("Searching: " + f.getPath()); JarFile jar = new JarFile(f); ZipEntry e = jar.getEntry(CLASS_FILE_TO_FIND); if (e == null) { e = jar.getJarEntry(CLASS_FILE_TO_FIND); if (e != null) { foundIn.add(f.getPath()); } } else { foundIn.add(f.getPath()); } } catch (IOException e) { e.printStackTrace(); } } }
IFS=$ jars=( $( find -P "$1" -type f -name "*.jar" ) ) for jar in ${jars[*]} do classes=( $( zipinfo -1 ${jar} | awk -F if [ ${ for class in ${classes[*]} do if [ ${class} == "$2" ]; then echo "Found in ${jar}" fi done fi done
bash $ ls -1 | xargs -i -t jar -tvf jar -tvf activation-1.1.jar jar -tvf antisamy-1.4.3.jar 2263 Thu Jan 13 21:38:10 IST 2011 org/owasp/validator/html/scan/AbstractAntiSamyScanner.class ...
for i in *.jar; do jar -tf "$i" | grep $1 | xargs -I{} echo -e "$i : {}" ; done
IFS=$(echo -en "\n\b") for f in `find ${1} -iname *.jar`; do jar -tf ${f}| grep --color $2 if [ $? == 0 ]; then echo -n "Match found: " echo -e "${f}\n" fi done unset IFS
LIB_DIR=/some/dir/full/of/jarfiles for jarfile in $(find $LIBDIR -name "*.jar"); do echo "--------$jarfile---------------" jar -tvf $jarfile | grep FooBar done
function find_jar_of_class() { OLD_IFS=$IFS IFS=$ jars=( $( find -type f -name "*.jar" ) ) for i in ${jars[*]} ; do if [ ! -z "$(jar -tvf "$i" | grep -Hsi $1)" ] ; then echo "$i" fi done IFS=$OLD_IFS }
$ find <base_dir> -name *.jar -print0 | xargs -0 -l jar tf | grep <name>
import java.net.URL; import java.net.URLClassLoader; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class FileFinder { public static void main(String[] args) throws Exception { String file = <your file name>; ClassLoader cl = ClassLoader.getSystemClassLoader(); URL[] urls = ((URLClassLoader)cl).getURLs(); for(URL url: urls){ listFiles(file, url); } } private static void listFiles(String file, URL url) throws Exception{ ZipInputStream zip = new ZipInputStream(url.openStream()); while(true) { ZipEntry e = zip.getNextEntry(); if (e == null) break; String name = e.getName(); if (name.endsWith(file)) { System.out.println(url.toString() + " -> " + name); } } } }
List<Integer> intList = myIntStream.mapToObj(i->i).collect(Collectors.toList());
MutableIntList list = IntStream.range(1, 5) .collect(IntArrayList::new, MutableIntList::add, MutableIntList::addAll);
collection.stream().forEach(System.out::println); collection.forEach(System.out::println);
public int outside = 0; private void forCounter(List<Integer> integers) { for(int ii = 0; ii < integers.size(); ii++) { Integer next = integers.get(ii); outside = next*next; } } private void forEach(List<Integer> integers) { for(Integer next : integers) { outside = next * next; } } private void iteratorForEach(List<Integer> integers) { integers.forEach((ii) -> { outside = ii*ii; }); } private void iteratorStream(List<Integer> integers) { integers.stream().forEach((ii) -> { outside = ii*ii; }); }
1 10 100 1000 10000 for with index 39 112 920 8577 89212 iterator.forEach 27 116 959 8832 88958 for:each 53 171 1262 11164 111005 iterable.stream.forEach 255 324 1030 8519 88419
I got: 1 10 100 1000 10000 iterator.forEach 27 106 1047 8516 88044 for:each 46 143 1182 10548 101925 iterable.stream.forEach 393 397 1108 8908 88361 for with index 49 145 887 7614 81130
foralobo@ubuntu-vincy:~$ java -version java version "1.7.0_21" Java(TM) SE Runtime Environment (build 1.7.0_21-b11) Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)
sudo apt-get update sudo apt-get install openjdk-7-jdk
tar -xvf jdk-7u75-linux-x64.tar.gz (32-bit) tar -xvf jdk-7u75-linux-x64.tar.gz (64-bit)
sudo mkdir -p /usr/lib/jvm sudo mv ./jdk1.7.0_75 /usr/lib/jvm/
sudo update-alternatives --install "/usr/bin/java" "java" "/usr/lib/jvm/jdk1.7.0_75/bin/java" 1 sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/lib/jvm/jdk1.7.0_75/bin/javac" 1 sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/lib/jvm/jdk1.7.0_75/bin/javaws" 1
sudo chmod a+x /usr/bin/java sudo chmod a+x /usr/bin/javac sudo chmod a+x /usr/bin/javaws sudo chown -R root:root /usr/lib/jvm/jdk1.7.0_75
Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-6-oracle1/bin/java 1047 auto mode 1 /usr/bin/gij-4.6 1046 manual mode 2 /usr/lib/jvm/java-6-oracle1/bin/java 1047 manual mode 3 /usr/lib/jvm/jdk1.7.0_75/bin/java 1 manual mode
update-alternatives: using /usr/lib/jvm/jdk1.7.0_75/bin/java to provide /usr/bin/java (java) in manual mode
sudo update-alternatives --config javac sudo update-alternatives --config javaws
sudo apt-get install python-software-properties sudo add-apt-repository ppa:webupd8team/java sudo apt-get update
wget https: chmod +x oab-java.sh sudo ./oab-java.sh -7 sudo apt-get update sudo sudo apt-get install oracle-java7-jdk oracle-java7-fonts oracle-java7-source sudo apt-get dist-upgrade
wget https: chmod +x oab-java.sh sudo ./oab-java.sh -7 sudo apt-get update sudo sudo apt-get install oracle-java7-jdk oracle-java7-fonts oracle-java7-source sudo apt-get dist-upgrade
Open Applicaction -> Accessories -> Terminal Type commandline as below... sudo apt-get install openjdk-7-jdk Type commandline as below... apt-cache search jdk (Note: openjdk-7-jdk is symbolically used here. You can choose the JDK version as per your requirement.) For "JAVA_HOME" (Environment Variable) type command as shown below, in "Terminal" using your installation path... export JAVA_HOME=/usr/lib/jvm/java-7-openjdk (Note: "/usr/lib/jvm/java-7-openjdk" is symbolically used here just for demostration. You should use your path as per your installation.) For "PATH" (Environment Variable) type command as shown below, in "Terminal" using your installation path... export PATH=$PATH:/usr/lib/jvm/java-7-openjdk/bin (Note: "/usr/lib/jvm/java-7-openjdk" is symbolically used here just for demostration. You should use your path as per your installation.) Check for "open jdk" installation, just type command in "Terminal" as shown below javac -version
@Path("get/id") @GET @Produces("application/json") public M_ getMachineToUpdate(@PathParam("id") String id) { return myJson; }
@GET @Path("retrieve/{uuid}") public Response retrieveSomething(@PathParam("uuid") String uuid) { if(uuid == null || uuid.trim().length() == 0) { return Response.serverError().entity("UUID cannot be blank").build(); } Entity entity = service.getById(uuid); if(entity == null) { return Response.status(Response.Status.NOT_FOUND).entity("Entity not found for UUID: " + uuid).build(); } String json = return Response.ok(json, MediaType.APPLICATION_JSON).build(); }
public class MyApplicationException extends Exception implements Serializable { private static final long serialVersionUID = 1L; public MyApplicationException() { super(); } public MyApplicationException(String msg) { super(msg); } public MyApplicationException(String msg, Exception e) { super(msg, e); } }
@Provider public class MyApplicationExceptionHandler implements ExceptionMapper<MyApplicationException> { @Override public Response toResponse(MyApplicationException exception) { return Response.status(Status.BAD_REQUEST).entity(exception.getMessage()).build(); } }
@GET @Path("myresource({id}") public Response retrieveSomething(@PathParam("id") String id) { ... Entity entity = service.getById(uuid); if(entity == null) { return Response.status(Response.Status.NOT_FOUND).entity("Resource not found for ID: " + uuid).build(); } ... }
@Path("/") @POST @Consumes({ MediaType.APPLICATION_JSON }) @Produces({ MediaType.APPLICATION_JSON }) public User addUser(User user){ User newuser = ... do something like DB insert ... return newuser; }
@Path("/") @POST @Consumes({ MediaType.APPLICATION_JSON }) @Produces({ MediaType.APPLICATION_JSON }) public User addUser(User user, @Context final HttpServletResponse response){ User newUser = ... response.setStatus(HttpServletResponse.SC_CREATED); try { response.flushBuffer(); }catch(Exception e){} return newUser; }
@Path("/") @POST @Consumes({ MediaType.APPLICATION_JSON }) @Produces({ MediaType.APPLICATION_JSON }) public Response addUser(User user){ User newUser = ... return Response.created(hateoas.buildLinkUri(newUser, "entity")).entity(restResponse).build(); }
@Path("/foos/{fooId}") @PUT @Consumes("application/json") @Produces("application/json") public Foo setFoo(@PathParam("fooID") final String fooID, final Foo foo, @Context final HttpServletResponse response) { if(itemDidNotExistBefore) { response.setStatus(Response.Status.CREATED.getStatusCode()); } return foo; }
@Context private HttpServletResponse response; @Path("/foos/{fooId}") @PUT @Consumes("application/json") @Produces("application/json") public Foo setFoo(@PathParam("fooID") final String fooID, final Foo foo) { if(itemDidNotExistBefore) { response.setStatus(Response.Status.CREATED.getStatusCode()); } return foo; }
package my.webservice.annotations.status; import javax.ws.rs.NameBinding; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @NameBinding @Retention(RetentionPolicy.RUNTIME) public @interface Status { int CREATED = 201; int value(); }
package my.webservice.interceptors.status; import javax.ws.rs.container.ContainerRequestContext; import javax.ws.rs.container.ContainerResponseContext; import javax.ws.rs.container.ContainerResponseFilter; import javax.ws.rs.ext.Provider; import java.io.IOException; @Provider public class StatusFilter implements ContainerResponseFilter { @Override public void filter(ContainerRequestContext containerRequestContext, ContainerResponseContext containerResponseContext) throws IOException { if (containerResponseContext.getStatus() == 200) { for (Annotation annotation : containerResponseContext.getEntityAnnotations()) { if(annotation instanceof Status){ containerResponseContext.setStatus(((Status) annotation).value()); break; } } } } }
package my.webservice.resources; import my.webservice.annotations.status.StatusCreated; import javax.ws.rs.*; @Path("/my-resource-path") public class MyResource{ @POST @Status(Status.CREATED) public boolean create(){ return true; } }
@Provider public class UnauthorizedExceptionMapper implements ExceptionMapper<EJBAccessException> { @Override public Response toResponse(EJBAccessException exception) { return Response.status(Response.Status.UNAUTHORIZED.getStatusCode()).build(); } }
@GET @Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML }) @Path("{id}") public MyEntity getFoo(@PathParam("id") long id, @QueryParam("lang")long idLanguage) { if (idLanguage== 0){ ResponseBuilder builder = Response.status(Response.Status.BAD_REQUEST); builder.entity("Missing idLanguage parameter on request"); Response response = builder.build(); throw new WebApplicationException(response); } ... return myEntity; }
response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
@POST @Consumes("application/json") @Produces("application/json") public Response authUser(JsonObject authData) { String email = authData.getString("email"); String password = authData.getString("password"); JSONObject json = new JSONObject(); if (email.equalsIgnoreCase(user.getEmail()) && password.equalsIgnoreCase(user.getPassword())) { json.put("status", "success"); json.put("code", Response.Status.OK.getStatusCode()); json.put("message", "User " + authData.getString("email") + " authenticated."); return Response.ok(json.toString()).build(); } else { json.put("status", "error"); json.put("code", Response.Status.NOT_FOUND.getStatusCode()); json.put("message", "User " + authData.getString("email") + " not found."); return Response.status(Response.Status.NOT_FOUND).entity(json.toString()).build(); } }
<init-param> <!-- used to overwrite default 4xx state pages --> <param-name>jersey.config.server.response.setStatusOverSendError</param-name> <param-value>true</param-value> </init-param>
public SkuResultListDTO getSkuData() .... return SkuResultListDTO;
public Response getSkuData() ... return Response.status(Response.Status.FORBIDDEN).entity(dfCoreResultListDTO).build();
package com.test; public class Foo { public Map map; public JTable table; }
java myapp -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=4000, suspend=n
java -agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=n <other arguments>
java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=4000,suspend=n myapp
-Xnoagent -Djava.compiler=NONE -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=6006
-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=6006
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=6006
JAVA_OPTS="$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n"
CATALINA_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n"
JPDA_OPTS="-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n"
public class PrintAppDataDir { public static void main(String[] args) { if (com.sun.jna.Platform.isWindows()) { HWND hwndOwner = null; int nFolder = Shell32.CSIDL_LOCAL_APPDATA; HANDLE hToken = null; int dwFlags = Shell32.SHGFP_TYPE_CURRENT; char[] pszPath = new char[Shell32.MAX_PATH]; int hResult = Shell32.INSTANCE.SHGetFolderPath(hwndOwner, nFolder, hToken, dwFlags, pszPath); if (Shell32.S_OK == hResult) { String path = new String(pszPath); int len = path.indexOf( path = path.substring(0, len); System.out.println(path); } else { System.err.println("Error: " + hResult); } } } private static Map<String, Object> OPTIONS = new HashMap<String, Object>(); static { OPTIONS.put(Library.OPTION_TYPE_MAPPER, W32APITypeMapper.UNICODE); OPTIONS.put(Library.OPTION_FUNCTION_MAPPER, W32APIFunctionMapper.UNICODE); } static class HANDLE extends PointerType implements NativeMapped { } static class HWND extends HANDLE { } static interface Shell32 extends Library { public static final int MAX_PATH = 260; public static final int CSIDL_LOCAL_APPDATA = 0x001c; public static final int SHGFP_TYPE_CURRENT = 0; public static final int SHGFP_TYPE_DEFAULT = 1; public static final int S_OK = 0; static Shell32 INSTANCE = (Shell32) Native.loadLibrary("shell32", Shell32.class, OPTIONS); /** * see http: * * HRESULT SHGetFolderPath( HWND hwndOwner, int nFolder, HANDLE hToken, * DWORD dwFlags, LPTSTR pszPath); */ public int SHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, int dwFlags, char[] pszPath); } }
for (Map.Entry<?,?> e : System.getProperties().entrySet()) { System.out.println(String.format("%s = %s", e.getKey(), e.getValue())); }
import com.sun.jna.platform.win32._ object jna { def getHome: java.io.File = { if (!com.sun.jna.Platform.isWindows()) { new java.io.File(System.getProperty("user.home")) } else { val pszPath: Array[Char] = new Array[Char](WinDef.MAX_PATH) new java.io.File(Shell32.INSTANCE.SHGetSpecialFolderPath(null, pszPath, ShlObj.CSIDL_MYDOCUMENTS, false) match { case true => new String(pszPath.takeWhile(c => c != case _ => System.getProperty("user.home") }) } } }
String.format("Hello %1$s, your name is %1$s and the time is %2$t", name, time)
public static void main(String[] args) throws Exception { long start = System.currentTimeMillis(); for(int i = 0; i < 1000000; i++){ String s = "Hi " + i + "; Hi to you " + i*2; } long end = System.currentTimeMillis(); System.out.println("Concatenation = " + ((end - start)) + " millisecond") ; start = System.currentTimeMillis(); for(int i = 0; i < 1000000; i++){ String s = String.format("Hi %s; Hi to you %s",i, + i*2); } end = System.currentTimeMillis(); System.out.println("Format = " + ((end - start)) + " millisecond"); }
String formatString = "Hi %s; Hi to you %s"; long start = System.currentTimeMillis(); for (int i = 0; i < 1000000; i++) { String s = String.format(formatString, i, +i * 2); } long end = System.currentTimeMillis(); log.info("Format = " + ((end - start)) + " millisecond"); start = System.currentTimeMillis(); for (int i = 0; i < 1000000; i++) { String s = "Hi " + i + "; Hi to you " + i * 2; } end = System.currentTimeMillis(); log.info("Concatenation = " + ((end - start)) + " millisecond"); start = System.currentTimeMillis(); for (int i = 0; i < 1000000; i++) { StringBuilder bldString = new StringBuilder("Hi "); bldString.append(i).append("; Hi to you ").append(i * 2); } end = System.currentTimeMillis(); log.info("String Builder = " + ((end - start)) + " millisecond");
public class Time { public static String sysFile = "/sys/class/camera/rear/rear_flash"; public static String cmdString = "echo %s > " + sysFile; public static void main(String[] args) { int i = 1; for(int run=1; run <= 12; run++){ for(int test =1; test <= 2 ; test++){ System.out.println( String.format("\nTEST: %s, RUN: %s, Iterations: %s",run,test,i)); test(run, i); } System.out.println("\n____________________________"); i = i*3; } } public static void test(int run, int iterations){ long start = System.nanoTime(); for( int i=0;i<iterations; i++){ String s = "echo " + i + " > "+ sysFile; } long t = System.nanoTime() - start; String r = String.format(" %-13s =%10d %s", "Concatenation",t,"nanosecond"); System.out.println(r) ; start = System.nanoTime(); for( int i=0;i<iterations; i++){ String s = String.format(cmdString, i); } t = System.nanoTime() - start; r = String.format(" %-13s =%10d %s", "Format",t,"nanosecond"); System.out.println(r); start = System.nanoTime(); for( int i=0;i<iterations; i++){ StringBuilder b = new StringBuilder("echo "); b.append(i).append(" > ").append(sysFile); String s = b.toString(); } t = System.nanoTime() - start; r = String.format(" %-13s =%10d %s", "StringBuilder",t,"nanosecond"); System.out.println(r); }
TEST: 1, RUN: 1, Iterations: 1 Concatenation = 14911 nanosecond Format = 45026 nanosecond StringBuilder = 3509 nanosecond TEST: 1, RUN: 2, Iterations: 1 Concatenation = 3509 nanosecond Format = 38594 nanosecond StringBuilder = 3509 nanosecond ____________________________ TEST: 2, RUN: 1, Iterations: 3 Concatenation = 8479 nanosecond Format = 94438 nanosecond StringBuilder = 5263 nanosecond TEST: 2, RUN: 2, Iterations: 3 Concatenation = 4970 nanosecond Format = 92976 nanosecond StringBuilder = 5848 nanosecond ____________________________ TEST: 3, RUN: 1, Iterations: 9 Concatenation = 11403 nanosecond Format = 287115 nanosecond StringBuilder = 14326 nanosecond TEST: 3, RUN: 2, Iterations: 9 Concatenation = 12280 nanosecond Format = 209051 nanosecond StringBuilder = 11818 nanosecond ____________________________ TEST: 5, RUN: 1, Iterations: 81 Concatenation = 54383 nanosecond Format = 1503113 nanosecond StringBuilder = 40056 nanosecond TEST: 5, RUN: 2, Iterations: 81 Concatenation = 44149 nanosecond Format = 1264241 nanosecond StringBuilder = 34208 nanosecond ____________________________ TEST: 6, RUN: 1, Iterations: 243 Concatenation = 76018 nanosecond Format = 3210891 nanosecond StringBuilder = 76603 nanosecond TEST: 6, RUN: 2, Iterations: 243 Concatenation = 91222 nanosecond Format = 2716773 nanosecond StringBuilder = 73972 nanosecond ____________________________ TEST: 8, RUN: 1, Iterations: 2187 Concatenation = 527450 nanosecond Format = 10291108 nanosecond StringBuilder = 885027 nanosecond TEST: 8, RUN: 2, Iterations: 2187 Concatenation = 526865 nanosecond Format = 6294307 nanosecond StringBuilder = 591773 nanosecond ____________________________ TEST: 10, RUN: 1, Iterations: 19683 Concatenation = 4592961 nanosecond Format = 60114307 nanosecond StringBuilder = 2129387 nanosecond TEST: 10, RUN: 2, Iterations: 19683 Concatenation = 1850166 nanosecond Format = 35940524 nanosecond StringBuilder = 1885544 nanosecond ____________________________ TEST: 12, RUN: 1, Iterations: 177147 Concatenation = 26847286 nanosecond Format = 126332877 nanosecond StringBuilder = 17578914 nanosecond TEST: 12, RUN: 2, Iterations: 177147 Concatenation = 24405056 nanosecond Format = 129707207 nanosecond StringBuilder = 12253840 nanosecond
class StringTest { public static void main(String[] args) { String formatString = "Hi %s; Hi to you %s"; long start = System.currentTimeMillis(); for (int i = 0; i < 1000000; i++) { String s = String.format(formatString, i, +i * 2); } long end = System.currentTimeMillis(); System.out.println("Format = " + ((end - start)) + " millisecond"); start = System.currentTimeMillis(); for (int i = 0; i < 1000000; i++) { String s = "Hi " + i + "; Hi to you " + i * 2; } end = System.currentTimeMillis(); System.out.println("Concatenation = " + ((end - start)) + " millisecond"); start = System.currentTimeMillis(); for (int i = 0; i < 1000000; i++) { StringBuilder bldString = new StringBuilder("Hi "); bldString.append(i).append("Hi to you ").append(i * 2).toString(); } end = System.currentTimeMillis(); System.out.println("String Builder = " + ((end - start)) + " millisecond"); } }
> javac StringTest.java > sh -c "for i in \$(seq 1 5); do echo \"Run \${i}\"; java StringTest; done"
Run 1 Format = 1290 millisecond Concatenation = 115 millisecond String Builder = 130 millisecond Run 2 Format = 1265 millisecond Concatenation = 114 millisecond String Builder = 126 millisecond Run 3 Format = 1303 millisecond Concatenation = 114 millisecond String Builder = 127 millisecond Run 4 Format = 1297 millisecond Concatenation = 114 millisecond String Builder = 127 millisecond Run 5 Format = 1270 millisecond Concatenation = 114 millisecond String Builder = 126 millisecond
public static void main(String[] args) throws Exception { long start = System.currentTimeMillis(); for( int i=0;i<1000000; i++){ String s = String.format( "Hi %s; Hi to you %s",i, + i*2); } long end = System.currentTimeMillis(); System.out.println("Format = " + ((end - start)) + " millisecond"); start = System.currentTimeMillis(); for( int i=0;i<1000000; i++){ String s = "Hi " + i + "; Hi to you " + i*2; } end = System.currentTimeMillis(); System.out.println("Concatenation = " + ((end - start)) + " millisecond") ; }
public class A { public static void empty(Box<? extends Number> b) {} }
public class B { public static void invoke() { A.empty(new Box()); } }
List<String> list = new ArrayList<String>(); list.add("Hi"); String x = list.get(0);
List list = new ArrayList(); list.add("Hi"); String x = (String) list.get(0);
Box<String> b = new Box<String>(); String x = b.getDefault();
Box b = new Box(); String x = (String) b.getDefault();
public static void printSuperclasses(Class clazz) { Type superClass = clazz.getGenericSuperclass(); Log.d("Reflection", "this class: " + (clazz == null ? "null" : clazz.getName())); Log.d("Reflection", "superClass: " + (superClass == null ? "null" : superClass.toString())); while (superClass != null && clazz != null) { clazz = clazz.getSuperclass(); superClass = clazz.getGenericSuperclass(); Log.d("Reflection", "this class: " + (clazz == null ? "null" : clazz.getName())); Log.d("Reflection", "superClass: " + (superClass == null ? "null" : superClass.toString())); } }
D/Reflection: this class: com.example.App.UsersList D/Reflection: superClass: com.example.App.SortedListWrapper<com.example.App.Models.User> D/Reflection: this class: com.example.App.SortedListWrapper D/Reflection: superClass: android.support.v7.util.SortedList$Callback<T> D/Reflection: this class: android.support.v7.util.SortedList$Callback D/Reflection: superClass: class java.lang.Object D/Reflection: this class: java.lang.Object D/Reflection: superClass: null
D/Reflection: this class: com.example.App.UsersList D/Reflection: superClass: class com.example.App.SortedListWrapper D/Reflection: this class: com.example.App.SortedListWrapper D/Reflection: superClass: class android.support.v7.g.e D/Reflection: this class: android.support.v7.g.e D/Reflection: superClass: class java.lang.Object D/Reflection: this class: java.lang.Object D/Reflection: superClass: null
List<String> l= List.<String>of("h","s"); List lRaw=l l.add(new Object()) String s=l.get(2)
void function(ArrayList<Integer> list){} void function(ArrayList<Float> list){} void function(ArrayList<String> list){}
String mytext = " hello there "; mytext = mytext.replaceAll("( )+", " ");
String after = before.trim().replaceAll(" +", " ");
String[] tests = { " x ", " 1 2 3 ", "", " ", }; for (String test : tests) { System.out.format("[%s]%n", test.replaceAll("^ +| +$|( )+", "$1") ); }
System.out.println(new String(" hello there ").trim().replaceAll("\\s{2,}", " "));
String str = " hello there "; System.out.println(str.replaceAll("( +)"," ").trim());
String mytext = " hello there "; mytext = mytext.trim().replaceAll("[ ]{2,}", " "); System.out.println(mytext);
String[] tests = { " x ", " 1 2 3 ", "", " ", }; for (String test : tests) { System.out.format("[%s]%n", test.replaceAll("^ +| +$| (?= )", "") ); }
str = str.substring(0,1).toUpperCase() +str.substring(1,str.length()).toLowerCase();
scan= filter(scan, " [\\s]+", " "); scan= sac.trim();
public String filter(String scan, String regex, String replace) { StringBuffer sb = new StringBuffer(); Pattern pt = Pattern.compile(regex); Matcher m = pt.matcher(scan); while (m.find()) { m.appendReplacement(sb, replace); } m.appendTail(sb); return sb.toString(); }
System.out.println(" D ev Dum my ".replace(" ","")); System.out.println(" D ev Dum my ".replaceAll(" ","")); System.out.println(" D ev Dum my ".replaceAll("\\s+",""));
public static void main(String[] args) { String s = "A B C D E F G\tH I\rJ\nK\tL"; System.out.println("Current : "+s); System.out.println("Single Space : "+singleSpace(s)); System.out.println("Space count : "+spaceCount(s)); System.out.format("Replace all = %s", s.replaceAll("\\s+", "")); String s = "My name is yashwanth . M"; String s2 = "My nameis yashwanth.M"; System.out.println("Normal : "+s.equals(s2)); System.out.println("Replace : "+s.replaceAll("\\s+", "").equals(s2.replaceAll("\\s+", ""))); }
public static String singleSpace(String str){ return str.replaceAll(" +| +|\t|\r|\n",""); }
public static String spaceCount(String str){ int i = 0; while(str.indexOf(" ") > -1){ str = str.replaceFirst(Pattern.quote(" "), ""+(i++)); } return str; }
private String replaceMultipleSpacesFromString(String s){ if(s.length() == 0 ) return ""; int timesSpace = 0; String res = ""; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if(c == timesSpace++; if(timesSpace < 2) res += c; }else{ res += c; timesSpace = 0; } } return res.trim(); }
String mytext = " hello there "; mytext = mytext.replaceAll("( +)", " ");
Stream.of(str.split("[ \\t]")).filter(s -> s.length() > 0).collect(Collectors.joining(" "))
public class RemoveExtraSpacesEfficient { public static void main(String[] args) { String s = "my name is mr space "; char[] charArray = s.toCharArray(); char prev = s.charAt(0); for (int i = 0; i < charArray.length; i++) { char cur = charArray[i]; if (cur == } else { System.out.print(cur); } prev = cur; } } }
package com.myjava.string; import java.util.StringTokenizer; public class MyStrRemoveMultSpaces { public static void main(String a[]){ String str = "String With Multiple Spaces"; StringTokenizer st = new StringTokenizer(str, " "); StringBuffer sb = new StringBuffer(); while(st.hasMoreElements()){ sb.append(st.nextElement()).append(" "); } System.out.println(sb.toString().trim()); } }
Mockito.verify(mockedObject) .someMethodOnMockedObject( Mockito.<SomeObjectAsArgument>anyObject())
Mockito.verify(mockedObject) .someMethodOnMockedObject( Mockito.<SomeObjectAsArgument>**compareWithThisObject()**)
ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class); verify(mock).doSomething(argument.capture()); assertEquals("John", argument.getValue().getName());
Mockito.verify(mockedObject).someMethodOnMockedObject(Matchers.refEq(objectToCompareWith));
import org.mockito.Mockito import org.hamcrest.Matchers ... Mockito.verify(mockedObject).someMethodOnMockedObject(Mockito.argThat( Matchers.<SomeObjectAsArgument>hasProperty("propertyName", desiredValue)));
@RunWith(MockitoJUnitRunner.class) public class SomeTest{ @Captor private ArgumentCaptor<List<SomeType>> captor; @Test public void shouldTestArgsVals() { verify(mockedObject).someMethodOnMockedObject(captor.capture()); assertThat(captor.getValue().getXXX(), is("expected")); } }
import java.util.Optional; import java.util.function.Predicate; import org.hamcrest.BaseMatcher; import org.hamcrest.Description; public class LambdaMatcher<T> extends BaseMatcher<T> { private final Predicate<T> matcher; private final Optional<String> description; public LambdaMatcher(Predicate<T> matcher) { this(matcher, null); } public LambdaMatcher(Predicate<T> matcher, String description) { this.matcher = matcher; this.description = Optional.ofNullable(description); } @SuppressWarnings("unchecked") @Override public boolean matches(Object argument) { return matcher.test((T) argument); } @Override public void describeTo(Description description) { this.description.ifPresent(description::appendText); } }
@Test public void canFindEmployee() { Employee employee = new Employee("John"); company.addEmployee(employee); verify(mockedDal).registerEmployee(argThat(new LambdaMatcher<>(e -> e.getName() .equals(employee.getName())))); }
private class PolygonMatcher extends ArgumentMatcher<PolygonOptions> { private int fillColor; public PolygonMatcher(int fillColor) { this.fillColor = fillColor; } @Override public boolean matches(Object argument) { if (!(argument instanceof PolygonOptions)) return false; PolygonOptions arg = (PolygonOptions)argument; return Color.red(arg.getFillColor()) == Color.red(fillColor) && Color.green(arg.getFillColor()) == Color.green(fillColor) && Color.blue(arg.getFillColor()) == Color.blue(fillColor); } }
int green = getContext().getResources().getColor(R.color.dmb_rx_bucket1); verify(map, times(3)).addPolygon(argThat(new PolygonMatcher(green))); int yellow = getContext().getResources().getColor(R.color.dmb_rx_bucket4); verify(map, times(1)).addPolygon(argThat(new PolygonMatcher(yellow))); int orange = getContext().getResources().getColor(R.color.dmb_rx_bucket5); verify(map, times(3)).addPolygon(argThat(new PolygonMatcher(orange))); int red = getContext().getResources().getColor(R.color.dmb_rx_bucket7); verify(map, times(2)).addPolygon(argThat(new PolygonMatcher(red)));
Mockito.verify(mockedObject).someMethodOnMockedObject(eq(desiredObject))
genericBeanDefinition(DefaultMongoTypeMapper.class) .setScope(SCOPE_SINGLETON) .setAutowireMode(AUTOWIRE_CONSTRUCTOR) .setLazyInit(false) .addConstructorArgValue(null) .getBeanDefinition()
Mockito.verify(mockedObject) .doSoething(genericBeanDefinition(YourClass.class).setA("a") .getBeanDefinition());
verify(mock).execute(argThat { this.param = expected })
GlobalState gs = (GlobalState) getApplication(); String s = gs.getTestMe();
Intent intent = new Intent(FirstActivity.this, SecondActivity.class); intent.putExtra("some_key", value); intent.putExtra("some_other_key", "a value"); startActivity(intent);
Bundle bundle = getIntent().getExtras(); int value = bundle.getInt("some_key"); String value2 = bundle.getString("some_other_key");
public class DataHolder { private String data; public String getData() {return data;} public void setData(String data) {this.data = data;} private static final DataHolder holder = new DataHolder(); public static DataHolder getInstance() {return holder;} }
import android.app.Application; public class MyApplication extends Application { private String data; public String getData() {return data;} public void setData(String data) {this.data = data;} }
MyApplication app = (MyApplication) getApplicationContext(); app.setData(someData);
MyApplication app = (MyApplication) getApplicationContext(); String data = app.getData();
public class DataHolder { private static String data; public static String getData() {return data;} public static String setData(String data) {DataHolder.data = data;} }
public class DataHolder { Map<String, WeakReference<Object>> data = new HashMap<String, WeakReference<Object>>(); void save(String id, Object object) { data.put(id, new WeakReference<Object>(object)); } Object retrieve(String id) { WeakReference<Object> objectWeakReference = data.get(id); return objectWeakReference.get(); } }
Intent intent=new Intent(this, desirableActivity.class); intent.putExtra("KEY", "Value"); startActivity(intent)
private String data; public String getData() { return data; } public void setData(String data) { this.data = data; }
((YourApplicationClass)getApplicationContext()).setData("abc"); String data=((YourApplicationClass)getApplicationContext()).getData();
Intent openLoginActivity = new Intent(getBaseContext(), Home.class); openLoginActivity.putExtra("email", getEmail);
Bundle extras = getIntent().getExtras(); accountEmail = extras.getString("email");
public class MyTest extends TestCase { public void testSomething() { System.out.println("Current test is " + getName()); ... } }
import org.junit.Rule; public class NameRuleTest { @Rule public TestName name = new TestName(); @Test public void testA() { assertEquals("testA", name.getMethodName()); } @Test public void testB() { assertEquals("testB", name.getMethodName()); } }
@Rule public TestRule watcher = new TestWatcher() { protected void starting(Description description) { System.out.println("Starting test: " + description.getMethodName()); } };
@Rule public MethodRule watchman = new TestWatchman() { public void starting(FrameworkMethod method) { System.out.println("Starting test: " + method.getName()); } };
import org.junit.Rule; import org.junit.Test; import org.junit.rules.MethodRule; import org.junit.rules.TestWatchman; import org.junit.runners.model.FrameworkMethod; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class LoggingTest { @Rule public MethodRule watchman = new TestWatchman() { public void starting(FrameworkMethod method) { logger.info("{} being run...", method.getName()); } }; final Logger logger = LoggerFactory.getLogger(LoggingTest.class); @Test public void testA() { } @Test public void testB() { } }
@Test @DisplayName("This is my test") @Tag("It is my tag") void test1(TestInfo testInfo) { assertEquals("This is my test", testInfo.getDisplayName()); assertTrue(testInfo.getTags().contains("It is my tag")); }
public class NameAwareRunner extends BlockJUnit4ClassRunner { public NameAwareRunner(Class<?> aClass) throws InitializationError { super(aClass); } @Override protected Statement methodBlock(FrameworkMethod frameworkMethod) { System.err.println(frameworkMethod.getName()); return super.methodBlock(frameworkMethod); } }
public class MyTest { @Rule public TestName testName = new TestName(); @Rule public TestWatcher testWatcher = new TestWatcher() { @Override protected void starting(final Description description) { String methodName = description.getMethodName(); String className = description.getClassName(); className = className.substring(className.lastIndexOf( System.err.println("Starting JUnit-test: " + className + " " + methodName); } }; @Test public void testA() { assertEquals("testA", testName.getMethodName()); } @Test public void testB() { assertEquals("testB", testName.getMethodName()); } }
Starting JUnit-test: MyTest testA Starting JUnit-test: MyTest testB
public class ImportUtilsTest { private static final Logger LOGGER = Logger.getLogger(ImportUtilsTest.class); @Rule public TestWatcher testWatcher = new JUnitHelper(LOGGER); @Test public test1(){ ... } }
public class JUnitHelper extends TestWatcher { private Logger LOGGER; public JUnitHelper(Logger LOGGER) { this.LOGGER = LOGGER; } @Override protected void starting(final Description description) { LOGGER.info("STARTED " + description.getMethodName()); } @Override protected void succeeded(Description description) { LOGGER.info("SUCCESSFUL " + description.getMethodName()); } @Override protected void failed(Throwable e, Description description) { LOGGER.error("FAILURE " + description.getMethodName()); } }
String testName = null; StackTraceElement[] trace = Thread.currentThread().getStackTrace(); for (int i = trace.length - 1; i > 0; --i) { StackTraceElement ste = trace[i]; try { Class<?> cls = Class.forName(ste.getClassName()); Method method = cls.getDeclaredMethod(ste.getMethodName()); Test annotation = method.getAnnotation(Test.class); if (annotation != null) { testName = ste.getClassName() + "." + ste.getMethodName(); break; } } catch (ClassNotFoundException e) { } catch (NoSuchMethodException e) { } catch (SecurityException e) { } }
@ClassRule public static TestRule watchman = new TestWatcher() { @Override protected void starting( final Description description ) { String mN = description.getMethodName(); if ( mN == null ) { mN = "setUpBeforeClass.."; } final String s = StringTools.toString( "starting..JUnit-Test: %s.%s", description.getClassName(), mN ); System.err.println( s ); } };
private static Logger _log = LoggerFactory.getLogger(SampleTest.class.getName()); @Rule public TestWatcher watchman = new TestWatcher() { @Override public void starting(final Description method) { _log.info("being run..." + method.getMethodName()); } };
import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.TestInfo; import org.junit.jupiter.api.Test; @Test void doThat(TestInfo testInfo) throws Exception { Assertions.assertEquals("doThat(TestInfo)",testInfo.getDisplayName()); Assertions.assertEquals("doThat",testInfo.getTestMethod().get().getName()); }
@JsonInclude(JsonInclude.Include.NON_NULL) @Transient private String token;
<attributes> (...) <transient name="field" /> </attributes>
ObjectMapper jacksonObjectMapper = new ObjectMapper(); Hibernate5Module jacksonHibernateModule = new Hibernate5Module(); jacksonHibernateModule.disable(Hibernate5Module.Feature.USE_TRANSIENT_ANNOTATION); jacksonObjectMapper.registerModule(jacksonHibernateModule);
<dependency> <groupId>com.fasterxml.jackson.datatype</groupId> <artifactId>jackson-datatype-hibernate5</artifactId> <version>2.8.9</version> </dependency>
public class Foo { private String name; public void setName(String name) { this.name = name; } }
public class Foo { public String useBarMethod() { Bar theBar = new Bar(); return theBar.barMethod(this); } public String getName() { return "Foo"; } } public class Bar { public void barMethod(Foo obj) { obj.getName(); } }
class Foo { public Foo() { this("Some default value for bar"); } public Foo(String bar) { } }
public class Outer { protected int a; public class Inner { protected int a; public int foo(){ return Outer.this.a; } public Outer getOuter(){ return Outer.this; } } }
public class MyClass { public MyClass(String foo) { this(foo, null); } public MyClass(String foo, String bar) { ... } }
public class User { private String firstName; private String surname; public User(Builder builder){ firstName = builder.firstName; surname = builder.surname; } public String getFirstName(){ return firstName; } public String getSurname(){ return surname; } public static class Builder { private String firstName; private String surname; public Builder setFirstName(String firstName) { this.firstName = firstName; return this; } public Builder setSurname(String surname) { this.surname = surname; return this; } public User build(){ return new User(this); } } public static void main(String[] args) { User.Builder builder = new User.Builder(); User user = builder.setFirstName("John").setSurname("Doe").build(); } }
public class Hello { private String foo; private String getStringFromSomewhere() { } public class World { private String bar; public void doSomething() { foo = "FOO"; String s = getStringFromSomewhere(); bar = s; } } }
public void doSomething() { Hello.this.foo = "FOO"; String s = Hello.this.getStringFromSomewhere(); this.bar = s; }
private int x; public void setX(int x) { this.x=x; }
private int x; public void setX(int newX) { x=newX; }
public class circle { int x; circle(int x){ this.x =x; } }
public class circle { int x; circle() { this(1); } circle(int x) { this.x = x; } }
class A { private int i; public A(int i) { this.i = i; } }
class POJO { protected int i; public void modify() { i = 9; } public void thisModify() { this.i = 9; } }
public class Window { private Window parent; public Window (Window parent) { this.parent = parent; } public void addSubWindow() { Window child = new Window(this); list.add(child); } public void printInfo() { if (parent == null) { System.out.println("root"); } else { System.out.println("child"); } } }
JSch jsch = new JSch(); String knownHostsFilename = "/home/username/.ssh/known_hosts"; jsch.setKnownHosts( knownHostsFilename ); Session session = jsch.getSession( "remote-username", "remote-host" ); { UserInfo ui = new MyUserInfo(); session.setUserInfo(ui); session.setPassword( "remote-password" ); } session.connect(); Channel channel = session.openChannel( "sftp" ); channel.connect(); ChannelSftp sftpChannel = (ChannelSftp) channel; sftpChannel.get("remote-file", "local-file" ); InputStream in = sftpChannel.get( "remote-file" ); sftpChannel.exit(); session.disconnect();
import com.jcraft.jsch.*; public class TestJSch { public static void main(String args[]) { JSch jsch = new JSch(); Session session = null; try { session = jsch.getSession("username", "127.0.0.1", 22); session.setConfig("StrictHostKeyChecking", "no"); session.setPassword("password"); session.connect(); Channel channel = session.openChannel("sftp"); channel.connect(); ChannelSftp sftpChannel = (ChannelSftp) channel; sftpChannel.get("remotefile.txt", "localfile.txt"); sftpChannel.exit(); session.disconnect(); } catch (JSchException e) { e.printStackTrace(); } catch (SftpException e) { e.printStackTrace(); } } }
FileSystemOptions fsOptions = new FileSystemOptions(); SftpFileSystemConfigBuilder.getInstance().setStrictHostKeyChecking(fsOptions, "no"); FileSystemManager fsManager = VFS.getManager(); String uri = "sftp: FileObject fo = fsManager.resolveFile(uri, fsOptions);
SshClient ssh = new SshClient(); ssh.connect(host, port); PasswordAuthenticationClient passwordAuthenticationClient = new PasswordAuthenticationClient(); passwordAuthenticationClient.setUsername(userName); passwordAuthenticationClient.setPassword(password); int result = ssh.authenticate(passwordAuthenticationClient); if(result != AuthenticationProtocolState.COMPLETE){ throw new SFTPException("Login to " + host + ":" + port + " " + userName + "/" + password + " failed"); } SftpClient client = ssh.openSftpClient(); client.put(filePath); client.quit(); ssh.disconnect();
final SSHClient ssh = new SSHClient(); ssh.loadKnownHosts(); ssh.connect("localhost"); try { ssh.authPassword("user", "password"); final SFTPClient sftp = ssh.newSFTPClient(); try { sftp.get("test_file", "/tmp/test.tmp"); } finally { sftp.close(); } } finally { ssh.disconnect(); }
import java.io.File; import java.io.FileInputStream; import java.util.Properties; import org.apache.commons.vfs2.FileObject; import org.apache.commons.vfs2.FileSystemOptions; import org.apache.commons.vfs2.Selectors; import org.apache.commons.vfs2.impl.StandardFileSystemManager; import org.apache.commons.vfs2.provider.sftp.SftpFileSystemConfigBuilder; public class SendMyFiles { static Properties props; public static void main(String[] args) { SendMyFiles sendMyFiles = new SendMyFiles(); if (args.length < 1) { System.err.println("Usage: java " + sendMyFiles.getClass().getName()+ " Properties_file File_To_FTP "); System.exit(1); } String propertiesFile = args[0].trim(); String fileToFTP = args[1].trim(); sendMyFiles.startFTP(propertiesFile, fileToFTP); } public boolean startFTP(String propertiesFilename, String fileToFTP){ props = new Properties(); StandardFileSystemManager manager = new StandardFileSystemManager(); try { props.load(new FileInputStream("properties/" + propertiesFilename)); String serverAddress = props.getProperty("serverAddress").trim(); String userId = props.getProperty("userId").trim(); String password = props.getProperty("password").trim(); String remoteDirectory = props.getProperty("remoteDirectory").trim(); String localDirectory = props.getProperty("localDirectory").trim(); String filepath = localDirectory + fileToFTP; File file = new File(filepath); if (!file.exists()) throw new RuntimeException("Error. Local file not found"); manager.init(); FileSystemOptions opts = new FileSystemOptions(); SftpFileSystemConfigBuilder.getInstance().setStrictHostKeyChecking( opts, "no"); SftpFileSystemConfigBuilder.getInstance().setUserDirIsRoot(opts, true); SftpFileSystemConfigBuilder.getInstance().setTimeout(opts, 10000); String sftpUri = "sftp: remoteDirectory + fileToFTP; FileObject localFile = manager.resolveFile(file.getAbsolutePath()); FileObject remoteFile = manager.resolveFile(sftpUri, opts); remoteFile.copyFrom(localFile, Selectors.SELECT_SELF); System.out.println("File upload successful"); } catch (Exception ex) { ex.printStackTrace(); return false; } finally { manager.close(); } return true; } }
import java.io.File; import java.io.FileInputStream; import java.util.Properties; import org.apache.commons.vfs2.FileObject; import org.apache.commons.vfs2.FileSystemOptions; import org.apache.commons.vfs2.Selectors; import org.apache.commons.vfs2.impl.StandardFileSystemManager; import org.apache.commons.vfs2.provider.sftp.SftpFileSystemConfigBuilder; public class GetMyFiles { static Properties props; public static void main(String[] args) { GetMyFiles getMyFiles = new GetMyFiles(); if (args.length < 1) { System.err.println("Usage: java " + getMyFiles.getClass().getName()+ " Properties_filename File_To_Download "); System.exit(1); } String propertiesFilename = args[0].trim(); String fileToDownload = args[1].trim(); getMyFiles.startFTP(propertiesFilename, fileToDownload); } public boolean startFTP(String propertiesFilename, String fileToDownload){ props = new Properties(); StandardFileSystemManager manager = new StandardFileSystemManager(); try { props.load(new FileInputStream("properties/" + propertiesFilename)); String serverAddress = props.getProperty("serverAddress").trim(); String userId = props.getProperty("userId").trim(); String password = props.getProperty("password").trim(); String remoteDirectory = props.getProperty("remoteDirectory").trim(); String localDirectory = props.getProperty("localDirectory").trim(); manager.init(); FileSystemOptions opts = new FileSystemOptions(); SftpFileSystemConfigBuilder.getInstance().setStrictHostKeyChecking( opts, "no"); SftpFileSystemConfigBuilder.getInstance().setUserDirIsRoot(opts, true); SftpFileSystemConfigBuilder.getInstance().setTimeout(opts, 10000); String sftpUri = "sftp: remoteDirectory + fileToDownload; String filepath = localDirectory + fileToDownload; File file = new File(filepath); FileObject localFile = manager.resolveFile(file.getAbsolutePath()); FileObject remoteFile = manager.resolveFile(sftpUri, opts); localFile.copyFrom(remoteFile, Selectors.SELECT_SELF); System.out.println("File download successful"); } catch (Exception ex) { ex.printStackTrace(); return false; } finally { manager.close(); } return true; } }
import java.io.FileInputStream; import java.util.Properties; import org.apache.commons.vfs2.FileObject; import org.apache.commons.vfs2.FileSystemOptions; import org.apache.commons.vfs2.impl.StandardFileSystemManager; import org.apache.commons.vfs2.provider.sftp.SftpFileSystemConfigBuilder; public class DeleteRemoteFile { static Properties props; public static void main(String[] args) { DeleteRemoteFile getMyFiles = new DeleteRemoteFile(); if (args.length < 1) { System.err.println("Usage: java " + getMyFiles.getClass().getName()+ " Properties_filename File_To_Delete "); System.exit(1); } String propertiesFilename = args[0].trim(); String fileToDownload = args[1].trim(); getMyFiles.startFTP(propertiesFilename, fileToDownload); } public boolean startFTP(String propertiesFilename, String fileToDownload){ props = new Properties(); StandardFileSystemManager manager = new StandardFileSystemManager(); try { props.load(new FileInputStream("properties/" + propertiesFilename)); String serverAddress = props.getProperty("serverAddress").trim(); String userId = props.getProperty("userId").trim(); String password = props.getProperty("password").trim(); String remoteDirectory = props.getProperty("remoteDirectory").trim(); manager.init(); FileSystemOptions opts = new FileSystemOptions(); SftpFileSystemConfigBuilder.getInstance().setStrictHostKeyChecking( opts, "no"); SftpFileSystemConfigBuilder.getInstance().setUserDirIsRoot(opts, true); SftpFileSystemConfigBuilder.getInstance().setTimeout(opts, 10000); String sftpUri = "sftp: remoteDirectory + fileToDownload; FileObject remoteFile = manager.resolveFile(sftpUri, opts); if(remoteFile.exists()){ remoteFile.delete(); System.out.println("File delete successful"); } } catch (Exception ex) { ex.printStackTrace(); return false; } finally { manager.close(); } return true; } }
package net.schmizz.sshj.examples; import net.schmizz.sshj.SSHClient; import net.schmizz.sshj.sftp.SFTPClient; import net.schmizz.sshj.xfer.FileSystemFile; import java.io.File; import java.io.IOException; /** This example demonstrates uploading of a file over SFTP to the SSH server. */ public class SFTPUpload { public static void main(String[] args) throws IOException { final SSHClient ssh = new SSHClient(); ssh.loadKnownHosts(); ssh.connect("localhost"); try { ssh.authPublickey(System.getProperty("user.name")); final String src = System.getProperty("user.home") + File.separator + "test_file"; final SFTPClient sftp = ssh.newSFTPClient(); try { sftp.put(new FileSystemFile(src), "/tmp"); } finally { sftp.close(); } } finally { ssh.disconnect(); } } }
JSch jsch = new JSch(); Session session = null; try { session = jsch.getSession("user", "127.0.0.1", 22); session.setConfig("StrictHostKeyChecking", "no"); session.setPassword("password"); session.connect(); Channel channel = session.openChannel("sftp"); channel.connect(); ChannelSftp sftpChannel = (ChannelSftp) channel; InputStream stream = sftpChannel.get("/usr/home/testfile.txt"); try { BufferedReader br = new BufferedReader(new InputStreamReader(stream)); String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException io) { System.out.println("Exception occurred during reading file from SFTP server due to " + io.getMessage()); io.getMessage(); } catch (Exception e) { System.out.println("Exception occurred during reading file from SFTP server due to " + e.getMessage()); e.getMessage(); } sftpChannel.exit(); session.disconnect(); } catch (JSchException e) { e.printStackTrace(); } catch (SftpException e) { e.printStackTrace(); }
SFTPFileCopy upload = new SFTPFileCopy(true, /path/to/sourcefile.png", /path/to/destinationfile.png");
SFTPFileCopy download = new SFTPFileCopy(false, "/path/to/sourcefile.png", "/path/to/destinationfile.png");
import com.jcraft.jsch.Channel; import com.jcraft.jsch.ChannelSftp; import com.jcraft.jsch.JSch; import com.jcraft.jsch.Session; import com.jcraft.jsch.UIKeyboardInteractive; import com.jcraft.jsch.UserInfo; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.ByteArrayInputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import javax.swing.JOptionPane; import menue.Menue; public class SFTPFileCopy1 { public SFTPFileCopy1(boolean upload, String sourcePath, String destPath) throws FileNotFoundException, IOException { Session session = null; Channel channel = null; ChannelSftp sftpChannel = null; try { JSch jsch = new JSch(); session = jsch.getSession("login", "mysite.com", 22); session.setPassword("password"); UserInfo ui = new MyUserInfo() { public void showMessage(String message) { JOptionPane.showMessageDialog(null, message); } public boolean promptYesNo(String message) { Object[] options = {"yes", "no"}; int foo = JOptionPane.showOptionDialog(null, message, "Warning", JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options[0]); return foo == 0; } }; session.setUserInfo(ui); session.setConfig("StrictHostKeyChecking", "no"); session.connect(); channel = session.openChannel("sftp"); channel.setInputStream(System.in); channel.setOutputStream(System.out); channel.connect(); sftpChannel = (ChannelSftp) channel; if (upload) { byte[] bufr = new byte[(int) new File(sourcePath).length()]; FileInputStream fis = new FileInputStream(new File(sourcePath)); fis.read(bufr); ByteArrayInputStream fileStream = new ByteArrayInputStream(bufr); sftpChannel.put(fileStream, destPath); fileStream.close(); } else { byte[] buffer = new byte[1024]; BufferedInputStream bis = new BufferedInputStream(sftpChannel.get(sourcePath)); OutputStream os = new FileOutputStream(new File(destPath)); BufferedOutputStream bos = new BufferedOutputStream(os); int readCount; while ((readCount = bis.read(buffer)) > 0) { bos.write(buffer, 0, readCount); } bis.close(); bos.close(); } } catch (Exception e) { System.out.println(e); } finally { if (sftpChannel != null) { sftpChannel.exit(); } if (channel != null) { channel.disconnect(); } if (session != null) { session.disconnect(); } } } public static abstract class MyUserInfo implements UserInfo, UIKeyboardInteractive { public String getPassword() { return null; } public boolean promptYesNo(String str) { return false; } public String getPassphrase() { return null; } public boolean promptPassphrase(String message) { return false; } public boolean promptPassword(String message) { return false; } public void showMessage(String message) { } public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) { return null; } } }
Session session = entityManager.unwrap(Session.class);
Session session = (Session) entityManager.getDelegate();
@PersistenceContext EntityManager entityManager; public List<MyEntity> findSomeApples() { return entityManager .createQuery("from MyEntity where apples=7", MyEntity.class) .getResultList(); }
@Autowired SessionFactory sessionFactory; public List<MyEntity> findSomeApples() { Session session = sessionFactory.getCurrentSession(); List<?> result = session.createQuery("from MyEntity where apples=7") .list(); @SuppressWarnings("unchecked") List<MyEntity> resultCasted = (List<MyEntity>) result; return resultCasted; }
/usr/libexec/java_home -verbose Matching Java Virtual Machines (1): 1.8.0_20, x86_64: "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_20.jdk/Contents/Home /Library/Java/JavaVirtualMachines/jdk1.8.0_20.jdk/Contents/Home
export JAVA_7_HOME=$(/usr/libexec/java_home -v1.7) export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8) export JAVA_9_HOME=$(/usr/libexec/java_home -v9) alias java7= alias java8= alias java9= export JAVA_HOME=$JAVA_8_HOME
if which jenv > /dev/null; then eval "$(jenv init -)"; fi
jenv add /Library/Java/JavaVirtualMachines/1.6.0___EXAMPLE___/Contents/Home jenv add /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk___EXAMPLE___/Contents/Home
$ sdk list java Available Java Versions + 9ea170 > + 8u131 7u141-zulu
if which jenv > /dev/null; then eval "$(jenv init -)"; fi
curl -sL https: jabba install 1.8 jabba install 1.7 jabba ls jabba use 1.8
function setjdk() { if [ $ removeFromPath if [ -n "${JAVA_HOME+x}" ]; then removeFromPath $JAVA_HOME fi export JAVA_HOME=/Library/Java/JavaVirtualMachines/$1/Contents/Home export PATH=$JAVA_HOME/bin:$PATH fi } function removeFromPath() { export PATH=$(echo $PATH | sed -E -e "s;:$1;;" -e "s;$1:?;;") } setjdk jdk1.7.0_15.jdk
for version in 1.7 1.8; do v="${version: -1}" h=JAVA_"$v"_HOME export "$h"=$(/usr/libexec/java_home -v $version) alias "java$v"="export JAVA_HOME=\$$h" done
@Entity @Table(name = "entities") public class Entity { ... private Date created; private Date updated; @PrePersist protected void onCreate() { created = new Date(); } @PreUpdate protected void onUpdate() { updated = new Date(); } }
import java.util.Date; import javax.persistence.Column; import javax.persistence.MappedSuperclass; import javax.persistence.PrePersist; import javax.persistence.PreUpdate; import javax.persistence.Temporal; import javax.persistence.TemporalType; @MappedSuperclass public abstract class AbstractTimestampEntity { @Temporal(TemporalType.TIMESTAMP) @Column(name = "created", nullable = false) private Date created; @Temporal(TemporalType.TIMESTAMP) @Column(name = "updated", nullable = false) private Date updated; @PrePersist protected void onCreate() { updated = created = new Date(); } @PreUpdate protected void onUpdate() { updated = new Date(); } }
@Entity @Table(name = "campaign") public class Campaign extends AbstractTimestampEntity implements Serializable { ... }
@CreationTimestamp @Temporal(TemporalType.TIMESTAMP) @Column(name = "create_date") private Date createDate; @UpdateTimestamp @Temporal(TemporalType.TIMESTAMP) @Column(name = "modify_date") private Date modifyDate;
public interface TimeStamped { public Date getCreatedDate(); public void setCreatedDate(Date createdDate); public Date getLastUpdated(); public void setLastUpdated(Date lastUpdatedDate); }
public class TimeStampInterceptor extends EmptyInterceptor { public boolean onFlushDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types) { if (entity instanceof TimeStamped) { int indexOf = ArrayUtils.indexOf(propertyNames, "lastUpdated"); currentState[indexOf] = new Date(); return true; } return false; } public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) { if (entity instanceof TimeStamped) { int indexOf = ArrayUtils.indexOf(propertyNames, "createdDate"); state[indexOf] = new Date(); return true; } return false; } }
@Temporal(TemporalType.TIMESTAMP) @Column(name = "created", nullable = false, updatable=false) private Date created;
@MappedSuperclass public abstract class AbstractTimestampEntity { @Temporal(TemporalType.TIMESTAMP) @Column(name = "created") private Date created=new Date(); @Temporal(TemporalType.TIMESTAMP) @Column(name = "updated") @Version private Date updated; public Date getCreated() { return created; } public void setCreated(Date created) { this.created = created; } public Date getUpdated() { return updated; } public void setUpdated(Date updated) { this.updated = updated; } }
CREATE TABLE my_table ( ... updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP );
IEnumerable<int> QuickSort(IEnumerable<int> ints) { if (!ints.Any()) { return Enumerable.Empty<int>(); } int pivot = ints.First(); IEnumerable<int> lt = ints.Where(i => i < pivot); IEnumerable<int> gt = ints.Where(i => i > pivot); return QuickSort(lt).Concat(new int[] { pivot }).Concat(QuickSort(gt)); }
val lines = fromString(data).getLines val registrants = lines.map(Registrant) registrants.foreach(println) registrants.foreach(println)
Iterable<?> it = source.filter(...).map(...).filter(...).map(...); it.into(dest1); it.into(dest2);
Stream<Integer> quickSort(List<Integer> ints) { if (!ints.stream().findAny().isPresent()) { return Stream.of(); } final Integer pivot = ints.get(0); List<Integer> lt = ints.stream().filter(i -> i < pivot).collect(Collectors.toList()); List<Integer> gt = ints.stream().filter(i -> i > pivot).collect(Collectors.toList()); return Stream.concat(Stream.concat(quickSort(lt), Stream.of(pivot)),quickSort(gt)); }
static Stream<Integer> quickSort(Supplier<Stream<Integer>> ints) { final Optional<Integer> optPivot = ints.get().findAny(); if(!optPivot.isPresent()) return Stream.empty(); final int pivot = optPivot.get(); Supplier<Stream<Integer>> lt = ()->ints.get().filter(i -> i < pivot); Supplier<Stream<Integer>> gt = ()->ints.get().filter(i -> i > pivot); return Stream.of(quickSort(lt), Stream.of(pivot), quickSort(gt)).flatMap(s->s); }
List<Integer> l=new Random().ints(100, 0, 1000).boxed().collect(Collectors.toList()); System.out.println(l); System.out.println(quickSort(l::stream) .map(Object::toString).collect(Collectors.joining(", ")));
static Stream<Integer> quickSort(Supplier<Stream<Integer>> ints) { return ints.get().findAny().map(pivot -> Stream.of( quickSort(()->ints.get().filter(i -> i < pivot)), Stream.of(pivot), quickSort(()->ints.get().filter(i -> i > pivot))) .flatMap(s->s)).orElse(Stream.empty()); }
IEnumerable<int> numbers = new int[] { 1, 2, 3, 4, 5 }; foreach (var n in numbers) { Console.WriteLine(n); }
IEnumerable<int> numbers = new int[] { 1, 2, 3, 4, 5 }; IEnumerator<int> enumerator = numbers.GetEnumerator(); while (enumerator.MoveNext()) { Console.WriteLine(enumerator.Current); }
class Generator : IEnumerator<int> { Random _r; int _current; int _count = 0; public Generator(Random r) { _r = r; } public bool MoveNext() { _current= _r.Next(); _count++; return _count <= 5; } public int Current { get { return _current; } } } class RandomNumberStream : IEnumerable<int> { Random _r = new Random(); public IEnumerator<int> GetEnumerator() { return new Generator(_r); } public IEnumerator IEnumerable.GetEnumerator() { return this.GetEnumerator(); } }
IEnumerable<int> numbers = new RandomNumberStream(); foreach (var n in numbers) { Console.WriteLine(n); } foreach (var n in numbers) { Console.WriteLine(n); }
Spliterator<String> split = Stream.of("hello","world") .map(s->"prefix-"+s) .spliterator(); Stream<String> replayable1 = StreamSupport.stream(split,false); Stream<String> replayable2 = StreamSupport.stream(split,false); replayable1.forEach(System.out::println); replayable2.forEach(System.out::println);
Spliterator<String> split = Stream.generate(this::nextValue) .map(s->"prefix-"+s) .spliterator(); Stream<String> replayable1 = StreamSupport.stream(split,false); Stream<String> replayable2 = StreamSupport.stream(split,false); replayable1.forEach(System.out::println); this.resetCounter(); replayable2.forEach(System.out::println);
MyArraySpliterator<String> arraySplit = new MyArraySpliterator("hello","world"); Spliterator<String> split = StreamSupport.stream(arraySplit,false) .map(s->"prefix-"+s) .spliterator(); Stream<String> replayable1 = StreamSupport.stream(split,false); Stream<String> replayable2 = StreamSupport.stream(split,false); replayable1.forEach(System.out::println); arraySplit.reset(); replayable2.forEach(System.out::println);
Stream<String> replayableStream = ReactiveSeq.of("hello","world") .map(s->"prefix-"+s); replayableStream.forEach(System.out::println); replayableStream.forEach(System.out::println);
prefix-hello prefix-world prefix-hello prefix-world
public class ConstructorTest { public ConstructorTest() throws InterruptedException { System.out.println("Preparing object...."); Thread.sleep(1000); System.out.println("Object ready"); } public static void main(String ... args) { try { ConstructorTest test = new ConstructorTest(); } catch (InterruptedException e) { System.out.println("Got interrupted..."); } } }
if(this instanceof A) doA(); else if(this instanceof B) doB(); else if(this instanceof C) doC():
interface I { void do(); } class A implements I { void do() { doA() } ... } class B implements I { void do() { doB() } ... } class C implements I { void do() { doC() } ... }
public A() { CLAZZ z = CLAZZ.valueOf(this.getClass().getSimpleName()); switch (z) { case A: doA(); break; case B: doB(); break; case C: doC(); break; } } enum CLAZZ { A,B,C; }
public enum Action { a{ void doAction(...){ } }, b{ void doAction(...){ } }, c{ void doAction(...){ } }; abstract void doAction (...); }
void someFunction ( Action action ) { action.doAction(...); }
Map<Class,Runnable> doByClass = new HashMap<>(); doByClass.put(Foo.class, () -> doAClosure(this)); doByClass.put(Bar.class, this::doBMethod); doByClass.put(Baz.class, new MyCRunnable());
Match.ofType(Number.class) .caze((Integer i) -> i) .caze((String s) -> new BigDecimal(s)) .orElse(() -> -1) .apply(1.0d);
class A extends Base { void do() { this.doA() } } class B extends Base { void do() { this.doB() } } class C extends Base { void do() { this.doC() } }
public interface CommonClass { MyEnum getEnumType(); }
public enum MyEnum { ClassA(0), ClassB(1), ClassC(2); private int value; private MyEnum(final int value) { this.value = value; } public int getValue() { return value; }
... switch(obj.getEnumType()) { case MyEnum.ClassA: ClassA classA = (ClassA) obj; break; case MyEnum.ClassB: ClassB classB = (ClassB) obj; break; case MyEnum.ClassC: ClassC classC = (ClassC) obj; break; } ...
switch (this.name) { case "A": doA(); break; case "B": doB(); break; case "C": doC(); break; default: console.log( }
mySwitch("YY") .myCase("AA", (o) -> { System.out.println(o+"aa"); }) .myCase("BB", (o) -> { System.out.println(o+"bb"); }) .myCase("YY", (o) -> { System.out.println(o+"yy"); }) .myCase("ZZ", (o) -> { System.out.println(o+"zz"); });
public Case mySwitch(Object reference) { return new Case(reference); } public class Case { private Object reference; public Case(Object reference) { this.reference = reference; } public Case myCase(Object b, OnMatchDo task) { if (reference.equals(b)) { task.task(reference); } return this; } } public interface OnMatchDo { public void task(Object o); }
public interface ClassTypeInterface { public String getType(); }
public class A extends Something implements ClassTypeInterface { public final static String TYPE = "A"; @Override public String getType() { return TYPE; } }
switch (var.getType()) { case A.TYPE: { break; } case B.TYPE: { break; } ... }
DEFINE_TYPE: { if (a instanceof x){ break DEFINE_TYPE; } if (a instanceof y){ break DEFINE_TYPE; } if (a instanceof z){ break DEFINE_TYPE; } }
public static <T> T process(Object model) { switch (model.getClass().getSimpleName()) { case "Trade": return processTrade(); case "InsuranceTransaction": return processInsuranceTransaction(); case "CashTransaction": return processCashTransaction(); case "CardTransaction": return processCardTransaction(); case "TransferTransaction": return processTransferTransaction(); case "ClientAccount": return processAccount(); ... default: throw new IllegalArgumentException(model.getClass().getSimpleName()); } }
private void switchByClassType(Object obj) { ClassNameEnum className = ClassNameEnum.valueOf(obj.getClass().getSimpleName()); switch (className) { case A: doA(); break; case B: doB(); break; case C: doC(); break; } } }
import static io.vavr.API.*; import static io.vavr.Predicates.instanceOf; public Throwable liftRootCause(final Throwable throwable) { return Match(throwable).of( Case($(instanceOf(CompletionException.class)), Throwable::getCause), Case($(instanceOf(ExecutionException.class)), Throwable::getCause), Case($(), th -> th) ); }
javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR
org.apache.http.impl.EnglishReasonPhraseCatalog.INSTANCE.getReason(httpCode,null)
package so4308554; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.net.URL; import java.nio.charset.Charset; import org.json.JSONException; import org.json.JSONObject; public class JsonReader { private static String readAll(Reader rd) throws IOException { StringBuilder sb = new StringBuilder(); int cp; while ((cp = rd.read()) != -1) { sb.append((char) cp); } return sb.toString(); } public static JSONObject readJsonFromUrl(String url) throws IOException, JSONException { InputStream is = new URL(url).openStream(); try { BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName("UTF-8"))); String jsonText = readAll(rd); JSONObject json = new JSONObject(jsonText); return json; } finally { is.close(); } } public static void main(String[] args) throws IOException, JSONException { JSONObject json = readJsonFromUrl("https: System.out.println(json.toString()); System.out.println(json.get("id")); } }
ObjectMapper mapper = new ObjectMapper(); FacebookGraph graph = mapper.readValue(url, FaceBookGraph.class); Map<String,Object> map = mapper.readValue(url, Map.class);
FacebookGraph graph = new ObjectMapper().readValue(url, FaceBookGraph.class);
String sURL = "http: URL url = new URL(sURL); URLConnection request = url.openConnection(); request.connect(); JsonParser jp = new JsonParser(); JsonElement root = jp.parse(new InputStreamReader((InputStream) request.getContent())); JsonObject rootobj = root.getAsJsonObject(); String zipcode = rootobj.get("zip_code").getAsString();
JSONObject json = new JSONObject(IOUtils.toString(new URL("https:
package com.inzane.shoapp.activity; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.UnsupportedEncodingException; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.methods.HttpPost; import org.apache.http.impl.client.DefaultHttpClient; import org.json.JSONException; import org.json.JSONObject; import android.util.Log; public class JSONParser { static InputStream is = null; static JSONObject jObj = null; static String json = ""; public JSONParser() { } public JSONObject getJSONFromUrl(String url) { try { DefaultHttpClient httpClient = new DefaultHttpClient(); HttpPost httpPost = new HttpPost(url); HttpResponse httpResponse = httpClient.execute(httpPost); HttpEntity httpEntity = httpResponse.getEntity(); is = httpEntity.getContent(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (ClientProtocolException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { BufferedReader reader = new BufferedReader(new InputStreamReader( is, "iso-8859-1"), 8); StringBuilder sb = new StringBuilder(); String line = null; while ((line = reader.readLine()) != null) { sb.append(line + "\n"); System.out.println(line); } is.close(); json = sb.toString(); } catch (Exception e) { Log.e("Buffer Error", "Error converting result " + e.toString()); } try { jObj = new JSONObject(json); } catch (JSONException e) { Log.e("JSON Parser", "Error parsing data " + e.toString()); System.out.println("error on parse data in jsonparser.java"); } return jObj; } }
String url = "your url"; JSONParser jsonParser = new JSONParser(); JSONObject object = jsonParser.getJSONFromUrl(url); String content=object.getString("json key");
<dependency> <groupId>org.glassfish.jersey.core</groupId> <artifactId>jersey-client</artifactId> <version>2.25.1</version> </dependency>
String json = ClientBuilder.newClient().target("http:
Gson gson = new Gson(); Type gm = new TypeToken<CoinDeskMessage>() {}.getType(); CoinDeskMessage cdm = gson.fromJson(json, gm);
JSONObject(java.lang.String source) Construct a JSONObject from a source JSON text string.
File[] files = directory.listFiles(); Arrays.sort(files, new Comparator<File>(){ public int compare(File f1, File f2) { return Long.valueOf(f1.lastModified()).compareTo(f2.lastModified()); } });
class Pair implements Comparable { public long t; public File f; public Pair(File file) { f = file; t = file.lastModified(); } public int compareTo(Object o) { long u = ((Pair) o).t; return t < u ? -1 : t == u ? 0 : 1; } }; File[] files = directory.listFiles(); Pair[] pairs = new Pair[files.length]; for (int i = 0; i < files.length; i++) pairs[i] = new Pair(files[i]); Arrays.sort(pairs); for (int i = 0; i < files.length; i++) files[i] = pairs[i].f;
File[] files = directory.listFiles(); Arrays.sort(files, new Comparator<File>() { public int compare(File f1, File f2) { return Long.compare(f1.lastModified(), f2.lastModified()); } });
File[] files = directory.listFiles(); Arrays.sort(files, Comparator.comparingLong(File::lastModified));
File[] files = directory.listFiles(); Arrays.sort(files, Comparator.comparingLong(File::lastModified).reversed());
org.apache.commons.io.comparator.LastModifiedFileComparator
public static void main(String[] args) throws IOException { File directory = new File("."); File[] files = directory.listFiles((FileFilter) FileFileFilter.FILE); System.out.println("Default order"); displayFiles(files); Arrays.sort(files, LastModifiedFileComparator.LASTMODIFIED_COMPARATOR); System.out.println("\nLast Modified Ascending Order (LASTMODIFIED_COMPARATOR)"); displayFiles(files); Arrays.sort(files, LastModifiedFileComparator.LASTMODIFIED_REVERSE); System.out.println("\nLast Modified Descending Order (LASTMODIFIED_REVERSE)"); displayFiles(files); }
Collection<File> files = ... final Map<File, Long> staticLastModifiedTimes = new HashMap<File,Long>(); for(final File f : files) { staticLastModifiedTimes.put(f, f.lastModified()); } Collections.sort(files, new Comparator<File>() { @Override public int compare(final File f1, final File f2) { return staticLastModifiedTimes.get(f1).compareTo(staticLastModifiedTimes.get(f2)); } });
public String[] getDirectoryList(String path) { String[] dirListing = null; File dir = new File(path); dirListing = dir.list(); Arrays.sort(dirListing, 0, dirListing.length); return dirListing; }
Function<File, Long> getLastModified = new Function<File, Long>() { public Long apply(File file) { return file.lastModified(); } }; List<File> orderedFiles = Ordering.natural().onResultOf(getLastModified). sortedCopy(files);
import org.apache.commons.io.comparator.LastModifiedFileComparator; File[] files = directory.listFiles(); Arrays.sort(files, LastModifiedFileComparator.LASTMODIFIED_COMPARATOR); for (File file : files) { Date lastMod = new Date(file.lastModified()); System.out.println("File: " + file.getName() + ", Date: " + lastMod + ""); }
private static List<File> sortByLastModified(String dirPath) { List<File> files = listFilesRec(dirPath); Collections.sort(files, new Comparator<File>() { public int compare(File o1, File o2) { return Long.compare(o1.lastModified(), o2.lastModified()); } }); return files; }
File downloadDir = new File("mypath"); File[] list = downloadDir.listFiles(); for (int i = list.length-1; i >=0 ; i--) { }
Collections.sort(listFiles, new Comparator<File>() { public int compare(File f1, File f2) { return Long.compare(f1.lastModified(), f2.lastModified()); } });
list.add(1, object1) list.add(2, object3) list.add(2, object2)
String modified_20_digits = ("00000000000000000000".concat(Long.toString(temp.lastModified()))).substring(Long.toString(temp.lastModified()).length()); result_filenames.add(modified_20_digits+temp.getAbsoluteFile().toString());
String.format("%010d", Integer.parseInt(mystring));
String paddedString = org.apache.commons.lang.StringUtils.leftPad("129018", 10, "0")
String unpadded = "12345"; String padded = unpadded + "
String unpadded = "12345"; String padded = "000000000000000".substring(unpadded.length()) + unpadded;
String str = "129018"; StringBuilder sb = new StringBuilder(); for (int toPrepend=10-str.length(); toPrepend>0; toPrepend--) { sb.append( } sb.append(str); String result = sb.toString();
String str = "129018"; String str2 = String.format("%10s", str).replace( System.out.println(str2);
import org.apache.commons.lang.StringUtils; public class test { public static void main(String[] args) { String result = StringUtils.leftPad("wrwer", 10, "0"); System.out.println("The String : " + result); } }
String zeroPad = "0000000000000000"; String str0 = zeroPad.substring(str.length()) + str;
public static String fill(String text) { if (text.length() >= 10) return text; else return "0000000000".substring(text.length()) + text; }
public static String fill(String text, int size) { StringBuilder builder = new StringBuilder(text); while (builder.length() < size) { builder.append( } return builder.toString(); }
<dependency> <artifactId>guava</artifactId> <groupId>com.google.guava</groupId> <version>14.0.1</version> </dependency>
public final class StrMgr { public static String rightPad(String input, int length, String fill){ String pad = input.trim() + String.format("%"+length+"s", "").replace(" ", fill); return pad.substring(0, length); } public static String leftPad(String input, int length, String fill){ String pad = String.format("%"+length+"s", "").replace(" ", fill) + input.trim(); return pad.substring(pad.length() - length, pad.length()); } }
System.out.println(StrMgr.leftPad("hello", 20, "x")); System.out.println(StrMgr.rightPad("hello", 20, "x"));
int pad = 4; char[] temp = (new String(new char[pad]) + "129018").toCharArray() Arrays.fill(temp, 0, pad, System.out.println(temp)
/** * Left padding a string with the given character * * @param str The string to be padded * @param length The total fix length of the string * @param padChar The pad character * @return The padded string */ public static String padLeft(String str, int length, String padChar) { String pad = ""; for (int i = 0; i < length; i++) { pad += padChar; } return pad.substring(str.length()) + str; }
String s = Integer.toBinaryString(5); int p = 8; for(int g=0,j=s.length();g<p-j;g++, s= "0" + s); System.out.println(s);
int maxDigits = 10; String str = "129018"; String formatString = "%"+n+"s"; String str2 = String.format(formatString, str).replace( System.out.println(str2);
int number = -1; int holdingDigits = 7; System.out.println(String.format("%0"+ holdingDigits +"d", number));
static String leadingZeros(int num, int digitSize) { if (digitSize < String.valueOf(num).length()) { return "Error : you number " + num + " is higher than the decimal system specified capacity of " + digitSize + " zeros."; } else if (digitSize == String.valueOf(num).length()) { return String.valueOf(num); } else { StringBuilder sb = new StringBuilder(); for (int i = 0; i < digitSize; i++) { sb.append("0"); } sb.append(String.valueOf(num)); return sb.substring(sb.length() - digitSize, sb.length()); } }
int number=129018; int requiredLengthAfterPadding=10; String resultString=Integer.toString(number); int inputStringLengh=resultString.length(); int diff=requiredLengthAfterPadding-inputStringLengh; if(inputStringLengh<requiredLengthAfterPadding) { resultString=new String(new char[diff]).replace("\0", "0")+number; } System.out.println(resultString);
public static String PadLeft(String stringToPad, int padToLength){ String retValue = null; if(stringToPad.length() < padToLength) { retValue = String.format("%0" + String.valueOf(padToLength - stringToPad.length()) + "d%s",0,stringToPad); } else{ retValue = stringToPad; } return retValue; } public static void main(String[] args) { System.out.println(" System.out.println(" System.out.println(" System.out.println(" }
DecimalFormat numFormat = new DecimalFormat("00000"); System.out.println("Code format: "+numFormat.format(123));
while (true) { if (i == 3) { i = 0; } ceva[i].setSelected(true); ceva[i].setSelected(false); i++; }
public static void main(String[] args) { final ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); executorService.scheduleAtFixedRate(App::myTask, 0, 1, TimeUnit.SECONDS); } private static void myTask() { System.out.println("Running"); }
public static void main(String[] args) { final ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); executorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { myTask(); } }, 0, 1, TimeUnit.SECONDS); } private static void myTask() { System.out.println("Running"); }
try { Thread.sleep(1000); } catch(InterruptedException ex) { Thread.currentThread().interrupt(); }
public class SleepMessages { public static void main(String args[]) throws InterruptedException { String importantInfo[] = { "Mares eat oats", "Does eat oats", "Little lambs eat ivy", "A kid will eat ivy too" }; for (int i = 0; i < importantInfo.length; i++) { Thread.sleep(4000); System.out.println(importantInfo[i]); } } }
public class MyClass { public static String getClassName() { String name = ????; return name; } }
return new Object() { }.getClass().getEnclosingClass();
Thread.currentThread().getStackTrace()[1].getClassName();
public class MyObject { static { System.loadLibrary( "classname" ); } public static native String getClassName(); public static void main( String[] args ) { System.out.println( getClassName() ); } }
JNIEXPORT jstring JNICALL Java_MyObject_getClassName( JNIEnv *env, jclass cls ) { jclass javaLangClass = (*env)->FindClass( env, "java/lang/Class" ); jmethodID getName = (*env)->GetMethodID( env, javaLangClass, "getName", "()Ljava/lang/String;" ); return (*env)->CallObjectMethod( env, cls, getName ); }
Benchmark Mode Cnt Score Error Units StaticClassLookup.MethodHandles_lookup_lookupClass avgt 30 3.630  0.024 ns/op StaticClassLookup.AnonymousObject_getClass_enclosingClass avgt 30 282.486  1.980 ns/op StaticClassLookup.SecurityManager_classContext_1 avgt 30 680.385  21.665 ns/op StaticClassLookup.Thread_currentThread_stackTrace_1_className avgt 30 11179.460  286.293 ns/op StaticClassLookup.Throwable_stackTrace_0_className avgt 30 10221.209  176.847 ns/op
public final class CallerClassGetter extends SecurityManager { private static final CallerClassGetter INSTANCE = new CallerClassGetter(); private CallerClassGetter() {} public static Class<?> getCallerClass() { return INSTANCE.getClassContext()[1]; } } class FooBar { static final Logger LOGGER = LoggerFactory.getLogger(CallerClassGetter.getCallerClass()) }
import org.slf4j.Logger import org.slf4j.LoggerFactory @Suppress("NOTHING_TO_INLINE") inline fun loggerFactoryStatic(): Logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass())
private val LOGGER = loggerFactoryStatic() /** * Returns a pseudo-random, uniformly distributed value between the * given least value (inclusive) and bound (exclusive). * * @param min the least value returned * @param max the upper bound (exclusive) * * @return the next value * @throws IllegalArgumentException if least greater than or equal to bound * @see java.util.concurrent.ThreadLocalRandom.nextDouble(double, double) */ fun Random.nextDouble(min: Double = .0, max: Double = 1.0): Double { if (min >= max) { if (min == max) return max LOGGER.warn("nextDouble: min $min > max $max") return min } return nextDouble() * (max - min) + min }
static final Logger logger = Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName());
System.getSecurityManager().getClassContext()[0].getName();
public static class CurrentClassGetter extends SecurityManager { public String getClassName() { return getClassContext()[1].getName(); } }
class BaseClass { static sharedStaticMethod (String callerClassName, Object... otherArgs) { useCallerClassNameAsYouWish (callerClassName); } } class SubClass1 extends BaseClass { static someSubclassStaticMethod () { sharedStaticMethod (SubClass1.class.getName(), other_arguments); sharedStaticMethod (new Object() { }.getClass().getEnclosingClass().getName(), other_arguments); } }
private static String getMyClassName(){ return MyClass.class.getName(); }
public static void myMethod(){ Tracer.debug(getMyClassName(), "message"); }
class MyService { private static Class thisClass = MyService.class; ... static void startService(Context context) { Intent i = new Intent(context, thisClass); context.startService(i); } }
public static String getClassName() { String className = Thread.currentThread().getStackTrace()[2].getClassName(); int lastIndex = className.lastIndexOf( return className.substring(lastIndex + 1); }
public AndroidLogger(Object classObject) { mClassName = classObject.getClass().getSimpleName(); } public AndroidLogger(String className) { mClassName = className; }
private AndroidLogger mLogger = new AndroidLogger(this);
private static AndroidLogger mLogger = new AndroidLogger(Myclass.class.getSimpleName());
Class<?> c = Class.forName("class name"); Method method = c.getDeclaredMethod ("method name", parameterTypes)
java.util.Date time = new java.util.Date(timeStamp);
java.util.Date time=new java.util.Date((long)timeStamp*1000);
Date date = Date.from( Instant.ofEpochSecond( timeStamp ) );
Date date = new Date (); date.setTime((long)unix_time*1000);
Calendar mydate = Calendar.getInstance(); mydate.setTimeInMillis(timestamp*1000); out.println(mydate.get(Calendar.DAY_OF_MONTH)+"."+mydate.get(Calendar.MONTH)+"."+mydate.get(Calendar.YEAR));
Instant instant = Instant.ofEpochSecond( 1_280_512_800L );
ZoneId z = ZoneId.of( "Asia/Tehran" ) ; ZonedDateTime zdt = instant.atZone( z );
java.util.Date date = java.util.Date.from( instant );
DateTime dateTime = new DateTime( ( 1_280_512_800L * 1000_L ), DateTimeZone.forID( "Europe/Paris" ) );
TimeZone.setDefault(TimeZone.getTimeZone("UTC")); java.util.Date time= new java.util.Date((Long.parseLong(timestamp)*1000));
Date d = new Date(i * 1000 + TimeZone.getDefault().getRawOffset());
javax.net.ssl.SSLProtocolException: handshake alert: unrecognized_name at sun.security.ssl.ClientHandshaker.handshakeAlert(ClientHandshaker.java:1288) at sun.security.ssl.SSLSocketImpl.recvAlert(SSLSocketImpl.java:1904) at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1027) at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1262) at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1289) at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1273) at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:523) at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:185) at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1296) at sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:254) at java.net.URL.openStream(URL.java:1035)
SAXBuilder builder = new SAXBuilder(); Document document = null; try { url = new URL(https: document = (Document) builder.build(url.openStream()); } catch (NoSuchAlgorithmException ex) { Logger.getLogger(DownloadLoadiciousComputer.class.getName()).log(Level.SEVERE, null, ex); }
TrustManager[] trustAllCerts = new TrustManager[]{ new X509TrustManager() { public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; } public void checkClientTrusted( java.security.cert.X509Certificate[] certs, String authType) { } public void checkServerTrusted( java.security.cert.X509Certificate[] certs, String authType) { } } }; try { SSLContext sc = SSLContext.getInstance("SSL"); sc.init(null, trustAllCerts, new java.security.SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); } catch (Exception e) { Logger.getLogger(DownloadManager.class.getName()).log(Level.SEVERE, null, e); }
System.setProperty("jsse.enableSNIExtension", "false");
public class a { public static void main(String [] a) throws Exception { java.net.URLConnection c = new java.net.URL("https: c.setDoOutput(true); c.getOutputStream(); } }
public class a { public static void main(String [] a) throws Exception { java.net.URLConnection c = new java.net.URL("https: c.setDoOutput(true); c.getOutputStream(); } }
<VirtualHost mydomain.com:443> ServerName mydomain.com ServerAlias www.mydomain.com
ServerName catchall.mydomain.com ServerAlias *.mydomain.com
public class SniHttpClientConnectionOperator extends DefaultHttpClientConnectionOperator { public SniHttpClientConnectionOperator(Lookup<ConnectionSocketFactory> socketFactoryRegistry) { super(socketFactoryRegistry, null, null); } @Override public void connect( final ManagedHttpClientConnection conn, final HttpHost host, final InetSocketAddress localAddress, final int connectTimeout, final SocketConfig socketConfig, final HttpContext context) throws IOException { try { super.connect(conn, host, localAddress, connectTimeout, socketConfig, context); } catch (SSLProtocolException e) { Boolean enableSniValue = (Boolean) context.getAttribute(SniSSLSocketFactory.ENABLE_SNI); boolean enableSni = enableSniValue == null || enableSniValue; if (enableSni && e.getMessage() != null && e.getMessage().equals("handshake alert: unrecognized_name")) { TimesLoggers.httpworker.warn("Server received saw wrong SNI host, retrying without SNI"); context.setAttribute(SniSSLSocketFactory.ENABLE_SNI, false); super.connect(conn, host, localAddress, connectTimeout, socketConfig, context); } else { throw e; } } } }
public class SniSSLSocketFactory extends SSLConnectionSocketFactory { public static final String ENABLE_SNI = "__enable_sni__"; /* * Implement any constructor you need for your particular application - * SSLConnectionSocketFactory has many variants */ public SniSSLSocketFactory(final SSLContext sslContext, final HostnameVerifier verifier) { super(sslContext, verifier); } @Override public Socket createLayeredSocket( final Socket socket, final String target, final int port, final HttpContext context) throws IOException { Boolean enableSniValue = (Boolean) context.getAttribute(ENABLE_SNI); boolean enableSni = enableSniValue == null || enableSniValue; return super.createLayeredSocket(socket, enableSni ? target : "", port, context); } }
cm = new PoolingHttpClientConnectionManager(new SniHttpClientConnectionOperator(socketFactoryRegistry), null, -1, TimeUnit.MILLISECONDS);
System.setProperty("jsse.enableSNIExtension", "false") bootRun.systemProperties = System.properties
public static HttpComponentsClientHttpRequestFactory requestFactory(CloseableHttpClient httpClient) { TrustStrategy acceptingTrustStrategy = new TrustStrategy() { @Override public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException { return true; } }; SSLContext sslContext = null; try { sslContext = org.apache.http.ssl.SSLContexts.custom() .loadTrustMaterial(null, acceptingTrustStrategy) .build(); } catch (Exception e) { logger.error(e.getMessage(), e); } HostnameVerifier hostnameVerifier = new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; } }; final SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext,hostnameVerifier); final Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create() .register("http", new PlainConnectionSocketFactory()) .register("https", csf) .build(); final PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager(registry); cm.setMaxTotal(100); httpClient = HttpClients.custom() .setSSLSocketFactory(csf) .setConnectionManager(cm) .build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(); requestFactory.setHttpClient(httpClient); return requestFactory; }
[Mon Jun 30 22:27:10 2014] [warn] NameVirtualHost *:80 has no VirtualHosts ... waiting [Mon Jun 30 22:27:11 2014] [warn] NameVirtualHost *:80 has no VirtualHosts
<VirtualHost *:80> DocumentRoot /var/www/html/load/web ServerName dev.load.com <Directory "/var/www/html/load/web"> Options +FollowSymLinks -SymLinksIfOwnerMatch AllowOverride All Require all granted Order Allow,Deny Allow from All </Directory> RewriteEngine on RewriteCond %{SERVER_PORT} !^443$ RewriteRule ^/(.*) https: </VirtualHost>
<VirtualHost *:80> DocumentRoot /var/www/html/load/web ServerName dev.load.com <Directory "/var/www/html/load/web"> AllowOverride All Options All Order Allow,Deny Allow from All </Directory> RewriteEngine On RewriteCond %{HTTP:Authorization} ^(.*) RewriteRule .* - [e=HTTP_AUTHORIZATION:%1] </VirtualHost>
C:\ YourFolder >set path=C:\Program Files\Java\jdk1.7.0_09\bin; C:\ YourFolder >javac YourCode.java
Pair<Integer, String> simplePair = new Pair<>(42, "Second"); Integer first = simplePair.first; String second = simplePair.second;
Pair<String, String> keyValue = new ImmutablePair("key", "value");
Pair<Integer, String> myPair = new Pair<>(7, "Seven"); Integer key = myPair.getKey(); String value = myPair.getValue();
import java.util.Map; public class KeyValue<K, V> implements Map.Entry<K, V> { private K key; private V value; public KeyValue(K key, V value) { this.key = key; this.value = value; } public K getKey() { return this.key; } public V getValue() { return this.value; } public K setKey(K key) { return this.key = key; } public V setValue(V value) { return this.value = value; } }
Properties props = new Properties(); props.setProperty("displayName", "Jim Wilson"); String name = props.getProperty("displayName"); String acctNum = props.getProperty("accountNumber"); String nextPosition = props.getProperty("position", "1");
ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); } finally { Thread.currentThread().setContextClassLoader(originalClassLoader); }
String str1="str"; String str2="ing"; String concat=str1+str2; System.out.println(concat=="string");
final String str1="str"; final String str2="ing"; String concat=str1+str2; System.out.println(concat=="string");
Code: 0: ldc 2: astore_1 3: ldc 5: astore_2 6: new 9: dup 10: invokespecial 13: aload_1 14: invokevirtual 17: aload_2 18: invokevirtual 21: invokevirtual 24: astore_3 25: getstatic 28: aload_3 29: ldc 31: if_acmpne 38 34: iconst_1 35: goto 39 38: iconst_0 39: invokevirtual 42: return
Code: 0: ldc 2: astore_3 3: getstatic 6: aload_3 7: ldc 9: if_acmpne 16 12: iconst_1 13: goto 17 16: iconst_0 17: invokevirtual 20: return
public void noFinal() { String str1 = "str"; String str2 = "ing"; String concat = str1 + str2; System.out.println(concat == "string"); } public void withFinal() { final String str1 = "str"; final String str2 = "ing"; String concat = str1 + str2; System.out.println(concat == "string"); }
public void noFinal(); Code: 0: ldc 2: astore_1 3: ldc 5: astore_2 6: new 9: dup 10: aload_1 11: invokestatic 14: invokespecial 17: aload_2 18: invokevirtual 21: invokevirtual ...
public void withFinal(); Code: 0: ldc 2: astore_1 3: ldc 5: astore_2 6: ldc 8: astore_3 ...
String concat = new StringBuilder(str1).append(str2).toString();
Compiled from "Main.java" public class Main { public Main(); Code: 0: aload_0 1: invokespecial 4: return public static void main(java.lang.String[]) throws java.lang.Exception; Code: 0: ldc 2: astore_3 3: getstatic 6: aload_3 7: ldc 9: if_acmpne 16 12: iconst_1 13: goto 17 16: iconst_0 17: invokevirtual 20: return }
Compiled from "Main2.java" public class Main2 { public Main2(); Code: 0: aload_0 1: invokespecial 4: return public static void main(java.lang.String[]) throws java.lang.Exception; Code: 0: ldc 2: astore_1 3: ldc 5: astore_2 6: new 9: dup 10: invokespecial 13: aload_1 14: invokevirtual ngBuilder; 17: aload_2 18: invokevirtual ngBuilder; 21: invokevirtual 24: astore_3 25: getstatic 28: aload_3 29: ldc 31: if_acmpne 38 34: iconst_1 35: goto 39 38: iconst_0 39: invokevirtual 42: return }
@Target(ElementType.ANNOTATION_TYPE) public @interface Category { String category(); } @Category(category="validator") public @interface MyFooBarValidator { }
@Target(ElementType.ANNOTATION_TYPE) public @interface Category { AnnotationCategory[] category(); } public enum AnnotationCategory { GENERAL, SEMANTICS, VALIDATION, ETC } @Category(category={AnnotationCategory.GENERAL, AnnotationCategory.SEMANTICS}) public @interface FooBarAnnotation { }
String text = readFileAsString("textfile.txt"); text.replace("\n", "");
String text = readFileAsString("textfile.txt"); text = text.replace("\n", "").replace("\r", "");
text = text.replace(System.getProperty("line.separator"), "");
text = text.replaceAll(System.getProperty("line.separator"), "");
text = text.replaceAll("\\r", "").replaceAll("\\n", "");
String s; s = "try this\n try me."; s.replaceAll("[\\r\\n]+", "")
import org.apache.commons.lang3.StringUtils; final String cleansedString = StringUtils.normalizeSpace(rawString);
String text = readFileAsString("textfile.txt").replaceAll("\n", "");
String text = readFileAsString("textfile.txt").replace("\n","");
BufferedReader br = new BufferedReader( new InputStreamReader("textfile.txt")); StringBuilder sb = new StringBuilder(); for (;;) { String line = br.readLine(); if (line == null) break; sb.append(line); sb.append( } String text = sb.toString();
StringBuilder sb = new StringBuilder(); FileInputStream fin=new FileInputStream("textfile.txt"); LineIterator lt=IOUtils.lineIterator(fin, "utf-8"); while(lt.hasNext()) { sb.append(lt.nextLine()); } String text = sb.toString(); IOUtils.closeQuitely(fin);
public static void removeWithAnyChar(String str, char replceChar, char replaceWith) { char chrs[] = str.toCharArray(); int i = 0; while (i < chrs.length) { if (chrs[i] == replceChar) { chrs[i] = replaceWith; } i++; } }
textValue= textValue.replaceAll("\n", ""); textValue= textValue.replaceAll("\t", ""); textValue= textValue.replaceAll("\\n", ""); textValue= textValue.replaceAll("\\t", ""); textValue= textValue.replaceAll("\r", ""); textValue= textValue.replaceAll("\\r", ""); textValue= textValue.replaceAll("\r\n", ""); textValue= textValue.replaceAll("\\r\\n", "");
jmap -dump:format=b,file=<heap_dump_filename> <pid>
jmap -J-d64 -dump:format=b,file=<heap_dump_filename> <pid>
jmap -J-d64 -dump:live,format=b,file=<heap_dump_filename> <pid>
:: set the paths for your environment set PsExec=C:\Apps\SysInternals\PsExec.exe set JAVA_HOME=C:\Apps\Java\jdk1.8.0_121 set DUMP_DIR=C:\temp @echo off set PID=%1 if "%PID%"=="" ( echo usage: jvmdump.bat {pid} exit /b ) for /f "tokens=2,3,4 delims=/ " %%f in ( for /f "tokens=1,2 delims=: " %%f in ( set timestamp=%timestamp_d%%timestamp_t% echo datetime is: %timestamp% echo %PsExec% -s %JAVA_HOME%\bin\jcmd.exe %PID% VM.version >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" echo. >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" echo %PsExec% -s %JAVA_HOME%\bin\jcmd.exe %PID% VM.uptime >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" echo. >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" echo %PsExec% -s %JAVA_HOME%\bin\jcmd.exe %PID% VM.command_line >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" echo. >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" echo %PsExec% -s %JAVA_HOME%\bin\jcmd.exe %PID% VM.flags >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" echo. >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" echo %PsExec% -s %JAVA_HOME%\bin\jcmd.exe %PID% VM.system_properties >>"%DUMP_DIR%\%PID%-%timestamp%-jvm.log" %PsExec% -s %JAVA_HOME%\bin\jcmd.exe %PID% Thread.print -l >"%DUMP_DIR%\%PID%-%timestamp%-threads.log" %PsExec% -s %JAVA_HOME%\bin\jcmd.exe %PID% GC.heap_dump "%DUMP_DIR%\%PID%-%timestamp%-heap.hprof" echo Dumped to %DUMP_DIR%
private static String getThreadDump() { Map<Thread, StackTraceElement[]> allStackTraces = Thread.getAllStackTraces(); StringBuilder out = new StringBuilder(); for (Map.Entry<Thread, StackTraceElement[]> entry : allStackTraces.entrySet()) { Thread thread = entry.getKey(); StackTraceElement[] elements = entry.getValue(); out.append(String.format("%s | prio=%d | %s", thread.getName(), thread.getPriority(), thread.getState())); out.append( for (StackTraceElement element : elements) { out.append(element.toString()).append( } out.append( } return out.toString(); }
main | prio=5 | RUNNABLE java.lang.Thread.dumpThreads(Native Method) java.lang.Thread.getAllStackTraces(Thread.java:1607) Main.getThreadDump(Main.java:8) Main.main(Main.java:36) Monitor Ctrl-Break | prio=5 | RUNNABLE java.net.PlainSocketImpl.initProto(Native Method) java.net.PlainSocketImpl.<clinit>(PlainSocketImpl.java:45) java.net.Socket.setImpl(Socket.java:503) java.net.Socket.<init>(Socket.java:424) java.net.Socket.<init>(Socket.java:211) com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:59) Finalizer | prio=8 | WAITING java.lang.Object.wait(Native Method) java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143) java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164) java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209) Reference Handler | prio=10 | WAITING java.lang.Object.wait(Native Method) java.lang.Object.wait(Object.java:502) java.lang.ref.Reference.tryHandlePending(Reference.java:191) java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)
private static String getThreadDump() { Map<Thread, StackTraceElement[]> allStackTraces = Thread.getAllStackTraces(); StringBuilder out = new StringBuilder(); allStackTraces.forEach((thread, elements) -> { out.append(String.format("%s | prio=%d | %s", thread.getName(), thread.getPriority(), thread.getState())); out.append( Arrays.stream(elements).forEach(element -> out.append(element.toString()).append( out.append( }); return out.toString(); }
private static final Logger logger = Logger.getLogger(MyClass.class);
private static final Logger logger = Logger.getLogger(MyClass.class); private static final double MY_CONSTANT = 0.0;
static final int NUMBER = 5; static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann"); static final Joiner COMMA_JOINER = Joiner.on( static final SomeMutableType[] EMPTY_ARRAY = {}; enum SomeEnum { ENUM_CONSTANT } static String nonFinal = "non-final"; final String nonStatic = "non-static"; static final Set<String> mutableCollection = new HashSet<String>(); static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable); static final Logger logger = Logger.getLogger(MyClass.getName()); static final String[] nonEmptyArray = {"these", "can", "change"};
try { ${cursor} or some other template } catch (Exception t) { LOGGER.error("${methodName} ${method parameters}", t); }
for(int i=Constants.ZERO; ...) { if(myArray.length > Constants.ONE) { System.out.println("More than one element"); } }
String.EMPTY = ""; myVar0 = String.EMPTY; myVar1 = String.EMPTY; myVar2 = String.EMPTY; myVar3 = String.EMPTY; myVar4 = String.EMPTY; myVar5 = String.EMPTY; myVar6 = String.EMPTY; myVar7 = String.EMPTY; myVar8 = String.EMPTY; myVar9 = String.EMPTY;
myVar0 = ""; myVar1 = ""; myVar2 = ""; myVar3 = ""; myVar4 = ""; myVar5 = ""; myVar6 = ""; myVar7 = ""; myVar8 = ""; myVar9 = "";
[ 115528] ERROR - tRunWizard$SetupProgressStep$1 - Android Studio 1.1.0 Build [ 115531] ERROR - tRunWizard$SetupProgressStep$1 - JDK: 1.8.0_40 [ 115531] ERROR - tRunWizard$SetupProgressStep$1 - VM: Java HotSpot(TM) 64-Bit Server VM [ 115531] ERROR - tRunWizard$SetupProgressStep$1 - Vendor: Oracle Corporation [ 115531] ERROR - tRunWizard$SetupProgressStep$1 - OS: Linux [ 115532] ERROR - tRunWizard$SetupProgressStep$1 - Last Action:
sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6
sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6
sudo yum install zlib.i686 ncurses-libs.i686 bzip2-libs.i686
E: Unable to locate package lib32bz2-1.0 E: Couldn E: Couldn
sudo apt-get install lib32z1 lib32ncurses5 libbz2-1.0:i386 lib32stdc++6
$ sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1
